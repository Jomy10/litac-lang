/*
    Test Suite Application
*/
import "libc"
import "json"
import "io"
import "array"
import "mem"
import "string_buffer"
import "../src/system"
import "../src/lita"
import "../src/phase_result"
import "../src/error_codes"

struct TestHarness {
    allocator: *const Allocator
    buffer: StringBuffer
    numberOfTests: i32
    numberOfFailures: i32
}

struct TestSuite {
    filename: *const char
    description: *const char
    disabled: bool
    programTemplate: *const char
    tests: Array<Test>
}

struct Test {
    programText: StringBuffer
    name: *const char

    //definitions: *const char
    //code: *const char
    disabled: bool
    expectedOutput: *const char
    expectedErrorOutput: *const char
}

enum TestResult {
    SUCCESS,
    LOADING_ERROR,
    OUTPUT_MISMATCH,
    ERROR_MISMATCH,
}

const testHarness = TestHarness{}

func main(len: i32, args: **char) : i32 {
    SystemInit()

    var testFiles = []*const char {
        // "../test/tests/misc.json", json syntax error
        "../test/tests/type_checker.json",
        "../test/tests/string_view.json",
        "../test/tests/string_buffer.json",
        "../test/tests/stmts.json",
        "../test/tests/array.json",
        "../test/tests/methods.json",
        "../test/tests/defer.json",
        "../test/tests/declarations.json",
        "../test/tests/arrays.json",
        "../test/tests/var_decl.json",
        "../test/tests/syntax_errors.json",
        "../test/tests/generics.json",
        "../test/tests/generics_inference.json",
        null
    }

    testHarness.allocator = defaultAllocator
    testHarness.buffer = StringBufferInit(1024, defaultAllocator)
    testHarness.numberOfTests = 0
    testHarness.numberOfFailures = 0

    for(var i = 0; testFiles[i] != null; i+=1) {
        var filename = testFiles[i]

        var suite = TestSuite{
            .disabled = false,
            .filename = filename,
            .description = null,
            .programTemplate = """
            @include("assert.h");
            @foreign func assert(e:bool):void;

            %definitions%

            func main(len:i32, args:**char):i32 {
                %code%
            }
            """
        }


        printf("Testing Suite: '%s'\n", filename)
        if(!RunTestSuite(suite, filename)) {
            printf("***FAILED Loading test suite: '%s'***\n", filename)
        }
    }

    printf("\nRan %d tests with %d failures\n", testHarness.numberOfTests, testHarness.numberOfFailures)
    printf("Complete.\n")
    return 0;
}

func RunTestSuite(suite: *TestSuite, filename: *const char) : i32 {
    var data:*char;
    if(ReadFile(filename, &data) != FileStatus.Ok) {
        goto err;
    }

    var parser = Parser{}
    parser.init(testHarness.allocator)
    defer parser.free()

    var node = parser.parseJson(data)
    defer if(node) node.free()

    if(!node) {
        if(parser.hasError()) {
            printf("Test Json Syntax error: %s", parser.errorMsg)
        }
        goto err;
    }

    suite.description = node.getStr("description", suite.description)
    suite.disabled = node.getBool("disabled", false)
    suite.programTemplate = node.getStr("program", suite.programTemplate)

    var tests = node.getArray("tests")
    if(!tests) {
        return 0
    }

    suite.tests.init(tests.size(), testHarness.allocator)
    for(var i = 0; i < tests.size(); i += 1) {
        var testNode = tests.at(i)
        if(!testNode) {
            continue
        }

        var test = CreateTest(suite, testNode, &suite.tests.elements[i])
        if(!test) {
            printf("FAILED to load test\n")
        }
        else {
            if(test.disabled) {
                printf("    %-85s ......%s\n", test.name, "SKIPPED!")
            }
            else {
                testHarness.numberOfTests += 1

                var result = RunTest(suite, test)
                var passed = result == TestResult.SUCCESS;
                printf("    %-85s ......%s\n", test.name, passed ? "SUCCESS" : "***FAILED***")
                if(!passed) {
                    testHarness.numberOfFailures += 1
                    switch(result) {
                        case TestResult.LOADING_ERROR: {
                            printf("        Error with the test case\n")
                            break
                        }
                        case TestResult.OUTPUT_MISMATCH: {
                            printf("        The expected output did not match the actual output:\n")
                            printf("\n%s\n\n", testHarness.buffer.cStr())
                            break
                        }
                        case TestResult.ERROR_MISMATCH: {
                            printf("        The expected ERROR output did not match the actual output:\n")
                            printf("\n%s\n\n", testHarness.buffer.cStr())
                            break
                        }
                        default: {}
                    }
                }
            }
        }
    }

err:
    return 1
}

func CreateTest(suite: *TestSuite, testNode: *JsonNode, output: *Test) : *Test {
    var programText = StringBufferInit(2048, testHarness.allocator)
    programText.append("%s\n", suite.programTemplate)

    const defsTemplate = "%definitions%"
    var defsLen = strlen(defsTemplate)
    var defsIndex = programText.indexOf(defsTemplate)
    if(defsIndex > -1) {
        programText.replace(defsIndex, defsIndex + defsLen, testNode.getStr("definitions", ""))
    }

    const codeTemplate = "%code%"
    var codeLen = strlen(codeTemplate)
    var codeIndex = programText.indexOf(codeTemplate)
    if(codeIndex > -1) {
        programText.replace(codeIndex, codeIndex + codeLen, testNode.getStr("code", ""))
    }

    output.programText = programText
    output.name = testNode.getStr("name", "")
    output.expectedOutput = testNode.getStr("output", null)
    output.expectedErrorOutput = testNode.getStr("error", null)
    output.disabled = testNode.getBool("disabled", false)

    return output
}

func RunTest(suite: *TestSuite, test: *Test) : TestResult {
    testHarness.buffer.clear() // clear previous run

    var tmpSrcFile = "test_output/lita_test.lita"
    if(WriteFile(tmpSrcFile, test.programText.cStrConst(), test.programText.length) != FileStatus.Ok) {
        return TestResult.LOADING_ERROR
    }

    var options = LitaOptions{}
    options.checkerOnly = false
    options.cOutputOnly = false
    options.showProfileInfo = false
    options.run = false // we run outselves

    strncpy(options.inputFile, tmpSrcFile, MAX_PATH)
    strncpy(options.litaPath, GetEnv("LITAC_HOME"), MAX_PATH)

    var outputFile = "test"
    strncpy(options.outputFile, outputFile, MAX_PATH)

    var outputPath = "test_output"
    strncpy(options.outputPath, outputPath, MAX_PATH)

    FilePath(options.inputFile, options.srcPath)

    var lita = Lita{}
    lita.init(&options)
    defer lita.free()

    var root = lita.parse()
    if(!root) {
        goto report
    }

    if(!lita.typeCheck(root)) {
        goto report
    }

    if(!lita.transpile(root)) {
        goto err
    }

    lita.runCaptureOutput(testHarness.buffer)

    if(test.expectedOutput) {
        if(strcmp(test.expectedOutput, testHarness.buffer.cStr())  != 0) {
            goto err
        }
    }
    else if(testHarness.buffer.length) {
        goto err
    }

report:
    if(!lita.result.errors.empty()) {
        testHarness.buffer.clear() // clear program output

        for(var i = 0; i < lita.result.errors.size(); i += 1) {
            PrintError(testHarness.buffer, lita.result.errors.get(i))
            testHarness.buffer.append("\n")
        }
        testHarness.buffer.append("Total errors: %d\n", lita.result.errors.size())

        if(test.expectedErrorOutput) {
            if(testHarness.buffer.contains(test.expectedErrorOutput)) {
                return TestResult.SUCCESS
            }
            else {
                return TestResult.ERROR_MISMATCH
            }
        }

        goto err
    }
    else if(test.expectedErrorOutput) {
        return TestResult.ERROR_MISMATCH
    }


    return TestResult.SUCCESS

err:
    return TestResult.OUTPUT_MISMATCH
}


public func (this: *Lita) runCaptureOutput(sb: *StringBuffer) : *const char {
    var path: [MAX_PATH]char;
    FilePath(this.binaryFilename, path)

    var len = strlen(path)
    sb.append("cd ")
    sb.appendStr(path, len)
    sb.append(" && %s 2>&1", &this.binaryFilename[len + 1])

    var process = SystemExec(sb.cStr())

    sb.clear()

    var buffer = [1024]char{};
    var bytesRead = -1
    while((bytesRead = process.readOutput(buffer, 1024)) > 0) {
        sb.append("%s", buffer)
    }

    return sb.cStrConst()
}