//import "test_module" as BAD
//import "mem"
//import "array"
@include("<stdio.h>");
@foreign public func printf(s:*const char, ...) : void;

struct Test<V> {
    v: V
}

func (this: *Test<V>) call<V>() : V{
    return this.v
}
/*
struct TestV {
    v: i32
}

func (this: *TestV) call() : i32 {
    return this.v
}*/



/*
struct Vector<T> {
    capacity: usize
    size: usize
    elements: []T
}

struct Pair<V,S> {
    first: V
    second: S
}

func TestX<T>(a: T) : T {
    return a
}

func TestT<T>() : T {
    var x: T = 4 as (T)
    return x
}


struct Allocator {
}

struct Arena {
    alloc: using Allocator
    decorated: *void
}

public func (arena: *Arena) free() {
    var alloc = arena.decorated
}

func ArenaMalloc(alloc: *const Allocator, size: usize) : *void {
    var arena = alloc as (*Arena);
//    return arena.malloc(size);
    return arena as (*void);
}
*/
/*
public struct DebugAllocator {
    totalBytesFreed: usize
}

public const debugAllocator = (&DebugAllocator {
})

const MAX_PATH = 256
public struct Allocation {
    addr: *void
    size: usize
    line: u64
    filename: [MAX_PATH]char
}
*/
func main(len:i32, args: **char) : i32 {
    var x = Test<i32>{.v = 4_i32}
    printf("Result: %d\n", x.call())
    //var x2 = TestV{.v = 4_i32}
    //printf("Result: %d\n", x2.call())
//    var a = BAD::A
    /*var arena = Arena{}
    arena.free()
    */

  /*  functionA();
    var a = A
    var s = StructA{4}*/

    /*
    var v = Vector<i32>{}
    var v3 = Vector<i32>{}
    var v2 = Vector<Pair<i32, *const char>>{}

    TestX<i32>(4)
    TestX<Vector<i32>>(v)
    TestX<Vector<Pair<i32, *const char>>>(v2)*/
/*
    var x = TestX(10.04_f32)
    printf("X = %.2f\n", x)

    var y = TestX(100_i32)
    printf("Y = %d\n", y)
*/
    //var t = TestT()
    //printf("T = %d\n", t)

    //var t = TestT<i32>();
    //printf("t = %d\n", t)
}