import "ast"
import "string_buffer"
import "string_view"
import "string"
import "types"
import "module"
import "symbols"
import "lita"
import "phase_result"
import "lex"
import "libc"
import "array"
import "common"
import "dependency_graph"
import "assert"
import "system"
import "cgen_decl"

public struct CGen {
    lita: using *Lita
    buf: StringBuffer
    line: StringBuffer
    tmp: StringBuffer
    indent: i32
    aggregateLevel: i32
}

public func (this: *CGen) init(lita: *Lita) {
    this.lita = lita
    this.buf.init(4096, lita.allocator)
    this.line.init(1024, lita.allocator)
    this.tmp.init(1024, lita.allocator)
    this.aggregateLevel = 0
}

public func (this: using *CGen) emitProgram(module: *Module) {
    assert(module != null)
    assert(module.ast != null)

    this.emitForward()
    this.emitPrimitiveConstDecls()
    this.emitForwardDecls()

    buf.append("\n\n")
    buf.append("// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n")
    buf.append("// translated code begins\n")
    buf.append("// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n")
    buf.append("\n\n")
    //this.emitStmt(module.ast)

    var graph = DependencyGraph{}
    graph.init(this.lita)
    var declarations = graph.sort()

    for(var i = 0; i < declarations.size(); i += 1) {
        var sym = declarations.get(i)
        assert(sym.decl)

        this.emitStmt(sym.decl)
        this.emitln()
    }

    this.emitln()
}

func (this: using *CGen) emitForward() {
    this.buf.append(
"""
// Generated on %s
#include <stdint.h>
#include <stddef.h>
typedef int8_t    %s%s;
typedef int16_t   %s%s;
typedef int32_t   %s%s;
typedef int64_t   %s%s;
typedef uint8_t   %s%s;
typedef uint16_t  %s%s;
typedef uint32_t  %s%s;
typedef uint64_t  %s%s;
typedef float     %s%s;
typedef double    %s%s;
typedef int8_t    %s%s;
typedef size_t    %s%s;
#define %s%s (1)
#define %s%s (0)
#define %s%s void

""", 
    CurrentDateTime(),
    this.options.cPrefix, "i8",
    this.options.cPrefix, "i16",
    this.options.cPrefix, "i32",
    this.options.cPrefix, "i64",
    this.options.cPrefix, "u8",
    this.options.cPrefix, "u16",
    this.options.cPrefix, "u32",
    this.options.cPrefix, "u64",
    this.options.cPrefix, "f32",
    this.options.cPrefix, "f64",
    this.options.cPrefix, "bool",
    this.options.cPrefix, "usize",
    this.options.cPrefix, "true",
    this.options.cPrefix, "false",
    this.options.cPrefix, "void"
    );

    if(strlen(this.options.cPrefix) > 0) {
        buf.append("typedef char   %s%s;\n", this.options.cPrefix, "char")
    }
}

func (this: using *CGen) emitPrimitiveConstDecls() {
    var program = &this.lita.programSymbols
    for(var i = 0; i < program.values.size(); i += 1) {
        var sym = program.values.get(i)

        if(!(sym.flags & SymbolFlags.IS_CONSTANT)) {
            continue
        }

        if(sym.flags & SymbolFlags.IS_FOREIGN) {
            continue
        }

        if(!IsPrimitive(sym.type)) {
            continue
        }

        this.emitVarDecl(sym.decl as (*VarDecl))
        this.emitln()
    }
}

func (this: using *CGen) emitForwardDecls() {
    var program = &this.lita.programSymbols
    for(var i = 0; i < program.symbolTypes.size(); i += 1) {
        var sym = program.symbolTypes.get(i)
        this.emitTypeForwardDecl(sym)
    }

    for(var i = 0; i < program.symbolFuncs.size(); i += 1) {
        var sym = program.symbolFuncs.get(i)
        this.emitTypeForwardDecl(sym)
    }
}

func (this: using *CGen) emitTypeForwardDecl(sym: *Symbol) {
    var decl = sym.decl

    if(sym.flags & SymbolFlags.IS_FOREIGN) {
        return;
    }
    
    var name = this.cName(decl.sym)
    switch(decl.kind) {
        case StmtKind.VAR_DECL:
        case StmtKind.CONST_DECL:
            this.buf.append("~~ %s;\n", sym.name)
            break;
        case StmtKind.FUNC_DECL: {
            this.emitNotes(decl.attributes)
            this.emitln()
            
            var funcInfo = decl.sym.type as (*FuncTypeInfo)
            if(funcInfo.returnType.kind == TypeKind.FUNC_PTR) {
                var funcPtrInfo = funcInfo.returnType as (*FuncPtrTypeInfo)
                buf.append("%s (*%s(", this.cType(funcPtrInfo.returnType), name)
            }
            else {
                buf.append("%s %s(", this.cType(funcInfo.returnType), name)
            }

            var decayArrays = true
            var isCast = false
            var i = 0
            for(; i < funcInfo.decl.params.size(); i += 1) {
                if(i > 0) {
                    buf.append(",")
                }

                var param = funcInfo.decl.params.get(i)
                buf.append("%s", this.cType(param.sym.type, isCast, decayArrays))
            }

            if(funcInfo.decl.flags & FuncFlags.HAS_VARARGS) {
                if(i > 0) {
                    buf.append(",")
                }
                buf.append("...")
            }

            buf.append(")")

            if(funcInfo.returnType.kind == TypeKind.FUNC_PTR) {
                var funcPtrInfo = funcInfo.returnType as (*FuncPtrTypeInfo)
                buf.append(")  (")

                var j = 0
                for(; j < funcPtrInfo.paramDecls.size(); j+=1) {
                    if(j > 0) {
                        buf.append(",")
                    }

                    buf.append("%s", this.cType(funcPtrInfo.paramDecls.get(j)))
                }
                if(funcPtrInfo.hasVarargs) {
                    if(j > 0) {
                        buf.append(",")
                    }
                    buf.append("...")
                }
                buf.append(")")
            }

            buf.append(";\n")
            break;
        }
        case StmtKind.UNION_DECL:
        case StmtKind.STRUCT_DECL: {
            var aggDecl = decl as (*AggregateDecl)
            if(!(aggDecl.flags & AggregateFlags.IS_EMBEDDED)) {
                this.buf.append("typedef %s %s %s;\n", aggDecl.kind == StmtKind.STRUCT_DECL ? "struct" : "union", name, name)
            }
            break;
        }
        case StmtKind.ENUM_DECL: {
            this.buf.append("enum %s;\n", sym.name)
            break;
        }
        default: {
            assert(false)
        }
    }
}

func (this: using *CGen) escapeNameStr(name: *const char) : *char {
    tmp.clear()
    tmp.appendStr(name, strlen(name))
    for(var i = 0; i < tmp.length; i+=1) {
        var c = tmp.buffer[i]
        switch(c) {
            case '*': tmp.replace(i, i+1, "_ptr_"); i+=6; break;
            case '<': tmp.replace(i, i+1, "_cb_");  i+=4; break;
            case '>': tmp.replace(i, i+1, "_ce_");  i+=4; break;
            case '[': tmp.replace(i, i+1, "_bb_");  i+=4; break;
            case ']': tmp.replace(i, i+1, "_be_");  i+=4; break;
            case '(': tmp.replace(i, i+1, "_pb_");  i+=4; break;
            case ')': tmp.replace(i, i+1, "_pe_");  i+=4; break;
            case ',': tmp.replace(i, i+1, "_c_");   i+=3; break;
            case ' ': tmp.replace(i, i+1, "_");     i+=1; break;
            case ':': {
                var n = i + 1;
                if(n < tmp.length) {
                    var nc = tmp.buffer[n]
                    if(nc == ':') {
                        tmp.replace(i, i+1, "__")
                        i+=2;
                        break;
                    }
                }
                tmp.replace(i, i+1, "_r_")
                i+=3;
                break;
            }
            default: {
                i+=1;
                break;
            }
        }
    }

    return tmp.cStr()
}

func (this: using *CGen) escapeName(type: *TypeInfo) : *const char {
    if(IsAggregate(type)) {
        return this.escapeNameStr(type.name)
    }

    if(IsFuncLike(type)) {
        if(type.kind == TypeKind.FUNC) {
            // TODO: Get method name
            var funcInfo = type as (*FuncTypeInfo)
            if(funcInfo.decl.flags & FuncFlags.IS_METHOD) {
                //var methodName = funcInfo.getMethodName()
                assert(false)
            }
        }
        return this.escapeNameStr(type.name)
    }

    return type.name
}

func (this: using *CGen) baseTypeName(name: *const char) : StringView {
    var str = StringViewInit(name)
    
    // strip module name
    var index = str.indexOf("::")
    if(index >= 0) {
        str = str.substring(index + 2)
    }

    // strip generics
    index = str.indexOf("<")
    if(index >= 0) {
        str = str.substring(0, index)
    }
    
    return str
}

func (this: using *CGen) emitLineInfo(stmt: *Stmt) {
    // TODO
    //this.emitln()
}

/**
    Outputs a type in C for the supplied symbol
*/
func (this: using *CGen) cType(type: *TypeInfo, 
                               isCast: bool = false, 
                               decay: bool = false) : *const char {
    var sb = StringBufferInit(256, this.allocator)
    switch(type.kind) {
        case TypeKind.PTR: {
            var ptrInfo = type as (*PtrTypeInfo)
            var baseInfo = ptrInfo.getBaseType()
            if(baseInfo.kind == TypeKind.ARRAY && !decay) {
                var arrayInfo = baseInfo as (*ArrayTypeInfo)
                if(arrayInfo.length > -1) {
                    var cType = this.cType(arrayInfo.arrayOf, isCast, decay)
                    sb.append("%s (*)[%zu]", cType, arrayInfo.length)
                    return sb.cStrConst()
                }
            }
            var cType = this.cType(ptrInfo.ptrOf, isCast, decay)
            sb.append("%s*", cType)
            return sb.cStrConst()

        }
        case TypeKind.CONST: {
            var constInfo = type as (*ConstTypeInfo)
            if(IsPtrLike(constInfo.constOf)) {
                var cType = this.cType(constInfo.constOf, isCast, decay)
                sb.append("%s const", cType)
                return sb.cStrConst()
            }
            var cType = this.cType(constInfo.constOf, isCast, decay)
            sb.append("const %s", cType)
            return sb.cStrConst()
        }
        case TypeKind.ARRAY: {
            var arrayInfo = type as (*ArrayTypeInfo)
            if(decay) {
                var ptrInfo = PtrTypeInfo {
                    .info = TypeInfo {. kind = TypeKind.PTR},
                    .ptrOf = arrayInfo.arrayOf
                }
                return this.cType(ptrInfo, isCast, decay)
            }

            var baseInfo = arrayInfo.getBaseType()
            var baseName = this.cType(baseInfo)

            var buf = StringBufferInit(256, this.allocator)
            do {
                if(arrayInfo.length < 0) {
                    if(arrayInfo.numOfElements) {
                        buf.append("[")
                        var cgen = CGen {
                            .lita = this.lita,
                            .buf = buf
                        }
                        cgen.emitStmt(arrayInfo.numOfElements)
                        buf.append("]")
                    }
                    else {
                        buf.append("[]")
                    }
                }
                else {
                    buf.append("[%zu]", arrayInfo.length)
                }

                if(arrayInfo.arrayOf && arrayInfo.arrayOf.kind == TypeKind.ARRAY) {
                    arrayInfo = arrayInfo.arrayOf as (*ArrayTypeInfo)
                }
                else {
                    arrayInfo = null
                }
            }
            while(arrayInfo);

            sb.append("%s%s", baseName, buf.cStrConst())
            return sb.cStrConst()
        }        
        case TypeKind.FUNC_PTR: {
            var funcInfo = type as (*FuncPtrTypeInfo)
            var params = StringBufferInit(512, this.allocator)
            for(var i = 0; i < funcInfo.paramDecls.size(); i += 1) {
                if(i > 0) {
                    params.append(",")
                }

                var param = funcInfo.paramDecls.get(i)
                params.append("%s", this.cType(param, isCast, true))
            }

            sb.append("%s (*%s)(%s)", this.cType(funcInfo.returnType, isCast, decay), 
                isCast ? "" : this.cTypeName(funcInfo), params.cStrConst())
            return sb.cStrConst()
        }
        default: {
            return this.cTypeName(type)
        }
    }
}

/**
    Outputs a type declaration in C for the supplied symbol
*/
func (this: using *CGen) cTypeDecl(type: *TypeInfo, 
                                   name: *const char, 
                                   decay: bool = false) : *const char {

    var sb = StringBufferInit(256, this.allocator)
    switch(type.kind) {
        case TypeKind.PTR: {
            var ptrInfo = type as (*PtrTypeInfo)
            var baseInfo = ptrInfo.getBaseType()
            if(baseInfo.kind == TypeKind.ARRAY && !decay) {
                var arrayInfo = baseInfo as (*ArrayTypeInfo)
                if(arrayInfo.length > -1) {
                    var cType = this.cType(arrayInfo.arrayOf)
                    sb.append("%s (*%s)[%zu]", cType, name, arrayInfo.length)
                    return sb.cStrConst()
                }
            }
            var cType = this.cType(type, false, decay)
            sb.append("%s %s", cType, name)
            return sb.cStrConst()
        }
        case TypeKind.CONST: {
            var constInfo = type as (*ConstTypeInfo)
            if(IsPtrLike(constInfo.constOf)) {
                var cType = this.cType(constInfo.constOf, false, decay)
                sb.append("%s const %s", cType, name)
                return sb.cStrConst()
            }
            var cType = this.cTypeDecl(constInfo.constOf, name, decay)
            sb.append("const %s", cType)
            return sb.cStrConst()
        }
        case TypeKind.ARRAY: {
            var arrayInfo = type as (*ArrayTypeInfo)
            if(decay) {
                var ptrInfo = PtrTypeInfo {
                    .info = TypeInfo {. kind = TypeKind.PTR},
                    .ptrOf = arrayInfo.arrayOf
                }
                return this.cTypeDecl(ptrInfo, name, decay)
            }

            var baseInfo = arrayInfo.getBaseType()
            var baseName = this.cType(baseInfo)

            var buf = StringBufferInit(256, this.allocator)
            do {
                if(arrayInfo.length < 0) {
                    if(arrayInfo.numOfElements) {
                        buf.append("[")
                        var cgen = CGen {
                            .lita = this.lita,
                            .buf = buf
                        }
                        cgen.emitStmt(arrayInfo.numOfElements)
                        buf.append("]")
                    }
                    else {
                        buf.append("[]")
                    }
                }
                else {
                    buf.append("[%zu]", arrayInfo.length)
                }

                if(arrayInfo.arrayOf && arrayInfo.arrayOf.kind == TypeKind.ARRAY) {
                    arrayInfo = arrayInfo.arrayOf as (*ArrayTypeInfo)
                }
                else {
                    arrayInfo = null
                }
            }
            while(arrayInfo);

            if(baseInfo.kind == TypeKind.FUNC_PTR) {
                buf.insert(0, "%s", name)
                return this.cTypeDecl(baseInfo, buf.cStrConst(), decay)
            }
            
            sb.append("%s %s%s", baseName, name, buf.cStrConst())
            return sb.cStrConst()
        }        
        case TypeKind.STR: {
            sb.append("const char* %s", name)
            return sb.cStrConst()
        }
        case TypeKind.FUNC_PTR: {
            var funcInfo = type as (*FuncPtrTypeInfo)
            var params = StringBufferInit(512, this.allocator)
            for(var i = 0; i < funcInfo.paramDecls.size(); i += 1) {
                if(i > 0) {
                    params.append(",")
                }

                var param = funcInfo.paramDecls.get(i)
                params.append("%s", this.cType(param, false, true))
            }

            sb.append("%s (*%s)(%s)", this.cType(funcInfo.returnType, false, decay), name, params.cStrConst())
            return sb.cStrConst()
        }
        default: {
            var cType = this.cType(type, false, decay)
            sb.append("%s %s", cType, name)
            return sb.cStrConst()
        }
    }
}

/**
    Outputs the C name for the symbol
*/    
func (this: using *CGen) cName(sym: *Symbol) : *const char {
    var declName:*const char = (sym.flags & SymbolFlags.IS_TYPE) 
                                    ? this.escapeName(sym.type) : sym.name;

    var sb = StringBufferInit(256, this.allocator)
    if(sym.flags & SymbolFlags.IS_LOCAL) {
        return this.prefix(declName, sb)
    }

    if(sym.flags & SymbolFlags.IS_FOREIGN) {
        if(sym.flags & SymbolFlags.IS_BUILTIN) {

        }
        // TODO: Get the foreign override name
    }

    // TODO: Get a non-collision based module name
    sb.append("%.*s__%s", sym.declared.id.name.length, sym.declared.id.name.buffer, declName)
    return sb.cStrConst()
}

/**
    Outputs the C name for the symbol
*/    
func (this: using *CGen) cTypeName(type: *TypeInfo) : *const char {
    assert(type != null)

    var typeName = this.escapeName(type)
    var sb = StringBufferInit(256, this.allocator)

    if(!type.sym) {
        return this.prefix(typeName, sb)
    }

    var sym = type.sym
    if(sym.flags & SymbolFlags.IS_FOREIGN) {
        if(sym.flags & SymbolFlags.IS_BUILTIN) {
            return typeName
        }
        // TODO: Get the foreign override name
    }

    // TODO: Get a non-collision based module name
    sb.append("%.*s__%s", sym.declared.id.name.length, sym.declared.id.name.buffer, typeName)
    return sb.cStrConst()
}

func (this: using *CGen) prefix(name: *const char, sb: *StringBuffer) : *const char {
    sb.append("%s%s", this.options.cPrefix, name)
    return sb.cStrConst()
}

func (this: using *CGen) emitTypeSpec(spec: *TypeSpec) {
    assert(spec != null)

    switch(spec.kind) {
        case TypeSpecKind.NONE: {
            return;
        }
        case TypeSpecKind.ARRAY: {
            var array = spec as (*ArrayTypeSpec)
            buf.append("[");
            if(array.numElements) {
                this.emitStmt(array.numElements)
            }
            buf.append("]");
            this.emitTypeSpec(array.base)
            return;
        }
        case TypeSpecKind.PTR: {
            var ptr = spec as (*PtrTypeSpec)
            buf.append("*");
            this.emitTypeSpec(ptr.base)
            return;
        }
        case TypeSpecKind.CONST: {
            var c = spec as (*ConstTypeSpec)
            buf.append("const ");
            this.emitTypeSpec(c.base)
            return;
        }
        case TypeSpecKind.NAME: {
            var name = spec as (*NameTypeSpec)
            buf.append("%s", name.name)
            if(!name.genericArgs.empty()) {
                buf.append("<")
                for(var i = 0; i < name.genericArgs.size(); i += 1) {
                    if(i > 0) buf.append(",")
                    this.emitTypeSpec(name.genericArgs.get(i))
                }
                buf.append(">")
            }
            return;
        }
        case TypeSpecKind.FUNC_PTR: {
            var fn = spec as (*FuncPtrTypeSpec)
            buf.append("func")
            if(!fn.genericParams.empty()) {
                buf.append("<")
                for(var i = 0; i < fn.genericParams.size(); i += 1) {
                    if(i > 0) buf.append(",")
                    this.emitName(fn.genericParams.get(i).name)
                }
                buf.append(">")
            }
            buf.append("(")
            for(var i = 0; i < fn.args.size(); i += 1) {
                if(i > 0) buf.append(",")
                this.emitTypeSpec(fn.args.get(i))
            }
            buf.append(") : ")
            this.emitTypeSpec(fn.ret)
            return;
        }
        default: {
            Panic("Invalid TypeSpecKind: '%d'\n", spec.kind)
        }
    }
}

func (this: using *CGen) emitName(tok: Token) {
    if(tok.type != TokenType.ERROR) {
        buf.append("%.*s", tok.value.str.length, tok.value.str.buffer)
    }
}

func (this: using *CGen) emitln() {
    buf.appendChar('\n')
    for(var i = 0; i < indent; i += 1) {
        buf.appendStr("    ", 4);
    }
}

func (this: using *CGen) emit(format: *const char, ...) {
    line.clear()

    var args: va_list;
    va_start(args, format);
    line.appendArgs(format, args)
    va_end(args)

    for(var i = 0; i < line.length; i+=1) {
        var c = line.buffer[i]
        if(c == '\n') {
            this.emitln()
        }
        else if(c == '{') {
            buf.appendChar(c)
            indent+=1
            this.emitln()
        }
        else if(c == '}') {
            indent-=1
            this.emitln()
            buf.appendChar(c)
        }
        else {
            buf.appendChar(c)
        }
    }
}

func (this: using *CGen) emitNotes(attributes: *Attributes) {
    if(!attributes.notes.empty()) {
        // TODO Notes!!
        for(var i = 0; i < attributes.notes.size(); i += 1) {
            //this.emitStmt(decl.attributes.notes.get(i))
            //this.emit("\n")
        }
    }
}

func (this: using *CGen) emitStmt(s: *Stmt) {
    if(!s) return;

    switch(s.kind) {
        case StmtKind.IMPORT_DECL: {
            var decl = s as (*ImportDecl)
            this.emit("import '")
            this.emitName(decl.name)
            this.emit("'")
            if(decl.alias.type == TokenType.IDENTIFIER) {
                this.emit(" as ")
                this.emitName(decl.alias)
            }
            return;
        }
        case StmtKind.CONST_DECL:
        case StmtKind.VAR_DECL: {
            var decl = s as (*VarDecl)
            this.emitVarDecl(decl)
            return;
        }
        case StmtKind.UNION_DECL:
        case StmtKind.STRUCT_DECL: {
            var decl = s as (*AggregateDecl)
            this.emitAggregateDecl(decl)
            return;
        }
        case StmtKind.ENUM_DECL: {
            var decl = s as (*EnumDecl)
            this.emitEnumDecl(decl)
            return;
        }
        case StmtKind.FUNC_DECL: {
            var decl = s as (*FuncDecl)
            this.emitFuncDecl(decl)
            return;
        }
        case StmtKind.TYPEDEF_DECL: {
            var decl = s as (*TypedefDecl)
            if(!decl.attributes.notes.empty()) {
                for(var i = 0; i < decl.attributes.notes.size(); i += 1) {
                    this.emitStmt(decl.attributes.notes.get(i))
                    this.emit("\n")
                }
            }

            this.emit("")
            if(decl.attributes.isPublic) {
                this.emit("public ")
            }
            this.emit("typedef ")
            this.emitTypeSpec(decl.type)
            this.emit(" as ")
            this.emitName(decl.name)
            return;
        }
        case StmtKind.PARAM_DECL: {
            var decl = s as (*ParameterDecl)
            if(!decl.attributes.notes.empty()) {
                for(var i = 0; i < decl.attributes.notes.size(); i += 1) {
                    this.emitStmt(decl.attributes.notes.get(i))
                    this.emit("\n")
                }
            }

            this.emitName(decl.name)
            this.emit(": ")
            this.emitTypeSpec(decl.type)
            if(decl.defaultExpr) {
                this.emit(" = ")
                this.emitStmt(decl.defaultExpr)
            }
            return;
        }
        /*
        case StmtKind.NATIVE_DECL: {
            // var decl = new<NativeDecl>(allocator)
            // decl.kind = StmtKind.NATIVE_DECL;
            // decl.startPos = startPos
            // decl.type = null
            // return decl as (*Stmt)
            return;
        }*/
        case StmtKind.POISON_DECL: {
            this.emit("<poison_decl>")
            return;
        }

        case StmtKind.BLOCK_STMT: {
            var stmt = s as (*BlockStmt)
            this.emit("{")
            for(var i = 0; i < stmt.stmts.size(); i += 1) {
                var n = stmt.stmts.get(i)
                this.emitStmt(n)
                if(IsExpr(n)) {
                    this.emit(";\n")
                }
                else {
                    this.emit("\n")
                }
            }
            this.emit("\n")
            this.emit("}")
            return;
        }
        case StmtKind.BREAK_STMT: {
            var stmt = s as (*BreakStmt)
            this.emit("break")
            return;
        }/*
        case StmtKind.COMP_STMT: {
            // var stmt = new<CompStmt>(allocator)
            // stmt.kind = StmtKind.COMP_STMT;
            // stmt.startPos = startPos
            // stmt.type = null
            // stmt.expr = null
            // stmt.body.init(16, allocator)
            // stmt.end = null
            // stmt.evaluatedStmt = null
            // return stmt as (*Stmt)
        }*/
        case StmtKind.CONTINUE_STMT: {            
            var stmt = s as (*ContinueStmt)
            this.emit("continue")
            return;
        }
        case StmtKind.DEFER_STMT: {
            var stmt = s as (*DeferStmt)
            this.emit("defer ")
            this.emitStmt(stmt.deferedStmt)
            return;
        }
        case StmtKind.DO_WHILE_STMT: {
            var stmt = s as (*DoWhileStmt)
            this.emit("do\n")
            this.emitStmt(stmt.body)
            this.emit("\nwhile(")
            this.emitStmt(stmt.cond)
            this.emit(")")
            return;
        }
        case StmtKind.EMPTY_STMT: {
            this.emit("\n")
            return;
        }
        case StmtKind.ENUM_FIELD_ENTRY_DECL: {
            var stmt = s as (*EnumFieldEntryDecl)
            this.emit("")
            this.emitName(stmt.name)
            if(stmt.value) {
                this.emit(" = ")
                this.emitStmt(stmt.value)
            }
            return;
        }/*
        case StmtKind.ENUM_FIELD_STMT: {
            var stmt = s as (*EnumDecl)
            this.emitStmt(stmt)
            return;
            
        }*/
        case StmtKind.FOR_STMT: {
            var stmt = s as (*ForStmt)
            this.emit("for(")
            if(stmt.init) {
                this.emitStmt(stmt.init)
            }
            this.emit(";")
            if(stmt.cond) {
                this.emitStmt(stmt.cond)
            }
            this.emit(";")
            if(stmt.post) {
                this.emitStmt(stmt.post)
            }
            this.emit(")\n")
            if(stmt.body) {
                this.emitStmt(stmt.body)
            }
            return;
        }
        case StmtKind.FUNC_BODY_STMT: {
            var stmt = s as (*FuncBodyStmt)
            for(var i = 0; i < stmt.stmts.size(); i += 1) {
                var n = stmt.stmts.get(i)
                this.emitStmt(n)
                if(IsExpr(n)) {
                    this.emit(";\n")
                }
                else {
                    this.emit("\n")
                }
            }
            return;
        }
        case StmtKind.GOTO_STMT: {
            var stmt = s as (*GotoStmt)
            this.emit("goto ")
            this.emitName(stmt.label)
            return;
        }
        case StmtKind.IF_STMT: {
            var stmt = s as (*IfStmt)
            this.emit("if(")
            this.emitStmt(stmt.cond)
            this.emit(") \n")
            this.emitStmt(stmt.then)
            this.emit("\n")
            if(stmt.elseStmt) {
                
                this.emit("else \n")
                this.emitStmt(stmt.elseStmt)
            }
            this.emit("\n")
            return;
        }
        case StmtKind.LABEL_STMT: {
            var stmt = s as (*LabelStmt)
            this.emit(":")
            this.emitName(stmt.label)
            return;
        }
        case StmtKind.MODULE_STMT: {
            var stmt = s as (*ModuleStmt)
            for(var i = 0; i < stmt.imports.size(); i += 1) {
                this.emitStmt(stmt.imports.get(i) as (*Stmt))
                this.emit("\n")
            }

            this.emit("\n")

            for(var i = 0; i < stmt.notes.size(); i += 1) {
                this.emitStmt(stmt.notes.get(i))
                this.emit(";\n")
            }

            this.emit("\n")

            for(var i = 0; i < stmt.declarations.size(); i += 1) {
                this.emitStmt(stmt.declarations.get(i) as (*Stmt))
                this.emit("\n")
                this.emit("\n")
            }

            this.emit("\n")
            return;
        }
        case StmtKind.NOTE_STMT: {
            var stmt = s as (*NoteStmt)
            this.emit("@")
            this.emitName(stmt.name)
            if(!stmt.attributes.empty()) {
                this.emit("(")
                for(var i = 0; i < stmt.attributes.size(); i += 1) {
                    if(i > 0) this.emit(", ")
                    this.emit("'")
                    this.emitName(stmt.attributes.get(i))
                    this.emit("'")
                }
                this.emit(")")
            }
            return;
        }
        case StmtKind.PARAMETERS_STMT: {
            var stmt = s as (*ParametersStmt)
            for(var i = 0; i < stmt.params.size(); i += 1) {
                if(i>0) this.emit(", ")
                this.emitStmt(stmt.params.get(i) as (*Stmt))
            }
            return;
        }
        case StmtKind.RETURN_STMT: {
            var stmt = s as (*ReturnStmt)
            this.emit("return");
            if(stmt.expr) {
                this.emit(" ")
                this.emitStmt(stmt.expr)
            }
            return;
        }/*
        case StmtKind.STRUCT_FIELD_STMT: {
            var stmt = new<AggregateFieldStmt>(allocator)
            stmt.kind = StmtKind.STRUCT_FIELD_STMT;
            stmt.startPos = startPos
            stmt.decl = null
            return stmt as (*Stmt)
        }
        case StmtKind.SWITCH_CASE_STMT: {
            var stmt = new<SwitchCaseStmt>(allocator)
            stmt.kind = StmtKind.SWITCH_CASE_STMT;
            stmt.startPos = startPos
            stmt.cond = null
            stmt.body = null
            return stmt as (*Stmt)
        }
        case StmtKind.SWITCH_STMT: {
            var stmt = new<SwitchStmt>(allocator)
            stmt.kind = StmtKind.SWITCH_STMT;
            stmt.startPos = startPos
            stmt.cond = null
            stmt.stmts.init(16, allocator)
            stmt.defaultStmt = null
            return stmt as (*Stmt)
        }
        case StmtKind.UNION_FIELD_STMT: {
            var stmt = new<AggregateFieldStmt>(allocator)
            stmt.kind = StmtKind.UNION_FIELD_STMT;
            stmt.startPos = startPos
            stmt.decl = null
            return stmt as (*Stmt)
        }*/
        case StmtKind.VAR_FIELD_DECL: {
            var decl = s as (*VarFieldDecl)
            this.emitLineInfo(decl)

            var name: [MAX_SYMBOL_NAME]char;
            var nameStr = StringInit(name, MAX_SYMBOL_NAME)
            nameStr.format("%.*s", decl.name.str.length, decl.name.str.buffer)

            var aliasNote = decl.getNote("alias")
            if(aliasNote && !aliasNote.attributes.empty()) {
                var aliasName = aliasNote.attributes.get(0)

                nameStr.clear()
                nameStr.format("%.*s", aliasName.str.length, aliasName.str.buffer)
            }

            this.emit("%s;\n", this.cTypeDecl(decl.type.typeInfo, nameStr.cStrConst()))
            return;
        }
        case StmtKind.WHILE_STMT: {
            var stmt = s as (*WhileStmt)            
            this.emit("while(")
            this.emitStmt(stmt.cond)
            this.emit(")\n")
            this.emitStmt(stmt.body)
            return;
        }
        
        case StmtKind.ARRAY_DESIGNATION_EXPR: {
            var expr = s as (*ArrayDesignationExpr)
            this.emit("[")
            this.emitStmt(expr.index)
            this.emit("] = ")
            this.emitStmt(expr.value)
            return;
        }
        case StmtKind.ARRAY_INIT_EXPR: {
            var expr = s as (*ArrayInitExpr)
            this.emitTypeSpec(expr.type)
            this.emit(" {")
            for(var i = 0; i < expr.values.size(); i+=1) {
                var v = expr.values.get(i)
                if(i > 0) {
                    this.emit(",\n")
                }
                this.emitStmt(v)
            }
            
            this.emit("}")
            return;
        }
        case StmtKind.BINARY_EXPR: {
            var expr = s as (*BinaryExpr)
            this.emitStmt(expr.left)
            this.emit(" %s ", tokenText[expr.operator])
            this.emitStmt(expr.right)
            break;
        }
        case StmtKind.BOOLEAN_EXPR: {
            var expr = s as (*BooleanExpr)
            this.emit("%s", expr.boolean ? "true" : "false")
            return;
        }/*
        case StmtKind.CAST_EXPR: {
            var expr = new<CastExpr>(allocator)
            expr.kind = StmtKind.CAST_EXPR;
            expr.startPos = startPos
            expr.castTo = null
            expr.exprToCast = null
            return expr as (*Stmt)
        }*/
        case StmtKind.CHAR_EXPR: {
            var expr = s as (*CharExpr)
            this.emit("'%c'", expr.character.intValue as (char))            
            return;
        }
        case StmtKind.FUNC_CALL_EXPR: {
            var expr = s as (*FuncCallExpr)
            this.emitStmt(expr.object)
            this.emit("(")
            for(var i = 0; i < expr.arguments.size(); i+=1) {
                if(i > 0) {
                    this.emit(", ")
                }
                this.emitStmt(expr.arguments.get(i))
            }
            this.emit(")")
            return;
        }
        
        case StmtKind.FUNC_IDENTIFIER_EXPR: {
            var expr = s as (*IdentifierExpr)
            this.emit("%s", expr.type.name)
            return;
        }
        case StmtKind.GET_EXPR: {
            var expr = s as (*GetExpr)
            this.emitStmt(expr.object)
            this.emit(".")
            this.emitStmt(expr.field)
            return;
        }
        case StmtKind.GROUP_EXPR: {
            var expr = s as (*GroupExpr)
            this.emit("(")
            this.emitStmt(expr.groupedExpr)
            this.emit(")")
            return;
        }
        case StmtKind.IDENTIFIER_EXPR: {
            var expr = s as (*IdentifierExpr)
            this.emit("%s", expr.type.name)
            return;
        }
        case StmtKind.INIT_ARG_EXPR: {
            var expr = s as (*InitArgExpr)
            if(expr.fieldName.type == TokenType.IDENTIFIER) {
                this.emit(".")
                this.emitName(expr.fieldName)
                this.emit(" = ")
            }

            this.emitStmt(expr.value)
            return;
        }
        case StmtKind.INIT_EXPR: {
            var expr = s as (*InitExpr)
            this.emit("%s", expr.type.name)
            this.emit(" {")
            for(var i = 0; i < expr.arguments.size(); i += 1) {
                if(i > 0) {
                    this.emit(",\n")
                }
                this.emitStmt(expr.arguments.get(i))
            }
            this.emit("}")
            return;
        }
        case StmtKind.NULL_EXPR: {
            var expr = s as (*NullExpr)
            this.emit("null")
            return;
        }
        case StmtKind.NUMBER_EXPR: {
            var expr = s as (*NumberExpr)
            switch(expr.number.type) {
                case TokenType.INT_NUMBER: {
                    this.emit("%llu", expr.number.value.intValue)
                    break;
                }
                case TokenType.FLOAT_NUMBER: {
                    this.emit("%f", expr.number.value.floatValue)
                    break;
                }
                default: {}
            }
            return;
        }/*
        case StmtKind.OFFSET_OF_EXPR: {
            var expr = new<OffsetOfExpr>(allocator)
            expr.kind = StmtKind.OFFSET_OF_EXPR;
            expr.startPos = startPos
            expr.type = null
            expr.field = null
            return expr as (*Stmt)
        }
        case StmtKind.SET_EXPR: {
            var expr = new<SetExpr>(allocator)
            expr.kind = StmtKind.SET_EXPR;
            expr.startPos = startPos
            expr.object = null
            expr.field = null
            expr.value = null
            return expr as (*Stmt)
        }
        case StmtKind.SIZE_OF_EXPR: {
            var expr = new<SizeOfExpr>(allocator)
            expr.kind = StmtKind.SIZE_OF_EXPR;
            expr.startPos = startPos
            expr.sizeOfExpr = null
            return expr as (*Stmt)
        }*/
        case StmtKind.STRING_EXPR: {
            var expr = s as (*StringExpr)
            // TODO: String escaping
            this.emit("\"%.*s\"", expr.string.str.length, expr.string.str.buffer)
            return;
        }/*
        case StmtKind.SUBSCRIPT_GET_EXPR: {
            var expr = new<SubscriptGetExpr>(allocator)
            expr.kind = StmtKind.SUBSCRIPT_GET_EXPR;
            expr.startPos = startPos
            expr.object = null
            expr.index = null
            return expr as (*Stmt);
        }
        case StmtKind.SUBSCRIPT_SET_EXPR: {
            var expr = new<SubscriptSetExpr>(allocator)
            expr.kind = StmtKind.SUBSCRIPT_SET_EXPR;
            expr.startPos = startPos
            expr.object = null
            expr.index = null
            expr.value = null
            return expr as (*Stmt);
        }*/
        case StmtKind.TERNARY_EXPR: {
            var expr = s as (*TernaryExpr)
            this.emit("(")
            this.emitStmt(expr.cond)
            this.emit(") ? ")
            this.emitStmt(expr.then)
            this.emit(" : ")
            this.emitStmt(expr.other)
            return;
        }/*
        case StmtKind.TYPE_IDENTIFIER_EXPR: {
            var expr = new<TypeIdentifierExpr>(allocator)
            expr.kind = StmtKind.TYPE_IDENTIFIER_EXPR;
            expr.startPos = startPos
            expr.genericArgs.init(2, allocator)
            expr.type = null
            //expr.sym//
            return expr as (*Stmt);
        }
        case StmtKind.TYPE_OF_EXPR: {
            var expr = new<TypeOfExpr>(allocator)
            expr.kind = StmtKind.TYPE_OF_EXPR;
            expr.startPos = startPos
            expr.typeOfExpr = null
            expr.type = null
            return expr as (*Stmt);
        }*/
        case StmtKind.UNARY_EXPR: {
            var expr = s as (*UnaryExpr)
            this.emit("%s", tokenText[expr.operator])
            this.emitStmt(expr.unaryExpr)
            return;
        }
        case StmtKind.POISON_EXPR: {
            this.emit("<poison_expr>")
            return;
        }
        default: {
            //Panic("Unknown statement kind: %d", s.kind)
            this.emit("<%s Not Implemented>", StmtKindAsStr(s.kind))
            return;
        }
    }    
}