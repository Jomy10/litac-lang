import "ast"
import "string_buffer"
import "string_view"
import "types"
import "module"
import "symbols"
import "lita"
import "phase_result"
import "lex"
import "libc"
import "array"
import "common"
import "assert"

import "cgen_decl"

public struct CGen {
    lita: using *Lita
    buf: StringBuffer
    line: StringBuffer
    tmp: StringBuffer
    indent: i32
}

public func (this: *CGen) init(lita: *Lita) {
    this.lita = lita
    this.buf.init(4096, lita.allocator)
    this.line.init(1024, lita.allocator)
    this.tmp.init(1024, lita.allocator)
}

public func (this: using *CGen) emitProgram(module: *Module) {
    assert(module != null)
    assert(module.ast != null)

    this.emitForward()
    this.emitPrimitiveConstDecls()
    this.emitForwardDecls()

    buf.append("\n// translated code begins\n")
    this.emitStmt(module.ast)
}

func (this: using *CGen) emitForward() {
    this.buf.append(
"""
// Generated on %s
""", "'TODO insert date'")
}

func (this: using *CGen) emitPrimitiveConstDecls() {
    var program = &this.lita.programSymbols
    for(var i = 0; i < program.values.size(); i += 1) {
        var sym = program.values.get(i)

        if(!(sym.flags & SymbolFlags.IS_CONSTANT)) {
            continue
        }

        if(sym.flags & SymbolFlags.IS_FOREIGN) {
            continue
        }

        if(!IsPrimitive(sym.type)) {
            continue
        }

        this.emitVarDecl(sym.decl as (*VarDecl))
    }
}

func (this: using *CGen) emitForwardDecls() {
    var program = &this.lita.programSymbols
    for(var i = 0; i < program.symbolTypes.size(); i += 1) {
        var sym = program.symbolTypes.get(i)
        this.emitTypeForwardDecl(sym)
    }
}

func (this: using *CGen) emitTypeForwardDecl(sym: *Symbol) {
    var decl = sym.decl

    if(sym.flags & SymbolFlags.IS_FOREIGN) {
        return;
    }

    switch(decl.kind) {
        case StmtKind.VAR_DECL:
        case StmtKind.CONST_DECL:
        case StmtKind.FUNC_DECL:
            this.buf.append("~~ %s;\n", sym.name)
            break;
        case StmtKind.UNION_DECL:
        case StmtKind.STRUCT_DECL: {
            this.buf.append("struct %s;\n", sym.name)
            break;
        }
        case StmtKind.ENUM_DECL: {
            this.buf.append("enum %s;\n", sym.name)
            break;
        }
        default: {
            assert(false)
        }
    }
}

func (this: using *CGen) escapeNameStr(name: *const char) : *char {
    tmp.clear()
    tmp.appendStr(name, strlen(name))
    for(var i = 0; i < tmp.length; i+=1) {
        var c = tmp.buffer[i]
        switch(c) {
            case '*': tmp.replace(i, i+1, "_ptr_"); i+=6; break;
            case '<': tmp.replace(i, i+1, "_cb_");  i+=4; break;
            case '>': tmp.replace(i, i+1, "_ce_");  i+=4; break;
            case '[': tmp.replace(i, i+1, "_bb_");  i+=4; break;
            case ']': tmp.replace(i, i+1, "_be_");  i+=4; break;
            case '(': tmp.replace(i, i+1, "_pb_");  i+=4; break;
            case ')': tmp.replace(i, i+1, "_pe_");  i+=4; break;
            case ',': tmp.replace(i, i+1, "_c_");   i+=3; break;
            case ' ': tmp.replace(i, i+1, "_");     i+=1; break;
            case ':': {
                var n = i + 1;
                if(n < tmp.length) {
                    var nc = tmp.buffer[n]
                    if(nc == ':') {
                        tmp.replace(i, i+1, "__")
                        i+=2;
                        break;
                    }
                }
                tmp.replace(i, i+1, "_r_")
                i+=3;
                break;
            }
            default: {
                i+=1;
                break;
            }
        }
    }

    return tmp.cStr()
}

func (this: using *CGen) escapeName(type: *TypeInfo) : *const char {
    if(IsAggregate(type)) {
        return this.escapeNameStr(type.name)
    }

    if(IsFuncLike(type)) {
        if(type.kind == TypeKind.FUNC) {
            // TODO: Get method name
            var funcInfo = type as (*FuncTypeInfo)
            if(funcInfo.decl.flags & FuncFlags.IS_METHOD) {
                //var methodName = funcInfo.getMethodName()
                assert(false)
            }
        }
        return this.escapeNameStr(type.name)
    }

    return type.name
}

func (this: using *CGen) baseTypeName(name: *const char) : StringView {
    var str = StringViewInit(name)
    
    // strip module name
    var index = str.indexOf("::")
    if(index >= 0) {
        str = str.substring(index + 2)
    }

    // strip generics
    index = str.indexOf("<")
    if(index >= 0) {
        str = str.substring(0, index)
    }
    
    return str
}

func (this: using *CGen) emitLineInfo(stmt: *Stmt) {
    // TODO
}

/**
    Outputs a type in C for the supplied symbol
*/
func (this: using *CGen) cType(type: *TypeInfo, 
                               isCast: bool = false, 
                               decay: bool = false) : *const char {
    var sb = StringBufferInit(256, this.allocator)
    switch(type.kind) {
        case TypeKind.PTR: {
            var ptrInfo = type as (*PtrTypeInfo)
            var baseInfo = ptrInfo.getBaseType()
            if(baseInfo.kind == TypeKind.ARRAY && !decay) {
                var arrayInfo = baseInfo as (*ArrayTypeInfo)
                if(arrayInfo.length > -1) {
                    var cType = this.cType(arrayInfo.arrayOf, isCast, decay)
                    sb.append("%s (*)[%zu]", cType, arrayInfo.length)
                    return sb.cStrConst()
                }
            }
            var cType = this.cType(ptrInfo.ptrOf, isCast, decay)
            sb.append("%s*", cType)
            return sb.cStrConst()

        }
        case TypeKind.CONST: {
            var constInfo = type as (*ConstTypeInfo)
            if(IsPtrLike(constInfo.constOf)) {
                var cType = this.cType(constInfo.constOf, isCast, decay)
                sb.append("%s const", cType)
                return sb.cStrConst()
            }
            var cType = this.cType(constInfo.constOf, isCast, decay)
            sb.append("const %s", cType)
            return sb.cStrConst()
        }
        case TypeKind.ARRAY: {
            var arrayInfo = type as (*ArrayTypeInfo)
            if(decay) {
                var ptrInfo = PtrTypeInfo {
                    .info = TypeInfo {. kind = TypeKind.PTR},
                    .ptrOf = arrayInfo.arrayOf
                }
                return this.cType(ptrInfo, isCast, decay)
            }

            var baseInfo = arrayInfo.getBaseType()
            var baseName = this.cType(baseInfo)

            var buf = StringBufferInit(256, this.allocator)
            do {
                if(arrayInfo.length < 0) {
                    if(arrayInfo.numOfElements) {
                        buf.append("[")
                        var cgen = CGen {
                            .lita = this.lita,
                            .buf = buf
                        }
                        cgen.emitStmt(arrayInfo.numOfElements)
                        buf.append("]")
                    }
                    else {
                        buf.append("[]")
                    }
                }
                else {
                    buf.append("[%zu]", arrayInfo.length)
                }

                if(arrayInfo.arrayOf && arrayInfo.arrayOf.kind == TypeKind.ARRAY) {
                    arrayInfo = arrayInfo.arrayOf as (*ArrayTypeInfo)
                }
                else {
                    arrayInfo = null
                }
            }
            while(arrayInfo);

            sb.append("%s%s", baseName, buf.cStrConst())
            return sb.cStrConst()
        }        
        case TypeKind.FUNC_PTR: {
            var funcInfo = type as (*FuncPtrTypeInfo)
            var params = StringBufferInit(512, this.allocator)
            for(var i = 0; i < funcInfo.paramDecls.size(); i += 1) {
                if(i > 0) {
                    params.append(",")
                }

                var param = funcInfo.paramDecls.get(i)
                params.append("%s", this.cType(param, isCast, true))
            }

            sb.append("%s (*%s)(%s)", this.cType(funcInfo.returnType, isCast, decay), 
                isCast ? "" : this.cTypeName(funcInfo), params.cStrConst())
            return sb.cStrConst()
        }
        default: {
            return this.cTypeName(type)
        }
    }
}

/**
    Outputs a type declaration in C for the supplied symbol
*/
func (this: using *CGen) cTypeDecl(type: *TypeInfo, 
                                   name: *const char, 
                                   decay: bool = false) : *const char {

    var sb = StringBufferInit(256, this.allocator)
    switch(type.kind) {
        case TypeKind.PTR: {
            var ptrInfo = type as (*PtrTypeInfo)
            var baseInfo = ptrInfo.getBaseType()
            if(baseInfo.kind == TypeKind.ARRAY && !decay) {
                var arrayInfo = baseInfo as (*ArrayTypeInfo)
                if(arrayInfo.length > -1) {
                    var cType = this.cType(arrayInfo.arrayOf)
                    sb.append("%s (*%s)[%zu]", cType, name, arrayInfo.length)
                    return sb.cStrConst()
                }
            }
            var cType = this.cType(type, false, decay)
            sb.append("%s %s", cType, name)
            return sb.cStrConst()
        }
        case TypeKind.CONST: {
            var constInfo = type as (*ConstTypeInfo)
            if(IsPtrLike(constInfo.constOf)) {
                var cType = this.cType(constInfo.constOf, false, decay)
                sb.append("%s const %s", cType, name)
                return sb.cStrConst()
            }
            var cType = this.cTypeDecl(constInfo.constOf, name, decay)
            sb.append("const %s", cType)
            return sb.cStrConst()
        }
        case TypeKind.ARRAY: {
            var arrayInfo = type as (*ArrayTypeInfo)
            if(decay) {
                var ptrInfo = PtrTypeInfo {
                    .info = TypeInfo {. kind = TypeKind.PTR},
                    .ptrOf = arrayInfo.arrayOf
                }
                return this.cTypeDecl(ptrInfo, name, decay)
            }

            var baseInfo = arrayInfo.getBaseType()
            var baseName = this.cType(baseInfo)

            var buf = StringBufferInit(256, this.allocator)
            do {
                if(arrayInfo.length < 0) {
                    if(arrayInfo.numOfElements) {
                        buf.append("[")
                        var cgen = CGen {
                            .lita = this.lita,
                            .buf = buf
                        }
                        cgen.emitStmt(arrayInfo.numOfElements)
                        buf.append("]")
                    }
                    else {
                        buf.append("[]")
                    }
                }
                else {
                    buf.append("[%zu]", arrayInfo.length)
                }

                if(arrayInfo.arrayOf && arrayInfo.arrayOf.kind == TypeKind.ARRAY) {
                    arrayInfo = arrayInfo.arrayOf as (*ArrayTypeInfo)
                }
                else {
                    arrayInfo = null
                }
            }
            while(arrayInfo);

            if(baseInfo.kind == TypeKind.FUNC_PTR) {
                buf.insert(0, "%s", name)
                return this.cTypeDecl(baseInfo, buf.cStrConst(), decay)
            }
            
            sb.append("%s %s%s", baseName, name, buf.cStrConst())
            return sb.cStrConst()
        }        
        case TypeKind.STR: {
            sb.append("const char* %s", name)
            return sb.cStrConst()
        }
        case TypeKind.FUNC_PTR: {
            var funcInfo = type as (*FuncPtrTypeInfo)
            var params = StringBufferInit(512, this.allocator)
            for(var i = 0; i < funcInfo.paramDecls.size(); i += 1) {
                if(i > 0) {
                    params.append(",")
                }

                var param = funcInfo.paramDecls.get(i)
                params.append("%s", this.cType(param, false, true))
            }

            sb.append("%s (*%s)(%s)", this.cType(funcInfo.returnType, false, decay), name, params.cStrConst())
            return sb.cStrConst()
        }
        default: {
            var cType = this.cType(type, false, decay)
            sb.append("%s %s", cType, name)
            return sb.cStrConst()
        }
    }
}

/**
    Outputs the C name for the symbol
*/    
func (this: using *CGen) cName(sym: *Symbol) : *const char {
    var declName:*const char = (sym.flags & SymbolFlags.IS_TYPE) 
                                    ? this.escapeName(sym.type) : sym.name;

    var sb = StringBufferInit(256, this.allocator)
    if(sym.flags & SymbolFlags.IS_LOCAL) {
        return this.prefix(declName, sb)
    }

    if(sym.flags & SymbolFlags.IS_FOREIGN) {
        if(sym.flags & SymbolFlags.IS_BUILTIN) {

        }
        // TODO: Get the foreign override name
    }

    // TODO: Get a non-collision based module name
    sb.append("%.*s__%s", sym.declared.id.name.length, sym.declared.id.name.buffer, declName)
    return sb.cStrConst()
}

/**
    Outputs the C name for the symbol
*/    
func (this: using *CGen) cTypeName(type: *TypeInfo) : *const char {
    assert(type != null)

    var typeName = this.escapeName(type)
    var sb = StringBufferInit(256, this.allocator)

    if(!type.sym) {
        return this.prefix(typeName, sb)
    }

    var sym = type.sym
    if(sym.flags & SymbolFlags.IS_FOREIGN) {
        if(sym.flags & SymbolFlags.IS_BUILTIN) {

        }
        // TODO: Get the foreign override name
    }

    // TODO: Get a non-collision based module name
    sb.append("%.*s__%s", sym.declared.id.name.length, sym.declared.id.name.buffer, typeName)
    return sb.cStrConst()
}

func (this: using *CGen) prefix(name: *const char, sb: *StringBuffer) : *const char {
    sb.append("%s%s", this.options.cPrefix, name)
    return sb.cStrConst()
}

func (this: using *CGen) emitTypeSpec(spec: *TypeSpec) {
    assert(spec != null)

    switch(spec.kind) {
        case TypeSpecKind.NONE: {
            return;
        }
        case TypeSpecKind.ARRAY: {
            var array = spec as (*ArrayTypeSpec)
            buf.append("[");
            if(array.numElements) {
                this.emitStmt(array.numElements)
            }
            buf.append("]");
            this.emitTypeSpec(array.base)
            return;
        }
        case TypeSpecKind.PTR: {
            var ptr = spec as (*PtrTypeSpec)
            buf.append("*");
            this.emitTypeSpec(ptr.base)
            return;
        }
        case TypeSpecKind.CONST: {
            var c = spec as (*ConstTypeSpec)
            buf.append("const ");
            this.emitTypeSpec(c.base)
            return;
        }
        case TypeSpecKind.NAME: {
            var name = spec as (*NameTypeSpec)
            buf.append("%s", name.name)
            if(!name.genericArgs.empty()) {
                buf.append("<")
                for(var i = 0; i < name.genericArgs.size(); i += 1) {
                    if(i > 0) buf.append(",")
                    this.emitTypeSpec(name.genericArgs.get(i))
                }
                buf.append(">")
            }
            return;
        }
        case TypeSpecKind.FUNC_PTR: {
            var fn = spec as (*FuncPtrTypeSpec)
            buf.append("func")
            if(!fn.genericParams.empty()) {
                buf.append("<")
                for(var i = 0; i < fn.genericParams.size(); i += 1) {
                    if(i > 0) buf.append(",")
                    this.emitName(fn.genericParams.get(i).name)
                }
                buf.append(">")
            }
            buf.append("(")
            for(var i = 0; i < fn.args.size(); i += 1) {
                if(i > 0) buf.append(",")
                this.emitTypeSpec(fn.args.get(i))
            }
            buf.append(") : ")
            this.emitTypeSpec(fn.ret)
            return;
        }
        default: {
            Panic("Invalid TypeSpecKind: '%d'\n", spec.kind)
        }
    }
}

func (this: using *CGen) emitName(tok: Token) {
    if(tok.type != TokenType.ERROR) {
        buf.append("%.*s", tok.value.str.length, tok.value.str.buffer)
    }
}

func (this: using *CGen) emitln() {
    buf.appendChar('\n')
    for(var i = 0; i < indent; i += 1) {
        buf.appendStr("    ", 4);
    }
}

func (this: using *CGen) emit(format: *const char, ...) {
    line.clear()

    var args: va_list;
    va_start(args, format);
    line.appendArgs(format, args)
    va_end(args)

    for(var i = 0; i < line.length; i+=1) {
        var c = line.buffer[i]
        if(c == '\n') {
            this.emitln()
        }
        else if(c == '{') {
            buf.appendChar(c)
            indent+=1
            this.emitln()
        }
        else if(c == '}') {
            indent-=1
            this.emitln()
            buf.appendChar(c)
        }
        else {
            buf.appendChar(c)
        }
    }
}

func (this: using *CGen) emitNotes(attributes: *Attributes) {
    if(!attributes.notes.empty()) {
        // TODO Notes!!
        for(var i = 0; i < attributes.notes.size(); i += 1) {
            //this.emitStmt(decl.attributes.notes.get(i))
            //this.emit("\n")
        }
    }
}

func (this: using *CGen) emitStmt(s: *Stmt) {
    if(!s) return;

    switch(s.kind) {
        case StmtKind.IMPORT_DECL: {
            var decl = s as (*ImportDecl)
            this.emit("import '")
            this.emitName(decl.name)
            this.emit("'")
            if(decl.alias.type == TokenType.IDENTIFIER) {
                this.emit(" as ")
                this.emitName(decl.alias)
            }
            return;
        }
        case StmtKind.CONST_DECL:
        case StmtKind.VAR_DECL: {
            var decl = s as (*VarDecl)
            this.emitVarDecl(decl)
            return;
            /*
            if(!decl.attributes.notes.empty()) {
                for(var i = 0; i < decl.attributes.notes.size(); i += 1) {
                    this.emitStmt(decl.attributes.notes.get(i))
                    this.emit("\n")
                }
            }

            if(decl.kind == StmtKind.CONST_DECL) {
                this.emit("const ")
            }
            else {
                this.emit("var ")
            }
            this.emitName(decl.name)
            if(decl.typeSpec != null) {
                this.emit(": ")
                this.emitTypeSpec(decl.typeSpec)
            }
            if(decl.expr != null) {
                this.emit(" = ")
                this.emitStmt(decl.expr)
            }
            this.emit(";")
            return;*/
        }
        case StmtKind.STRUCT_DECL: {
            var decl = s as (*AggregateDecl)
            if(!decl.attributes.notes.empty()) {
                for(var i = 0; i < decl.attributes.notes.size(); i += 1) {
                    this.emitStmt(decl.attributes.notes.get(i))
                    this.emit("\n")
                }
            }

            if(decl.attributes.isPublic) {
                this.emit("public ")
            }            
            this.emit("struct ")
            this.emitName(decl.name)
            if(!decl.genericParams.empty()) {
                this.emit("<")
                for(var i = 0; i < decl.genericParams.size(); i += 1) {
                    if(i > 0) {
                        this.emit(",")
                    }
                    var t = decl.genericParams.get(i).name                    
                    this.emit("%.*s", t.value.str.length, t.value.str.buffer)
                }
                this.emit(">")
            }
            this.emit(" {")
            for(var i = 0; i < decl.fields.size(); i+=1) {
                var field = decl.fields.get(i)
                switch(field.kind) {
                    case StmtKind.ENUM_FIELD_STMT: {
                        this.emitStmt(field.enumField as (*Stmt))
                        break;
                    }
                    case StmtKind.STRUCT_FIELD_STMT: 
                    case StmtKind.UNION_FIELD_STMT: {
                        this.emitStmt(field.aggregateField as (*Stmt))
                        break;
                    }
                    case StmtKind.VAR_FIELD_STMT: {
                        this.emitStmt(field.varField)
                        break;
                    }
                    default:{}
                }
                this.emit("\n")
            }
            this.emit("}")
            return;
        }
        case StmtKind.UNION_DECL: {
            var decl = s as (*AggregateDecl)
            if(!decl.attributes.notes.empty()) {
                for(var i = 0; i < decl.attributes.notes.size(); i += 1) {
                    this.emitStmt(decl.attributes.notes.get(i))
                    this.emit("\n")
                }
            }

            if(decl.attributes.isPublic) {
                this.emit("public ")
            }            
            this.emit("union ")
            this.emitName(decl.name)
            if(!decl.genericParams.empty()) {
                this.emit("<")
                for(var i = 0; i < decl.genericParams.size(); i += 1) {
                    if(i > 0) {
                        this.emit(",")
                    }
                    var t = decl.genericParams.get(i).name
                    this.emit("%.*s", t.value.str.length, t.value.str.buffer)
                }
                this.emit(">")
            }
            this.emit(" {")
            for(var i = 0; i < decl.fields.size(); i+=1) {
                var field = decl.fields.get(i)
                switch(field.kind) {
                    case StmtKind.ENUM_FIELD_STMT: {
                        this.emitStmt(field.enumField as (*Stmt))
                        break;
                    }
                    case StmtKind.STRUCT_FIELD_STMT: 
                    case StmtKind.UNION_FIELD_STMT: {
                        this.emitStmt(field.aggregateField as (*Stmt))
                        break;
                    }
                    case StmtKind.VAR_FIELD_STMT: {
                        this.emitStmt(field.varField)
                        break;
                    }
                    default:{}
                }
                this.emit("\n")
            }
            this.emit("}")
            return;
        }
        case StmtKind.ENUM_DECL: {
            var decl = s as (*EnumDecl)
            if(!decl.attributes.notes.empty()) {
                for(var i = 0; i < decl.attributes.notes.size(); i += 1) {
                    this.emitStmt(decl.attributes.notes.get(i))
                    this.emit("\n")
                }
            }

            if(decl.attributes.isPublic) {
                this.emit("public ")
            }        
            this.emit("enum ")
            this.emitName(decl.name)        
            this.emit(" {\n")
            for(var i = 0; i < decl.fields.size(); i+=1) {
                var field = decl.fields.get(i)
                this.emitStmt(field)
                this.emit(",\n")
            }
            this.emit("}")
            return;
        }
        case StmtKind.FUNC_DECL: {
            var decl = s as (*FuncDecl)
            this.emitFuncDecl(decl)
            return;
            /*if(!decl.attributes.notes.empty()) {
                for(var i = 0; i < decl.attributes.notes.size(); i += 1) {
                    this.emitStmt(decl.attributes.notes.get(i))
                    this.emit("\n")
                }
            }

            this.emit("")
            if(decl.attributes.isPublic) {
                this.emit("public ")
            }            
            this.emit("func ")
            this.emitName(decl.name)
            if(!decl.genericParams.empty()) {
                this.emit("<")
                for(var i = 0; i < decl.genericParams.size(); i += 1) {
                    if(i > 0) this.emit(",")                    
                    var t = decl.genericParams.get(i).name                    
                    this.emit("%.*s", t.value.str.length, t.value.str.buffer)
                }
                this.emit(">")
            }
            this.emit("(")
            if(decl.params) {
                this.emitStmt(decl.params)
            }
            this.emit(")")
            if(decl.returnType) {
                this.emit(" : ")
                this.emitTypeSpec(decl.returnType)
            }
            if(decl.body) {
                this.emit("\n")
                //this.emit(indent, " {\n")
                this.emitStmt(decl.body)
                //this.emit(indent, "}")
            }
            return;*/
        }
        case StmtKind.TYPEDEF_DECL: {
            var decl = s as (*TypedefDecl)
            if(!decl.attributes.notes.empty()) {
                for(var i = 0; i < decl.attributes.notes.size(); i += 1) {
                    this.emitStmt(decl.attributes.notes.get(i))
                    this.emit("\n")
                }
            }

            this.emit("")
            if(decl.attributes.isPublic) {
                this.emit("public ")
            }
            this.emit("typedef ")
            this.emitTypeSpec(decl.type)
            this.emit(" as ")
            this.emitName(decl.name)
            return;
        }
        case StmtKind.PARAM_DECL: {
            var decl = s as (*ParameterDecl)
            if(!decl.attributes.notes.empty()) {
                for(var i = 0; i < decl.attributes.notes.size(); i += 1) {
                    this.emitStmt(decl.attributes.notes.get(i))
                    this.emit("\n")
                }
            }

            this.emitName(decl.name)
            this.emit(": ")
            this.emitTypeSpec(decl.type)
            if(decl.defaultExpr) {
                this.emit(" = ")
                this.emitStmt(decl.defaultExpr)
            }
            return;
        }
        /*
        case StmtKind.NATIVE_DECL: {
            // var decl = new<NativeDecl>(allocator)
            // decl.kind = StmtKind.NATIVE_DECL;
            // decl.startPos = startPos
            // decl.type = null
            // return decl as (*Stmt)
            return;
        }*/
        case StmtKind.POISON_DECL: {
            this.emit("<poison_decl>")
            return;
        }

        case StmtKind.BLOCK_STMT: {
            var stmt = s as (*BlockStmt)
            this.emit("{")
            for(var i = 0; i < stmt.stmts.size(); i += 1) {
                var n = stmt.stmts.get(i)
                this.emitStmt(n)
                if(IsExpr(n)) {
                    this.emit(";\n")
                }
                else {
                    this.emit("\n")
                }
            }
            this.emit("\n")
            this.emit("}")
            return;
        }
        case StmtKind.BREAK_STMT: {
            var stmt = s as (*BreakStmt)
            this.emit("break")
            return;
        }/*
        case StmtKind.COMP_STMT: {
            // var stmt = new<CompStmt>(allocator)
            // stmt.kind = StmtKind.COMP_STMT;
            // stmt.startPos = startPos
            // stmt.type = null
            // stmt.expr = null
            // stmt.body.init(16, allocator)
            // stmt.end = null
            // stmt.evaluatedStmt = null
            // return stmt as (*Stmt)
        }*/
        case StmtKind.CONTINUE_STMT: {            
            var stmt = s as (*ContinueStmt)
            this.emit("continue")
            return;
        }
        case StmtKind.DEFER_STMT: {
            var stmt = s as (*DeferStmt)
            this.emit("defer ")
            this.emitStmt(stmt.deferedStmt)
            return;
        }
        case StmtKind.DO_WHILE_STMT: {
            var stmt = s as (*DoWhileStmt)
            this.emit("do\n")
            this.emitStmt(stmt.body)
            this.emit("\nwhile(")
            this.emitStmt(stmt.cond)
            this.emit(")")
            return;
        }
        case StmtKind.EMPTY_STMT: {
            this.emit("\n")
            return;
        }
        case StmtKind.ENUM_FIELD_ENTRY_STMT: {
            var stmt = s as (*EnumFieldEntryStmt)
            this.emit("")
            this.emitName(stmt.fieldName)
            if(stmt.value) {
                this.emit(" = ")
                this.emitStmt(stmt.value)
            }
            return;
        }/*
        case StmtKind.ENUM_FIELD_STMT: {
            var stmt = s as (*EnumDecl)
            this.emitStmt(stmt)
            return;
            
        }*/
        case StmtKind.FOR_STMT: {
            var stmt = s as (*ForStmt)
            this.emit("for(")
            if(stmt.init) {
                this.emitStmt(stmt.init)
            }
            this.emit(";")
            if(stmt.cond) {
                this.emitStmt(stmt.cond)
            }
            this.emit(";")
            if(stmt.post) {
                this.emitStmt(stmt.post)
            }
            this.emit(")\n")
            if(stmt.body) {
                this.emitStmt(stmt.body)
            }
            return;
        }
        case StmtKind.FUNC_BODY_STMT: {
            var stmt = s as (*FuncBodyStmt)
           // this.emit("{")
            for(var i = 0; i < stmt.stmts.size(); i += 1) {
                var n = stmt.stmts.get(i)
                this.emitStmt(n)
                if(IsExpr(n)) {
                    this.emit(";\n")
                }
                else {
                    this.emit("\n")
                }
            }
            //this.emit("}")
            return;
        }
        case StmtKind.GOTO_STMT: {
            var stmt = s as (*GotoStmt)
            this.emit("goto ")
            this.emitName(stmt.label)
            return;
        }
        case StmtKind.IF_STMT: {
            var stmt = s as (*IfStmt)
            this.emit("if(")
            this.emitStmt(stmt.cond)
            this.emit(") \n")
            this.emitStmt(stmt.then)
            this.emit("\n")
            if(stmt.elseStmt) {
                
                this.emit("else \n")
                this.emitStmt(stmt.elseStmt)
            }
            this.emit("\n")
            return;
        }
        case StmtKind.LABEL_STMT: {
            var stmt = s as (*LabelStmt)
            this.emit(":")
            this.emitName(stmt.label)
            return;
        }
        case StmtKind.MODULE_STMT: {
            var stmt = s as (*ModuleStmt)
            for(var i = 0; i < stmt.imports.size(); i += 1) {
                this.emitStmt(stmt.imports.get(i) as (*Stmt))
                this.emit("\n")
            }

            this.emit("\n")

            for(var i = 0; i < stmt.notes.size(); i += 1) {
                this.emitStmt(stmt.notes.get(i))
                this.emit(";\n")
            }

            this.emit("\n")

            for(var i = 0; i < stmt.declarations.size(); i += 1) {                
                this.emitStmt(stmt.declarations.get(i) as (*Stmt))
                this.emit("\n")
                this.emit("\n")
            }

            this.emit("\n")
            return;
        }
        case StmtKind.NOTE_STMT: {
            var stmt = s as (*NoteStmt)
            this.emit("@")
            this.emitName(stmt.name)
            if(!stmt.attributes.empty()) {
                this.emit("(")
                for(var i = 0; i < stmt.attributes.size(); i += 1) {
                    if(i > 0) this.emit(", ")
                    this.emit("'")
                    this.emitName(stmt.attributes.get(i))
                    this.emit("'")
                }
                this.emit(")")
            }
            return;
        }
        case StmtKind.PARAMETERS_STMT: {
            var stmt = s as (*ParametersStmt)
            for(var i = 0; i < stmt.params.size(); i += 1) {
                if(i>0) this.emit(", ")
                this.emitStmt(stmt.params.get(i) as (*Stmt))
            }
            return;
        }
        case StmtKind.RETURN_STMT: {
            var stmt = s as (*ReturnStmt)
            this.emit("return");
            if(stmt.expr) {
                this.emit(" ")
                this.emitStmt(stmt.expr)
            }
            return;
        }/*
        case StmtKind.STRUCT_FIELD_STMT: {
            var stmt = new<AggregateFieldStmt>(allocator)
            stmt.kind = StmtKind.STRUCT_FIELD_STMT;
            stmt.startPos = startPos
            stmt.decl = null
            return stmt as (*Stmt)
        }
        case StmtKind.SWITCH_CASE_STMT: {
            var stmt = new<SwitchCaseStmt>(allocator)
            stmt.kind = StmtKind.SWITCH_CASE_STMT;
            stmt.startPos = startPos
            stmt.cond = null
            stmt.body = null
            return stmt as (*Stmt)
        }
        case StmtKind.SWITCH_STMT: {
            var stmt = new<SwitchStmt>(allocator)
            stmt.kind = StmtKind.SWITCH_STMT;
            stmt.startPos = startPos
            stmt.cond = null
            stmt.stmts.init(16, allocator)
            stmt.defaultStmt = null
            return stmt as (*Stmt)
        }
        case StmtKind.UNION_FIELD_STMT: {
            var stmt = new<AggregateFieldStmt>(allocator)
            stmt.kind = StmtKind.UNION_FIELD_STMT;
            stmt.startPos = startPos
            stmt.decl = null
            return stmt as (*Stmt)
        }*/
        case StmtKind.VAR_FIELD_STMT: {
            var stmt = s as (*VarFieldStmt)
            if(!stmt.attributes.notes.empty()) {
                for(var i = 0; i < stmt.attributes.notes.size(); i += 1) {
                    this.emitStmt(stmt.attributes.notes.get(i))
                    this.emit("\n")
                }
            }
            this.emit("")
            this.emitName(stmt.fieldName)
            this.emit(": ")
            this.emitTypeSpec(stmt.type)
            return;
        }
        case StmtKind.WHILE_STMT: {
            var stmt = s as (*WhileStmt)            
            this.emit("while(")
            this.emitStmt(stmt.cond)
            this.emit(")\n")
            this.emitStmt(stmt.body)
            return;
        }
        
        case StmtKind.ARRAY_DESIGNATION_EXPR: {
            var expr = s as (*ArrayDesignationExpr)
            this.emit("[")
            this.emitStmt(expr.index)
            this.emit("] = ")
            this.emitStmt(expr.value)
            return;
        }
        case StmtKind.ARRAY_INIT_EXPR: {
            var expr = s as (*ArrayInitExpr)
            this.emitTypeSpec(expr.type)
            this.emit(" {")
            for(var i = 0; i < expr.values.size(); i+=1) {
                var v = expr.values.get(i)
                if(i > 0) {
                    this.emit(",\n")
                }
                this.emitStmt(v)
            }
            
            this.emit("}")
            return;
        }
        case StmtKind.BINARY_EXPR: {
            var expr = s as (*BinaryExpr)
            this.emitStmt(expr.left)
            this.emit(" %s ", tokenText[expr.operator])
            this.emitStmt(expr.right)
            break;
        }
        case StmtKind.BOOLEAN_EXPR: {
            var expr = s as (*BooleanExpr)
            this.emit("%s", expr.boolean ? "true" : "false")
            return;
        }/*
        case StmtKind.CAST_EXPR: {
            var expr = new<CastExpr>(allocator)
            expr.kind = StmtKind.CAST_EXPR;
            expr.startPos = startPos
            expr.castTo = null
            expr.exprToCast = null
            return expr as (*Stmt)
        }*/
        case StmtKind.CHAR_EXPR: {
            var expr = s as (*CharExpr)
            this.emit("'%c'", expr.character.intValue as (char))            
            return;
        }/*
        case StmtKind.FUNC_CALL_EXPR: {
            var expr = new<FuncCallExpr>(allocator)
            expr.kind = StmtKind.FUNC_CALL_EXPR;
            expr.startPos = startPos
            expr.object = null
            expr.arguments.init(16, allocator)
            return expr as (*Stmt)
        }
        case StmtKind.FUNC_IDENTIFIER_EXPR: {
            var expr = new<IdentifierExpr>(allocator)
            expr.kind = StmtKind.FUNC_IDENTIFIER_EXPR;
            expr.startPos = startPos
            expr.genericArgs.init(2, allocator)
            expr.type = null
            //expr.sym///            
            return expr as (*Stmt)
        }*/
        case StmtKind.GET_EXPR: {
            var expr = s as (*GetExpr)
            this.emitStmt(expr.object)
            this.emit(".")
            this.emitStmt(expr.field)
            return;
        }
        case StmtKind.GROUP_EXPR: {
            var expr = s as (*GroupExpr)
            this.emit("(")
            this.emitStmt(expr.groupedExpr)
            this.emit(")")
            return;
        }
        case StmtKind.IDENTIFIER_EXPR: {
            var expr = s as (*IdentifierExpr)
            this.emit("%s", expr.type.name)
            return;
        }/*
        case StmtKind.INIT_ARG_EXPR: {
            var expr = new<InitArgExpr>(allocator)
            expr.kind = StmtKind.INIT_ARG_EXPR;
            expr.startPos = startPos
            expr.fieldName = null
            expr.argPosition = 0
            expr.value = null
            return expr as (*Stmt)
        }
        case StmtKind.INIT_EXPR: {
            var expr = new<InitExpr>(allocator)
            expr.kind = StmtKind.INIT_EXPR;
            expr.startPos = startPos
            expr.genericArgs.init(2, allocator)
            expr.type = null
            expr.arguments.init(8, allocator)
            return expr as (*Stmt)
        }*/
        case StmtKind.NULL_EXPR: {
            var expr = s as (*NullExpr)
            this.emit("null")
            return;
        }
        case StmtKind.NUMBER_EXPR: {
            var expr = s as (*NumberExpr)
            switch(expr.number.type) {
                case TokenType.INT_NUMBER: {
                    this.emit("%llu", expr.number.value.intValue)
                    break;
                }
                case TokenType.FLOAT_NUMBER: {
                    this.emit("%f", expr.number.value.floatValue)
                    break;
                }
                default: {}
            }
            return;
        }/*
        case StmtKind.OFFSET_OF_EXPR: {
            var expr = new<OffsetOfExpr>(allocator)
            expr.kind = StmtKind.OFFSET_OF_EXPR;
            expr.startPos = startPos
            expr.type = null
            expr.field = null
            return expr as (*Stmt)
        }
        case StmtKind.SET_EXPR: {
            var expr = new<SetExpr>(allocator)
            expr.kind = StmtKind.SET_EXPR;
            expr.startPos = startPos
            expr.object = null
            expr.field = null
            expr.value = null
            return expr as (*Stmt)
        }
        case StmtKind.SIZE_OF_EXPR: {
            var expr = new<SizeOfExpr>(allocator)
            expr.kind = StmtKind.SIZE_OF_EXPR;
            expr.startPos = startPos
            expr.sizeOfExpr = null
            return expr as (*Stmt)
        }*/
        case StmtKind.STRING_EXPR: {
            var expr = s as (*StringExpr)
            this.emit("\"%.*s\"", expr.string.str.length, expr.string.str.buffer)
            return;
        }/*
        case StmtKind.SUBSCRIPT_GET_EXPR: {
            var expr = new<SubscriptGetExpr>(allocator)
            expr.kind = StmtKind.SUBSCRIPT_GET_EXPR;
            expr.startPos = startPos
            expr.object = null
            expr.index = null
            return expr as (*Stmt);
        }
        case StmtKind.SUBSCRIPT_SET_EXPR: {
            var expr = new<SubscriptSetExpr>(allocator)
            expr.kind = StmtKind.SUBSCRIPT_SET_EXPR;
            expr.startPos = startPos
            expr.object = null
            expr.index = null
            expr.value = null
            return expr as (*Stmt);
        }*/
        case StmtKind.TERNARY_EXPR: {
            var expr = s as (*TernaryExpr)
            this.emit("(")
            this.emitStmt(expr.cond)
            this.emit(") ? ")
            this.emitStmt(expr.then)
            this.emit(" : ")
            this.emitStmt(expr.other)
            return;
        }/*
        case StmtKind.TYPE_IDENTIFIER_EXPR: {
            var expr = new<TypeIdentifierExpr>(allocator)
            expr.kind = StmtKind.TYPE_IDENTIFIER_EXPR;
            expr.startPos = startPos
            expr.genericArgs.init(2, allocator)
            expr.type = null
            //expr.sym//
            return expr as (*Stmt);
        }
        case StmtKind.TYPE_OF_EXPR: {
            var expr = new<TypeOfExpr>(allocator)
            expr.kind = StmtKind.TYPE_OF_EXPR;
            expr.startPos = startPos
            expr.typeOfExpr = null
            expr.type = null
            return expr as (*Stmt);
        }
        case StmtKind.UNARY_EXPR: {
            var expr = new<UnaryExpr>(allocator)
            expr.kind = StmtKind.UNARY_EXPR;
            expr.startPos = startPos
            expr.unaryExpr = null
            return expr as (*Stmt);
        }*/
        case StmtKind.POISON_EXPR: {
            this.emit("<poison_expr>")
            return;
        }
        default: {
            //Panic("Unknown statement kind: %d", s.kind)
            this.emit("<%s Not Implemented>", StmtKindAsStr(s.kind))
            return;
        }
    }    
}