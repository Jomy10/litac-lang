import "ast"
import "string_buffer"
import "string_view"
import "string"
import "types"
import "module"
import "symbols"
import "lita"
import "phase_result"
import "lex"
import "libc"
import "array"
import "map"
import "common"
import "dependency_graph"
import "assert"
import "system"
import "cgen_decl"

public struct CGen {
    lita: using *Lita
    buf: StringBuffer
    line: StringBuffer
    indent: i32
    aggregateLevel: i32

    currentFunc: *FuncTypeInfo
    currentScope: *CGenScope
}

struct CGenScope {
    parent: *CGenScope
    defers: Array<*Stmt>
    isLoop: bool
    isSwitch: bool
}

const escapeStrings = [256]*const char {
    ['\b'] = "\\b",
    ['\f'] = "\\f",
    ['\n'] = "\\n",
    ['\r'] = "\\r",
    ['\t'] = "\\t",
    ['\\'] = "\\\\",
    ['\''] = "\\'",
    //['"'] = "\\\"",
    ['\0'] = "\\0",
}

const escapeChars = [256]*const char {
    ['b'] = "\\\\b",
    ['f'] = "\\\\f",
    ['n'] = "\\\\n",
    ['r'] = "\\\\r",
    ['t'] = "\\\\t",
    ['\\'] = "\\\\",
    ['\''] = "\\'",
    ['"'] = "\\\\\"",
    ['\0'] = "\\0",
}


public func (this: *CGen) init(lita: *Lita) {
    this.lita = lita
    this.buf.init(4096*4, lita.allocator)
    this.line.init(1024, lita.allocator)
    this.aggregateLevel = 0
    this.currentFunc = null
    this.currentScope = null
}

public func (this: using *CGen) emitProgram(module: *Module) {
    assert(module != null)
    assert(module.ast != null)

    this.emitForward()
    this.emitPrimitiveConstDecls()
    this.emitModuleNotes()
    this.emitForwardDecls()

    buf.append("\n\n")
    buf.append("// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n")
    buf.append("// translated code begins\n")
    buf.append("// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n")
    buf.append("\n\n")

    var graph = DependencyGraph{}
    graph.init(this.lita)
    var declarations = graph.sort()

    var mainSym: *Symbol = null

    for(var i = 0; i < declarations.size(); i += 1) {
        var sym = declarations.get(i)
        assert(sym.decl)

        if(sym.flags & SymbolFlags.IS_GENERIC_TEMPLATE) {
            continue
        }

        if(sym.flags & SymbolFlags.IS_EMITTED) {
            continue
        }

        if(sym.flags & SymbolFlags.IS_FOREIGN) {
            continue
        }

        if(sym.decl.kind == StmtKind.FUNC_DECL &&
           strcmp(sym.name, "main") == 0) {
           mainSym = sym
           continue
        }

        this.emitStmt(sym.decl)
        this.emitln()
    }

    this.emitln()

    if(mainSym) {
        this.emitMain(mainSym)
    }
}

func (this: using *CGen) emitMain(sym: *Symbol) {
    var decl = sym.decl as (*FuncDecl)
    this.emitFuncDeclSignature(decl, "main");
    this.currentFunc = sym.type as (*FuncTypeInfo)
    defer this.currentFunc = null

    this.emit(" {")
    this.emitStmt(decl.body)
    this.emit("}")

}

func (this: using *CGen) emitForward() {
    this.buf.append(
"""
// Generated on %s
#include <stdint.h>
#include <stddef.h>
typedef int8_t    %s%s;
typedef int16_t   %s%s;
typedef int32_t   %s%s;
typedef int64_t   %s%s;
typedef uint8_t   %s%s;
typedef uint16_t  %s%s;
typedef uint32_t  %s%s;
typedef uint64_t  %s%s;
typedef float     %s%s;
typedef double    %s%s;
typedef int8_t    %s%s;
typedef size_t    %s%s;
#define %s%s (1)
#define %s%s (0)


""",
    CurrentDateTime(),
    this.options.cPrefix, "i8",
    this.options.cPrefix, "i16",
    this.options.cPrefix, "i32",
    this.options.cPrefix, "i64",
    this.options.cPrefix, "u8",
    this.options.cPrefix, "u16",
    this.options.cPrefix, "u32",
    this.options.cPrefix, "u64",
    this.options.cPrefix, "f32",
    this.options.cPrefix, "f64",
    this.options.cPrefix, "bool",
    this.options.cPrefix, "usize",
    this.options.cPrefix, "true",
    this.options.cPrefix, "false",
    this.options.cPrefix, "void"
    );

    if(strlen(this.options.cPrefix) > 0) {
        buf.append("#define %s%s void\n", this.options.cPrefix, "void")
        buf.append("typedef char   %s%s;\n", this.options.cPrefix, "char")
    }
}

func (this: using *CGen) emitPrimitiveConstDecls() {
    var program = &this.lita.programSymbols
    for(var i = 0; i < program.values.size(); i += 1) {
        var sym = program.values.get(i)

        if(!(sym.flags & SymbolFlags.IS_CONSTANT)) {
            continue
        }

        if(sym.flags & SymbolFlags.IS_FOREIGN) {
            continue
        }

        if(!IsPrimitive(sym.type)) {
            continue
        }

        this.emitVarDecl(sym.decl as (*VarDecl))
        this.emitln()
    }
}

func (this: using *CGen) emitModuleNotes() {
    for(var it = this.lita.modules.iter(); it.hasNext();) {
        var m = it.next()
        for(var i = 0; i < m.value.ast.notes.size(); i += 1) {
            this.emitPreludeNote(m.value.ast.notes.get(i))
            this.emit("\n")
        }
    }
}

func (this: using *CGen) emitForwardDecls() {
    var program = &this.lita.programSymbols
    for(var i = 0; i < program.symbolTypes.size(); i += 1) {
        var sym = program.symbolTypes.get(i)
        this.emitTypeForwardDecl(sym)
    }

    for(var i = 0; i < program.symbolFuncs.size(); i += 1) {
        var sym = program.symbolFuncs.get(i)
        this.emitTypeForwardDecl(sym)
    }
}

func (this: using *CGen) emitTypeForwardDecl(sym: *Symbol) {
    var decl = sym.decl

    if(sym.flags & SymbolFlags.IS_FOREIGN || sym.flags & SymbolFlags.IS_GENERIC_TEMPLATE) {
        return;
    }

    var name = this.cName(decl.sym)
    switch(decl.kind) {
        case StmtKind.VAR_DECL:
        case StmtKind.CONST_DECL:
            break;
        case StmtKind.FUNC_DECL: {
            this.emitFuncDeclSignature(decl as (*FuncDecl), name)
            buf.append(";\n")
            break;
        }
        case StmtKind.UNION_DECL:
        case StmtKind.STRUCT_DECL: {
            var aggDecl = decl as (*AggregateDecl)
            if(!(aggDecl.flags & AggregateFlags.IS_EMBEDDED)) {
                this.buf.append("typedef %s %s %s;\n", aggDecl.kind == StmtKind.STRUCT_DECL ? "struct" : "union", name, name)
            }
            break;
        }
        case StmtKind.ENUM_DECL: {
            this.emitEnumDecl(decl as (*EnumDecl))
            break;
        }
        case StmtKind.TYPEDEF_DECL: {
            // we don't emit any other typedefs because we just use the
            // raw types
            break;
        }
        default: {
            assert(false)
        }
    }
}

func (this: using *CGen) escapeNameStr(name: *const char) : *char {
    var sb = StringBufferInit(256, this.allocator)
    sb.appendStr(name, strlen(name))
    for(var i = 0; i < sb.length;) {
        var c = sb.buffer[i]

        switch(c) {
            case '*': sb.replace(i, i+1, "_ptr_"); i+=5; break;
            case '<': sb.replace(i, i+1, "_cb_");  i+=4; break;
            case '>': sb.replace(i, i+1, "_ce_");  i+=4; break;
            case '[': sb.replace(i, i+1, "_bb_");  i+=4; break;
            case ']': sb.replace(i, i+1, "_be_");  i+=4; break;
            case '(': sb.replace(i, i+1, "_pb_");  i+=4; break;
            case ')': sb.replace(i, i+1, "_pe_");  i+=4; break;
            case ',': sb.replace(i, i+1, "_c_");   i+=3; break;
            case ' ': sb.replace(i, i+1, "_");     i+=1; break;
            case ':': {
                var n = i + 1;
                if(n < sb.length) {
                    var nc = sb.buffer[n]
                    if(nc == ':') {
                        sb.replace(i, i+1, "__")
                        i+=2;
                        break;
                    }
                }
                sb.replace(i, i+1, "_r_")
                i+=3;
                break;
            }
            default: {
                i+=1;
                break;
            }
        }
    }

    return sb.cStr()
}

func (this: using *CGen) escapeName(type: *TypeInfo) : *const char {
    if(IsAggregate(type)) {
        return this.escapeNameStr(type.name)
    }

    if(IsFuncLike(type)) {
        if(type.kind == TypeKind.FUNC) {
            var funcInfo = type as (*FuncTypeInfo)
            if(funcInfo.decl.flags & FuncFlags.IS_METHOD) {
                var methodName:[MAX_SYMBOL_NAME]char;
                if(!funcInfo.decl.getName(methodName)) {
                    assert(false)
                }

                return this.escapeNameStr(methodName)
            }
        }
        return this.escapeNameStr(type.name)
    }

    return type.name
}

func (this: using *CGen) baseTypeName(name: StringView) : StringView {
    // strip module name
    var index = name.indexOf("::")
    if(index >= 0) {
        name = name.substring(index + 2)
    }

    // strip generics
    index = name.indexOf("<")
    if(index >= 0) {
        name = name.substring(0, index)
    }

    return name
}

func (this: using *CGen) pushScope(scope: *CGenScope) {
    scope.parent = this.currentScope
    this.currentScope = scope
}

func (this: using *CGen) popScope() : *CGenScope {
    var scope = this.currentScope
    if(!scope) {
        return null
    }

    this.currentScope = scope.parent
    this.leaveScope(scope)
    return scope
}

func (this: using *CGen) popLoopScope(checkSwitch: bool = false) {
    var scope = this.currentScope
    while(scope) {
        if(checkSwitch && scope.isSwitch) {
            break;
        }

        this.leaveScope(scope)
        if(!scope || scope.isLoop) {
            break;
        }

        scope = scope.parent
    }
}

func (this: using *CGen) leaveScope(scope: *CGenScope) {
    if(!scope || scope.defers.empty()) {
        return;
    }

    for(var i = scope.defers.size() - 1; i >= 0; i-=1) {
        var deferStmt = scope.defers.get(i)
        this.emitStmt(deferStmt)
        this.emit(";\n")
    }
}

func (this: using *CGen) hasPendingDefers() : bool {
    var scope = this.currentScope
    while(scope) {
        if(!scope.defers.empty()) {
            return true
        }

        scope = scope.parent
    }

    return false
}

func (this: using *CGen) emitDefers() {
    var scope = this.currentScope
    while(scope) {
        this.leaveScope(scope)
        scope = scope.parent
    }
}

func (this: using *CGen) emitLineInfo(stmt: *Stmt) {
    // TODO
    //this.emitln()
}

/**
    Outputs a type in C for the supplied symbol
*/
func (this: using *CGen) cType(type: *TypeInfo,
                               isCast: bool = false,
                               decay: bool = false) : *const char {
    var sb = StringBufferInit(256, this.allocator)
    switch(type.kind) {
        case TypeKind.PTR: {
            var ptrInfo = type as (*PtrTypeInfo)
            var baseInfo = ptrInfo.getBaseType()
            if(baseInfo.kind == TypeKind.ARRAY && !decay) {
                var arrayInfo = baseInfo as (*ArrayTypeInfo)
                if(arrayInfo.length > -1) {
                    var cType = this.cType(arrayInfo.arrayOf, isCast, decay)
                    sb.append("%s (*)[%zu]", cType, arrayInfo.length)
                    return sb.cStrConst()
                }
            }
            var cType = this.cType(ptrInfo.ptrOf, isCast, decay)
            sb.append("%s*", cType)
            return sb.cStrConst()

        }
        case TypeKind.CONST: {
            var constInfo = type as (*ConstTypeInfo)
            if(IsPtrLike(constInfo.constOf)) {
                var cType = this.cType(constInfo.constOf, isCast, decay)
                sb.append("%s const", cType)
                return sb.cStrConst()
            }
            var cType = this.cType(constInfo.constOf, isCast, decay)
            sb.append("const %s", cType)
            return sb.cStrConst()
        }
        case TypeKind.ARRAY: {
            var arrayInfo = type as (*ArrayTypeInfo)
            if(decay) {
                var ptrInfo = PtrTypeInfo {
                    .info = TypeInfo {. kind = TypeKind.PTR},
                    .ptrOf = arrayInfo.arrayOf
                }
                return this.cType(ptrInfo, isCast, decay)
            }

            var baseInfo = arrayInfo.getBaseType()
            var baseName = this.cType(baseInfo)

            var buf = StringBufferInit(256, this.allocator)
            var line = StringBufferInit(256, this.allocator)
            do {
                if(arrayInfo.length < 0) {
                    if(arrayInfo.numOfElements) {
                        buf.append("[")
                        var cgen = CGen {
                            .lita = this.lita,
                            .buf = buf,
                            .line = line
                        }
                        cgen.emitStmt(arrayInfo.numOfElements)
                        buf.append("]")
                    }
                    else {
                        buf.append("[]")
                    }
                }
                else {
                    buf.append("[%zu]", arrayInfo.length)
                }

                if(arrayInfo.arrayOf && arrayInfo.arrayOf.kind == TypeKind.ARRAY) {
                    arrayInfo = arrayInfo.arrayOf as (*ArrayTypeInfo)
                }
                else {
                    arrayInfo = null
                }
            }
            while(arrayInfo);

            sb.append("%s%s", baseName, buf.cStrConst())
            return sb.cStrConst()
        }
        case TypeKind.FUNC_PTR: {
            var funcInfo = type as (*FuncPtrTypeInfo)
            var params = StringBufferInit(512, this.allocator)
            for(var i = 0; i < funcInfo.paramDecls.size(); i += 1) {
                if(i > 0) {
                    params.append(",")
                }

                var param = funcInfo.paramDecls.get(i)
                params.append("%s", this.cType(param, isCast, true))
            }

            sb.append("%s (*%s)(%s)", this.cType(funcInfo.returnType, isCast, decay),
                isCast ? "" : this.cTypeName(funcInfo), params.cStrConst())
            return sb.cStrConst()
        }
        default: {
            return this.cTypeName(type)
        }
    }
}

/**
    Outputs a type declaration in C for the supplied symbol
*/
func (this: using *CGen) cTypeDecl(type: *TypeInfo,
                                   name: *const char,
                                   decay: bool = false) : *const char {

    var sb = StringBufferInit(256, this.allocator)
    switch(type.kind) {
        case TypeKind.PTR: {
            var ptrInfo = type as (*PtrTypeInfo)
            var baseInfo = ptrInfo.getBaseType()
            if(baseInfo.kind == TypeKind.ARRAY && !decay) {
                var arrayInfo = baseInfo as (*ArrayTypeInfo)
                if(arrayInfo.length > -1) {
                    var cType = this.cType(arrayInfo.arrayOf)
                    sb.append("%s (*%s)[%zu]", cType, name, arrayInfo.length)
                    return sb.cStrConst()
                }
            }
            var cType = this.cType(type, false, decay)
            sb.append("%s %s", cType, name)
            return sb.cStrConst()
        }
        case TypeKind.CONST: {
            var constInfo = type as (*ConstTypeInfo)
            if(IsPtrLike(constInfo.constOf)) {
                var cType = this.cType(constInfo.constOf, false, decay)
                sb.append("%s const %s", cType, name)
                return sb.cStrConst()
            }
            var cType = this.cTypeDecl(constInfo.constOf, name, decay)
            sb.append("const %s", cType)
            return sb.cStrConst()
        }
        case TypeKind.ARRAY: {
            var arrayInfo = type as (*ArrayTypeInfo)
            if(decay) {
                var ptrInfo = PtrTypeInfo {
                    .info = TypeInfo {. kind = TypeKind.PTR},
                    .ptrOf = arrayInfo.arrayOf
                }
                return this.cTypeDecl(ptrInfo, name, decay)
            }

            var baseInfo = arrayInfo.getBaseType()
            var baseName = this.cType(baseInfo)

            var buf = StringBufferInit(256, this.allocator)
            var line = StringBufferInit(256, this.allocator)
            do {
                if(arrayInfo.length == 0) {
                    if(arrayInfo.numOfElements) {
                        buf.append("[")
                        var cgen = CGen {
                            .lita = this.lita,
                            .buf = buf,
                            .line = line
                        }
                        cgen.emitStmt(arrayInfo.numOfElements)
                        buf = cgen.buf // the buffer has expanded
                        buf.append("]")
                    }
                    else {
                        buf.append("[]")
                    }
                }
                else {
                    buf.append("[%zu]", arrayInfo.length)
                }

                if(arrayInfo.arrayOf && arrayInfo.arrayOf.kind == TypeKind.ARRAY) {
                    arrayInfo = arrayInfo.arrayOf as (*ArrayTypeInfo)
                }
                else {
                    arrayInfo = null
                }
            }
            while(arrayInfo);

            if(baseInfo.kind == TypeKind.FUNC_PTR) {
                buf.insert(0, "%s", name)
                return this.cTypeDecl(baseInfo, buf.cStrConst(), decay)
            }

            sb.append("%s %s%s", baseName, name, buf.cStrConst())
            return sb.cStrConst()
        }
        case TypeKind.STR: {
            sb.append("const char* %s", name)
            return sb.cStrConst()
        }
        case TypeKind.FUNC_PTR: {
            var funcInfo = type as (*FuncPtrTypeInfo)
            var params = StringBufferInit(512, this.allocator)
            for(var i = 0; i < funcInfo.paramDecls.size(); i += 1) {
                if(i > 0) {
                    params.append(",")
                }

                var param = funcInfo.paramDecls.get(i)
                params.append("%s", this.cType(param, false, true))
            }

            sb.append("%s (*%s)(%s)", this.cType(funcInfo.returnType, false, decay), name, params.cStrConst())
            return sb.cStrConst()
        }
        default: {
            var cType = this.cType(type, false, decay)
            sb.append("%s %s", cType, name)
            return sb.cStrConst()
        }
    }
}

func (this: using *CGen) foreignName(decl: *Decl, defaultName: StringView) : StringView {
    if(!decl) {
        return defaultName
    }

    var note = decl.getNote("foreign")
    if(!note) {
        return defaultName
    }

    if(note.attributes.empty()) {
        return defaultName
    }

    var arg = note.attributes.get(0)
    return arg.str;
}

/**
    Outputs the C name for the symbol
*/
func (this: using *CGen) cName(sym: *Symbol) : *const char {
    var sb = StringBufferInit(256, this.allocator)

    var declName:*const char = sym.name
    if(IsFuncLike(sym.type)) {//}.kind == TypeKind.FUNC) {
        declName = this.escapeNameStr(sym.name)
    }
    else if (sym.flags & SymbolFlags.IS_TYPE) {
        declName = this.escapeName(sym.type)
    }

    if(sym.flags & SymbolFlags.IS_LOCAL) {
        return this.prefix(declName, sb)
    }

    if(sym.flags & SymbolFlags.IS_FOREIGN) {
        if(sym.flags & SymbolFlags.IS_BUILTIN) {
            return sym.name
        }

        var name = this.foreignName(sym.decl, this.baseTypeName(sym.decl.name.str))
        sb.append("%.*s", name.length, name.buffer)
        return sb.cStrConst()
    }

    sb.append("%.*s__%s", sym.declared.id.name.length, sym.declared.id.name.buffer, declName)
    return sb.cStrConst()
}

/**
    Outputs the C name for the symbol
*/
func (this: using *CGen) cTypeName(type: *TypeInfo) : *const char {
    assert(type != null)

    var typeName = this.escapeName(type)

    if(!type.sym) {
        var sb = StringBufferInit(256, this.allocator)
        return this.prefix(typeName, sb)
    }

    return this.cName(type.sym)
}

func (this: using *CGen) prefix(name: *const char, sb: *StringBuffer) : *const char {
    sb.append("%s%s", this.options.cPrefix, name)
    return sb.cStrConst()
}

func (this: using *CGen) emitTypeSpec(spec: *TypeSpec) {
    assert(spec != null)

    switch(spec.kind) {
        case TypeSpecKind.NONE: {
            return;
        }
        case TypeSpecKind.ARRAY: {
            var array = spec as (*ArrayTypeSpec)
            buf.append("[");
            if(array.numElements) {
                this.emitStmt(array.numElements)
            }
            buf.append("]");
            this.emitTypeSpec(array.base)
            return;
        }
        case TypeSpecKind.PTR: {
            var ptr = spec as (*PtrTypeSpec)
            buf.append("*");
            this.emitTypeSpec(ptr.base)
            return;
        }
        case TypeSpecKind.CONST: {
            var c = spec as (*ConstTypeSpec)
            buf.append("const ");
            this.emitTypeSpec(c.base)
            return;
        }
        case TypeSpecKind.NAME: {
            var name = spec as (*NameTypeSpec)
            buf.append("%s", name.name)
            if(!name.genericArgs.empty()) {
                buf.append("<")
                for(var i = 0; i < name.genericArgs.size(); i += 1) {
                    if(i > 0) buf.append(",")
                    this.emitTypeSpec(name.genericArgs.get(i))
                }
                buf.append(">")
            }
            return;
        }
        case TypeSpecKind.FUNC_PTR: {
            var fn = spec as (*FuncPtrTypeSpec)
            buf.append("func")
            if(!fn.genericParams.empty()) {
                buf.append("<")
                for(var i = 0; i < fn.genericParams.size(); i += 1) {
                    if(i > 0) buf.append(",")
                    this.emitName(fn.genericParams.get(i).name)
                }
                buf.append(">")
            }
            buf.append("(")
            for(var i = 0; i < fn.args.size(); i += 1) {
                if(i > 0) buf.append(",")
                this.emitTypeSpec(fn.args.get(i))
            }
            buf.append(") : ")
            this.emitTypeSpec(fn.ret)
            return;
        }
        default: {
            Panic("Invalid TypeSpecKind: '%d'\n", spec.kind)
        }
    }
}

func (this: using *CGen) emitName(tok: Token) {
    if(tok.type != TokenType.ERROR) {
        buf.append("%.*s", tok.value.str.length, tok.value.str.buffer)
    }
}

func (this: using *CGen) emitln() {
    buf.appendChar('\n')
    for(var i = 0; i < indent; i += 1) {
        buf.appendStr("    ", 4);
    }
}

func (this: using *CGen) emit(format: *const char, ...) {
    line.clear()

    var args: va_list;
    va_start(args, format);
    line.appendArgs(format, args)
    va_end(args)

    for(var i = 0; i < line.length; i+=1) {
        var c = line.buffer[i]
        if(c == '\n') {
            this.emitln()
        }
        else if(c == '{') {
            buf.appendChar(c)
            indent+=1
            this.emitln()
        }
        else if(c == '}') {
            indent-=1
            this.emitln()
            buf.appendChar(c)
        }
        else {
            buf.appendChar(c)
        }
    }
}

func (this: using *CGen) emitNotes(attributes: *Attributes, isPrelude: bool = true) {
    if(attributes.notes.empty()) {
        return;
    }

    if(isPrelude) {
        for(var i = 0; i < attributes.notes.size(); i += 1) {
            this.emitPreludeNote(attributes.notes.get(i))
            this.emit("\n")
        }
    }
    else {
        for(var i = 0; i < attributes.notes.size(); i += 1) {
            this.emitPostludeNote(attributes.notes.get(i))
            this.emit("\n")
        }
    }

}

func (this: using *CGen) emitPreludeNote(note: *NoteStmt) {
    if(strncmp(note.name.str.buffer, "include", note.name.str.length) == 0) {
        for(var i = 0; i < note.attributes.size(); i += 1) {
            var attr = note.attributes.get(i)
            if(attr.str.length > 0 && attr.str.buffer[0] == '<') {
                this.emit("#include %.*s\n", attr.str.length, attr.str.buffer)
            }
            else {
                this.emit("#include \"%.*s\"\n", attr.str.length, attr.str.buffer)
            }

        }
    }
    else if(strncmp(note.name.str.buffer, "raw", note.name.str.length) == 0) {
        for(var i = 0; i < note.attributes.size(); i += 1) {
            var attr = note.attributes.get(i)
            buf.appendStr(attr.str.buffer, attr.str.length)
        }
    }
    else if(strncmp(note.name.str.buffer, "inline", note.name.str.length) == 0) {
        this.emit("LITAC_INLINE ")
    }
    else if(strncmp(note.name.str.buffer, "noinline", note.name.str.length) == 0) {
        this.emit("LITAC_NOINLINE ")
    }
    else if(strncmp(note.name.str.buffer, "static", note.name.str.length) == 0) {
        this.emit("static ")
    }
    else if(strncmp(note.name.str.buffer, "register", note.name.str.length) == 0) {
        this.emit("register ")
    }
    else if(strncmp(note.name.str.buffer, "threadlocal", note.name.str.length) == 0) {
        this.emit("LITAC_THREADLOCAL ")
    }
    else if(strncmp(note.name.str.buffer, "export", note.name.str.length) == 0) {
        this.emit("LITAC_EXPORT ")
        // TODO
    }
    else if(strncmp(note.name.str.buffer, "packed", note.name.str.length) == 0) {
        this.emit("LITAC_PACKED ")
    }
    else if(strncmp(note.name.str.buffer, "cc", note.name.str.length) == 0) {
        if(!note.attributes.empty()) {
            var attr = note.attributes.get(0)
            this.emit("%.*s ", attr.str.length, attr.str.buffer)
        }
    }
    else if(strncmp(note.name.str.buffer, "cFile", note.name.str.length) == 0) {
        // TODO
        assert(false)
    }
}

func (this: using *CGen) emitPostludeNote(note: *NoteStmt) {
    if(strncmp(note.name.str.buffer, "packed", note.name.str.length) == 0) {
        this.emit(" LITAC_PACKED_POP ")
    }
}

func (this: using *CGen) emitSymbol(sym: *Symbol) {
    if(!sym) {
        return;
    }

    if(!(sym.flags & SymbolFlags.IS_USING)) {
        this.emit("%s", this.cName(sym))
        return;
    }

    var paramInfo = sym.usingParent
    assert(paramInfo != null)

    var aggType = paramInfo.type.getBaseType() as (*AggregateTypeInfo)
    this.emit("%s", this.cName(paramInfo))

    var path = FieldPath{}
    var isFound = aggType.getFieldPath(sym.name, &path)
    assert(isFound)

    var nextType = paramInfo.type
    for(var i = 0; i < path.numOfFields; i+=1) {
        var field = path.fields[i]
        if(nextType.kind == TypeKind.PTR) {
            buf.append("->")
        }
        else {
            buf.append(".")
        }
        this.emit("%.*s", field.varField.name.str.length, field.varField.name.str.buffer)
        nextType = field.typeInfo
    }
}

func (this: using *CGen) emitStmt(s: *Stmt) {
    if(!s) return;

    switch(s.kind) {
        case StmtKind.IMPORT_DECL: {
            return;
        }
        case StmtKind.CONST_DECL:
        case StmtKind.VAR_DECL: {
            var decl = s as (*VarDecl)
            this.emitVarDecl(decl)
            return;
        }
        case StmtKind.UNION_DECL:
        case StmtKind.STRUCT_DECL: {
            var decl = s as (*AggregateDecl)
            this.emitAggregateDecl(decl)
            return;
        }
        case StmtKind.ENUM_DECL: {
            var decl = s as (*EnumDecl)
            this.emitEnumDecl(decl)
            return;
        }
        case StmtKind.FUNC_DECL: {
            var decl = s as (*FuncDecl)
            this.emitFuncDecl(decl)
            return;
        }
        case StmtKind.TYPEDEF_DECL: {
            return;
        }
        case StmtKind.PARAM_DECL: {
            assert(false)
            return;
        }
        case StmtKind.NATIVE_DECL: {
            assert(false)
            return;
        }
        case StmtKind.POISON_DECL: {
            assert(false)
            return;
        }
        case StmtKind.BLOCK_STMT: {
            var stmt = s as (*BlockStmt)
            this.emit("{")
            {
                this.pushScope(&CGenScope{})
                defer this.popScope()

                for(var i = 0; i < stmt.stmts.size(); i += 1) {
                    var n = stmt.stmts.get(i)
                    this.emitStmt(n)
                    if(IsExpr(n)) {
                        this.emit(";\n")
                    }
                    else {
                        this.emit("\n")
                    }
                }
            }
            this.emit("\n}")
            return;
        }
        case StmtKind.BREAK_STMT: {
            this.popLoopScope(true)
            this.emit("break;")
            return;
        }
        case StmtKind.COMP_STMT: {
            var stmt = s as (*CompStmt)

            var result = stmt.evaluatedStmt
            if(result) {
                this.emitStmt(result)
            }
            return;
        }
        case StmtKind.CONTINUE_STMT: {
            this.popLoopScope()
            this.emit("continue;")
            return;
        }
        case StmtKind.DEFER_STMT: {
            var stmt = s as (*DeferStmt)
            if(this.currentScope.defers.empty()) {
                this.currentScope.defers.init(16, this.lita.allocator)
            }

            this.currentScope.defers.add(stmt.deferedStmt)
            return;
        }
        case StmtKind.DO_WHILE_STMT: {
            var stmt = s as (*DoWhileStmt)
            this.emit("do {")
            {
                this.pushScope(&CGenScope{.isLoop = true})
                defer this.popScope()

                this.emitStmt(stmt.body)
                if(IsExpr(stmt.body)) {
                    this.emit(";\n")
                }
            }
            this.emit("}\nwhile(")
            this.emitStmt(stmt.cond)
            this.emit(");")
            return;
        }
        case StmtKind.EMPTY_STMT: {
            return;
        }
        case StmtKind.ENUM_FIELD_ENTRY_DECL: {
            assert(false)
            return;
        }
        case StmtKind.FOR_STMT: {
            var stmt = s as (*ForStmt)
            this.emit("for(")
            if(stmt.init) {
                this.emitStmt(stmt.init)
                if(IsExpr(stmt.init)) {
                    this.emit(";\n")
                }
            }
            else {
                this.emit(";")
            }

            if(stmt.cond) {
                this.emitStmt(stmt.cond)
            }

            this.emit(";")

            if(stmt.post) {
                this.emitStmt(stmt.post)
            }
            this.emit(") {")

            if(stmt.body) {
                this.pushScope(&CGenScope{.isLoop = true})
                defer this.popScope()

                this.emitStmt(stmt.body)

                if(IsExpr(stmt.body)) {
                    this.emit(";\n")
                }
            }
            else {
                this.emit(";")
            }
            this.emit("}")
            return;
        }
        case StmtKind.FUNC_BODY_STMT: {
            var stmt = s as (*FuncBodyStmt)
            this.pushScope(&CGenScope{})
            defer this.popScope()

            for(var i = 0; i < stmt.stmts.size(); i += 1) {
                var n = stmt.stmts.get(i)
                this.emitStmt(n)
                if(IsExpr(n)) {
                    this.emit(";\n")
                }
                else {
                    this.emit("\n")
                }
            }
            return;
        }
        case StmtKind.GOTO_STMT: {
            var stmt = s as (*GotoStmt)
            this.emit("goto ")
            this.emitName(stmt.label)
            this.emit(";\n")
            return;
        }
        case StmtKind.IF_STMT: {
            var stmt = s as (*IfStmt)
            this.emit("if(")
            this.emitStmt(stmt.cond)
            this.emit(") {")
            {
                this.pushScope(&CGenScope{})
                defer this.popScope()

                this.emitStmt(stmt.then)
                if(IsExpr(stmt.then)) {
                    this.emit(";")
                }
                this.emit("\n")
            }
            this.emit("} ")
            if(stmt.elseStmt) {
                this.emit("else {")
                {
                    this.pushScope(&CGenScope{})
                    defer this.popScope()

                    this.emitStmt(stmt.elseStmt)
                    if(IsExpr(stmt.elseStmt)) {
                        this.emit(";")
                    }
                }
                this.emit("} ")
            }
            this.emit("\n")
            return;
        }
        case StmtKind.LABEL_STMT: {
            var stmt = s as (*LabelStmt)
            this.emitName(stmt.label)
            this.emit(":\n")
            return;
        }
        case StmtKind.MODULE_STMT: {
            assert(false)
            return;
        }
        case StmtKind.NOTE_STMT: {
            var stmt = s as (*NoteStmt)
            this.emit("@")
            this.emitName(stmt.name)
            if(!stmt.attributes.empty()) {
                this.emit("(")
                for(var i = 0; i < stmt.attributes.size(); i += 1) {
                    if(i > 0) this.emit(", ")
                    this.emit("'")
                    this.emitName(stmt.attributes.get(i))
                    this.emit("'")
                }
                this.emit(")")
            }
            return;
        }
        case StmtKind.PARAMETERS_STMT: {
            assert(false)
            return;
        }
        case StmtKind.RETURN_STMT: {
            var stmt = s as (*ReturnStmt)


            if(stmt.expr && this.hasPendingDefers()) {
                assert(this.currentFunc != null)
                this.emit("{%s = ", this.cTypeDecl(this.currentFunc.returnType, "___result"))
                this.emitStmt(stmt.expr)
                this.emit(";\n")

                this.emitDefers()
                this.emit("return ___result;\n}\n")
            }
            else {
                this.emitDefers()

                this.emit("return");
                if(stmt.expr) {
                    this.emit(" ")
                    this.emitStmt(stmt.expr)
                }
                this.emit(";\n")
            }
            return;
        }

        case StmtKind.SWITCH_CASE_STMT: {
            var stmt = s as (*SwitchCaseStmt)
            this.emit("case ")
            this.emitStmt(stmt.cond)
            this.emit(": ")
            this.emitStmt(stmt.body)
            return;
        }
        case StmtKind.SWITCH_STMT: {
            var stmt = s as (*SwitchStmt)

            this.pushScope(&CGenScope{.isSwitch = true})
            defer this.popScope()

            this.emit("switch(")
            this.emitStmt(stmt.cond)
            this.emit(") {")
            for(var i = 0; i < stmt.cases.size(); i+=1) {
                if(i > 0) this.emitln()
                this.emitStmt(stmt.cases.get(i))
            }

            if(stmt.defaultStmt) {
                this.emit("\ndefault: ")
                this.emitStmt(stmt.defaultStmt)
            }
            this.emit("}")
            return;
        }
        case StmtKind.VAR_FIELD_DECL: {
            var decl = s as (*VarFieldDecl)
            this.emitLineInfo(decl)

            var name: [MAX_SYMBOL_NAME]char;
            var nameStr = StringInit(name, MAX_SYMBOL_NAME)
            nameStr.format("%.*s", decl.name.str.length, decl.name.str.buffer)

            var aliasNote = decl.getNote("alias")
            if(aliasNote && !aliasNote.attributes.empty()) {
                var aliasName = aliasNote.attributes.get(0)

                nameStr.clear()
                nameStr.format("%.*s", aliasName.str.length, aliasName.str.buffer)
            }

            this.emit("%s;\n", this.cTypeDecl(decl.type.typeInfo, nameStr.cStrConst()))
            return;
        }
        case StmtKind.WHILE_STMT: {
            var stmt = s as (*WhileStmt)
            this.emit("while(")
            this.emitStmt(stmt.cond)
            this.emit(") {")
            {
                this.pushScope(&CGenScope{.isLoop = true})
                defer this.popScope()

                this.emitStmt(stmt.body)
                if(IsExpr(stmt.body)) {
                    this.emit(";\n")
                }
            }
            this.emit("}")
            return;
        }

        case StmtKind.ARRAY_DESIGNATION_EXPR: {
            var expr = s as (*ArrayDesignationExpr)
            this.emit("[")
            this.emitStmt(expr.index)
            this.emit("] = ")
            this.emitStmt(expr.value)
            return;
        }
        case StmtKind.ARRAY_INIT_EXPR: {
            var expr = s as (*ArrayInitExpr)
            if(expr.values.empty()) {
                buf.append("{}")
            }
            else {
                var requiresCast = false
                if(expr.parent) {
                    requiresCast = expr.parent.kind == StmtKind.RETURN_STMT ||
                                expr.parent.kind == StmtKind.FUNC_CALL_EXPR;
                }

                if(requiresCast || !expr.expectedType || expr.expectedType.kind == TypeKind.PTR) {
                    this.emit("(%s)", this.cType(expr.type.typeInfo))
                }

                this.emit(" {")
                for(var i = 0; i < expr.values.size(); i+=1) {
                    if(i > 0) {
                        this.emit(",\n")
                    }
                    this.emitStmt(expr.values.get(i))
                }

                this.emit("}")
            }
            return;
        }
        case StmtKind.BINARY_EXPR: {
            var expr = s as (*BinaryExpr)
            this.emitStmt(expr.left)
            this.emit(" %s ", tokenText[expr.operator])
            this.emitStmt(expr.right)
            break;
        }
        case StmtKind.BOOLEAN_EXPR: {
            var expr = s as (*BooleanExpr)
            this.emit("%s", expr.boolean ? "true" : "false")
            return;
        }
        case StmtKind.CAST_EXPR: {
            var expr = s as (*CastExpr)
            this.emit("(%s)", this.cType(expr.castTo.typeInfo, true))
            this.emitStmt(expr.exprToCast)
            return;
        }
        case StmtKind.CHAR_EXPR: {
            var expr = s as (*CharExpr)
            var c = escapeStrings[expr.character.intValue]
            if(c != 0) {
                this.buf.append("'%s'", c)
            }
            else {
                this.buf.append("'%c'", expr.character.intValue as (char))
            }
            return;
        }
        case StmtKind.FUNC_CALL_EXPR: {
            var expr = s as (*FuncCallExpr)
            this.emitStmt(expr.object)
            this.emit("(")

            var i = 0;
            for(; i < expr.arguments.size(); i+=1) {
                if(i > 0) {
                    this.emit(", ")
                }
                this.emitStmt(expr.arguments.get(i))
            }
            var objectType = expr.object.operand.typeInfo
            if(objectType.kind == TypeKind.FUNC) {
                var funcType = objectType as (*FuncTypeInfo)
                for(; i < funcType.decl.params.size(); i+=1) {
                    var param = funcType.decl.params.get(i)
                    if(param.defaultExpr) {
                        if(i > 0) {
                            this.emit(", ")
                        }
                        this.emitStmt(param.defaultExpr)
                    }
                }
            }
            this.emit(")")
            return;
        }
        case StmtKind.IDENTIFIER_EXPR:
        case StmtKind.FUNC_IDENTIFIER_EXPR: {
            var expr = s as (*IdentifierExpr)

            var type = expr.type.typeInfo
            var sym: *Symbol = (type) ? type.sym : expr.sym;

            if(!sym) {
                this.emit("%s%s", this.options.cPrefix, expr.type.name)
            }
            else {
                this.emitSymbol(sym)
            }

            return;
        }
        case StmtKind.GET_EXPR: {
            var expr = s as (*GetExpr)

            // handled by funcCallExpr
            if(expr.flags & GetExprFlags.IS_METHOD_CALL) {
                this.emit("%s", this.cTypeName(expr.field.operand.typeInfo))
                return;
            }

            var objectType = expr.object.operand.typeInfo

            if(expr.flags & GetExprFlags.IS_ENUM) {
                if(objectType.sym && objectType.sym.flags & SymbolFlags.IS_FOREIGN) {
                    buf.append("%s", expr.field.type.name)
                }
                else {
                    buf.append("%s_%s", this.cName(objectType.sym), expr.field.type.name)
                }
                return;
            }

            this.emitStmt(expr.object)

            if(expr.flags & GetExprFlags.IS_USING) {
                var baseInfo = objectType.getBaseType()
                assert(baseInfo != null)
                assert(baseInfo.kind == TypeKind.STRUCT || baseInfo.kind == TypeKind.UNION)

                var aggInfo = baseInfo as (*AggregateTypeInfo)

                var path = FieldPath{}
                var isFound = aggInfo.getFieldPath(expr.field.type.name, &path)
                assert(isFound)

                var nextType = objectType
                for(var i = 0; i < path.numOfFields; i+=1) {
                    var field = path.fields[i]
                    if(nextType.kind == TypeKind.PTR) {
                        buf.append("->")
                    }
                    else {
                        buf.append(".")
                    }
                    this.emit("%.*s", field.varField.name.str.length, field.varField.name.str.buffer)
                    nextType = field.typeInfo
                }
            }
            else {
                if(objectType.kind == TypeKind.PTR) {
                    buf.append("->")
                }
                else {
                    buf.append(".")
                }

                this.emitStmt(expr.field)
            }

            return;
        }
        case StmtKind.GROUP_EXPR: {
            var expr = s as (*GroupExpr)
            this.emit("(")
            this.emitStmt(expr.groupedExpr)
            this.emit(")")
            return;
        }
        case StmtKind.INIT_ARG_EXPR: {
            var expr = s as (*InitArgExpr)
            if(expr.fieldName.type == TokenType.IDENTIFIER) {
                this.emit(".")
                this.emitName(expr.fieldName)
                this.emit(" = ")
            }

            this.emitStmt(expr.value)
            return;
        }
        case StmtKind.INIT_EXPR: {
            var expr = s as (*InitExpr)

            var requiresCast = false
            if(expr.parent) {
                requiresCast = expr.parent.kind == StmtKind.RETURN_STMT ||
                               expr.parent.kind == StmtKind.FUNC_CALL_EXPR;
            }

            if(requiresCast || !expr.expectedType || expr.expectedType.kind == TypeKind.PTR) {
                this.emit("(%s)", this.cType(expr.type.typeInfo))
            }
            this.emit(" {")
            for(var i = 0; i < expr.arguments.size(); i += 1) {
                if(i > 0) {
                    this.emit(",\n")
                }
                this.emitStmt(expr.arguments.get(i))
            }
            this.emit("}")
            return;
        }
        case StmtKind.NULL_EXPR: {
            this.emit("NULL")
            return;
        }
        case StmtKind.NUMBER_EXPR: {
            var expr = s as (*NumberExpr)

            var hasDecimal = false
            var isHex = false
            var isBin = false
            var length: usize = expr.startPos.end - expr.startPos.start
            if(length > 2) {
                var first = expr.startPos.start[0]
                var second = tolower(expr.startPos.start[1])
                if(first == '0' && second == 'x') {
                    isHex = true
                }
                else if(first == '0' && second == 'b') {
                    isBin = true
                }
            }

            for(var start = expr.startPos.start; start != expr.startPos.end; start += 1) {
                var c = *start

                if(c == '.') {
                    hasDecimal = true
                }
                else if(c == '_') {
                    continue
                }
                else if(isalpha(c)) {
                    if(!isHex && !isBin) {
                        break;
                    }

                    if(isHex) {
                        var lowered = tolower(c)
                        if(c != 'a' &&
                           c != 'b' &&
                           c != 'c' &&
                           c != 'd' &&
                           c != 'e' &&
                           c != 'f' &&
                           c != 'x') {
                               break
                        }
                    }
                    else if(isBin) {
                        var lowered = tolower(c)
                        if(c != 'b') {
                               break
                        }
                    }
                    else {
                        break
                    }
                }

                this.emit("%c", *start)
            }

            var type = expr.operand.typeInfo
            switch(type.kind) {
                case TypeKind.F32: {
                    if(!hasDecimal) {
                        this.emit(".")
                    }
                    this.emit("f")
                    break;
                }
                case TypeKind.U8:
                case TypeKind.U16:
                case TypeKind.U32: {
                    this.emit("U")
                    break;
                }
                case TypeKind.U64: {
                    this.emit("UL")
                    break;
                }
                case TypeKind.I64: {
                    this.emit("L")
                    break;
                }
                default: {

                }
            }
            return;
        }
        case StmtKind.OFFSET_OF_EXPR: {
            var expr = s as (*OffsetOfExpr)
            this.emit("offsetof(%s, %.*s)", this.cType(expr.type.typeInfo), expr.field.str.length, expr.field.str.buffer)
            return;
        }
        case StmtKind.SET_EXPR: {
            var expr = s as (*SetExpr)
            this.emitStmt(expr.object)

            var objectType = expr.object.operand.typeInfo
            if(expr.flags & GetExprFlags.IS_USING) {
                var baseInfo = objectType.getBaseType()
                assert(baseInfo != null)
                assert(baseInfo.kind == TypeKind.STRUCT || baseInfo.kind == TypeKind.UNION)

                var aggInfo = baseInfo as (*AggregateTypeInfo)

                var path = FieldPath{}
                var isFound = aggInfo.getFieldPath(expr.field.type.name, &path)
                assert(isFound)

                var nextType = objectType
                for(var i = 0; i < path.numOfFields; i+=1) {
                    var field = path.fields[i]
                    if(nextType.kind == TypeKind.PTR) {
                        buf.append("->")
                    }
                    else {
                        buf.append(".")
                    }
                    this.emit("%.*s", field.varField.name.str.length, field.varField.name.str.buffer)
                    nextType = field.typeInfo
                }

                this.emit(" %s ", tokenText[expr.operator])
            }
            else {
                if(objectType.kind == TypeKind.PTR) {
                    buf.append("->%s %s ", expr.field.type.name, tokenText[expr.operator])
                }
                else {
                    buf.append(".%s %s ", expr.field.type.name, tokenText[expr.operator])
                }
            }

            this.emitStmt(expr.value)
            return;
        }
        case StmtKind.SIZE_OF_EXPR: {
            var expr = s as (*SizeOfExpr)
            this.emit("sizeof(")
            this.emitStmt(expr.sizeOfExpr)
            this.emit(")")
            return;
        }
        case StmtKind.STRING_EXPR: {
            var expr = s as (*StringExpr)

            if(expr.string.mod == Mod.MULTISTR) {
                this.buf.appendChar('"') // "
                for(var i = 0; i < expr.string.str.length; i += 1) {
                    var c:char = expr.string.str.buffer[i]
                    var escaped = escapeStrings[c as (u32)]
                    if(escaped) {
                        buf.append("%s", escaped)
                        continue
                    }

                    if(c == '\\') {
                        var n = expr.string.str.buffer[i+1] as (u32)
                        var escapedChar = escapeChars[n]
                        if(escapedChar) {
                            var chars = escapeChars[n]
                            assert(chars)
                            buf.append("%s", chars)
                            i += 1
                            continue
                        }
                        else {
                            buf.append("\\")
                        }
                    }
                    if(c == '"') {  // "
                        buf.append("\\")
                    }
                    buf.appendChar(c)
                }
                this.buf.appendChar('"') // "
            }
            else {
                this.buf.append("\"%.*s\"", expr.string.str.length, expr.string.str.buffer)
            }
            return;
        }
        case StmtKind.SUBSCRIPT_GET_EXPR: {
            var expr = s as (*SubscriptGetExpr)
            this.emitStmt(expr.object)
            this.emit("[")
            this.emitStmt(expr.index)
            this.emit("]")
            return;
        }
        case StmtKind.SUBSCRIPT_SET_EXPR: {
            var expr = s as (*SubscriptSetExpr)
            this.emitStmt(expr.object)
            this.emit("[")
            this.emitStmt(expr.index)
            this.emit("] %s ", tokenText[expr.operator])
            this.emitStmt(expr.value)
            return;
        }
        case StmtKind.TERNARY_EXPR: {
            var expr = s as (*TernaryExpr)
            this.emit("(")
            this.emitStmt(expr.cond)
            this.emit(") ? ")
            this.emitStmt(expr.then)
            this.emit(" : ")
            this.emitStmt(expr.other)
            return;
        }
        case StmtKind.TYPE_IDENTIFIER_EXPR: {
            var expr = s as (*TypeIdentifierExpr)
            // TODO: Simplify this...
            if(expr.type.typeInfo) {
                this.emit("%s", this.cType(expr.type.typeInfo))
            }
            else {
                if(expr.sym) {
                    this.emitSymbol(expr.sym)
                }
                else {
                    this.emitTypeSpec(expr.type)
                }
            }
            return;
        }/*
        case StmtKind.TYPE_OF_EXPR: {
            var expr = new<TypeOfExpr>(allocator)
            expr.kind = StmtKind.TYPE_OF_EXPR;
            expr.startPos = startPos
            expr.typeOfExpr = null
            expr.type = null
            return expr as (*Stmt);
        }*/
        case StmtKind.UNARY_EXPR: {
            var expr = s as (*UnaryExpr)
            this.emit("%s(", tokenText[expr.operator])
            this.emitStmt(expr.unaryExpr)
            this.emit(")")
            return;
        }
        case StmtKind.POISON_EXPR: {
            assert(false)
            return;
        }
        default: {
            //Panic("Unknown statement kind: %d", s.kind)
            this.emit("<%s Not Implemented>", StmtKindAsStr(s.kind))
            assert(false)
        }
    }
}