import "types"
import "types_new"
import "symbols"
import "phase_result"
import "module"
import "ast"
import "lex"
import "state"
import "map"
import "string_buffer"
import "array"
import "assert"

import "ast_print"
import "libc"

import "checker"

public func (this: *TypeChecker) resolveDecl(decl: *Decl) : bool {
    assert(decl != null)

    switch(decl.kind) {
        case StmtKind.IMPORT_DECL: {
            return true;
        }
        case StmtKind.CONST_DECL:
        case StmtKind.VAR_DECL: {            
            var type = this.resolveValueDecl(decl as (*VarDecl))
            this.addSymbol(decl, type)
            return true;
        }
        case StmtKind.STRUCT_DECL:
        case StmtKind.UNION_DECL:
        case StmtKind.ENUM_DECL:
        case StmtKind.FUNC_DECL: {
            var funcDecl = decl as (*FuncDecl)            
            return this.resolveFuncDecl(funcDecl)
        }
        case StmtKind.TYPEDEF_DECL:
        case StmtKind.PARAM_DECL:
        case StmtKind.NATIVE_DECL:
        case StmtKind.POISON_DECL:
        default: {
            assert(false)
        }
    }

    return false
}

func (this: *TypeChecker) resolveFuncDecl(funcDecl: *FuncDecl) : bool {
    this.enterModule(funcDecl.sym.declared)
    defer this.leaveModule()

    this.pushScope(Scope{})
    defer this.popScope()

    this.resolveStmt(funcDecl.params)
    if(funcDecl.body) {
        // keep track of which function we are currently parsing
        this.currentFuncDecl = funcDecl.sym.type as (*FuncTypeInfo)
        defer this.currentFuncDecl = null

        // TODO Handle goto labels
        this.resolveStmt(funcDecl.body)
    }

    return true
}

public func (this: *TypeChecker) resolveParamDecl(paramDecl: *ParameterDecl) : bool {
    assert(paramDecl != null)

    if(paramDecl.defaultExpr) {
        this.resolveExpr(paramDecl.defaultExpr)
    }

    var typeInfo = this.resolveTypeSpec(paramDecl.type)
    paramDecl.sym = this.addSymbol(paramDecl, typeInfo)

    // TODO: Handle using parameters
    return true
}