import "ast"
import "ast_new"
import "lex"
import "array"
import "map"
import "phase_result"
import "string"
import "string_view"
import "string_buffer"
import "system"
import "lita"
import "libc"
import "mem"
import "symbols"
import "types"

public enum ModuleFlags {
    TYPE_CHECKED  = (1<<0),
    TYPE_RESOLVED = (1<<1),
}

public struct ModuleId {
    filename: [MAX_PATH]char   // full path the file of this module
    packageName: StringView    // relative path from the main module's directory
    name: StringView           // the name of the module
}

public struct Module {
    id: ModuleId        // TODO: don't make a separate allocation
    text: *char         // text of modules file
    ast: *ModuleStmt
    //result: *PhaseResult
    symbols: Scope
    currentScope: *Scope
    genericSymbols: *Map<*const char, *Symbol>
    flags: i32

    allocator: *const Allocator
}

public const BUILTIN_IMPORT_TOKEN = Token {
    .type = TokenType.STRING,
    .value = Value {
        .str = StringView {
            .buffer = "builtin",
            .length = 7
        }
    }
}
public const builtins = Module{}
const genericSymbols = Map<*const char, *Symbol>{}
public func BuiltinsInit(lita: *Lita) : *Module {
    genericSymbols.init(null, 128, StrHashFn, StrEqualFn, lita.allocator)

    builtins.text = null
    builtins.ast = null
    builtins.flags = 0
    builtins.allocator = lita.allocator
    builtins.symbols.init(ScopeKind.MODULE, null, lita.result, lita.allocator)
    builtins.genericSymbols = &genericSymbols

    var filename: [MAX_PATH]char;
    var pathStr = StringInit(filename, MAX_PATH);
    pathStr.format("%s/lib/builtins.lita", lita.options.litaPath)
    builtins.id.fromFile(lita, pathStr.cStr())

    AddBuiltin(lita, &BOOL_TYPE)
    AddBuiltin(lita, &CHAR_TYPE)
    AddBuiltin(lita, &I8_TYPE)
    AddBuiltin(lita, &U8_TYPE)
    AddBuiltin(lita, &I16_TYPE)
    AddBuiltin(lita, &U16_TYPE)
    AddBuiltin(lita, &I32_TYPE)
    AddBuiltin(lita, &U32_TYPE)
    AddBuiltin(lita, &I64_TYPE)
    AddBuiltin(lita, &U64_TYPE)
    AddBuiltin(lita, &F32_TYPE)
    AddBuiltin(lita, &F64_TYPE)
    AddBuiltin(lita, &USIZE_TYPE)
    AddBuiltin(lita, &NULL_TYPE)
    AddBuiltin(lita, &VOID_TYPE)

    return &builtins
}

func AddBuiltin(lita: *Lita, type: *TypeInfo) {
    var sym = builtins.symbols.addSymbol(type.name,
                                        &builtins,
                                        NewBuiltinDecl(SrcPos{}, SrcPos{}, type, lita.allocator),
                                        SymbolFlags.IS_BUILTIN|SymbolFlags.IS_TYPE|SymbolFlags.IS_FOREIGN)

    sym.state = SymbolState.RESOLVED
    sym.type = type
    type.sym = sym
}

public func NewModule(lita: *Lita,
                      filename: *const char) : *Module {

    var mod = new<Module>(lita.allocator)
    mod.init(lita.result, lita.allocator)
    mod.id.fromFile(lita, filename)
    return mod
}

public func (this: *Module) init(result: *PhaseResult,
                                 allocator: *const Allocator) {
    this.text = null
    this.ast = null
    this.symbols.init(ScopeKind.MODULE, &builtins.symbols, result, allocator)
    this.flags = 0
    this.allocator = allocator
    this.currentScope = &this.symbols
    this.genericSymbols = &genericSymbols

    this.symbols.module = this // TEMP
}

public func (this: *Module) getType(type: *const char) : *Symbol {
    var sym = this.symbols.lookup(type)
    if(sym) {
        return sym
    }

    return this.genericSymbols.get(type)
}

public func (this: *Module) importModule(importDecl: *ImportDecl, module: *Module) {
    var moduleName: *StringView = null;

    if(importDecl.alias.type == TokenType.IDENTIFIER) {
        moduleName = &importDecl.alias.str;
    }
    else {
        //moduleName = module.id.name;
    }
    this.importModuleSymbols(module, moduleName)

}


func (this: *Module) importModuleSymbols(module: *Module, moduleName: *StringView) {
    for(var i = 0; i < module.symbols.capacity; i += 1) {
        var symName = module.symbols.keys[i]
        var symbol = module.symbols.values[i]
        if(!symName || !symbol) {
            continue
        }

        // only import public symbols
        if(!(symbol.flags & SymbolFlags.IS_PUBLIC)) {
            continue
        }

        // only import symbols that are declared in the import module
        if(!symbol.declared.equals(module)) {
            continue
        }

        // don't import symbols already defined in this module
        if(symbol.declared.equals(this)) {
            continue
        }

        if(moduleName) {

            var name = StringBufferInit(MAX_SYMBOL_NAME, this.allocator)
            name.appendStr(moduleName.buffer, moduleName.length)
            name.append("::%s", symbol.name)

            // TEMP
            //printf("%s importing type '%s' from %s\n", this.id.filename, name.cStrConst(), module.id.filename)
            this.symbols.importSymbol(name.cStrConst(), symbol)
        }
        else {
            //printf("%s importing type '%s' from %s\n", this.id.filename, symName, module.id.filename)
            this.symbols.importSymbol(symName, symbol)
        }
    }
}

public func (this: *Module) equals(other: *Module) : bool {
    if(!other) return false

    return strcmp(this.id.filename, other.id.filename) == 0
}

public func (this: *Module) print(header: *const char) {
    printf("Module %s %.*s {\n", header, this.id.name.length, this.id.name.buffer)
    for(var i = 0; i < this.symbols.capacity; i+=1) {
        var symName = this.symbols.keys[i]
        var symbol = this.symbols.values[i]
        if(!symName || !symbol) {
            printf("   %d null\n", i)
            continue
        }
        printf("   %d '%s' %s\n", i, symName, SymbolKindAsStr(symbol.kind))
    }
    printf("}\n")
}

public func (moduleId: *ModuleId) fromFile(lita: *Lita, filename: *const char) {
    strcpy(moduleId.filename, filename)
    var pathStr = StringViewInit(moduleId.filename);

    moduleId.packageName = StringViewInit(moduleId.filename, 0)
    moduleId.name = GetModuleName(pathStr)
}

public func GetModuleName(pathStr: StringView) : StringView {
    var endIndex = -1
    var startIndex = -1
    for(var i = pathStr.length - 1; i >= 0; i -= 1) {
        var c = pathStr.buffer[i]
        if(c == '.' && endIndex < 0) {
            endIndex = i
        }
        else if(c == '/') {
            startIndex = i + 1
            break
        }
    }

    if(endIndex < 0 || startIndex < 0 || startIndex > endIndex) {
        return StringView {
            .buffer = 0,
            .length = 0
        }
    }

    return StringView {
        .buffer = pathStr.buffer + startIndex,
        .length = endIndex - startIndex
    }
}

