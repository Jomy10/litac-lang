import "checker"
import "array"
import "map"
import "types"
import "lita"
import "symbols"
import "string_buffer"
import "string_view"
import "ast"
import "ast_copy"
import "assert"
import "libc"
import "parser"
import "lex"
import "module"

public func CreateTraitWrappers(checker: *TypeChecker) : Array<*Decl> {

    var decls = ArrayInit<*Decl>(512, checker.lita.allocator)
    var sb = StringBufferInit(2048, checker.lita.allocator)

    for(var it = checker.interfaceImpls.iter(); it.hasNext();) {
        var entry = it.next()
        var traitSym = FindSymbolByTypeid(checker.symbolTypes, entry.key)
        assert(traitSym)
        assert(traitSym.decl && traitSym.decl.kind == StmtKind.TRAIT_DECL)

        var traitDecl = traitSym.decl as (*AggregateDecl)
        var traitName = traitSym.name

        printf("Trait: %s\n", traitName)

        // Generate VTable
        {
            /*
            var vtableDecl = CopyAggregateDecl(traitDecl, checker.lita.allocator)

            var name = StringBufferInit(256, checker.lita.allocator)
            name.append("__%s_vtable", traitName)
            vtableDecl.name = Token {
                .type = TokenType.IDENTIFIER,
                .pos = vtableDecl.startPos,
                .value = Value { .str = StringViewInit(name.cStr(), name.length) }
            }
            vtableDecl.kind = StmtKind.STRUCT_DECL

            decls.add(vtableDecl as (*Decl))*/

            sb.append("struct %s__VirtualTable", traitName)
            PrintGenerics(traitSym.genericParams, sb)
            sb.append(" {\n")

            for(var j = 0; j < traitDecl.fields.size(); j += 1) {
                  var field = traitDecl.fields.get(j)
                  assert(field.kind == StmtKind.TRAIT_FIELD_DECL)
                  assert(field.typeInfo != null && field.typeInfo.kind == TypeKind.FUNC_PTR)

                  var fn = field.typeInfo as (*FuncPtrTypeInfo)
                  var traitField = field.traitField
                  sb.append("    %s: func", traitField.name.asString())
                  PrintGenerics(fn.genericParams, sb)
                  sb.append("(*void")
                  for(var p = 0; p < fn.paramDecls.size(); p += 1) {
                      var param = fn.paramDecls.get(p)
                      sb.append(", ")
                      param.toString(sb)
                  }
                  sb.append(") : ")
                  fn.returnType.toString(sb)
                  sb.append(";\n")
            }
            sb.append("}\n")

            /*{
                printf("Trait Virtual Table: \n%s\n", sb.cStr())
                var module = traitSym.declared
                var parser = ParserInit(module.id.filename, sb.cStr(), checker.lita)
                var stmts = parser.parseModule()
                decls.addAll(stmts.declarations)

                sb.clear()
            }*/
        }

        // Generate Wrapper functions
        {
            for(var i = 0; i < entry.value.size(); i += 1) {
                var implSym = FindSymbolByTypeid(checker.symbolTypes, entry.value.get(i))
                assert(implSym)

                var implName = implSym.name //this.cTypeName(implSym.type)

                var isFromGeneric = false
                if(implSym.flags & SymbolFlags.IS_FROM_GENERIC_TEMPLATE) {
                    isFromGeneric = true
                    var genericTypeid = (implSym.type as (*GenericTypeInfo)).genericTypeid
                    var genSym = FindSymbolByTypeid(checker.symbolTypes, genericTypeid)
                    implName = genSym.name
                }

                for(var j = 0; j < traitDecl.fields.size(); j += 1) {
                    var field = traitDecl.fields.get(j)
                    assert(field.kind == StmtKind.TRAIT_FIELD_DECL)

                    //var fieldName = field.traitField.name.asString()

                    assert(field.typeInfo && field.typeInfo.kind == TypeKind.FUNC_PTR)
                    var fn = field.typeInfo as (*FuncPtrTypeInfo)

                    sb.append("func __%s_%s_wrapper", implName, field.traitField.name.asString())
                    PrintGenerics(implSym.genericParams, sb)
                    sb.append("(this: *void")
                    for(var p = 0; p < fn.paramDecls.size(); p += 1) {
                        var param = fn.paramDecls.get(p)
                        sb.append(", _%d: ", p)
                        param.toString(sb)
                    }

                    if(fn.hasVarargs) {
                        // TODO: do varargs passing
                        sb.append(", ...")
                    }

                    sb.append(") : ")
                    fn.returnType.toString(sb)
                    sb.append(" {\n")
                    {
                        var moduleName = implSym.declared.id.name
                        sb.append("    var __this = this as (*%.*s::%s", moduleName.length, moduleName.buffer, implName)
                        PrintGenerics(implSym.genericParams, sb)
                        sb.append(")\n")

                        if(fn.returnType.kind != TypeKind.VOID) {
                            sb.append("    return ")
                        }
                        else {
                            sb.append("    ")
                        }

                        sb.append("__this.%s", field.traitField.name.asString())
                        PrintGenerics(implSym.genericParams, sb)

                        sb.append("(")
                        for(var p = 0; p < fn.paramDecls.size(); p += 1) {
                            var param = fn.paramDecls.get(p)
                            if(p > 0) {
                                sb.append(", ")
                            }
                            sb.append("_%d", p)
                        }
                        sb.append(")")
                    }
                    sb.append("\n}\n")
                }
            }

            /*{

                printf("Trait Wrapper Functions: \n%s\n", sb.cStr())
                var module = traitSym.declared
                var parser = ParserInit(module.id.filename, sb.cStr(), checker.lita)
                var stmts = parser.parseModule()
                decls.addAll(stmts.declarations)

                sb.clear()
            }*/
        }

        // Generate Casting functions
        /*
        {
            for(var i = 0; i < entry.value.size(); i += 1) {
                var implSym = FindSymbolByTypeid(checker.symbolTypes, entry.value.get(i))
                assert(implSym)

                var implName = implSym.name //this.cTypeName(implSym.type)

                var isFromGeneric = false
                if(implSym.flags & SymbolFlags.IS_FROM_GENERIC_TEMPLATE) {
                    isFromGeneric = true
                    var genericTypeid = (implSym.type as (*GenericTypeInfo)).genericTypeid
                    var genSym = FindSymbolByTypeid(checker.symbolTypes, genericTypeid)
                    implName = genSym.name
                }

                sb.append("%s %s__to__%s", traitName, implName, traitName)
                PrintGenerics(implSym, sb)

                sb.append("(x: *%s", implName)
                PrintGenerics(implSym, sb)
                sb.append(") {\n")

                {
                    sb.append("    return %s {\n", traitName)
                    for(var j = 0; j < traitDecl.fields.size(); j += 1) {
                        var field = traitDecl.fields.get(j)
                        assert(field.kind == StmtKind.TRAIT_FIELD_DECL)

                        var fieldName = field.traitField.name.asString()
                        sb.append("        .%s = __%s_%s_wrapper", fieldName, implName, fieldName)
                        PrintGenerics(implSym, sb)
                        sb.append(",\n")
                    }
                    sb.append("        .__this = x\n")
                    sb.append("    }\n")
                }
                sb.append("}\n")
            }
        }
        */

        // Generate Vtables implementations
        {
            sb.append("const %s__vtables = []*%s__VirtualTable {\n", traitName, traitName)
            for(var i = 0; i < entry.value.size(); i += 1) {
                var implSym = FindSymbolByTypeid(checker.symbolTypes, entry.value.get(i))
                assert(implSym)

                var implName = implSym.name //this.cTypeName(implSym.type)

                var isFromGeneric = false
                if(implSym.flags & SymbolFlags.IS_FROM_GENERIC_TEMPLATE) {
                    isFromGeneric = true
                    var genericTypeid = (implSym.type as (*GenericTypeInfo)).genericTypeid
                    var genSym = FindSymbolByTypeid(checker.symbolTypes, genericTypeid)
                    implName = genSym.name
                }

                sb.append("    [%d] = &%s__VirtualTable {\n", i, traitName)
                {
                    for(var j = 0; j < traitDecl.fields.size(); j += 1) {
                        var field = traitDecl.fields.get(j)
                        assert(field.kind == StmtKind.TRAIT_FIELD_DECL)

                        var fieldName = field.traitField.name.asString()
                        sb.append("        .%s = __%s_%s_wrapper", fieldName, implName, fieldName)
                        PrintGenericArgs(implSym.genericArgs, sb)
                        sb.append(",\n")
                    }
                }
                sb.append("    },\n")
            }
            sb.append("}\n")
        }
    }

    {
        // printf("Traits Source: \n%s\n", sb.cStr())
        var parser = ParserInit("generated", sb.cStr(), checker.lita)
        var stmts = parser.parseModule()
        decls.addAll(stmts.declarations)
    }

    return decls
}

func PrintGenerics(genericParams: *Array<GenericParam>, sb: *StringBuffer) {
    for(var x = 0; x < genericParams.size(); x += 1) {
        if(x == 0) {
            sb.append("<")
        }
        if(x > 0) {
            sb.append(", ")
        }
        sb.append("%s", genericParams.get(x).name.asString())
    }
    if(genericParams.size() > 0) {
        sb.append(">")
    }
}

func PrintGenericArgs(genericArgs: *Array<*TypeInfo>, sb: *StringBuffer) {
    for(var x = 0; x < genericArgs.size(); x += 1) {
        if(x == 0) {
            sb.append("<")
        }
        if(x > 0) {
            sb.append(", ")
        }

        var type = genericArgs.get(x)
        assert(type)
        type.toString(sb)
    }
    if(genericArgs.size() > 0) {
        sb.append(">")
    }
}

func FindSymbolByTypeid(symbols: Array<*Symbol>, id: Typeid) : *Symbol {
    for(var i = 0; i < symbols.size(); i += 1) {
        var sym = symbols.get(i)
        if(sym.type && sym.type.typeid == id) {
            return sym
        }
    }

    return null
}
