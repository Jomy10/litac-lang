import "ast"
import "ast_new"
import "lex"
import "symbols"
import "types"
import "mem"
import "array"
import "common"
import "assert"

import "libc"

public func NewTokenName(token: Token, allocator: *const Allocator) : *const char {
    if(token.type != TokenType.IDENTIFIER && token.type != TokenType.STRING) {
        return tokenText[token.type]
    }

    var bytes = allocator.alloc(token.value.str.length + 1) as (*char)
    token.value.str.copyTo(bytes, token.value.str.length)

    return bytes
}

public func CopyTypeSpecs(specs: Array<*TypeSpec>, allocator: *const Allocator) : Array<*TypeSpec> {
    if(specs.empty()) {
        return Array<*TypeSpec>{
            0
        }
    }

    var result = Array<*TypeSpec>{}
    result.init(specs.size(), allocator)

    for(var i = 0; i < specs.size(); i += 1) {
        var spec = specs.get(i)
        result.add(CopyTypeSpec(spec, allocator))
    }

    return result
}

public func CopyTypeSpec(spec: *TypeSpec, allocator: *const Allocator) : *TypeSpec {
    if(spec == null) {
        return null;
    }

    var copy = NewTypeSpec(spec.kind, spec.pos, allocator)
    copy.base = CopyTypeSpec(spec.base, allocator)

    switch(spec.kind) {
        case TypeSpecKind.NONE: {
            return copy
        }
        case TypeSpecKind.ARRAY: {
            var originalArray = spec as (*ArrayTypeSpec)
            var copyArray = copy as (*ArrayTypeSpec)
            if(originalArray.numElements) {
                copyArray.numElements = CopyExpr(originalArray.numElements, allocator)
            }
            return copyArray as (*TypeSpec)
        }
        case TypeSpecKind.PTR:
        case TypeSpecKind.CONST: {
            return copy
        }
        case TypeSpecKind.NAME: {
            var originalName = spec as (*NameTypeSpec)
            var copyName = copy as (*NameTypeSpec)
            copyName.name = originalName.name
            copyName.genericArgs = CopyTypeSpecs(originalName.genericArgs, allocator)
            return copy
        }
        case TypeSpecKind.FUNC_PTR: {
            var original = spec as (*FuncPtrTypeSpec)
            var copyFunc = copy as (*FuncPtrTypeSpec)
            copyFunc.args = CopyTypeSpecs(original.args, allocator)
            copyFunc.ret = CopyTypeSpec(original.ret, allocator)
            copyFunc.hasVarargs = original.hasVarargs
            copyFunc.genericParams.init(original.genericParams.size(), allocator)
            for(var i = 0; i < original.genericParams.size(); i+=1) {
                var param = original.genericParams.get(i)
                copyFunc.genericParams.add(param)
            }
            return copy;
        }
        default: {
            assert(false)
        }
    }

    return null
}

public func CopyDecl(decl: *Decl, allocator: *const Allocator) : *Decl {
    if(!decl) return null;

    switch(decl.kind) {
        case StmtKind.IMPORT_DECL: {
            assert(false); // don't allow
        }
        case StmtKind.CONST_DECL:
        case StmtKind.VAR_DECL: {
            var original = decl as (*VarDecl)
            var copy = NewVarDecl(original.startPos,
                                  original.endPos,
                                  original.name,
                                  CopyTypeSpec(original.typeSpec, allocator),
                                  CopyExpr(original.expr, allocator),
                                  allocator)
            if(decl.kind == StmtKind.CONST_DECL) {
                copy.kind = StmtKind.CONST_DECL
            }
            return copy
        }
        case StmtKind.STRUCT_DECL:
        case StmtKind.UNION_DECL: {
            return CopyAggregateDecl(decl as (*AggregateDecl), allocator) as (*Decl)
        }
        case StmtKind.ENUM_DECL:
        case StmtKind.FUNC_DECL: {
            return CopyFuncDecl(decl as (*FuncDecl), allocator) as (*Decl)
        }
        case StmtKind.TYPEDEF_DECL: {
            return CopyTypedefDecl(decl as (*TypedefDecl), allocator) as (*Decl)
        }
        case StmtKind.PARAM_DECL: {
            var original = decl as (*ParameterDecl)
            var copy = NewParameterDecl(original.startPos,
                                        original.endPos,
                                        original.name,
                                        CopyTypeSpec(original.type, allocator),
                                        CopyExpr(original.defaultExpr, allocator),
                                        original.attributes.isUsing,
                                        allocator)
            return copy
        }
        case StmtKind.NATIVE_DECL: {
            return decl;
        }
        case StmtKind.POISON_DECL:
            return decl;
        default:
            assert(false)
    }
    return null
}

public func CopyExprs(exprs: *Array<*Expr>, allocator: *const Allocator) : Array<*Expr> {
    if(exprs.empty()) {
        return Array<*Expr>{}
    }
    var result = ArrayInit<*Expr>(exprs.size(), allocator)
    for(var i = 0; i < exprs.size(); i += 1) {
        var copy = CopyExpr(exprs.get(i), allocator)
        result.add(copy)
    }

    return result
}

public func CopyStmts(stmts: *Array<*Stmt>, allocator: *const Allocator) : Array<*Stmt> {
    if(stmts.empty()) {
        return Array<*Stmt>{}
    }
    var result = ArrayInit<*Stmt>(stmts.size(), allocator)
    for(var i = 0; i < stmts.size(); i += 1) {
        var copy = CopyStmt(stmts.get(i), allocator)
        result.add(copy)
    }

    return result
}


public func CopyExpr(expr: *Expr, allocator: *const Allocator) : *Expr {
    if(!expr) return null;

    switch(expr.kind) {
        case StmtKind.ARRAY_DESIGNATION_EXPR: {
            var original = expr as (*ArrayDesignationExpr)
            var copy = NewArrayDesignationExpr(original.startPos,
                                               original.endPos,
                                               CopyExpr(original.index, allocator),
                                               CopyExpr(original.value, allocator),
                                               allocator)
            return copy
        }
        case StmtKind.ARRAY_INIT_EXPR: {
            var original = expr as (*ArrayInitExpr)
            var copy = NewArrayInitExpr(original.startPos,
                                        original.endPos,
                                        CopyTypeSpec(original.type, allocator),
                                        CopyExprs(original.values, allocator),
                                        allocator)
            return copy
        }
        case StmtKind.BINARY_EXPR: {
            var original = expr as (*BinaryExpr)
            var copy = NewBinaryExpr(original.startPos,
                                     original.endPos,
                                     CopyExpr(original.left, allocator),
                                     original.operator,
                                     CopyExpr(original.right, allocator),
                                     allocator)
            return copy
        }
        case StmtKind.BOOLEAN_EXPR: {
            return expr // nothing to copy
        }
        case StmtKind.CAST_EXPR: {
            var original = expr as (*CastExpr)
            var copy = NewCastExpr(original.startPos,
                                   original.endPos,
                                   CopyExpr(original.exprToCast, allocator),
                                   CopyTypeSpec(original.castTo, allocator),
                                   allocator)
            return copy
        }
        case StmtKind.CHAR_EXPR: {
            return expr // nothing to copy
        }
        case StmtKind.FUNC_CALL_EXPR: {
            var original = expr as (*FuncCallExpr)
            var copy = NewFuncCallExpr(original.startPos,
                                       original.endPos,
                                       CopyExpr(original.object, allocator),
                                       CopyExprs(original.arguments, allocator),
                                       CopyTypeSpecs(original.genericArgs, allocator),
                                       allocator)
            return copy
        }
        case StmtKind.FUNC_IDENTIFIER_EXPR: {
            var original = expr as (*IdentifierExpr)
            var copy = NewIdentifierExpr(original.startPos,
                                         original.endPos,
                                         CopyTypeSpec(original.type, allocator) as (*NameTypeSpec),
                                         allocator)
            copy.kind = StmtKind.FUNC_IDENTIFIER_EXPR
            return copy
        }
        case StmtKind.GET_EXPR:{
            var original = expr as (*GetExpr)
            var copy = NewGetExpr(original.startPos,
                                  original.endPos,
                                  CopyExpr(original.object, allocator),
                                  CopyExpr(original.field, allocator) as (*IdentifierExpr),
                                  allocator)
            return copy
        }
        case StmtKind.GROUP_EXPR: {
            var original = expr as (*GroupExpr)
            var copy = NewGroupExpr(original.startPos,
                                    original.endPos,
                                    CopyExpr(original.groupedExpr, allocator),
                                    allocator)
            return copy
        }
        case StmtKind.IDENTIFIER_EXPR: {
            var original = expr as (*IdentifierExpr)
            var copy = NewIdentifierExpr(original.startPos,
                                         original.endPos,
                                         CopyTypeSpec(original.type, allocator) as (*NameTypeSpec),
                                         allocator)
            return copy
        }
        case StmtKind.INIT_ARG_EXPR: {
            var original = expr as (*InitArgExpr)
            var copy = NewInitArgExpr(original.startPos,
                                      original.endPos,
                                      original.fieldName,
                                      original.argPosition,
                                      CopyExpr(original.value, allocator),
                                      allocator)
            return copy
        }
        case StmtKind.INIT_EXPR: {
            var original = expr as (*InitExpr)
            var arguments = Array<*InitArgExpr>{}
            if(!original.arguments.empty()) {
                arguments.init(original.arguments.size(), allocator)
            }

            for(var i = 0; i < original.arguments.size(); i += 1) {
                var copy = CopyExpr(original.arguments.get(i), allocator) as (*InitArgExpr)
                arguments.add(copy)
            }

            var copy = NewInitExpr(original.startPos,
                                   original.endPos,
                                   CopyTypeSpec(original.type, allocator) as (*NameTypeSpec),
                                   arguments,
                                   allocator)
            return copy
        }
        case StmtKind.NULL_EXPR: {
            return expr // nothing to copy
        }
        case StmtKind.NUMBER_EXPR: {
            return expr // nothing to copy
        }
        case StmtKind.SET_EXPR: {
            var original = expr as (*SetExpr)
            var copy = NewSetExpr(original.startPos,
                                  original.endPos,
                                  CopyExpr(original.object, allocator),
                                  CopyExpr(original.field, allocator) as (*IdentifierExpr),
                                  original.operator,
                                  CopyExpr(original.value, allocator),
                                  allocator)
            return copy
        }
        case StmtKind.OFFSET_OF_EXPR: {
            var original = expr as (*OffsetOfExpr)
            var copy = NewOffsetOfExpr(original.startPos,
                                       original.endPos,
                                       CopyTypeSpec(original.type, allocator),
                                       original.field,
                                       allocator)
            return copy
        }
        case StmtKind.SIZE_OF_EXPR: {
            var original = expr as (*SizeOfExpr)
            var copy = NewSizeOfExpr(original.startPos,
                                     original.endPos,
                                     CopyExpr(original.sizeOfExpr, allocator),
                                     allocator)
            return copy
        }
        case StmtKind.STRING_EXPR: {
            return expr // nothing to copy
        }
        case StmtKind.SUBSCRIPT_GET_EXPR: {
            var original = expr as (*SubscriptGetExpr)
            var copy = NewSubscriptGetExpr(original.startPos,
                                           original.endPos,
                                           CopyExpr(original.object, allocator),
                                           CopyExpr(original.index, allocator),
                                           allocator)
            return copy
        }
        case StmtKind.SUBSCRIPT_SET_EXPR: {
            var original = expr as (*SubscriptSetExpr)
            var copy = NewSubscriptSetExpr(original.startPos,
                                           original.endPos,
                                           CopyExpr(original.object, allocator),
                                           CopyExpr(original.index, allocator),
                                           original.operator,
                                           CopyExpr(original.value, allocator),
                                           allocator)
            return copy
        }
        case StmtKind.TERNARY_EXPR: {
            var original = expr as (*TernaryExpr)
            var copy = NewTernaryExpr(original.startPos,
                                      original.endPos,
                                      CopyExpr(original.cond, allocator),
                                      CopyExpr(original.then, allocator),
                                      CopyExpr(original.other, allocator),
                                      allocator)
            return copy
        }
        case StmtKind.TYPE_IDENTIFIER_EXPR: {
            var original = expr as (*TypeIdentifierExpr)
            var copy = NewTypeIdentifierExpr(original.startPos,
                                             original.endPos,
                                             CopyTypeSpec(original.type, allocator),
                                             allocator)
            return copy
        }
        case StmtKind.TYPE_OF_EXPR: {
            var original = expr as (*TypeOfExpr)
            var copy = NewTypeOfExpr(original.startPos,
                                     original.endPos,
                                     CopyExpr(original.typeOfExpr, allocator),
                                     CopyTypeSpec(original.type, allocator),
                                     allocator)
            return copy
        }
        case StmtKind.UNARY_EXPR: {
            var original = expr as (*UnaryExpr)
            var copy = NewUnaryExpr(original.startPos,
                                    original.endPos,
                                    original.operator,
                                    CopyExpr(original.expr, allocator),
                                    allocator)
            return copy
        }
        case StmtKind.POISON_EXPR: {
            return expr
        }
        default: {
            assert(false)
        }
    }
    return null
}

public func CopyStmt(stmt: *Stmt, allocator: *const Allocator) : *Stmt {
    if(!stmt) return null;

    switch(stmt.kind) {
        case StmtKind.BLOCK_STMT: {
            var original = stmt as (*BlockStmt)
            var copy = NewBlockStmt(original.startPos,
                                    original.endPos,
                                    CopyStmts(original.stmts, allocator),
                                    allocator)
            return copy
        }
        case StmtKind.BREAK_STMT: {
            return stmt; // nothing to copy
        }
        case StmtKind.COMP_STMT: {
            var original = stmt as (*CompStmt)
            var copy = NewCompStmt(original.startPos,
                                   original.endPos,
                                   original.type,
                                   original.expr,
                                   CopyStmts(original.body, allocator),
                                   CopyStmt(original.end, allocator) as (*CompStmt),
                                   allocator)
            return copy
        }
        case StmtKind.CONTINUE_STMT: {
            return stmt // nothing to copy
        }
        case StmtKind.DEFER_STMT: {
            var original = stmt as (*DeferStmt)
            var copy = NewDeferStmt(original.startPos,
                                    original.endPos,
                                    CopyStmt(original.deferedStmt, allocator),
                                    allocator)
            return copy
        }
        case StmtKind.DO_WHILE_STMT: {
            var original = stmt as (*DoWhileStmt)
            var copy = NewDoWhileStmt(original.startPos,
                                    original.endPos,
                                    CopyExpr(original.cond, allocator),
                                    CopyStmt(original.body, allocator),
                                    allocator)
            return copy
        }
        case StmtKind.EMPTY_STMT: {
            return stmt; // nothing to copy
        }
        case StmtKind.FOR_STMT: {
            var original = stmt as (*ForStmt)
            var copy = NewForStmt(original.startPos,
                                  original.endPos,
                                  CopyStmt(original.init, allocator),
                                  CopyExpr(original.cond, allocator),
                                  CopyStmt(original.post, allocator),
                                  CopyStmt(original.body, allocator),
                                  allocator)
            return copy
        }
        case StmtKind.FUNC_BODY_STMT: {
            var original = stmt as (*FuncBodyStmt)
            var copy = NewBlockStmt(original.startPos,
                                    original.endPos,
                                    CopyStmts(original.stmts, allocator),
                                    allocator)
            copy.kind = StmtKind.FUNC_BODY_STMT
            return copy
        }
        case StmtKind.GOTO_STMT: {
            return stmt // nothing to copy
        }
        case StmtKind.IF_STMT: {
            var original = stmt as (*IfStmt)
            var copy = NewIfStmt(original.startPos,
                                 original.endPos,
                                 CopyExpr(original.cond, allocator),
                                 CopyStmt(original.then, allocator),
                                 CopyStmt(original.elseStmt, allocator),
                                 allocator)
            return copy
        }
        case StmtKind.LABEL_STMT: {
            return stmt // nothing to copy
        }
        case StmtKind.MODULE_STMT: {
            assert(false); // we shouldn't be copying modules
        }
        case StmtKind.NOTE_STMT: {
            return stmt // nothing to copy
        }
        case StmtKind.PARAMETERS_STMT: {
            var original = stmt as (*ParametersStmt)
            var params = Array<*ParameterDecl>{}
            if(!original.params.empty()) {
                params.init(original.params.size(), allocator)
            }
            for(var i = 0; i < original.params.size(); i += 1) {
                var copy = CopyStmt(original.params.get(i), allocator) as (*ParameterDecl)
                params.add(copy)
            }

            var copy = NewParametersStmt(original.startPos,
                                         original.endPos,
                                         params,
                                         original.isVararg,
                                         allocator)
            return copy
        }
        case StmtKind.RETURN_STMT: {
            var original = stmt as (*ReturnStmt)
            var copy = NewReturnStmt(original.startPos,
                                     original.endPos,
                                     CopyExpr(original.expr, allocator),
                                     allocator)
            return copy
        }
        case StmtKind.SWITCH_CASE_STMT: {
            var original = stmt as (*SwitchCaseStmt)
            var copy = NewSwitchCaseStmt(original.startPos,
                                         original.endPos,
                                        CopyExpr(original.cond, allocator),
                                        CopyStmt(original.body, allocator),
                                        allocator)
            return copy
        }
        case StmtKind.SWITCH_STMT:{
            var original = stmt as (*SwitchStmt)
            var cases = Array<*SwitchCaseStmt>{}
            if(!original.cases.empty()) {
                cases.init(original.cases.size(), allocator)
            }
            for(var i = 0; i < original.cases.size(); i += 1) {
                var copy = CopyStmt(original.cases.get(i), allocator) as (*SwitchCaseStmt)
                cases.add(copy)
            }

            var copy = NewSwitchStmt(original.startPos,
                                     original.endPos,
                                     CopyExpr(original.cond, allocator),
                                     cases,
                                     CopyStmt(original.defaultStmt, allocator),
                                     allocator)
            return copy
        }
        case StmtKind.ENUM_FIELD_DECL:
        case StmtKind.ENUM_FIELD_ENTRY_DECL:
        case StmtKind.STRUCT_FIELD_DECL:
        case StmtKind.UNION_FIELD_DECL:
        case StmtKind.VAR_FIELD_DECL:{
            assert(false) // shouldn't reach here -- handled in CopyAggregateDecl
        }
        case StmtKind.WHILE_STMT: {
            var original = stmt as (*WhileStmt)
            var copy = NewWhileStmt(original.startPos,
                                    original.endPos,
                                    CopyExpr(original.cond, allocator),
                                    CopyStmt(original.body, allocator),
                                    allocator)
            return copy
        }
        default: {
            if(IsExpr(stmt)) {
                return CopyExpr(stmt as (*Expr), allocator) as (*Stmt)
            }
            if(IsDecl(stmt)) {
                return CopyDecl(stmt as (*Decl), allocator) as (*Stmt)
            }

            assert(false)
        }
    }

    return null
}

public func CopyAggregateDecl(decl: *AggregateDecl, allocator: *const Allocator) : *AggregateDecl {
    var copy = NewAggregateDecl(decl.startPos, decl.endPos, decl.kind, decl.name, decl.genericParams, decl.fields, decl.flags, allocator) as (*AggregateDecl)
    copy.fields = Array<FieldStmt>{}
    copy.fields.init(decl.fields.size(), allocator)

    for(var i = 0; i < decl.fields.size(); i+=1) {
        var field = decl.fields.get(i)
        switch(field.kind) {
            case StmtKind.VAR_FIELD_DECL: {
                var o = field.varField
                var varField = NewVarFieldDecl(o.startPos,
                                               o.endPos,
                                               o.name,
                                               CopyTypeSpec(o.type, allocator),
                                               o.attributes,
                                               CopyExpr(o.defaultExpr, allocator),
                                               allocator) as (*VarFieldDecl)

                var copyField = FieldStmt {
                    .kind = StmtKind.VAR_FIELD_DECL,
                    .varField = varField
                }
                copy.fields.add(copyField)
                break;
            }
            case StmtKind.ENUM_FIELD_DECL: {
                var copyField = FieldStmt {
                    .kind = StmtKind.ENUM_FIELD_DECL,
                    .enumField = field.enumField
                }
                copy.fields.add(copyField)
                break;
            }
            case StmtKind.UNION_FIELD_DECL:
            case StmtKind.STRUCT_FIELD_DECL: {
                var aggField = field.aggregateField
                var copyField = FieldStmt {
                    .kind = field.kind,
                    .aggregateField = CopyAggregateDecl(aggField, allocator)
                }
                copy.fields.add(copyField)
                break;
            }
            case StmtKind.POISON_EXPR: {
                break;
            }
            default: {
                assert(false)
            }
        }
    }
    return copy;
}


public func CopyFuncDecl(decl: *FuncDecl, allocator: *const Allocator) : *FuncDecl {
    var copy = NewFuncDecl(decl.startPos,
                           decl.endPos,
                           decl.name,
                           decl.genericParams,
                           CopyParameters(decl.params, allocator),
                           CopyStmt(decl.body, allocator),
                           CopyTypeSpec(decl.returnType, allocator),
                           decl.flags,
                           allocator)
    return copy as (*FuncDecl)
}

public func CopyParameters(params: ParametersStmt, allocator: *const Allocator) : *ParametersStmt {
    var paramDecls = Array<*ParameterDecl>{}
    paramDecls.init(params.params.size(), allocator)

    for(var i = 0; i < params.params.size(); i+=1) {
        var decl = params.params.get(i)
        var copy = NewParameterDecl(decl.startPos,
                                    decl.endPos,
                                    decl.name,
                                    CopyTypeSpec(decl.type, allocator),
                                    CopyExpr(decl.defaultExpr, allocator),
                                    decl.attributes.isUsing, allocator) as (*ParameterDecl)
        paramDecls.add(copy)
    }

    var paramsCopy = NewParametersStmt(params.startPos, params.endPos, paramDecls, params.isVararg, allocator)
    return paramsCopy as (*ParametersStmt)
}


public func CopyTypedefDecl(decl: *TypedefDecl, allocator: *const Allocator) : *TypedefDecl {
    var copy = NewTypedefDecl(decl.startPos, decl.endPos, decl.name, decl.genericParams, CopyTypeSpec(decl.type, allocator), allocator)
    return copy as (*TypedefDecl)
}