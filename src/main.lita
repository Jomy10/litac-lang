import "libc"
import "mem"
import "io"
import "lex"
import "lita"
import "types"
import "ast"
import "ast_print"
import "parser"
import "phase_result"
import "system"
import "array"
import "map"
import "error_codes"
import "module"
import "string"
import "string_view"
import "checker"
import "cgen"

func main(len: i32, args: **char) {
    SystemInit()
    var startTime = SystemTimeMSec()

    var options = LitaOptions{}
    ParseArgs(len, args, &options)

    var lita = LitaInit(&options)
    defer lita.free()

    var root = Parse(lita)
    if(!root) {
        goto report
    }
    
    if(!TypeCheck(lita, root)) {
        goto report
    }

    if(options.checkerOnly) {
        goto report;
    }

    
    if(!GenerateC(lita, root)) {
        goto report;
    }
    
    if(options.cOutputOnly) {
        goto report;
    }

    if(!CompileC(lita, root)) {
        goto report;
    }

    if(options.run) {
        Run(lita)
    }

report:
    if(!lita.result.errors.empty()) {
        printf("Total errors: %d\n", lita.result.errors.size())
        for(var i = 0; i < lita.result.errors.size(); i += 1) {
            PrintError(lita.result.errors.get(i))
            printf("\n")
        }
    }

    var endTime = SystemTimeMSec()
    if(options.showProfileInfo) {
        var allocator: *LinearAllocator = lita.allocator as (*LinearAllocator)

        printf("%-30s %-17s %-6s %-14s %-5s\n", "Segment", "Time", "%", "Mem", "#")
        printf("====================================================================================\n")
        for(var i = 0; i < MetricType.MAX_METRIC_TYPES; i+=1) {
            var metric = &lita.metrics[i]
            printf("%-30s %-15.6f   %-6d %-14zu %-5u\n", 
                MetricTypeAsStr(i), 
                metric.executionTime, 
                0, 
                metric.bytesAllocated, 
                metric.allocationCount)
        }
        printf("\n")
        printf("Total time:         %f\n", endTime - startTime)
        printf("Total memory:       %llu\n", allocator.totalBytesAllocated)
        printf("Total allocations:  %u\n", allocator.totalAllocations)
        printf("Total source lines: %u\n", lita.totalSourceLines)
        printf("\n")
    }
}

func ParseArgs(n: i32, args: **char, options: *LitaOptions) {
    strncpy(options.litaPath, GetEnv("LITAC_HOME"), MAX_PATH)

// TEMP start
    options.checkerOnly = false
    options.cOutputOnly = true
    options.showProfileInfo = true

    //strncpy(options.srcPath, "../test", MAX_PATH) // TEMP
    strncpy(options.inputFile, "../test/test.lita", MAX_PATH) // TEMP
    strncpy(options.outputFile, "test", MAX_PATH) // TEMP
    strncpy(options.outputPath, "../test/output/", MAX_PATH) // TEMP
// TEMP end

    if(n > 1) {
        strncpy(options.inputFile, args[1], MAX_PATH)
    }

    FilePath(options.inputFile, options.srcPath)
    printf("Reading in: '%s'\n", options.inputFile)
    printf("Source Path: '%s'\n", options.srcPath)
}

func FindModulePath(lita: *Lita, 
                    moduleName: StringView, 
                    filename: [MAX_PATH]char) : bool {    

    var pathStr = StringInit(filename, MAX_PATH);
    
    pathStr.format("%s/%.*s.lita", lita.options.srcPath, moduleName.length, moduleName.buffer)
    //printf("Check: '%s'\n", pathStr.cStr())
    if(FileExists(pathStr.cStrConst())) {
        return true
    }
    
    pathStr.format("%s/%.*s.lita", lita.options.libPath, moduleName.length, moduleName.buffer)
    //printf("Check: '%s'\n", pathStr.cStr())
    if(FileExists(pathStr.cStrConst())) {
        return true
    }

    pathStr.format("%s/lib/%.*s.lita", lita.options.litaPath, moduleName.length, moduleName.buffer)
    //printf("Check: '%s'\n", pathStr.cStr())
    if(FileExists(pathStr.cStrConst())) {
        return true
    }

    pathStr.clear()
    return false
}

func ReadModuleText(lita: *Lita, 
                    module: *Module, 
                    pos: SrcPos) : bool {    

    var status = ReadFile(module.id.filename, &module.text, lita.allocator) 
    if(status == FileStatus.FileNotFoundError) {
        lita.result.addError(pos, "Could not open file '%s'\n", module.id.filename)
        return false
    }

    if(status == FileStatus.IOError) {
        lita.result.addError(pos, "Could not read file '%s'\n", module.id.filename)
        return false
    }

    return true
}

func ParseModule(lita: *Lita, 
                 module: *Module,
                 pos: SrcPos) {

    var parser = ParserInit(module.id.filename, module.text, lita)
    var moduleStmt = parser.parseModule()
    module.ast = moduleStmt
    lita.totalSourceLines += parser.totalLines
}

func ParseImport(lita: *Lita, root: *Module) {
    if(!root) {
        return;
    }

    //printf("Parsing Imports for '%s'\n", root.id.filename)

    for(var i = 0; i < root.ast.imports.size(); i += 1) {
        var importStmt = root.ast.imports.get(i)
        if(importStmt.name.type == TokenType.ERROR) {
            lita.result.addError(importStmt.pos, "Could not parse import statement")
            continue
        }

        var filename: [MAX_PATH]char
        if(!FindModulePath(lita, importStmt.name.str, filename)) {  
            lita.result.addError(importStmt.pos, "Could not find module '%.*s'", 
                    importStmt.name.str.length, importStmt.name.str.buffer)
            continue
        }

        var module = lita.modules.get(filename)
        if(module) {
            importStmt.moduleId = &module.id
            continue;
        }        

        //printf("Parsing file: '%s' with error count: %d\n", filename, lita.result.errors.size())
        
        module = NewModule(lita.result, lita.allocator)
        module.id.fromFile(lita, filename)
        importStmt.moduleId = &module.id

        lita.addModule(module)

        if(!ReadModuleText(lita, module, importStmt.pos)) {
            continue
        }

        ParseModule(lita, module, importStmt.pos)
        ParseImport(lita, module)
    }
}

func Parse(lita: *Lita) : *Module {
    lita.startCapture(MetricType.PARSING)
    defer lita.endCapture(MetricType.PARSING)

    var root = NewModule(lita.result, lita.allocator)
    root.id.fromFile(lita, lita.options.inputFile)

    lita.addModule(root)
    
    var pos = SrcPos{}

    if(!ReadModuleText(lita, root, pos)) {
        return null;
    }

    ParseModule(lita, root, pos)
    ParseImport(lita, root)

    return root
}

func TypeCheck(lita: *Lita, module: *Module) : bool {
    BuiltinsInit(lita)

    lita.startCapture(MetricType.TYPE_CHECKING)
    defer lita.endCapture(MetricType.TYPE_CHECKING)

    var checker = TypeChecker{}
    checker.init(lita)

    lita.programSymbols = checker.typeCheck(module)

    return lita.result.errors.empty()
}

func GenerateC(lita: *Lita, module: *Module) : bool {
    lita.startCapture(MetricType.CGEN)
    defer lita.endCapture(MetricType.CGEN)

    var cgen = CGen{}
    cgen.init(lita)
    cgen.emitProgram(module)
    //printf("Generated: \n%s", cgen.buf.cStr())
    
    var filename: [MAX_PATH]char;
    strcat(filename, lita.options.outputPath)
    if(!Mkdir(filename)) {
        printf("Unable to create directory: '%s'", filename)
        return false
    }

    strcat(filename, lita.options.outputFile)
    strcat(filename, ".c")
    
    var status = WriteFile(filename, cgen.buf.cStrConst(), cgen.buf.length)
    if(status != FileStatus.Ok) {
        return false
    }

    return lita.result.errors.empty()
}

func CompileC(lita: *Lita, module: *Module) : bool {
    return lita.result.errors.empty()
}

func Run(lita: *Lita) {

}