import "libc"
import "mem"
import "io"
import "lex"
import "lita"
import "types"
import "ast"
import "ast_new"
import "ast_print"
import "parser"
import "phase_result"
import "system"
import "array"
import "map"
import "error_codes"
import "module"
import "string"
import "string_view"
import "checker"
import "cgen"

func main(len: i32, args: **char) {
    SystemInit()
    var startTime = SystemTimeMSec()

    var options = LitaOptions{}
    ParseArgs(len, args, &options)

    var lita = LitaInit(&options)
    defer lita.free()

    var root = Parse(lita)
    if(!root) {
        goto report
    }
    
    if(!TypeCheck(lita, root)) {
        goto report
    }

    if(options.checkerOnly) {
        goto report;
    }
    
    if(!Transpile(lita, root)) {
        goto report;
    }

report:
    if(!lita.result.errors.empty()) {
        printf("Total errors: %d\n", lita.result.errors.size())
        for(var i = 0; i < lita.result.errors.size(); i += 1) {
            PrintError(lita.result.errors.get(i))
            printf("\n")
        }
    }

    var endTime = SystemTimeMSec()
    if(options.showProfileInfo) {
        var allocator: *LinearAllocator = lita.allocator as (*LinearAllocator)

        printf("%-30s %-17s %-6s %-14s %-5s\n", "Segment", "Time", "%", "Mem", "#")
        printf("====================================================================================\n")
        for(var i = 0; i < MetricType.MAX_METRIC_TYPES; i+=1) {
            var metric = &lita.metrics[i]
            printf("%-30s %-15.6f   %-6d %-14zu %-5u\n", 
                MetricTypeAsStr(i), 
                metric.executionTime, 
                0, 
                metric.bytesAllocated, 
                metric.allocationCount)
        }
        printf("\n")
        printf("Total time:         %f\n", endTime - startTime)
        printf("Total memory:       %llu\n", allocator.totalBytesAllocated)
        printf("Total allocations:  %u\n", allocator.totalAllocations)
        printf("Total source lines: %u\n", lita.totalSourceLines)
        printf("\n")
    }
}

func ParseArgs(n: i32, args: **char, options: *LitaOptions) {
    strncpy(options.litaPath, GetEnv("LITAC_HOME"), MAX_PATH)

// TEMP start
    options.checkerOnly = false
    options.cOutputOnly = false
    options.showProfileInfo = true
    options.run = true

    //strncpy(options.srcPath, "../test", MAX_PATH) // TEMP
    strncpy(options.inputFile, "../test/test2.lita", MAX_PATH) // TEMP
    strncpy(options.outputFile, "test.exe", MAX_PATH) // TEMP
    strncpy(options.outputPath, "../test/output/", MAX_PATH) // TEMP
// TEMP end

    if(n > 1) {
        strncpy(options.inputFile, args[1], MAX_PATH)
    }

    FilePath(options.inputFile, options.srcPath)
    //printf("Reading in: '%s'\n", options.inputFile)
    //printf("Source Path: '%s'\n", options.srcPath)
}

func FindModulePath(lita: *Lita, 
                    moduleName: StringView, 
                    filename: [MAX_PATH]char) : bool {    

    var pathStr = StringInit(filename, MAX_PATH);
    
    pathStr.format("%s/%.*s.lita", lita.options.srcPath, moduleName.length, moduleName.buffer)
    //printf("Check: '%s'\n", pathStr.cStr())
    if(FileExists(pathStr.cStrConst())) {
        return true
    }
    
    pathStr.format("%s/%.*s.lita", lita.options.libPath, moduleName.length, moduleName.buffer)
    //printf("Check: '%s'\n", pathStr.cStr())
    if(FileExists(pathStr.cStrConst())) {
        return true
    }

    pathStr.format("%s/lib/%.*s.lita", lita.options.litaPath, moduleName.length, moduleName.buffer)
    //printf("Check: '%s'\n", pathStr.cStr())
    if(FileExists(pathStr.cStrConst())) {
        return true
    }

    pathStr.clear()
    return false
}

func ParseModule(lita: *Lita, module: *Module, pos: SrcPos) : bool {
    if(!module) {
        return false
    }

    var status = ReadFile(module.id.filename, &module.text, lita.allocator) 
    if(status == FileStatus.FileNotFoundError) {
        lita.result.addError(pos, "Could not open file '%s'\n", module.id.filename)
        return false
    }

    if(status == FileStatus.IOError) {
        lita.result.addError(pos, "Could not read file '%s'\n", module.id.filename)
        return false
    }

    var parser = ParserInit(module.id.filename, module.text, lita)
    var moduleStmt = parser.parseModule()
    module.ast = moduleStmt
    lita.totalSourceLines += parser.totalLines

    for(var i = 0; i < module.ast.imports.size(); i += 1) {
        var importStmt = module.ast.imports.get(i)
        if(importStmt.name.type == TokenType.ERROR) {
            lita.result.addError(importStmt.pos, "Could not parse import statement")
            continue
        }

        var filename: [MAX_PATH]char
        if(!FindModulePath(lita, importStmt.name.str, filename)) {  
            lita.result.addError(importStmt.pos, "Could not find module '%.*s'", 
                    importStmt.name.str.length, importStmt.name.str.buffer)
            continue
        }

        var importModule = lita.modules.get(filename)
        if(importModule) {
            importStmt.moduleId = &importModule.id
            continue;
        }        

        importModule = NewModule(lita, filename)
        importStmt.moduleId = &importModule.id

        lita.addModule(importModule)

        ParseModule(lita, importModule, importStmt.pos)
    }

    return true
}

func Parse(lita: *Lita) : *Module {
    lita.startCapture(MetricType.PARSING)
    defer lita.endCapture(MetricType.PARSING)

    var builtin = BuiltinsInit(lita)
    lita.addModule(builtin)

    if(!ParseModule(lita, builtin, SrcPos{})) {
        lita.result.addError(SrcPos{}, "unable to parse builtins.lita")
        return null;
    }
    
    var root = NewModule(lita, lita.options.inputFile)
    lita.addModule(root)
    
    if(!ParseModule(lita, root, SrcPos{})) {
        return null;
    }

    var builtinImport = NewImportDecl(SrcPos{}, SrcPos{}, BUILTIN_IMPORT_TOKEN, Token{.type = TokenType.VOID}, false, lita.allocator) as (*ImportDecl)
    root.ast.imports.add(builtinImport)

    return root
}

func TypeCheck(lita: *Lita, module: *Module) : bool {
    lita.startCapture(MetricType.TYPE_CHECKING)
    defer lita.endCapture(MetricType.TYPE_CHECKING)

    var checker = TypeChecker{}
    checker.init(lita)

    lita.programSymbols = checker.typeCheck(module)

    return lita.result.errors.empty()
}

func Transpile(lita: *Lita, module: *Module) : bool {
    var filename: [MAX_PATH]char;
    strcat(filename, lita.options.outputPath)
    if(!Mkdir(filename)) {
        printf("Unable to create directory: '%s'", filename)
        return false
    }

    strcat(filename, lita.options.outputFile)
    strcat(filename, ".c")

    if(!GenerateC(lita, module, filename)) {
        return false
    }

    if(lita.options.cOutputOnly) {
        return false
    }

    if(!CompileC(lita, module, filename)) {
        return false
    }

    if(lita.options.run) {
        Run(lita, lita.options.outputFile)
    }

    return true
}

func GenerateC(lita: *Lita, module: *Module, filename: *const char) : bool {
    lita.startCapture(MetricType.CGEN)
    defer lita.endCapture(MetricType.CGEN)

    var cgen = CGen{}
    cgen.init(lita)
    cgen.emitProgram(module)
    
    var status = WriteFile(filename, cgen.buf.cStrConst(), cgen.buf.length)
    if(status != FileStatus.Ok) {
        return false
    }

    return lita.result.errors.empty()
}

func CompileC(lita: *Lita, module: *Module, filename: *const char) : bool {
    var command: [512]char;
    var commandStr = StringInit(command, 512)
    commandStr.format("clang -o \"%s\" \"%s\" -D_CRT_SECURE_NO_WARNINGS", lita.options.outputFile, filename)
    if(system(commandStr.cStrConst()) == 0) {
        return true
    }
    return false
}

func Run(lita: *Lita, filename: *const char) {
    system(filename)
}