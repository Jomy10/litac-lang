import "types"
import "types_new"
import "symbols"
import "phase_result"
import "module"
import "ast"
import "lex"
import "state"
import "map"
import "string_buffer"
import "array"
import "assert"

import "ast_print"
import "libc"

import "checker"

public func (this: *TypeChecker) resolveConstExpr(expr: *Expr) : bool {
    if(!this.resolveExpr(expr)) {
        return false
    }

    if(!expr.operand.isConst) {
        this.result.addError(expr.startPos, "expected a constant expression")
        return false;
    }
    return true
}

public func (this: *TypeChecker) resolveExpr(expr: *Expr) : bool {
    if(!expr) return false

    switch(expr.kind) {
        case StmtKind.ARRAY_DESIGNATION_EXPR: {
            return this.resolveArrayDesignationExpr(expr as (*ArrayDesignationExpr))
        }
        case StmtKind.ARRAY_INIT_EXPR: {
            return this.resolveArrayInitExpr(expr as (*ArrayInitExpr))
        }
        case StmtKind.BINARY_EXPR: {
            return this.resolveBinaryExpr(expr as (*BinaryExpr))
        }
        case StmtKind.BOOLEAN_EXPR: {
            expr.operand.typeInfo = &BOOL_TYPE
            expr.operand.isConst = true
            expr.operand.isLeftValue = false
            //expr.operand.val = (expr as (*BooleanExpr)).string TODO
            return true
        }
        case StmtKind.CAST_EXPR: {
            return this.resolveCastExpr(expr as (*CastExpr))
        }
        case StmtKind.CHAR_EXPR: {
            expr.operand.typeInfo = &CHAR_TYPE
            expr.operand.isConst = true
            expr.operand.isLeftValue = false
            expr.operand.val = (expr as (*CharExpr)).character
            return true
        }
        case StmtKind.FUNC_CALL_EXPR:
        case StmtKind.FUNC_IDENTIFIER_EXPR:
        case StmtKind.GET_EXPR:
        case StmtKind.GROUP_EXPR:
        case StmtKind.IDENTIFIER_EXPR: {
            return this.resolveIdentiferExpr(expr as (*IdentifierExpr))            
        }
        case StmtKind.INIT_EXPR:
        case StmtKind.INIT_ARG_EXPR:
        case StmtKind.NULL_EXPR: {
            expr.operand.typeInfo = &NULL_TYPE
            expr.operand.isConst = true
            expr.operand.isLeftValue = false            
            return true
        }
        case StmtKind.NUMBER_EXPR: {
            var numberExpr = (expr as (*NumberExpr))
            expr.operand.typeInfo = numberExpr.number.typeInfo
            expr.operand.isConst = true
            expr.operand.isLeftValue = false
            expr.operand.val = numberExpr.number
            return true
        }
        case StmtKind.OFFSET_OF_EXPR:
        case StmtKind.SET_EXPR: 
        case StmtKind.SIZE_OF_EXPR:
        case StmtKind.STRING_EXPR: {
            expr.operand.typeInfo = &STR_TYPE
            expr.operand.isConst = true
            expr.operand.isLeftValue = false
            expr.operand.val = (expr as (*StringExpr)).string
            return true
        }
        case StmtKind.SUBSCRIPT_GET_EXPR:
        case StmtKind.SUBSCRIPT_SET_EXPR:
        case StmtKind.TERNARY_EXPR:
        case StmtKind.TYPE_IDENTIFIER_EXPR:
        case StmtKind.TYPE_OF_EXPR:
        case StmtKind.UNARY_EXPR:
        case StmtKind.POISON_EXPR: {
            break;
        }
        default: {
            PrintStmt(expr as (*Stmt))
            assert(false)
        }
    }
    return false
}

func (this: *TypeChecker) resolveCastExpr(expr: *CastExpr) : bool {
    assert(expr != null)

    var typeInfo = this.resolveTypeSpec(expr.castTo)
    if(!typeInfo) {
        return false
    }

    if(!this.resolveExpr(expr.exprToCast)) {
        return false
    }

    expr.operand.typeInfo = typeInfo

    if(!this.checkCastability(expr.startPos, expr.expr.operand.typeInfo, typeInfo)) {
        return false
    }

    return true
}


func (this: *TypeChecker) resolveArrayDesignationExpr(expr: *ArrayDesignationExpr) : bool {
    assert(expr != null)

    if(!this.resolveExpr(expr.index)) {
        return false
    }

    if(!this.resolveExpr(expr.value)) {
        return false
    }

    if(!expr.index.isConstNumberExpr()) {
        this.result.addError(expr.index.startPos, "array designation must be indexed by a number")
        return false
    }

    if(expr.index.kind == StmtKind.IDENTIFIER_EXPR) {
        var idExpr = expr.index as (*IdentifierExpr)
        if(idExpr.sym != null && !(idExpr.sym.flags & SymbolFlags.IS_CONSTANT)) {
            this.result.addError(expr.index.startPos, "'%s' must be a constant", idExpr.sym.name)
            return false
        }
    }
    
    if(!this.checkTypeCompatibility(expr.startPos, &USIZE_TYPE, expr.index.operand.typeInfo)) {
        return false
    }

    expr.operand = expr.value.operand
    return true
}

func (this: *TypeChecker) resolveArrayInitExpr(expr: *ArrayInitExpr) : bool {
    assert(expr != null)

    var typeInfo = this.resolveTypeSpec(expr.type)
    if(!typeInfo) {
        return false
    }

    expr.operand.typeInfo = typeInfo
    expr.operand.isLeftValue = false

    assert(typeInfo.kind == TypeKind.ARRAY)

    var arrayInfo = typeInfo as (*ArrayTypeInfo)
    var arrayOf = arrayInfo.arrayOf

    if(!expr.values.empty()) {
        if(!arrayInfo.numOfElements && !arrayInfo.length) {
            arrayInfo.length = expr.values.size()
        }

        var hasFailed = false
        for(var i = 0; i < expr.values.size(); i += 1) {
            var value = expr.values.get(i)
            value.expectedType = arrayOf

            if(!this.resolveExpr(value)) {
                hasFailed = true
            }

            if(value.operand.typeInfo) {
                this.checkTypeCompatibility(value.startPos, arrayOf, value.operand.typeInfo)
            }
        }

        return hasFailed
    }

    return true
}

func (this: *TypeChecker) resolveBinaryExpr(expr: *BinaryExpr) : bool {
    assert(expr != null)

    if(!this.resolveExpr(expr.left)) {
        goto err;
    }

    if(!this.resolveExpr(expr.right)) {
        goto err;
    }

    var leftType = expr.left.operand.typeInfo
    var rightType = expr.right.operand.typeInfo

    var targetType = leftType

    switch(expr.operator) {
        case TokenType.EQUALS: {
            this.checkConstant(expr.left)
            this.checkAssignability(expr.right.startPos, leftType, rightType)
            this.checkRightValue(expr.left)
            break;
        }
        case TokenType.BAND_EQ:
        case TokenType.BNOT_EQ:
        case TokenType.BOR_EQ:
        case TokenType.XOR_EQ:
        case TokenType.LSHIFT_EQ:
        case TokenType.RSHIFT_EQ: 
            this.checkConstant(expr.left)
            this.checkAssignability(expr.right.startPos, leftType, rightType)
            this.checkRightValue(expr.left)
            // fallthru
        case TokenType.BAND:
        case TokenType.BNOT:
        case TokenType.BOR:
        case TokenType.XOR:
        case TokenType.LSHIFT:
        case TokenType.RSHIFT: {
            if(!IsInteger(leftType)) {
                this.errorOperand(expr.left, leftType, "left")
            }
            
            if(!IsInteger(rightType)) {
                this.errorOperand(expr.right, rightType, "right")
            }
            break;
        }
        case TokenType.AND:
        case TokenType.OR: {
            this.checkTruthyness(expr.left, leftType)
            this.checkTruthyness(expr.right, rightType)
            targetType = &BOOL_TYPE
            break;
        }
        case TokenType.EQUALS_EQUALS:
        case TokenType.NOT_EQUALS: {
            this.checkTruthyness(expr.left, leftType)
            this.checkTruthyness(expr.right, rightType)
            targetType = &BOOL_TYPE
            break;
        }
        case TokenType.GREATER_EQUALS:
        case TokenType.GREATER_THAN:
        case TokenType.LESS_EQUALS:
        case TokenType.LESS_THAN: {
            if(!IsNumberLike(leftType)) {
                this.errorOperand(expr.left, leftType, "left")
            }
            
            if(!IsNumberLike(rightType)) {
                this.errorOperand(expr.right, rightType, "right")
            }
            targetType = &BOOL_TYPE;
            break;
        }
        case TokenType.MINUS_EQ:
        case TokenType.PLUS_EQ:
        case TokenType.MOD_EQ:
        case TokenType.MUL_EQ:
        case TokenType.DIV_EQ:
            this.checkConstant(expr.left)
            this.checkAssignability(expr.right.startPos, leftType, rightType)
            // fallthru
        case TokenType.MINUS:
        case TokenType.PLUS:
        case TokenType.MOD:
        case TokenType.STAR:
        case TokenType.SLASH: {
            if(!IsNumberLike(leftType)) {
                this.errorOperand(expr.left, leftType, "left")
            }
            
            if(!IsNumberLike(rightType)) {
                this.errorOperand(expr.right, rightType, "right")
            }
            break;
        }
        default: {
            assert(false)
        }
    }

    expr.operand.typeInfo = targetType
    expr.operand.isConst = expr.left.operand.isConst && 
                           expr.right.operand.isConst

err:
    return false    
}

func (this: *TypeChecker) errorOperand(expr: *Expr, type: *TypeInfo, side: *const char) {
    assert(expr != null)
    assert(type != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.append("illegal, %s operand has type '", side)
    type.toString(sb)
    sb.append("'")

    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) checkConstant(expr: *Expr) {
    assert(expr != null)

    var sym: *Symbol = null
    if(expr.kind == StmtKind.IDENTIFIER_EXPR) {
        var idExpr = expr as (*IdentifierExpr)
        sym = idExpr.sym        
    }

    if(!sym) {
        if(!expr.operand.typeInfo) {
            return;
        }

        sym = expr.operand.typeInfo.sym
        if(!sym) {
            return;
        }
    }
    
    if(sym.flags & SymbolFlags.IS_CONSTANT) {
       this.result.addError(expr.startPos, "can't reassign constant variable '%s'", sym.name)       
    }
}

func (this: *TypeChecker) checkTruthyness(expr: *Expr, type: *TypeInfo) {
    assert(expr != null)
    assert(type != null)

    if(!IsBooleanable(type)) {
        var sb = StringBufferInit(256, this.allocator)
        sb.append("'")
        type.toString(sb)
        sb.append("' can't be coerced to boolean")

        this.result.addErrorStr(expr.startPos, sb)
    }
}

func (this: *TypeChecker) checkRightValue(expr: *Expr) {
    assert(expr != null)    
    if(!expr.operand.isLeftValue) {        
        this.result.addError(expr.startPos, "rvalue can't be assigned to")
    }
}

func (this: *TypeChecker) resolveIdentiferExpr(expr: *IdentifierExpr) : bool {
    assert(expr != null)

    var sym = this.currentScope.lookup(expr.type.name)
    if(!sym) {
        this.result.addError(expr.startPos, "unknown variable '%s'", expr.type.name)
        return false
    }

    expr.operand.typeInfo = sym.type
    expr.operand.isConst = sym.flags & SymbolFlags.IS_CONSTANT
    expr.sym = sym
    return true;
}