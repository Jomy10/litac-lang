import "types"
import "types_new"
import "symbols"
import "phase_result"
import "module"
import "ast"
import "ast_new"
import "lex"
import "lita"
import "map"
import "string_buffer"
import "string_view"
import "string"
import "array"
import "checker"
import "assert"

import "ast_print"
import "libc"
import "error_codes"



public func (this: *TypeChecker) resolveConstExpr(expr: *Expr) : bool {
    if(!this.resolveExpr(expr)) {
        return false
    }

    if(!expr.operand.isConst) {
        this.result.addError(expr.startPos, "expected a constant expression")
        return false;
    }
    return true
}

public func (this: *TypeChecker) resolveExpr(expr: *Expr) : bool {
    if(!expr) return false

    switch(expr.kind) {
        case StmtKind.ARRAY_DESIGNATION_EXPR: {
            return this.resolveArrayDesignationExpr(expr as (*ArrayDesignationExpr))
        }
        case StmtKind.ARRAY_INIT_EXPR: {
            return this.resolveArrayInitExpr(expr as (*ArrayInitExpr))
        }
        case StmtKind.BINARY_EXPR: {
            return this.resolveBinaryExpr(expr as (*BinaryExpr))
        }
        case StmtKind.BOOLEAN_EXPR: {
            return this.resolveBooleanExpr(expr as (*BooleanExpr))
        }
        case StmtKind.CAST_EXPR: {
            return this.resolveCastExpr(expr as (*CastExpr))
        }
        case StmtKind.CHAR_EXPR: {
            return this.resolveCharExpr(expr as (*CharExpr))
        }
        case StmtKind.FUNC_CALL_EXPR: {
            return this.resolveFuncCallExpr(expr as (*FuncCallExpr))
        }
        case StmtKind.FUNC_IDENTIFIER_EXPR: {
            return this.resolveFuncIdentifierExpr(expr as (*IdentifierExpr))
        }
        case StmtKind.GET_EXPR:{
            return this.resolveGetExpr(expr as (*GetExpr))
        }
        case StmtKind.GROUP_EXPR: {
            return this.resolveGroupExpr(expr as (*GroupExpr))
        }
        case StmtKind.IDENTIFIER_EXPR: {
            return this.resolveIdentiferExpr(expr as (*IdentifierExpr))
        }
        case StmtKind.INIT_ARG_EXPR: {
            return this.resolveInitArgExpr(expr as (*InitArgExpr))
        }
        case StmtKind.INIT_EXPR: {
            return this.resolveInitExpr(expr as (*InitExpr))
        }
        case StmtKind.NULL_EXPR: {
            return this.resolveNullExpr(expr as (*NullExpr))
        }
        case StmtKind.NUMBER_EXPR: {
            return this.resolveNumberExpr(expr as (*NumberExpr))
        }
        case StmtKind.SET_EXPR: {
            return this.resolveSetExpr(expr as (*SetExpr))
        }
        case StmtKind.OFFSET_OF_EXPR: {
            return this.resolveOffsetOfExpr(expr as (*OffsetOfExpr))
        }
        case StmtKind.SIZE_OF_EXPR: {
            return this.resolveSizeOfExpr(expr as (*SizeOfExpr))
        }
        case StmtKind.STRING_EXPR: {            
            return this.resolveStringExpr(expr as (*StringExpr))
        }
        case StmtKind.SUBSCRIPT_GET_EXPR: {
            return this.resolveSubscriptGetExpr(expr as (*SubscriptGetExpr))
        }
        case StmtKind.SUBSCRIPT_SET_EXPR: {
            return this.resolveSubscriptSetExpr(expr as (*SubscriptSetExpr))
        }
        case StmtKind.TERNARY_EXPR: {
            return this.resolveTernaryExpr(expr as (*TernaryExpr))
        }
        case StmtKind.TYPE_IDENTIFIER_EXPR: {
            return this.resolveTypeIdentifierExpr(expr as (*TypeIdentifierExpr))
        }
        case StmtKind.TYPE_OF_EXPR: {
            return this.resolveTypeOfExpr(expr as (*TypeOfExpr))
        }
        case StmtKind.UNARY_EXPR: {
            return this.resolveUnaryExpr(expr as (*UnaryExpr))
        }
        case StmtKind.POISON_EXPR: {
            return false
        }
        default: {
            PrintStmt(expr as (*Stmt))
            assert(false)
        }
    }
    return false
}


func (this: *TypeChecker) resolveFuncIdentifierExpr(expr: *IdentifierExpr) : bool {
    assert(expr != null)
    var type = this.resolveTypeSpec(expr.type)
    if(!type) {
        this.result.addError(expr.startPos, "unknown function '%s'", expr.type.name)
        return false
    }

    var sym = type.sym
    if(type.kind == TypeKind.FUNC_PTR) {
        var funcSym = this.current.getType(expr.type.name)
        if(funcSym && funcSym.type && funcSym.type.kind == TypeKind.FUNC_PTR) {
            sym = funcSym
        }
    }

    if(!sym) {
        this.result.addError(expr.startPos, "unknown function '%s'", expr.type.name)
        return false
    }

    expr.operand.typeInfo = sym.type
    expr.operand.isRightValue = true
    expr.sym = sym
    return true
}

func (this: *TypeChecker) isMethodSyntax(expr: *FuncCallExpr, funcPtr: *FuncPtrTypeInfo, suppliedArgs: *Array<*Expr>) : bool {    
    assert(expr != null)
    if(expr.object.kind != StmtKind.GET_EXPR) {
        return false
    }

    var getExpr = expr.object as (*GetExpr)
    if(getExpr.field.operand.typeInfo.kind != TypeKind.FUNC) {
        return false
    }

    suppliedArgs.insertAt(0, getExpr.object)    
    return true
}

func (this: *TypeChecker) coerceFuncArgs(expr: *FuncCallExpr, 
                                         funcPtr: *FuncPtrTypeInfo, 
                                         suppliedArgs: *Array<*Expr>) : bool {

    
    for(var i = 0; i < funcPtr.paramDecls.size() && i < suppliedArgs.size(); i += 1) {
        var argExpr = suppliedArgs.get(i)
        if(!this.resolveExpr(argExpr)) {
            return false
        }

        var paramInfo = funcPtr.paramDecls.get(i)
        var argInfo = argExpr.operand.typeInfo

        if(argInfo.kind == TypeKind.ARRAY) {
            continue
        }

        if(!IsAggregateLike(argInfo)) {
            continue
        }

        if(!IsAggregateLike(paramInfo)) {
            continue
        }

        var argAggInfo = argInfo.getBaseType() as (*AggregateTypeInfo)
        var paramAggInfo = paramInfo.getBaseType() as (*AggregateTypeInfo)

        // coerce any arguments that match via using fields
        if(argAggInfo.typeid != paramAggInfo.typeid) {
            var path = FieldPath{}
            if(!argAggInfo.getFieldPathByType(paramAggInfo, &path)) {
                continue
            }

            for(var i = 0; i < path.numOfFields; i+=1) {
                var field = path.fields[i]
                assert(field.kind == StmtKind.VAR_FIELD_DECL)

                var name = this.allocator.alloc((field.varField.name.str.length + 1) * sizeof(:char)) as (*char)
                field.varField.name.str.copyTo(name, field.varField.name.str.length)

                var nameTypeSpec = NewNameTypeSpec(argExpr.startPos, name, this.allocator)
                var idExpr = NewIdentifierExpr(argExpr.startPos, argExpr.endPos, nameTypeSpec, this.allocator) as (*IdentifierExpr)
                argExpr = NewGetExpr(argExpr.startPos, argExpr.endPos, argExpr, idExpr, this.allocator)
            }

            if(!this.resolveExpr(argExpr)) {
                return false
            }

            argInfo = argExpr.operand.typeInfo
        }
        

        // promote the argument to a pointer
        if(IsPtrAggregate(paramInfo) && (!IsPtrAggregate(argInfo) && argInfo.kind != TypeKind.NULL)) {
            // can't take the address of a right value
            if(argExpr.operand.isRightValue) {
                continue
            }

            var groupExpr = NewGroupExpr(argExpr.startPos, argExpr.endPos, argExpr, this.allocator)
            argExpr = NewUnaryExpr(argExpr.startPos, argExpr.endPos, TokenType.BAND, groupExpr, this.allocator)
            if(!this.resolveExpr(argExpr)) {
                return false
            }
        }
        else if(IsAggregate(paramInfo) && IsPtrAggregate(argInfo)) {
            var groupExpr = NewGroupExpr(argExpr.startPos, argExpr.endPos, argExpr, this.allocator)
            argExpr = NewUnaryExpr(argExpr.startPos, argExpr.endPos, TokenType.STAR, groupExpr, this.allocator)
            if(!this.resolveExpr(argExpr)) {
                return false
            }
        }

        expr.node.becomeParentOf(argExpr)
        suppliedArgs.set(i, argExpr)
    }

    return true
}

func (this: *TypeChecker) checkNumberOfArgs(expr: *FuncCallExpr, 
                                            funcName: *const char, 
                                            funcPtr: *FuncPtrTypeInfo, 
                                            numberOfSuppliedArgs: i32,
                                            numberOfDefaultArgs: i32) : bool {
    assert(expr != null)

    var maxNumOfArgs = funcPtr.paramDecls.size()
    if(maxNumOfArgs == numberOfSuppliedArgs) {
        return true
    }

    var minNumOfArgs = maxNumOfArgs - numberOfDefaultArgs
    if(numberOfSuppliedArgs == minNumOfArgs) {
        return true
    }
    if(minNumOfArgs > numberOfSuppliedArgs) {
        this.result.addError(expr.startPos, "'%s' called with too few arguments", funcName)
        return false
    }

    if(funcPtr.hasVarargs) {
        return true
    }

    if(maxNumOfArgs < numberOfSuppliedArgs) {
        this.result.addError(expr.startPos, "'%s' called with too many arguments", funcName)
        return false
    }

    return true
}

func (this: *TypeChecker) resolveFuncCallExpr(expr: *FuncCallExpr) : bool {
    assert(expr != null)

    if(!this.resolveExpr(expr.object)) {
        return false
    }

    var objectType = expr.object.operand.typeInfo
    if(!IsFuncLike(objectType)){
        this.errorNonFuncType(expr.object, objectType)
        return false
    }

    var isMethod = false
    var numberOfDefaultArgs = 0
    var suppliedArgs = Array<*Expr>{}
    suppliedArgs.init(expr.arguments.size() + 1, this.allocator)
    suppliedArgs.addAll(expr.arguments)

    var funcPtr: *FuncPtrTypeInfo = null

    if(objectType.kind == TypeKind.FUNC) {
        var funcInfo = objectType as (*FuncTypeInfo)
        isMethod = funcInfo.decl.flags & FuncFlags.IS_METHOD
        funcPtr = funcInfo.asPtr(this.allocator)

        for(var i = 0; i < funcInfo.decl.params.size(); i += 1) {
            var p = funcInfo.decl.params.get(i)
            if(p.defaultExpr) {
                numberOfDefaultArgs += 1
            }
        }
    }
    else {
        funcPtr = objectType as (*FuncPtrTypeInfo)
    }

    var isMethodCall = isMethod && this.isMethodSyntax(expr, funcPtr, &suppliedArgs)
    var numberOfSuppliedArgs = suppliedArgs.size()
    this.checkNumberOfArgs(expr, objectType.name, funcPtr, numberOfSuppliedArgs, numberOfDefaultArgs)

    if(!this.coerceFuncArgs(expr, funcPtr, suppliedArgs)) {
        return false
    }

    var i = 0;
    for(; i < funcPtr.paramDecls.size(); i+=1) {
        var p = funcPtr.paramDecls.get(i)
        if(i < numberOfSuppliedArgs) {
            var arg = suppliedArgs.get(i)
            if(!this.resolveExpr(arg)) {
                return false
            }

            this.checkTypeCompatibility(arg.startPos, p, arg.operand.typeInfo)
            arg.expectedType = p;
        }
    }

    if(funcPtr.hasVarargs) {
        for(; i < numberOfSuppliedArgs; i+=1) {
            var arg = suppliedArgs.get(i)
            if(!this.resolveExpr(arg)) {
                return false
            }
        }
    }

    expr.arguments = *expr.node.becomeParentOfChildren(suppliedArgs)
    expr.operand.typeInfo = funcPtr.returnType
    expr.operand.isRightValue = true
    return true
}

func (this: *TypeChecker) resolveBooleanExpr(expr: *BooleanExpr) : bool {
    assert(expr != null)
    expr.operand.typeInfo = &BOOL_TYPE
    expr.operand.isConst = true
    expr.operand.isRightValue = true
    expr.operand.val.intValue = expr.boolean
    return true
}

func (this: *TypeChecker) resolveCharExpr(expr: *CharExpr) : bool {
    assert(expr != null)
    expr.operand.typeInfo = &CHAR_TYPE
    expr.operand.isConst = true
    expr.operand.isRightValue = true
    expr.operand.val = expr.character.value
    return true
}

func (this: *TypeChecker) resolveNullExpr(expr: *NullExpr) : bool {
    assert(expr != null)
    expr.operand.typeInfo = &NULL_TYPE
    expr.operand.isConst = true
    expr.operand.isRightValue = true
    return true
}

func (this: *TypeChecker) resolveNumberExpr(expr: *NumberExpr) : bool {
    assert(expr != null)
    expr.operand.typeInfo = expr.number.typeInfo
    expr.operand.isConst = true
    expr.operand.isRightValue = true
    expr.operand.val = expr.number.value
    return true
}

func (this: *TypeChecker) resolveStringExpr(expr: *StringExpr) : bool {
    assert(expr != null)
    expr.operand.typeInfo = &STR_TYPE
    expr.operand.isConst = true
    expr.operand.isRightValue = true
    expr.operand.val = expr.string.value
    return true
}

func (this: *TypeChecker) resolveSubscriptSetExpr(expr: *SubscriptSetExpr) : bool {
    assert(expr != null)

    if(!this.resolveExpr(expr.object)) {
        return false
    }

    if(!this.resolveExpr(expr.index)) {
        return false
    }

    if(!this.resolveExpr(expr.value)) {
        return false
    }

    var baseObj: *TypeInfo = null

    var objectType = expr.object.operand.typeInfo
    switch(objectType.kind) {
        case TypeKind.STR: {
            this.errorSetIndexingConstType(expr.object, objectType)
            return false
        }
        case TypeKind.PTR: {
            var ptrInfo = objectType as (*PtrTypeInfo)
            baseObj = ptrInfo.ptrOf
            break;
        }
        case TypeKind.ARRAY: {
            var arrayInfo = objectType as (*ArrayTypeInfo)
            baseObj = arrayInfo.arrayOf
            break;
        }
        default: {
            this.errorNonIndexableType(expr.object, objectType)
            return false
        }
    }

    if(baseObj.kind == TypeKind.CONST) {
        this.errorSetIndexingConstType(expr.object, objectType)
        return false
    }

    var indexType = expr.index.operand.typeInfo
    if(!IsInteger(indexType)) {
        this.errorIndexType(expr.index, indexType)
    }

    this.checkTypeCompatibility(expr.value.startPos, baseObj, expr.value.operand.typeInfo)
    expr.operand.typeInfo = expr.value.operand.typeInfo
    return true
}


func (this: *TypeChecker) resolveSubscriptGetExpr(expr: *SubscriptGetExpr) : bool {
    assert(expr != null)

    if(!this.resolveExpr(expr.object)) {
        return false
    }

    if(!this.resolveExpr(expr.index)) {
        return false
    }

    var baseObj: *TypeInfo = null

    var objectType = expr.object.operand.typeInfo    
    switch(objectType.kind) {
        case TypeKind.STR: {
            baseObj = &CHAR_TYPE
            break;
        }
        case TypeKind.PTR: {
            var ptrInfo = objectType as (*PtrTypeInfo)
            baseObj = ptrInfo.ptrOf
            break;
        }
        case TypeKind.ARRAY: {
            var arrayInfo = objectType as (*ArrayTypeInfo)
            baseObj = arrayInfo.arrayOf
            break;
        }
        default: {
            this.errorNonIndexableType(expr.object, objectType)
            return false
        }
    }

    var indexType = expr.index.operand.typeInfo
    if(!IsInteger(indexType)) {
        this.errorIndexType(expr.index, indexType)
    }

    expr.operand.typeInfo = baseObj
    return true
}

func (this: *TypeChecker) resolveInitArgExpr(expr: *InitArgExpr) : bool {
    assert(expr != null)
    expr.operand.typeInfo = &NULL_TYPE
    if(expr.value) {
        if(!this.resolveExpr(expr.value)) {
            return false
        }
        expr.operand = expr.value.operand
    }

    return true
}

func (this: *TypeChecker) addDefaultArguments(type: *TypeInfo, expr: *InitExpr) : bool {
    assert(expr != null)
    assert(type != null)
    assert(IsAggregate(type))

    var aggInfo = type as (*AggregateTypeInfo)

    var defaultArgs = Array<*InitArgExpr>{}
    defaultArgs.init(aggInfo.decl.fields.size(), this.allocator)
    
    for(var position = 0; position < aggInfo.decl.fields.size(); position += 1) {
        var field = aggInfo.decl.fields.get(position)
        if(field.kind != StmtKind.VAR_FIELD_DECL) {
            continue
        }

        if(!field.varField.defaultExpr) {
            continue
        }

        var byName = false
        var byPos = false
        var hasNamedArgs = false
        for(var i = 0; i < expr.arguments.size(); i += 1) {
            var arg = expr.arguments.get(i)
            if(arg.fieldName.type == TokenType.IDENTIFIER) {
                hasNamedArgs = true

                if(arg.fieldName.str.equalsStringView(field.varField.name.str)) {
                    byName = true
                    break
                }
            }
            else if(arg.argPosition == position) {
                byPos = true
                break
            }
        }

        if(!byName && !(!hasNamedArgs && byPos)) {
            var arg = NewInitArgExpr(expr.startPos, expr.endPos, field.varField.name, position, field.varField.defaultExpr, this.allocator) as (*InitArgExpr)
            expr.node.becomeParentOf(arg)
            defaultArgs.add(arg)
        }
    }

    for(var i = 0; i < defaultArgs.size(); i += 1) {
        var arg = defaultArgs.get(i)
        expr.arguments.add(arg)
    }

    return true
}

func (this: *TypeChecker) checkInitArguments(type: *TypeInfo, expr: *InitExpr) : bool {
    assert(expr != null)
    assert(type != null)

    var isSuccessful = true
    if(IsAggregate(type)) {
        var fieldName:[MAX_SYMBOL_NAME]char;
        var fieldNameStr = StringInit(fieldName, MAX_SYMBOL_NAME)
        var aggInfo = type as (*AggregateTypeInfo)
        for(var i = 0; i < expr.arguments.size(); i += 1) {
            var arg = expr.arguments.get(i)
            var field: FieldStmt;

            if(arg.fieldName.type == TokenType.IDENTIFIER) {
                fieldNameStr.format("%.*s", arg.fieldName.str.length, arg.fieldName.str.buffer)
                field = aggInfo.getField(fieldNameStr.cStr())
                if(field.kind == StmtKind.POISON_EXPR) {
                    this.errorNoField(arg, type, fieldNameStr.cStr())
                    isSuccessful = false
                    continue
                }
            }
            else {
                field = aggInfo.getFieldByPosition(arg.argPosition)
                if(field.kind == StmtKind.POISON_EXPR) {
                    this.errorNoFieldAt(arg, type, arg.argPosition)
                    isSuccessful = false
                    continue
                }
            }

            this.checkTypeCompatibility(arg.startPos, field.typeInfo, arg.operand.typeInfo)
            arg.expectedType = field.typeInfo
            arg.value.expectedType = field.typeInfo
        }
    }
    else if(type.kind == TypeKind.ARRAY) {
        var arrayInfo = type as (*ArrayTypeInfo)
        for(var i = 0; i < expr.arguments.size(); i += 1) {
            var arg = expr.arguments.get(i)
            this.checkTypeCompatibility(arg.startPos, arrayInfo.arrayOf, arg.operand.typeInfo)
            arg.expectedType = arrayInfo.arrayOf
            arg.value.expectedType = arrayInfo.arrayOf
        }

    }

    return isSuccessful
}

func (this: *TypeChecker) resolveInitExpr(expr: *InitExpr) : bool {
    assert(expr != null)

    var type = this.resolveTypeSpec(expr.type)
    if(!type) {
        return false
    }

    if(!IsAggregate(type) && type.kind != TypeKind.ARRAY) {
        this.result.addError(expr.startPos, "only struct, union or array can use initialization syntax")
        return false
    }

    if(IsAggregate(type)) {
        if(!this.addDefaultArguments(type, expr)) {
            return false
        }
    }

    for(var i = 0; i < expr.arguments.size(); i += 1) {
        var arg = expr.arguments.get(i)
        if(!this.resolveInitArgExpr(arg)) {
            return false
        }
    }
    // TODO: Infer generic types

    expr.operand.typeInfo = type
    return this.checkInitArguments(type, expr)
}



func (this: *TypeChecker) resolveSetExpr(expr: *SetExpr) : bool {
    assert(expr != null)
    
    if(!this.resolveExpr(expr.object)) {
        return false
    }

    if(!this.resolveExpr(expr.value)) {
        return false
    }

    // should we resolve field?
    if(!expr.field) {
        return false
    }

    var objectTypeInfo = expr.object.operand.typeInfo
    if(objectTypeInfo.kind == TypeKind.ENUM) {
        this.errorEnumFieldSet(expr.object, objectTypeInfo, expr.field.type.name)
        return false
    }

    if(!IsFieldAccessible(objectTypeInfo)) {
        this.errorNoFieldAccess(expr.object, objectTypeInfo, expr.field.type.name)
        return false
    }
    
    var info = objectTypeInfo.getBaseType()
    assert(info != null)
    assert(info.kind == TypeKind.STRUCT || info.kind == TypeKind.UNION)

    var aggInfo = info as (*AggregateTypeInfo)
    var field = aggInfo.getField(expr.field.type.name)
    if(field.kind == StmtKind.POISON_EXPR) {
        field = aggInfo.getFieldWithUsing(expr.field.type.name)
        if(field.kind == StmtKind.POISON_EXPR) {
            this.errorNoField(expr.field, objectTypeInfo, expr.field.type.name)
            return false
        }
        expr.flags |= GetExprFlags.IS_USING
    }

    expr.field.operand.typeInfo = field.typeInfo
    expr.operand.typeInfo = field.typeInfo
    
    this.checkTypeCompatibility(expr.startPos, expr.value.operand.typeInfo, field.typeInfo)
    return true
}

func (this: *TypeChecker) resolveTernaryExpr(expr: *TernaryExpr) : bool {
    assert(expr != null)

    if(!this.resolveExpr(expr.cond)) {
        return false
    }

    var condType = expr.cond.operand.typeInfo
    if(!IsBooleanable(condType)) {
        this.result.addError(expr.cond.startPos, "must be a boolean expression")
        return false
    }

    if(!this.resolveExpr(expr.then)) {
        return false;
    }

    if(!this.resolveExpr(expr.other)) {
        return false;
    }

    this.checkTypeCompatibility(expr.startPos, expr.then.operand.typeInfo, expr.other.operand.typeInfo)

    expr.operand.typeInfo = expr.then.operand.typeInfo
    expr.operand.isRightValue = true
    return true
}

func (this: *TypeChecker) resolveTypeIdentifierExpr(expr: *TypeIdentifierExpr) : bool {
    assert(expr != null)

    var type = this.resolveTypeSpec(expr.type)
    if(!type) {
        return false
    }

    expr.sym = type.sym // TODO: Is this still necessary?
    expr.operand.typeInfo = type
    expr.operand.isRightValue = true
    expr.operand.isConst = true
    return true
}

func (this: *TypeChecker) resolveTypeOfExpr(expr: *TypeOfExpr) : bool {
    assert(expr != null)
    if(expr.typeOfExpr) {
        if(!this.resolveExpr(expr.typeOfExpr)) {
            return false
        }
        var type = expr.typeOfExpr.operand.typeInfo
        expr.operand.val.intValue = type.typeid
    }
    else {
        var type = this.resolveTypeSpec(expr.type)
        if(!type) {
            return false
        }
        expr.operand.val.intValue = type.typeid
    }

    expr.operand.typeInfo = &U64_TYPE
    expr.operand.isRightValue = true
    expr.operand.isConst = true
    return true
}

func (this: *TypeChecker) resolveOffsetOfExpr(expr: *OffsetOfExpr) : bool {
    assert(expr != null)
    var type = this.resolveTypeSpec(expr.type)
    if(!type) {
        return false
    }
    if(!IsAggregate(type)) {
        this.errorNonAggregateType(expr, type)
        return false
    }
    if(expr.field.type != TokenType.IDENTIFIER) {
        return false
    }

    var fieldName:[MAX_SYMBOL_NAME]char;
    var fieldNameStr = StringInit(fieldName, MAX_SYMBOL_NAME)    
    fieldNameStr.format("%.*s", expr.field.str.length, expr.field.str.buffer)

    var aggInfo = type as (*AggregateTypeInfo)
    var fieldStmt = aggInfo.getField(fieldNameStr.cStr())    
    if(fieldStmt.kind == StmtKind.POISON_EXPR) {
        this.errorNoField(expr, type, fieldNameStr.cStr())
        return false
    }
    
    expr.operand.typeInfo = &USIZE_TYPE
    expr.operand.isRightValue = true
    expr.operand.isConst = true
    return true
}

func (this: *TypeChecker) resolveSizeOfExpr(expr: *SizeOfExpr) : bool {
    assert(expr != null)
    if(!this.resolveExpr(expr.sizeOfExpr)) {
        return false
    }

    expr.operand.typeInfo = &USIZE_TYPE
    expr.operand.isRightValue = true
    expr.operand.isConst = true
    return true
}

func (this: *TypeChecker) checkMethodExpr(expr: *GetExpr, aggInfo: *AggregateTypeInfo) : bool {
    assert(expr != null)

    // TODO: We shouldn't be looking thru all possible functions - performance!!
    for(var i = 0; i < this.symbolFuncs.size(); i += 1) {
        var sym = this.symbolFuncs.get(i)
        var decl = sym.decl as (*FuncDecl)
        if(!(decl.flags & FuncFlags.IS_METHOD)) {
            continue
        }

        if(!decl.name.str.equals(expr.field.type.name)) {
            continue
        }

        var methodName: [MAX_SYMBOL_NAME]char;
        if(!decl.getName(methodName)) {
            continue
        }

        var methodStr = StringViewInit(methodName, MAX_SYMBOL_NAME)
        var index = methodStr.indexOf("_")
        assert(index >= 0)
        
        if(strncmp(methodName, aggInfo.name, index) == 0) {
            if(decl.params.params.empty()) {
                continue
            }

            var objectParam = decl.params.get(0).typeInfo
            var baseType: *TypeInfo = objectParam

            if(objectParam.kind == TypeKind.PTR) {
                var ptrType = objectParam as (*PtrTypeInfo)
                baseType = ptrType.getBaseType()
            }

            if(baseType.strictEquals(aggInfo)) {
                expr.flags |= GetExprFlags.IS_METHOD_CALL
                expr.field.operand.typeInfo = sym.type
                expr.operand.typeInfo = sym.type
                return true
            }
        }
    }

    for(var i = 0; i < aggInfo.decl.fields.size(); i += 1) {
        var field = aggInfo.decl.fields.get(i)
        if(field.kind == StmtKind.VAR_FIELD_DECL) {
            var varField = field.varField
            if(varField.attributes.isUsing) {
                var baseType = field.typeInfo.getBaseType()
                if(this.checkMethodExpr(expr, baseType as (*AggregateTypeInfo))) {
                    return true
                }
            }
        }
    }

    return false
}

func (this: *TypeChecker) resolveGetExpr(expr: *GetExpr) : bool {
    assert(expr != null)

    if(!this.resolveExpr(expr.object)) {
        return false
    }

    // should we resolve field?
    if(!expr.field) {
        return false
    }

    var objectTypeInfo = expr.object.operand.typeInfo
    if(!IsFieldAccessible(objectTypeInfo)) {
        this.errorNoFieldAccess(expr.object, objectTypeInfo, expr.field.type.name)
        return false
    }

    if(objectTypeInfo.kind == TypeKind.ENUM) {
        var enumInfo = objectTypeInfo as (*EnumTypeInfo)
        var field = enumInfo.getField(expr.field.type.name)
        if(!field) {
            this.errorNoField(expr.field, objectTypeInfo, expr.field.type.name)
            return false
        }

        expr.flags |= GetExprFlags.IS_ENUM
        expr.operand.typeInfo = &I32_TYPE
        expr.operand.isConst = true
        expr.operand.isRightValue = true
        return true
    }
    else {
        var info = objectTypeInfo.getBaseType()
        assert(info != null)
        assert(info.kind == TypeKind.STRUCT || info.kind == TypeKind.UNION)

        var aggInfo = info as (*AggregateTypeInfo)

        // is this a vanilla field access?
        var field = aggInfo.getField(expr.field.type.name)
        if(field.kind != StmtKind.POISON_EXPR) {
            expr.field.operand.typeInfo = field.typeInfo
            expr.operand.typeInfo = field.typeInfo
            return true
        }
        
        // is this a using field access?
        field = aggInfo.getFieldWithUsing(expr.field.type.name)
        if(field.kind != StmtKind.POISON_EXPR) {
            expr.flags |= GetExprFlags.IS_USING
            expr.field.operand.typeInfo = field.typeInfo
            expr.operand.typeInfo = field.typeInfo
            return true
        }
        
        if(this.checkMethodExpr(expr, aggInfo)) {
            return true
        }
        
    }

    this.errorNoField(expr.field, objectTypeInfo, expr.field.type.name)
    return false
}

func (this: *TypeChecker) resolveGroupExpr(expr: *GroupExpr) : bool {
    assert(expr != null)

    if(!this.resolveExpr(expr.groupedExpr)) {
        return false
    }

    expr.operand = expr.groupedExpr.operand
    return true
}

func (this: *TypeChecker) resolveUnaryExpr(expr: *UnaryExpr) : bool {
    assert(expr != null)

    if(!this.resolveExpr(expr.unaryExpr)) {
        return false
    }
        
    var type = expr.unaryExpr.operand.typeInfo
    assert(type != null)

    switch(expr.operator) {
        case TokenType.STAR: {
            switch(type.kind) {
                case TypeKind.PTR: {
                    var info = type as (*PtrTypeInfo)
                    if(info.ptrOf.kind == TypeKind.CONST) {
                        var constInfo = info.ptrOf as (*ConstTypeInfo)
                        expr.operand.typeInfo = constInfo.constOf
                    }
                    else {
                        expr.operand.typeInfo = info.ptrOf
                    }
                    break
                }
                case TypeKind.STR: {
                    expr.operand.typeInfo = &CHAR_TYPE
                    break
                }
                case TypeKind.ARRAY: {
                    var info = type as (*ArrayTypeInfo)
                    if(info.arrayOf.kind == TypeKind.CONST) {
                        var constInfo = info.arrayOf as (*ConstTypeInfo)
                        expr.operand.typeInfo = constInfo.constOf
                    }
                    else {
                        expr.operand.typeInfo = info.arrayOf
                    }
                    break
                }
                case TypeKind.CONST: {
                    var constInfo = type as (*ConstTypeInfo)
                    if(IsPtrLike(constInfo.constOf)) {
                        expr.operand.typeInfo = constInfo.constOf
                    }
                    break
                }
                default: {
                    var sb = StringBufferInit(256, this.allocator)
                    sb.append("'")
                    type.toString(sb)
                    sb.append("' is not a pointer type")
                    
                    this.result.addErrorStr(expr.unaryExpr.startPos, sb)
                    return false
                }

            }
            break;
        }
        case TokenType.BAND: {
            if(type.kind == TypeKind.FUNC) {
                expr.operand.typeInfo = (type as (*FuncTypeInfo)).asPtr(this.allocator) as (*TypeInfo)
                expr.operand.isRightValue = true
            }
            else if(expr.unaryExpr.operand.isRightValue) {
                this.result.addError(expr.unaryExpr.startPos, "lvalue required as unary '&' operand")
                return false
            }
            else {
                expr.operand.typeInfo = NewPtrTypeInfo(type, this.allocator) as (*TypeInfo)
            }
            break;
        }
        case TokenType.NOT: {
            if(!this.checkTruthyness(expr.unaryExpr, type)) {
                return false
            }
            expr.operand.typeInfo = &BOOL_TYPE
            break;
        }
        default: {
            expr.operand = expr.unaryExpr.operand
            break;
        }
    }

    return true
}

func (this: *TypeChecker) resolveCastExpr(expr: *CastExpr) : bool {
    assert(expr != null)

    var typeInfo = this.resolveTypeSpec(expr.castTo)
    if(!typeInfo) {
        return false
    }

    if(!this.resolveExpr(expr.exprToCast)) {
        return false
    }

    expr.operand.typeInfo = typeInfo

    if(!this.checkCastability(expr.startPos, expr.expr.operand.typeInfo, typeInfo)) {
        return false
    }

    return true
}


func (this: *TypeChecker) resolveArrayDesignationExpr(expr: *ArrayDesignationExpr) : bool {
    assert(expr != null)

    if(!this.resolveExpr(expr.index)) {
        return false
    }

    if(!this.resolveExpr(expr.value)) {
        return false
    }

    if(!expr.index.isConstNumberExpr()) {
        this.result.addError(expr.index.startPos, "array designation must be indexed by a number")
        return false
    }

    if(expr.index.kind == StmtKind.IDENTIFIER_EXPR) {
        var idExpr = expr.index as (*IdentifierExpr)
        if(idExpr.sym != null && !(idExpr.sym.flags & SymbolFlags.IS_CONSTANT)) {
            this.result.addError(expr.index.startPos, "'%s' must be a constant", idExpr.sym.name)
            return false
        }
    }
    
    if(!this.checkTypeCompatibility(expr.startPos, &USIZE_TYPE, expr.index.operand.typeInfo)) {
        return false
    }

    expr.operand = expr.value.operand
    return true
}

func (this: *TypeChecker) resolveArrayInitExpr(expr: *ArrayInitExpr) : bool {
    assert(expr != null)

    var typeInfo = this.resolveTypeSpec(expr.type)
    if(!typeInfo) {
        return false
    }

    expr.operand.typeInfo = typeInfo
    expr.operand.isRightValue = true

    assert(typeInfo.kind == TypeKind.ARRAY)

    var arrayInfo = typeInfo as (*ArrayTypeInfo)
    var arrayOf = arrayInfo.arrayOf

    if(!expr.values.empty()) {
        if(!arrayInfo.numOfElements && !arrayInfo.length) {
            arrayInfo.length = expr.values.size()
        }

        var hasSucceed = true
        for(var i = 0; i < expr.values.size(); i += 1) {
            var value = expr.values.get(i)
            value.expectedType = arrayOf

            if(!this.resolveExpr(value)) {
                hasSucceed = false
            }

            if(value.operand.typeInfo) {
                this.checkTypeCompatibility(value.startPos, arrayOf, value.operand.typeInfo)
            }
        }
        return hasSucceed
    }

    return true
}

func (this: *TypeChecker) resolveBinaryExpr(expr: *BinaryExpr) : bool {
    assert(expr != null)

    if(!this.resolveExpr(expr.left)) {
        goto err;
    }

    if(!this.resolveExpr(expr.right)) {
        goto err;
    }

    var leftType = expr.left.operand.typeInfo
    var rightType = expr.right.operand.typeInfo

    var targetType = leftType

    switch(expr.operator) {
        case TokenType.EQUALS: {
            this.checkConstant(expr.left)
            this.checkAssignability(expr.right.startPos, leftType, rightType)
            this.checkRightValue(expr.left)
            break;
        }
        case TokenType.BAND_EQ:
        case TokenType.BNOT_EQ:
        case TokenType.BOR_EQ:
        case TokenType.XOR_EQ:
        case TokenType.LSHIFT_EQ:
        case TokenType.RSHIFT_EQ: 
            this.checkConstant(expr.left)
            this.checkAssignability(expr.right.startPos, leftType, rightType)
            this.checkRightValue(expr.left)
            // fallthru
        case TokenType.BAND:
        case TokenType.BNOT:
        case TokenType.BOR:
        case TokenType.XOR:
        case TokenType.LSHIFT:
        case TokenType.RSHIFT: {
            if(!IsInteger(leftType)) {
                this.errorOperand(expr.left, leftType, "left")
            }
            
            if(!IsInteger(rightType)) {
                this.errorOperand(expr.right, rightType, "right")
            }
            break;
        }
        case TokenType.AND:
        case TokenType.OR: {
            this.checkTruthyness(expr.left, leftType)
            this.checkTruthyness(expr.right, rightType)
            targetType = &BOOL_TYPE
            break;
        }
        case TokenType.EQUALS_EQUALS:
        case TokenType.NOT_EQUALS: {
            this.checkTruthyness(expr.left, leftType)
            this.checkTruthyness(expr.right, rightType)
            targetType = &BOOL_TYPE
            break;
        }
        case TokenType.GREATER_EQUALS:
        case TokenType.GREATER_THAN:
        case TokenType.LESS_EQUALS:
        case TokenType.LESS_THAN: {
            if(!IsNumberLike(leftType)) {
                this.errorOperand(expr.left, leftType, "left")
            }
            
            if(!IsNumberLike(rightType)) {
                this.errorOperand(expr.right, rightType, "right")
            }
            targetType = &BOOL_TYPE;
            break;
        }
        case TokenType.MINUS_EQ:
        case TokenType.PLUS_EQ:
        case TokenType.MOD_EQ:
        case TokenType.MUL_EQ:
        case TokenType.DIV_EQ:
            this.checkConstant(expr.left)
            this.checkAssignability(expr.right.startPos, leftType, rightType)
            // fallthru
        case TokenType.MINUS:
        case TokenType.PLUS:
        case TokenType.MOD:
        case TokenType.STAR:
        case TokenType.SLASH: {
            if(!IsNumberLike(leftType)) {
                this.errorOperand(expr.left, leftType, "left")
            }
            
            if(!IsNumberLike(rightType)) {
                this.errorOperand(expr.right, rightType, "right")
            }
            break;
        }
        default: {
            assert(false)
        }
    }

    expr.operand.typeInfo = targetType
    expr.operand.isConst = expr.left.operand.isConst && 
                           expr.right.operand.isConst
    return true

err:
    return false    
}

func (this: *TypeChecker) errorNonIndexableType(expr: *Expr, type: *TypeInfo) {
    assert(expr != null)
    assert(type != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.append("invalid index into '")
    type.toString(sb)
    sb.append("'")

    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) errorSetIndexingConstType(expr: *Expr, type: *TypeInfo) {
    assert(expr != null)
    assert(type != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.append("invalid read-only assignment to '")
    type.toString(sb)
    sb.append("'")

    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) errorIndexType(expr: *Expr, type: *TypeInfo) {
    assert(expr != null)
    assert(type != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.append("'")
    type.toString(sb)
    sb.append("'")
    sb.append(" invalid index value")

    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) errorNonAggregateType(expr: *Expr, type: *TypeInfo) {
    assert(expr != null)
    assert(type != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.append("'")
    type.toString(sb)
    sb.append("'")
    sb.append(" must be an aggregate type")

    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) errorNonFuncType(expr: *Expr, type: *TypeInfo) {
    assert(expr != null)
    assert(type != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.append("'")
    type.toString(sb)
    sb.append("'")
    sb.append(" must be function type")

    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) errorOperand(expr: *Expr, type: *TypeInfo, side: *const char) {
    assert(expr != null)
    assert(type != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.append("illegal, %s operand has type '", side)
    type.toString(sb)
    sb.append("'")

    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) errorEnumFieldSet(expr: *Expr, type: *TypeInfo, field: *const char) {
    assert(expr != null)
    assert(type != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.append("can't reassign enum '")
    type.toString(sb)
    sb.append("' field '%s'", field)

    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) errorNoField(expr: *Expr, type: *TypeInfo, field: *const char) {
    assert(expr != null)
    assert(type != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.append("'")
    type.toString(sb)
    sb.append("'")
    sb.append(" does not have field '%s'", field)

    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) errorNoFieldAt(expr: *Expr, type: *TypeInfo, position: i32) {
    assert(expr != null)
    assert(type != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.append("'")
    type.toString(sb)
    sb.append("'")
    sb.append(" does not have a field at index '%d'", position)

    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) errorNoFieldAccess(expr: *Expr, type: *TypeInfo, field: *const char) {
    assert(expr != null)
    assert(type != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.append("'")
    type.toString(sb)
    sb.append("'")
    sb.append(" can't be accessed with field '%s'", field)

    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) checkConstant(expr: *Expr) : bool {
    assert(expr != null)

    var sym: *Symbol = null
    if(expr.kind == StmtKind.IDENTIFIER_EXPR) {
        var idExpr = expr as (*IdentifierExpr)
        sym = idExpr.sym        
    }

    if(!sym) {
        if(!expr.operand.typeInfo) {
            return false;
        }

        sym = expr.operand.typeInfo.sym
        if(!sym) {
            return false;
        }
    }
    
    if(sym.flags & SymbolFlags.IS_CONSTANT) {
       this.result.addError(expr.startPos, "can't reassign constant variable '%s'", sym.name)       
       return false
    }

    return true
}

func (this: *TypeChecker) checkTruthyness(expr: *Expr, type: *TypeInfo) : bool {
    assert(expr != null)
    assert(type != null)

    if(!IsBooleanable(type)) {
        var sb = StringBufferInit(256, this.allocator)
        sb.append("'")
        type.toString(sb)
        sb.append("' can't be coerced to boolean")

        this.result.addErrorStr(expr.startPos, sb)
        return false
    }
    return true
}

func (this: *TypeChecker) checkRightValue(expr: *Expr) : bool {
    assert(expr != null)    
    if(expr.operand.isRightValue) {
        this.result.addError(expr.startPos, "rvalue can't be assigned to")
        return false
    }
    return true
}

func (this: *TypeChecker) resolveIdentiferExpr(expr: *IdentifierExpr) : bool {
    assert(expr != null)

    var sym = this.currentScope.lookup(expr.type.name)
    if(!sym) {
        this.result.addError(expr.startPos, "unknown variable '%s'", expr.type.name)
        return false
    }

    expr.operand.typeInfo = sym.type
    expr.operand.isConst = sym.flags & SymbolFlags.IS_CONSTANT
    expr.sym = sym
    return true;
}