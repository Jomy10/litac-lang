import "string_view"
import "string_buffer"
import "symbols"
import "ast"
import "array"
import "assert"
import "libc"

@asStr
public enum TypeKind {
    BOOL,
    CHAR,
    I8,
    U8,
    I16,
    U16,
    I32,
    U32,
    I64,
    U64,
    F32,
    F64,
    USIZE,
    NULL,
    VOID,

    STR,
    ARRAY,
    PTR,
    FUNC_PTR,

    STRUCT,
    UNION,
    ENUM,
    FUNC,

    CONST,
    GENERIC_PARAM,

    MAX_TYPE_KINDS
}

const typeKindText = []*const char {
    [TypeKind.BOOL] = "bool",
    [TypeKind.CHAR] = "char",
    [TypeKind.I8] = "i8",
    [TypeKind.U8] = "u8",
    [TypeKind.I16] = "i16",
    [TypeKind.U16] = "u16",
    [TypeKind.I32] = "i32",
    [TypeKind.U32] = "u32",
    [TypeKind.I64] = "i64",
    [TypeKind.U64] = "u64",
    [TypeKind.F32] = "f32",
    [TypeKind.F64] = "f64",
    [TypeKind.USIZE] = "usize",
    [TypeKind.NULL] = "null",
    [TypeKind.VOID] = "void",

    [TypeKind.STR] = "string",
    [TypeKind.ARRAY] = "array",
    [TypeKind.PTR] = "pointer",
    [TypeKind.FUNC_PTR] = "func_pointer",

    [TypeKind.STRUCT] = "struct",
    [TypeKind.UNION] = "union",
    [TypeKind.ENUM] = "enum",
    [TypeKind.FUNC] = "func",

    [TypeKind.CONST] = "const",
    [TypeKind.GENERIC_PARAM] = "generic_param",

    [TypeKind.MAX_TYPE_KINDS] = "",
}

public func TypeKindFromString(str: *const char, len: i32) : TypeKind {
    var view = StringViewInit(str, len)
    for(var i = TypeKind.BOOL; i < TypeKind.MAX_TYPE_KINDS; i += 1) {
        if(view.equals(typeKindText[i])) {
            return i;
        }
    }

    return TypeKind.MAX_TYPE_KINDS
}

public func IsPtrLike(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.PTR:
        case TypeKind.STR:
        case TypeKind.ARRAY: {
            return true;
        }
        case TypeKind.CONST: {
            var constInfo = type as (*ConstTypeInfo)
            return IsPtrLike(constInfo.constOf)
        }
        default: {
            return false;
        }
    }
}

public func IsPtrOf(type: *TypeInfo, kind: TypeKind) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.PTR: {
            var ptrInfo = type as (*PtrTypeInfo)
            return ptrInfo.ptrOf.kind == kind
        }
        case TypeKind.STR: {
            return kind == TypeKind.CHAR
        }
        case TypeKind.ARRAY: {
            var arrayInfo = type as (*ArrayTypeInfo)
            return arrayInfo.arrayOf.kind == kind
        }
        case TypeKind.CONST: {
            var constInfo = type as (*ConstTypeInfo)
            return IsPtrLike(constInfo.constOf)
        }
        default: {
            return false;
        }
    }
}

public func IsFuncLike(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.FUNC:
        case TypeKind.FUNC_PTR: {
            return true;
        }
        default: {
            return false;
        }
    }
}

public func IsPrimitive(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    return type.kind < TypeKind.STR
}

public func IsNumberLike(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.BOOL:
        case TypeKind.CHAR:
        case TypeKind.I8:
        case TypeKind.U8:
        case TypeKind.I16:
        case TypeKind.U16:
        case TypeKind.I32:
        case TypeKind.U32:
        case TypeKind.I64:
        case TypeKind.U64:
        case TypeKind.F32:
        case TypeKind.F64:
        case TypeKind.USIZE:
        case TypeKind.PTR:
        case TypeKind.STR:
        case TypeKind.ARRAY:
        case TypeKind.NULL:
        case TypeKind.ENUM: {
            return true;
        }
        case TypeKind.CONST: {
            var constInfo = type as (*ConstTypeInfo)
            return IsNumberLike(constInfo.constOf)
        }
        default: {
            return false
        }
    }
}

public func IsInteger(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.BOOL:
        case TypeKind.CHAR:
        case TypeKind.I8:
        case TypeKind.U8:
        case TypeKind.I16:
        case TypeKind.U16:
        case TypeKind.I32:
        case TypeKind.U32:
        case TypeKind.I64:
        case TypeKind.U64:        
        case TypeKind.USIZE:
        case TypeKind.ENUM: {
            return true;
        }
        case TypeKind.CONST: {
            var constInfo = type as (*ConstTypeInfo)
            return IsInteger(constInfo.constOf)
        }
        default: {
            return false
        }
    }
}

public func IsBooleanable(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.BOOL:
        case TypeKind.CHAR:
        case TypeKind.I8:
        case TypeKind.U8:
        case TypeKind.I16:
        case TypeKind.U16:
        case TypeKind.I32:
        case TypeKind.U32:
        case TypeKind.I64:
        case TypeKind.U64:
        case TypeKind.F32:
        case TypeKind.F64:
        case TypeKind.USIZE:
        case TypeKind.PTR:
        case TypeKind.STR:
        case TypeKind.ARRAY:
        case TypeKind.NULL:
        case TypeKind.ENUM: {
            return true;
        }
        case TypeKind.CONST: {
            var constInfo = type as (*ConstTypeInfo)
            return IsBooleanable(constInfo.constOf)
        }
        default: {
            return false
        }
    }
}

public func (this: *TypeInfo) toString(sb: *StringBuffer) {
    if(!this) return;

    switch(this.kind) {
        case TypeKind.BOOL:
        case TypeKind.CHAR:
        case TypeKind.I8:
        case TypeKind.U8:
        case TypeKind.I16:
        case TypeKind.U16:
        case TypeKind.I32:
        case TypeKind.U32:
        case TypeKind.I64:
        case TypeKind.U64:
        case TypeKind.F32:
        case TypeKind.F64:
        case TypeKind.USIZE:
        case TypeKind.NULL:
        case TypeKind.VOID:
        case TypeKind.STRUCT: 
        case TypeKind.UNION: 
        case TypeKind.ENUM:
            sb.append(this.name)
            break;
        case TypeKind.STR: {
            sb.append("*const char")
            break;
        }
        case TypeKind.ARRAY: {
            var arrayInfo = this as (*ArrayTypeInfo)
            sb.append("[]")
            arrayInfo.arrayOf.toString(sb)
            break;
        }
        case TypeKind.PTR: {
            var ptrInfo = this as (*PtrTypeInfo)
            sb.append("*")
            ptrInfo.ptrOf.toString(sb)
            break;
        }
        case TypeKind.CONST: {
            var constInfo = this as (*ConstTypeInfo)
            sb.append("const ")
            constInfo.constOf.toString(sb)
            break;
        }
        case TypeKind.FUNC_PTR: {
            var funcPtrInfo = this as (*FuncPtrTypeInfo)
            sb.append("func")
            if(!funcPtrInfo.genericParams.empty()) {
                sb.append("<")
                for(var i = 0; i < funcPtrInfo.genericParams.size(); i += 1) {
                    if(i > 0) sb.append(",")                    
                    var t = funcPtrInfo.genericParams.get(i).name                    
                    sb.append("%.*s", t.value.str.length, t.value.str.buffer)
                }
                sb.append(">")
            }
            sb.append("(")
            for(var i = 0; i < funcPtrInfo.paramDecls.size(); i += 1) {
                if(i > 0) sb.append(",")
                var paramType = funcPtrInfo.paramDecls.get(i)
                paramType.toString(sb)
            }
            sb.append(") : ")
            funcPtrInfo.returnType.toString(sb)
            break;
        }
        case TypeKind.FUNC: {
            var funcInfo = this as (*FuncTypeInfo)
            sb.append("func")
            if(!funcInfo.genericParams.empty()) {
                sb.append("<")
                for(var i = 0; i < funcInfo.genericParams.size(); i += 1) {
                    if(i > 0) sb.append(",")                    
                    var t = funcInfo.genericParams.get(i).name                    
                    sb.append("%.*s", t.value.str.length, t.value.str.buffer)
                }
                sb.append(">")
            }
            sb.append("(")
            for(var i = 0; i < funcInfo.decl.params.size(); i += 1) {
                if(i > 0) sb.append(",")
                var paramType = funcInfo.decl.params.get(i)
                paramType.typeInfo.toString(sb)
            }
            sb.append(") : ")
            funcInfo.returnType.toString(sb)
            break;
        }
        default: {
            assert(false)
        }
    }
}

public func (this: *TypeInfo) strictEquals(castTo: *TypeInfo) : bool {
    return false
}

public func (this: *TypeInfo) isAssignable(other: *TypeInfo) : bool {
    // this = other    
    switch(this.kind) {
        case TypeKind.BOOL: {
            return other.kind == TypeKind.BOOL
        }
        case TypeKind.CHAR: {
            return other.kind <= TypeKind.CHAR
        }
        case TypeKind.I8: {
            return other.kind <= TypeKind.I8
        }
        case TypeKind.U8: {
            return other.kind <= TypeKind.U8
        }
        case TypeKind.I16: {
            return other.kind <= TypeKind.I16
        }
        case TypeKind.U16: {
            return other.kind <= TypeKind.U16
        }
        case TypeKind.I32: {
            return other.kind <= TypeKind.I32
        }
        case TypeKind.U32: {
            return other.kind <= TypeKind.U32
        }
        case TypeKind.I64: {
            return other.kind <= TypeKind.I64
        }
        case TypeKind.U64: {
            return other.kind <= TypeKind.U64
        }
        case TypeKind.F32: {
            return other.kind == TypeKind.F32
        }
        case TypeKind.F64: {
            return other.kind == TypeKind.F32 ||
                   other.kind == TypeKind.F64
        }
        case TypeKind.USIZE: {
            return other.kind == TypeKind.USIZE || 
                   other.kind == TypeKind.NULL ||
                   IsPtrLike(other);
        }
        case TypeKind.NULL: {
            return other.kind == TypeKind.NULL
        }
        case TypeKind.VOID: {
            return other.kind == TypeKind.VOID
        }

        case TypeKind.STR: {
            return other.kind == TypeKind.STR ||
                   IsPtrOf(other, TypeKind.CHAR)
        }
        // TODO
        case TypeKind.ARRAY: {
            break;
        }
        case TypeKind.PTR: {
            break;
        }        
        case TypeKind.CONST: {
            break;
        }

        case TypeKind.FUNC_PTR: {
            break;
        }

        case TypeKind.STRUCT: {
            break;
        }
        case TypeKind.UNION: {
            break;
        }
        case TypeKind.ENUM: {
            break;
        }
        case TypeKind.FUNC: {
            break;
        }
        default: {
            assert(false)
        }
    }    
    return false
}

public func (this: *TypeInfo) canCastTo(castTo: *TypeInfo) : bool {
    switch(this.kind) {
        case TypeKind.BOOL: {
            return IsNumberLike(castTo)
        }
        case TypeKind.CHAR: {
            return IsNumberLike(castTo)
        }
        case TypeKind.I8: {
            return IsNumberLike(castTo)
        }
        case TypeKind.U8: {
            return IsNumberLike(castTo)
        }
        case TypeKind.I16: {
            return IsNumberLike(castTo)
        }
        case TypeKind.U16: {
            return IsNumberLike(castTo)
        }
        case TypeKind.I32: {
            return IsNumberLike(castTo)
        }
        case TypeKind.U32: {
            return IsNumberLike(castTo)
        }
        case TypeKind.I64: {
            return IsNumberLike(castTo)
        }
        case TypeKind.U64: {
            return IsNumberLike(castTo)
        }
        case TypeKind.F32: {
            return IsNumberLike(castTo)
        }
        case TypeKind.F64: {
            return IsNumberLike(castTo)
        }
        case TypeKind.USIZE: {
            return IsNumberLike(castTo)
        }
        case TypeKind.NULL: {
            return IsPtrLike(castTo)
        }
        case TypeKind.VOID: {
            return castTo.kind == TypeKind.VOID
        }

        case TypeKind.STR: {
            break;
        }
        case TypeKind.ARRAY: {
            break;
        }
        case TypeKind.PTR: {
            break;
        }
        case TypeKind.FUNC_PTR: {
            break;
        }

        case TypeKind.STRUCT: {
            break;
        }
        case TypeKind.UNION: {
            break;
        }
        case TypeKind.ENUM: {
            break;
        }
        case TypeKind.FUNC: {
            break;
        }

        case TypeKind.CONST: {
            break;
        }
        default: {
            assert(false)
        }
    }
    return false
}

public typedef i64 as Typeid;
var idGen: Typeid = TypeKind.MAX_TYPE_KINDS as (i64);

public func NextTypeId() : Typeid {
    idGen += 1
    return idGen;
}

public struct TypeInfo {
    kind: TypeKind
    typeid: Typeid
    name: *const char
    sym: *Symbol
}

public struct FuncTypeInfo {
    info: using TypeInfo   
    genericParams: Array<GenericParam> 
    returnType: *TypeInfo
    decl: *FuncDecl
}

public struct ConstTypeInfo {
    info: using TypeInfo
    constOf: *TypeInfo
}

public struct PtrTypeInfo {
    info: using TypeInfo
    ptrOf: *TypeInfo
}

public struct ArrayTypeInfo {
    info: using TypeInfo
    arrayOf: *TypeInfo
    length: usize
    numElements: *Expr
}

public struct FuncPtrTypeInfo {
    info: using TypeInfo
    genericParams: Array<GenericParam>
    returnType: *TypeInfo
    paramDecls: Array<*TypeInfo>
}

public struct EnumTypeInfo {
    info: using TypeInfo
    decl: *EnumDecl
}

public struct AggregateTypeInfo {
    info: using TypeInfo
    decl: *AggregateDecl
}

public const BOOL_TYPE = TypeInfo {
    .kind = TypeKind.BOOL,
    .typeid = TypeKind.BOOL as (Typeid),
    .name = "bool",
    .sym = null
}

public const CHAR_TYPE = TypeInfo {
    .kind = TypeKind.CHAR,
    .typeid = TypeKind.CHAR as (Typeid),
    .name = "char",
    .sym = null
}

public const I8_TYPE = TypeInfo {
    .kind = TypeKind.I8,
    .typeid = TypeKind.I8 as (Typeid),
    .name = "i8",
    .sym = null
}

public const U8_TYPE = TypeInfo {
    .kind = TypeKind.U8,
    .typeid = TypeKind.U8 as (Typeid),
    .name = "u8",
    .sym = null
}

public const I16_TYPE = TypeInfo {
    .kind = TypeKind.I16,
    .typeid = TypeKind.I16 as (Typeid),
    .name = "i16",
    .sym = null
}

public const U16_TYPE = TypeInfo {
    .kind = TypeKind.U16,
    .typeid = TypeKind.U16 as (Typeid),
    .name = "u16",
    .sym = null
}

public const I32_TYPE = TypeInfo {
    .kind = TypeKind.I32,
    .typeid = TypeKind.I32 as (Typeid),
    .name = "i32",
    .sym = null
}

public const U32_TYPE = TypeInfo {
    .kind = TypeKind.U32,
    .typeid = TypeKind.U32 as (Typeid),
    .name = "u32",
    .sym = null
}

public const I64_TYPE = TypeInfo {
    .kind = TypeKind.I64,
    .typeid = TypeKind.I64 as (Typeid),
    .name = "i64",
    .sym = null
}

public const U64_TYPE = TypeInfo {
    .kind = TypeKind.U64,
    .typeid = TypeKind.U64 as (Typeid),
    .name = "u64",
    .sym = null
}

public const F32_TYPE = TypeInfo {
    .kind = TypeKind.F32,
    .typeid = TypeKind.F32 as (Typeid),
    .name = "f32",
    .sym = null
}

public const F64_TYPE = TypeInfo {
    .kind = TypeKind.F64,
    .typeid = TypeKind.F64 as (Typeid),
    .name = "f64",
    .sym = null
}

public const USIZE_TYPE = TypeInfo {
    .kind = TypeKind.USIZE,
    .typeid = TypeKind.USIZE as (Typeid),
    .name = "usize",
    .sym = null
}

public const NULL_TYPE = TypeInfo {
    .kind = TypeKind.NULL,
    .typeid = TypeKind.NULL as (Typeid),
    .name = "null",
    .sym = null
}

public const VOID_TYPE = TypeInfo {
    .kind = TypeKind.VOID,
    .typeid = TypeKind.VOID as (Typeid),
    .name = "void",
    .sym = null
}

public const STR_TYPE = TypeInfo {
    .kind = TypeKind.STR,
    .typeid = TypeKind.STR as (Typeid),
    .name = "*char",
    .sym = null
}