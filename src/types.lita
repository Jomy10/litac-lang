import "string_view"
import "string_buffer"
import "symbols"
import "ast"
import "lex"
import "array"
import "assert"
import "mem"
import "ast_new"
import "libc"
import "module"
import "types_new"
import "common"

@asStr
public enum TypeKind {
    BOOL = 1,
    CHAR,
    I8,
    U8,
    I16,
    U16,
    I32,
    U32,
    I64,
    U64,
    F32,
    F64,
    USIZE,
    NULL,
    VOID,

    STR,
    ARRAY,
    PTR,
    FUNC_PTR,

    STRUCT,
    UNION,
    ENUM,
    FUNC,

    CONST,
    GENERIC_PARAM,

    POISON,

    MAX_TYPE_KINDS
}

const typeKindText = [TypeKind.MAX_TYPE_KINDS + 1]*const char {
    [TypeKind.BOOL] = "bool",
    [TypeKind.CHAR] = "char",
    [TypeKind.I8] = "i8",
    [TypeKind.U8] = "u8",
    [TypeKind.I16] = "i16",
    [TypeKind.U16] = "u16",
    [TypeKind.I32] = "i32",
    [TypeKind.U32] = "u32",
    [TypeKind.I64] = "i64",
    [TypeKind.U64] = "u64",
    [TypeKind.F32] = "f32",
    [TypeKind.F64] = "f64",
    [TypeKind.USIZE] = "usize",
    [TypeKind.NULL] = "null",
    [TypeKind.VOID] = "void",

    [TypeKind.STR] = "string",
    [TypeKind.ARRAY] = "array",
    [TypeKind.PTR] = "pointer",
    [TypeKind.FUNC_PTR] = "func_pointer",

    [TypeKind.STRUCT] = "struct",
    [TypeKind.UNION] = "union",
    [TypeKind.ENUM] = "enum",
    [TypeKind.FUNC] = "func",

    [TypeKind.CONST] = "const",
    [TypeKind.GENERIC_PARAM] = "generic_param",
    [TypeKind.POISON] = "poison",

    [TypeKind.MAX_TYPE_KINDS] = "",
}

public func TypeKindFromString(str: *const char, len: i32) : TypeKind {
    var view = StringViewInit(str, len)
    for(var i = TypeKind.BOOL; i < TypeKind.MAX_TYPE_KINDS; i += 1) {
        if(view.equals(typeKindText[i])) {
            return i;
        }
    }

    return TypeKind.MAX_TYPE_KINDS
}

public func IsPtr(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    if(type.kind == TypeKind.CONST) {
        var constInfo = type as (*ConstTypeInfo)
        return IsPtr(constInfo.constOf)
    }

    return type.kind == TypeKind.PTR
}

public func IsPtrLike(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.PTR:
        case TypeKind.STR:
        case TypeKind.ARRAY: {
            return true;
        }
        case TypeKind.CONST: {
            var constInfo = type as (*ConstTypeInfo)
            return IsPtrLike(constInfo.constOf)
        }
        default: {
            return false;
        }
    }
}

public func IsPtrOf(type: *TypeInfo, kind: TypeKind) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.PTR: {
            var ptrInfo = type as (*PtrTypeInfo)
            return ptrInfo.ptrOf.kind == kind
        }
        case TypeKind.STR: {
            return kind == TypeKind.CHAR
        }
        case TypeKind.ARRAY: {
            var arrayInfo = type as (*ArrayTypeInfo)
            return arrayInfo.arrayOf.kind == kind
        }
        case TypeKind.CONST: {
            var constInfo = type as (*ConstTypeInfo)
            return constInfo.constOf.kind == kind
        }
        default: {
            return false;
        }
    }
}


public func IsFuncLike(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.FUNC:
        case TypeKind.FUNC_PTR: {
            return true;
        }
        default: {
            return false;
        }
    }
}

public func IsPrimitive(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    return type.kind < TypeKind.STR
}

public func IsNumberLike(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.BOOL:
        case TypeKind.CHAR:
        case TypeKind.I8:
        case TypeKind.U8:
        case TypeKind.I16:
        case TypeKind.U16:
        case TypeKind.I32:
        case TypeKind.U32:
        case TypeKind.I64:
        case TypeKind.U64:
        case TypeKind.F32:
        case TypeKind.F64:
        case TypeKind.USIZE:
        case TypeKind.PTR:
        case TypeKind.STR:
        case TypeKind.ARRAY:
        case TypeKind.NULL:
        case TypeKind.ENUM: {
            return true;
        }
        case TypeKind.CONST: {
            var constInfo = type as (*ConstTypeInfo)
            return IsNumberLike(constInfo.constOf)
        }
        default: {
            return false
        }
    }
}

public func IsInteger(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.BOOL:
        case TypeKind.CHAR:
        case TypeKind.I8:
        case TypeKind.U8:
        case TypeKind.I16:
        case TypeKind.U16:
        case TypeKind.I32:
        case TypeKind.U32:
        case TypeKind.I64:
        case TypeKind.U64:
        case TypeKind.USIZE:
        case TypeKind.ENUM: {
            return true;
        }
        case TypeKind.CONST: {
            var constInfo = type as (*ConstTypeInfo)
            return IsInteger(constInfo.constOf)
        }
        default: {
            return false
        }
    }
}

public func IsBooleanable(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.BOOL:
        case TypeKind.CHAR:
        case TypeKind.I8:
        case TypeKind.U8:
        case TypeKind.I16:
        case TypeKind.U16:
        case TypeKind.I32:
        case TypeKind.U32:
        case TypeKind.I64:
        case TypeKind.U64:
        case TypeKind.F32:
        case TypeKind.F64:
        case TypeKind.USIZE:
        case TypeKind.PTR:
        case TypeKind.STR:
        case TypeKind.ARRAY:
        case TypeKind.NULL:
        case TypeKind.FUNC_PTR:
        case TypeKind.ENUM: {
            return true;
        }
        case TypeKind.CONST: {
            var constInfo = type as (*ConstTypeInfo)
            return IsBooleanable(constInfo.constOf)
        }
        default: {
            return false
        }
    }
}

public func IsAggregateLike(type: *TypeInfo) : bool {
    return IsAggregate(type) || IsPtrAggregate(type)
}

public func IsAggregate(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    if(type.kind == TypeKind.CONST) {
        var constInfo = type as (*ConstTypeInfo)
        return IsAggregate(constInfo.constOf)
    }

    return type.kind == TypeKind.STRUCT ||
           type.kind == TypeKind.UNION
}

public func IsPtrAggregate(type: *TypeInfo) : bool {
    if(!IsPtr(type)) {
        return false;
    }
    var ptrInfo: *TypeInfo = null
    if(type.kind == TypeKind.CONST) {
        var constInfo = type as (*ConstTypeInfo)
        ptrInfo = constInfo.constOf
    }
    else {
        ptrInfo = (type as (*PtrTypeInfo)).ptrOf
    }
    return IsAggregate(ptrInfo)
}

public func IsFieldAccessible(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    if(IsAggregate(type) || IsPtrAggregate(type) || type.kind == TypeKind.ENUM) {
        return true
    }

    return false
}

public func IsGenericCapable(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.FUNC:
        case TypeKind.FUNC_PTR:
        case TypeKind.STRUCT:
        case TypeKind.UNION:
            return true
        default:
            return false
    }
}

public func (this: *TypeInfo) getBaseType() : *TypeInfo {
    if(!this) return null;
    switch(this.kind) {
        case TypeKind.PTR: {
            var info = this as (*PtrTypeInfo)
            return info.ptrOf.getBaseType()
        }
        case TypeKind.CONST: {
            var info = this as (*ConstTypeInfo)
            return info.constOf.getBaseType()
        }
        case TypeKind.ARRAY: {
            var info = this as (*ArrayTypeInfo)
            if(info.arrayOf.kind == TypeKind.ARRAY) {
                return info.arrayOf.getBaseType()
            }
            return info.arrayOf
        }
        case TypeKind.STR: {
            return &CHAR_TYPE
        }
        default: {
            return this
        }
    }
}

public func (this: *TypeInfo) getTypeOf() : *TypeInfo {
    if(!this) return null;

    switch(this.kind) {
        case TypeKind.PTR: {
            var info = this as (*PtrTypeInfo)
            return info.ptrOf
        }
        case TypeKind.CONST: {
            var info = this as (*ConstTypeInfo)
            return info.constOf
        }
        case TypeKind.ARRAY: {
            var info = this as (*ArrayTypeInfo)
            return info.arrayOf
        }
        case TypeKind.STR: {
            return &CHAR_TYPE
        }
        default: {
            return null
        }
    }
}

public func (this: *TypeInfo) toStringDebug() : *const char {
    var sb = StringBufferInit(256)
    this.toString(sb)
    return sb.cStr()
}

public func (this: *TypeInfo) toString(sb: *StringBuffer) {
    if(!this) return;

    switch(this.kind) {
        case TypeKind.BOOL:
        case TypeKind.CHAR:
        case TypeKind.I8:
        case TypeKind.U8:
        case TypeKind.I16:
        case TypeKind.U16:
        case TypeKind.I32:
        case TypeKind.U32:
        case TypeKind.I64:
        case TypeKind.U64:
        case TypeKind.F32:
        case TypeKind.F64:
        case TypeKind.USIZE:
        case TypeKind.NULL:
        case TypeKind.VOID:
        case TypeKind.STRUCT:
        case TypeKind.UNION:
        case TypeKind.ENUM:
        case TypeKind.GENERIC_PARAM:
            sb.appendStr(this.name)
            break;
        case TypeKind.STR: {
            sb.appendStr("*const char")
            break;
        }
        case TypeKind.ARRAY: {
            var arrayInfo = this as (*ArrayTypeInfo)
            if(arrayInfo.length) {
                sb.append("[%llu]", arrayInfo.length)
            }
            else {
                sb.appendStrn("[]", 2)
            }
            arrayInfo.arrayOf.toString(sb)
            break;
        }
        case TypeKind.PTR: {
            var ptrInfo = this as (*PtrTypeInfo)
            sb.appendStrn("*", 1)
            ptrInfo.ptrOf.toString(sb)
            break;
        }
        case TypeKind.CONST: {
            var constInfo = this as (*ConstTypeInfo)
            sb.appendStrn("const ", 6)
            constInfo.constOf.toString(sb)
            break;
        }
        case TypeKind.FUNC_PTR: {
            var funcPtrInfo = this as (*FuncPtrTypeInfo)
            sb.appendStrn("func", 4)
            if(!funcPtrInfo.genericParams.empty()) {
                sb.appendStrn("<", 1)
                for(var i = 0; i < funcPtrInfo.genericParams.size(); i += 1) {
                    if(i > 0) sb.appendStrn(",", 1)
                    var t = funcPtrInfo.genericParams.get(i).name
                    sb.appendStrn(t.value.str.buffer, t.value.str.length)
                }
                sb.appendStrn(">", 1)
            }
            sb.appendStrn("(", 1)
            for(var i = 0; i < funcPtrInfo.paramDecls.size(); i += 1) {
                if(i > 0) sb.appendStrn(",", 1)
                var paramType = funcPtrInfo.paramDecls.get(i)
                paramType.toString(sb)
            }
            sb.appendStr(") : ")
            funcPtrInfo.returnType.toString(sb)
            break;
        }
        case TypeKind.FUNC: {
            var funcInfo = this as (*FuncTypeInfo)
            sb.appendStrn("func", 4)
            if(!funcInfo.decl.genericParams.empty()) {
                sb.appendStrn("<", 1)
                for(var i = 0; i < funcInfo.decl.genericParams.size(); i += 1) {
                    if(i > 0) sb.appendStrn(",", 1)
                    var t = funcInfo.decl.genericParams.get(i).name
                    sb.appendStrn(t.value.str.buffer, t.value.str.length)
                }
                sb.appendStrn(">", 1)
            }
            sb.appendStrn("(", 1)
            for(var i = 0; i < funcInfo.decl.params.size(); i += 1) {
                if(i > 0) sb.appendStrn(",", 1)
                var paramType = funcInfo.decl.params.get(i)
                paramType.typeInfo.toString(sb)
            }
            sb.appendStr(") : ")
            funcInfo.returnType.toString(sb)
            break;
        }
        case TypeKind.POISON: {
            sb.appendStr("<poison>")
            break;
        }
        default: {
            assert(false)
        }
    }
}

public func (this: *TypeInfo) strictEquals(other: *TypeInfo) : bool {
    if(this == other) {
        return true
    }

    if(this && !other) {
        return false
    }

    if(!this && other) {
        return false
    }

    if(other.kind != this.kind) {
        return false
    }

    switch(this.kind) {
        case TypeKind.PTR: {
            var thisInfo = this as (*PtrTypeInfo)
            var otherInfo = other as (*PtrTypeInfo)
            return thisInfo.ptrOf.strictEquals(otherInfo.ptrOf)
        }
        case TypeKind.CONST: {
            var thisInfo = this as (*ConstTypeInfo)
            var otherInfo = other as (*ConstTypeInfo)
            return thisInfo.constOf.strictEquals(otherInfo.constOf)
        }
        case TypeKind.ARRAY: {
            var thisInfo = this as (*ArrayTypeInfo)
            var otherInfo = other as (*ArrayTypeInfo)
            if(thisInfo.length != otherInfo.length) {
                return false;
            }
            return thisInfo.arrayOf.strictEquals(otherInfo.arrayOf)
        }
        case TypeKind.FUNC_PTR: {
            var thisInfo = this as (*FuncPtrTypeInfo)
            var otherInfo = other as (*FuncPtrTypeInfo)
            if(thisInfo.paramDecls.size() != otherInfo.paramDecls.size()) {
                return false;
            }
            if(!thisInfo.returnType.strictEquals(otherInfo.returnType)) {
                return false;
            }
            for(var i = 0; i < thisInfo.paramDecls.size(); i += 1) {
                var a = thisInfo.paramDecls.get(i)
                var b = otherInfo.paramDecls.get(i)
                if(a.strictEquals(b)) {
                    return false;
                }
            }
            return true
        }
        default: {
            return this.typeid == other.typeid
        }
    }

    return false
}

public func (this: *TypeInfo) isAssignable(other: *TypeInfo) : bool {
    assert(this != null)
    assert(other != null)

    if(other.typeid == this.typeid) {
        return true
    }

    // this = other
    switch(this.kind) {
        case TypeKind.BOOL: {
            if(other.kind == TypeKind.VOID) {
                return false
            }

            return true
        }
        case TypeKind.CHAR: {
            return other.kind <= TypeKind.U32
        }
        case TypeKind.I8: {
            return other.kind <= TypeKind.I8
        }
        case TypeKind.U8: {
            return other.kind <= TypeKind.U8
        }
        case TypeKind.I16: {
            return other.kind <= TypeKind.I16
        }
        case TypeKind.U16: {
            return other.kind <= TypeKind.U16
        }
        case TypeKind.I32: {
            return other.kind <= TypeKind.I32 ||
                   other.kind == TypeKind.ENUM
        }
        case TypeKind.U32: {
            return other.kind <= TypeKind.U32 ||
                   other.kind == TypeKind.ENUM
        }
        case TypeKind.I64: {
            return other.kind <= TypeKind.I64 ||
                   other.kind == TypeKind.ENUM
        }
        case TypeKind.U64: {
            return other.kind <= TypeKind.U64 ||
                   other.kind == TypeKind.ENUM
        }
        case TypeKind.F32: {
            return other.kind == TypeKind.F32 ||
                   other.kind <= TypeKind.U32
        }
        case TypeKind.F64: {
            return other.kind == TypeKind.F32 ||
                   other.kind == TypeKind.F64
        }
        case TypeKind.USIZE: {
            return other.kind <= TypeKind.USIZE ||
                   other.kind == TypeKind.NULL ||
                   IsPtrLike(other);
        }
        case TypeKind.NULL: {
            return other.kind == TypeKind.NULL
        }
        case TypeKind.VOID: {
            return other.kind == TypeKind.VOID
        }

        case TypeKind.STR: {
            // Allow for pointer arithmetic
            if(IsInteger(other)) {
                return true
            }
            return this.isDeclarable(other)
        }
        case TypeKind.ARRAY: {

            // Allow for pointer arithmetic
            if(IsInteger(other)) {
                return true
            }
            return this.isDeclarable(other)
        }
        case TypeKind.PTR: {
            // Allow for pointer arithmetic
            if(IsInteger(other)) {
                return true
            }
            return this.isDeclarable(other)
        }
        case TypeKind.CONST: {
            var thisInfo = this as (*ConstTypeInfo)

            // Allow for *const char = *char
            if(other.kind != TypeKind.CONST) {
                return thisInfo.constOf.isAssignable(other)
            }

            var otherInfo = other as (*ConstTypeInfo)
            return thisInfo.constOf.isAssignable(otherInfo.constOf)
        }
        case TypeKind.STRUCT: {
            if(other.kind != TypeKind.STRUCT) {
                return false
            }
            return this.typeid == other.typeid
        }
        case TypeKind.UNION: {
            if(other.kind != TypeKind.UNION) {
                return false
            }
            return this.typeid == other.typeid
        }
        case TypeKind.ENUM: {
            if(IsInteger(other)) {
                return true
            }
            if(other.kind != TypeKind.ENUM) {
                return false
            }
            return this.typeid == other.typeid
        }
        case TypeKind.FUNC_PTR: {
            if(other.kind == TypeKind.NULL) {
                return true
            }

            if(IsPtrOf(other, TypeKind.VOID)) {
                return true
            }

            if(!IsFuncLike(other)) {
                return false
            }

            var thisInfo = this as (*FuncPtrTypeInfo)
            if(other.kind != TypeKind.FUNC) {
                return this.isDeclarable(other)
            }

            var funcInfo = other as (*FuncTypeInfo)

            if(funcInfo.decl.params.size() != thisInfo.paramDecls.size()) {
                return false
            }

            if(funcInfo.decl.params.isVararg  != thisInfo.hasVarargs) {
                return false
            }
            if(!funcInfo.returnType.strictEquals(thisInfo.returnType)) {
                return false
            }

            for(var i = 0; i < thisInfo.paramDecls.size(); i += 1) {
                var a = thisInfo.paramDecls.get(i)

                var b = funcInfo.decl.params.get(i)
                if(!b.typeInfo) {
                    return false
                }

                if(!a.strictEquals(b.typeInfo)) {
                    return false
                }
            }
            return true
        }
        case TypeKind.FUNC: {
            break;
        }
        case TypeKind.POISON: {
            return false;
        }
        default: {
            printf("Type: %s\n", typeKindText[this.kind])
            assert(false)
        }
    }
    return false
}

public func (this: *TypeInfo) isDeclarable(other: *TypeInfo) : bool {
    // this = other
    switch(this.kind) {
        case TypeKind.BOOL: {
            return other.kind == TypeKind.BOOL
        }
        case TypeKind.CHAR: {
            return other.kind <= TypeKind.U32
        }
        case TypeKind.I8: {
            return other.kind <= TypeKind.I8
        }
        case TypeKind.U8: {
            return other.kind <= TypeKind.U8
        }
        case TypeKind.I16: {
            return other.kind <= TypeKind.I16
        }
        case TypeKind.U16: {
            return other.kind <= TypeKind.U16
        }
        case TypeKind.I32: {
            return other.kind <= TypeKind.I32 ||
                   other.kind == TypeKind.ENUM
        }
        case TypeKind.U32: {
            return other.kind <= TypeKind.U32 ||
                   other.kind == TypeKind.ENUM
        }
        case TypeKind.I64: {
            return other.kind <= TypeKind.I64 ||
                   other.kind == TypeKind.ENUM
        }
        case TypeKind.U64: {
            return other.kind <= TypeKind.U64 ||
                   other.kind == TypeKind.ENUM
        }
        case TypeKind.F32: {
            return other.kind == TypeKind.F32 ||
                   other.kind <= TypeKind.U32
        }
        case TypeKind.F64: {
            return other.kind == TypeKind.F32 ||
                   other.kind == TypeKind.F64
        }
        case TypeKind.USIZE: {
            return other.kind <= TypeKind.USIZE ||
                   other.kind == TypeKind.NULL ||
                   IsPtrLike(other);
        }
        case TypeKind.NULL: {
            return other.kind == TypeKind.NULL
        }
        case TypeKind.VOID: {
            return other.kind == TypeKind.VOID
        }

        case TypeKind.STR: {
            if(IsPtr(other)) {
                var otherPtr = other as (*PtrTypeInfo)
                if(otherPtr.ptrOf.kind == TypeKind.CONST) {
                    var constOf = otherPtr.ptrOf as (*ConstTypeInfo)
                    return constOf.constOf.kind == TypeKind.CHAR
                }
                return otherPtr.ptrOf.kind == TypeKind.CHAR
            }
            return other.kind == TypeKind.STR
        }
        case TypeKind.ARRAY: {
            var thisArray = this as (*ArrayTypeInfo)
            if(other.kind == TypeKind.STR) {
                if(thisArray.arrayOf.kind == TypeKind.CONST) {
                    return IsPtrOf(thisArray.arrayOf, TypeKind.CHAR)
                }
                if(!IsPtrOf(thisArray, TypeKind.CHAR)) {
                    return false
                }

                return true
            }

            if(other.kind == TypeKind.PTR) {
                var otherPtr = other as (*PtrTypeInfo)
                return thisArray.arrayOf.isDeclarable(otherPtr.ptrOf)
            }

            if(other.kind != TypeKind.ARRAY) {
                return false
            }
            var otherArray = other as (*ArrayTypeInfo)

            if(!thisArray.arrayOf.isDeclarable(otherArray.arrayOf)) {
                return false
            }

            if(!thisArray.length) {
                return true
            }
            return thisArray.length == otherArray.length
        }
        case TypeKind.PTR: {
            if(other.kind == TypeKind.NULL) {
                return true
            }

            if(other.kind == TypeKind.FUNC_PTR) {
                if(IsPtrOf(this, TypeKind.VOID)) {
                    return true
                }
            }

            if(!IsPtrLike(other)) {
                return false
            }

            var thisPtr = this as (*PtrTypeInfo)
            var isVoidPtr = false
            var isConst = false

            var ptrOf = thisPtr.ptrOf
            if(thisPtr.ptrOf.kind == TypeKind.CONST) {
                var thisConst = thisPtr.ptrOf as (*ConstTypeInfo)
                ptrOf = thisConst.constOf
                isConst = true
            }

            if(ptrOf.kind == TypeKind.VOID) {
                isVoidPtr = true
            }

            switch(other.kind) {
                case TypeKind.PTR: {
                    var otherPtr = other as (*PtrTypeInfo)

                    // can't assign const to a non const: *x = *const x
                    if(otherPtr.ptrOf.kind == TypeKind.CONST) {
                        if(!isConst) {
                            return false
                        }
                    }

                    // *void or *const void can be assigned any ptr
                    if(isVoidPtr) {
                        return true
                    }

                    // determine if we can do a using coersion
                    if(IsPtrAggregate(this) && IsPtrAggregate(other)) {
                        var otherAgg = other.getBaseType() as (*AggregateTypeInfo)
                        var thisAgg = this.getBaseType() as (*AggregateTypeInfo)

                        if(otherAgg.typeid == thisAgg.typeid) {
                            return true
                        }

                        // if a using field can be found, this can be assigned
                        var field = otherAgg.getFieldByType(thisAgg)
                        return (field.kind == StmtKind.VAR_FIELD_DECL);
                    }

                    return thisPtr.ptrOf.isDeclarable(otherPtr.ptrOf)
                }
                case TypeKind.ARRAY: {
                    if(isVoidPtr) {
                        return true
                    }

                    var otherArray = other as (*ArrayTypeInfo)
                    return thisPtr.ptrOf.isDeclarable(otherArray.arrayOf)
                }
                case TypeKind.STR: {
                    if(!isConst) {
                        return false
                    }

                    if(isVoidPtr) {
                        return true
                    }

                    return thisPtr.ptrOf.isDeclarable(&CHAR_TYPE)
                }
                case TypeKind.CONST: {
                    return false; // can't assign const to non const
                }
                case TypeKind.FUNC_PTR: {
                    return true
                }
                default: {
                    return false
                }
            }

        }
        case TypeKind.CONST: {
            var constInfo = this as (*ConstTypeInfo)

            if(other.kind == TypeKind.CONST) {
                var otherConst = other as (*ConstTypeInfo)
                other = otherConst.constOf
            }
            return constInfo.constOf.isDeclarable(other)
        }

        case TypeKind.FUNC_PTR: {
            if(other.kind == TypeKind.NULL) {
                return true
            }

            if(IsPtrOf(other, TypeKind.VOID)) {
                return true
            }

            if(other.kind != TypeKind.FUNC_PTR) {
                return false
            }

            var fnPtrInfo = this as (*FuncPtrTypeInfo)
            var otherFnPtrInfo = other as (*FuncPtrTypeInfo)

            if(fnPtrInfo.paramDecls.size() != otherFnPtrInfo.paramDecls.size()) {
                return false;
            }

            if(fnPtrInfo.hasVarargs != otherFnPtrInfo.hasVarargs) {
                return false;
            }

            if(!fnPtrInfo.returnType.strictEquals(otherFnPtrInfo.returnType)) {
                return false;
            }

            for(var i = 0; i < fnPtrInfo.paramDecls.size(); i += 1) {
                var a = fnPtrInfo.paramDecls.get(i)
                var b = otherFnPtrInfo.paramDecls.get(i)
                if(!a.strictEquals(b)) {
                    return false
                }
            }

            return true;
        }

        case TypeKind.STRUCT: {
            if(other.kind != TypeKind.STRUCT) {
                return false
            }
            if(this.typeid == other.typeid) {
                return true
            }
            var aggInfo = other as (*AggregateTypeInfo)
            if(aggInfo.decl.fields.empty()) {
                return false
            }

            var field = aggInfo.getFieldByPosition(0)
            return this.isDeclarable(field.typeInfo)
        }
        case TypeKind.UNION: {
            if(other.kind != TypeKind.UNION) {
                return false
            }

            if(this.typeid == other.typeid) {
                return true
            }
            var aggInfo = other as (*AggregateTypeInfo)
            if(aggInfo.decl.fields.empty()) {
                return false
            }

            var field = aggInfo.getFieldByPosition(0)
            return this.isDeclarable(field.typeInfo)
        }
        case TypeKind.ENUM: {
            if(other.kind != TypeKind.ENUM) {
                return IsInteger(other)
            }
            return this.typeid == other.typeid
        }
        case TypeKind.FUNC: {
            // TODO
            assert(false)
            break;
        }
        case TypeKind.POISON: {
            return false;
        }
        default: {
            assert(false)
        }
    }
    return false
}


public func (this: *TypeInfo) canCastTo(castTo: *TypeInfo) : bool {
    if(IsPtrOf(castTo, TypeKind.VOID)) {
        return true
    }

    if(castTo.kind == TypeKind.NULL) {
        return false
    }

    switch(this.kind) {
        case TypeKind.BOOL: {
            return IsNumberLike(castTo)
        }
        case TypeKind.CHAR: {
            return IsNumberLike(castTo)
        }
        case TypeKind.I8: {
            return IsNumberLike(castTo)
        }
        case TypeKind.U8: {
            return IsNumberLike(castTo)
        }
        case TypeKind.I16: {
            return IsNumberLike(castTo)
        }
        case TypeKind.U16: {
            return IsNumberLike(castTo)
        }
        case TypeKind.I32: {
            return IsNumberLike(castTo)
        }
        case TypeKind.U32: {
            return IsNumberLike(castTo)
        }
        case TypeKind.I64: {
            return IsNumberLike(castTo)
        }
        case TypeKind.U64: {
            return IsNumberLike(castTo)
        }
        case TypeKind.F32: {
            return IsNumberLike(castTo)
        }
        case TypeKind.F64: {
            return IsNumberLike(castTo)
        }
        case TypeKind.USIZE: {
            return IsNumberLike(castTo)
        }
        case TypeKind.NULL: {
            return IsPtrLike(castTo)
        }
        case TypeKind.VOID: {
            return castTo.kind == TypeKind.VOID
        }
        // TODO
        case TypeKind.STR: {
            if(IsPtrLike(castTo)) {
                return true
            }
            return this.isDeclarable(castTo)
        }
        case TypeKind.ARRAY: {
            return IsPtrLike(castTo)
        }
        case TypeKind.PTR: {

            if(castTo.kind == TypeKind.PTR) {
                return true
            }
            if(IsInteger(castTo)) {
                return true
            }
            // TODO: this is wide open right now!
            return this.isDeclarable(castTo)
        }
        case TypeKind.FUNC_PTR: {
            return this.isDeclarable(castTo)
        }

        case TypeKind.STRUCT: {
            return this.isDeclarable(castTo)
        }
        case TypeKind.UNION: {
            return this.isDeclarable(castTo)
        }
        case TypeKind.ENUM: {
            return this.isDeclarable(castTo)
        }
        case TypeKind.FUNC: {
            return this.isDeclarable(castTo)
        }

        case TypeKind.CONST: {
            if(castTo.kind != TypeKind.CONST) {
                return false
            }
            return this.isDeclarable(castTo)
        }
        case TypeKind.POISON: {
            return false;
        }
        default: {
            assert(false)
        }
    }
    return false
}


public func (this: *TypeInfo) asTypeSpec(allocator: *const Allocator) : *TypeSpec {
    var pos = (this.sym) ? this.sym.decl.startPos : SrcPos{};

    switch(this.kind) {
        case TypeKind.BOOL: {
            return NewNameTypeSpec(pos, "bool", allocator) as (*TypeSpec)
        }
        case TypeKind.CHAR: {
            return NewNameTypeSpec(pos, "char", allocator) as (*TypeSpec)
        }
        case TypeKind.I8: {
            return NewNameTypeSpec(pos, "i8", allocator) as (*TypeSpec)
        }
        case TypeKind.U8: {
            return NewNameTypeSpec(pos, "u8", allocator) as (*TypeSpec)
        }
        case TypeKind.I16: {
            return NewNameTypeSpec(pos, "i16", allocator) as (*TypeSpec)
        }
        case TypeKind.U16: {
            return NewNameTypeSpec(pos, "u16", allocator) as (*TypeSpec)
        }
        case TypeKind.I32: {
            return NewNameTypeSpec(pos, "i32", allocator) as (*TypeSpec)
        }
        case TypeKind.U32: {
            return NewNameTypeSpec(pos, "u32", allocator) as (*TypeSpec)
        }
        case TypeKind.I64: {
            return NewNameTypeSpec(pos, "i64", allocator) as (*TypeSpec)
        }
        case TypeKind.U64: {
            return NewNameTypeSpec(pos, "u64", allocator) as (*TypeSpec)
        }
        case TypeKind.F32: {
            return NewNameTypeSpec(pos, "f32", allocator) as (*TypeSpec)
        }
        case TypeKind.F64: {
            return NewNameTypeSpec(pos, "f64", allocator) as (*TypeSpec)
        }
        case TypeKind.USIZE: {
            return NewNameTypeSpec(pos, "usize", allocator) as (*TypeSpec)
        }
        case TypeKind.NULL: {
            return NewNameTypeSpec(pos, "null", allocator) as (*TypeSpec)
        }
        case TypeKind.VOID: {
            return NewNameTypeSpec(pos, "void", allocator) as (*TypeSpec)
        }
        case TypeKind.STR: {
            return NewNameTypeSpec(pos, "*const char", allocator) as (*TypeSpec)
        }
        case TypeKind.ARRAY: {
            var arrayInfo = this as (*ArrayTypeInfo)
            var arrayTypeSpec = NewTypeSpec(TypeSpecKind.ARRAY, pos, allocator) as (*ArrayTypeSpec)
            arrayTypeSpec.base = arrayInfo.arrayOf.asTypeSpec(allocator)
            arrayTypeSpec.numElements = arrayInfo.numOfElements
            return arrayTypeSpec as (*TypeSpec)
        }
        case TypeKind.PTR: {
            var ptrInfo = this as (*PtrTypeInfo)
            var ptrTypeSpec = NewTypeSpec(TypeSpecKind.PTR, pos, allocator) as (*PtrTypeSpec)
            ptrTypeSpec.base = ptrInfo.ptrOf.asTypeSpec(allocator)
            return ptrTypeSpec as (*TypeSpec)
        }
        case TypeKind.CONST: {
            var constInfo = this as (*ConstTypeInfo)
            var constTypeSpec = NewTypeSpec(TypeSpecKind.CONST, pos, allocator) as (*ConstTypeSpec)
            constTypeSpec.base = constInfo.constOf.asTypeSpec(allocator)
            return constTypeSpec as (*TypeSpec)
        }
        case TypeKind.FUNC_PTR: {
            var funcInfo = this as (*FuncPtrTypeInfo)
            var args = Array<*TypeSpec>{}
            args.init(funcInfo.paramDecls.size(), allocator)
            for(var i = 0; i < funcInfo.paramDecls.size(); i += 1) {
                var param = funcInfo.paramDecls.get(i)
                args.add(param.asTypeSpec(allocator))
            }

            var result = NewTypeSpec(TypeSpecKind.FUNC_PTR, pos, allocator) as (*FuncPtrTypeSpec)
            result.ret = funcInfo.returnType.asTypeSpec(allocator)
            result.args = args
            result.hasVarargs = funcInfo.hasVarargs
            result.genericParams = funcInfo.genericParams
            return result as (*TypeSpec)
        }

        case TypeKind.UNION:
        case TypeKind.STRUCT: {
            var aggInfo = this as (*AggregateTypeInfo)
            var result = NewNameTypeSpec(pos, aggInfo.name, allocator)

            var args = Array<*TypeSpec>{}
            args.init(aggInfo.decl.genericParams.size(), allocator)
            for(var i = 0; i < aggInfo.decl.genericParams.size(); i += 1) {
                var param = aggInfo.decl.genericParams.get(i)
                var name = allocator.alloc((param.name.str.length+1) * sizeof(:char)) as (*char)
                param.name.str.copyTo(name, param.name.str.length)

                args.add(NewNameTypeSpec(pos, name, allocator) as (*TypeSpec))
            }

            result.genericArgs = args;
            return result as (*TypeSpec)
        }
        case TypeKind.ENUM: {
            var info = this as (*EnumTypeInfo)
            return NewNameTypeSpec(pos, info.name, allocator) as (*TypeSpec)
        }
        case TypeKind.FUNC: {
            var info = this as (*FuncTypeInfo)
            return NewNameTypeSpec(pos, info.name, allocator) as (*TypeSpec)
        }
        case TypeKind.POISON: {
            return NewNameTypeSpec(pos, "<poison>", allocator) as (*TypeSpec)
        }
        default: {
            assert(false)
        }
    }
    return null
}

public func (this: *FuncTypeInfo) asPtr(typeCache: *TypeCache) : *FuncPtrTypeInfo {
    var genericParams = ArrayInit<GenericParam>(this.decl.genericParams.size(), typeCache.allocator)
    genericParams.addAll(this.decl.genericParams)
    var paramDecls = ArrayInit<*TypeInfo>(this.decl.params.size(), typeCache.allocator)
    for(var i = 0; i < this.decl.params.size() ; i += 1) {
        var p = this.decl.params.get(i)
        paramDecls.add(p.typeInfo)
    }
    return typeCache.newFuncPtrTypeInfo(genericParams, this.returnType, paramDecls, this.decl.flags & FuncFlags.HAS_VARARGS)
}


public func (this: *EnumTypeInfo) getField(name: *const char) : *EnumFieldEntryDecl {
    assert(this != null)
    for(var i = 0; i < this.decl.fields.size(); i+=1) {
        var field = this.decl.fields.get(i)
        if(field.name.str.equals(name)) {
            return field
        }
    }

    return null
}

public func (this: *EnumTypeInfo) getFieldIndex(name: *const char) : i32 {
    assert(this != null)
    for(var i = 0; i < this.decl.fields.size(); i+=1) {
        var field = this.decl.fields.get(i)
        if(field.name.str.equals(name)) {
            return i
        }
    }

    return -1
}


public func (this: *AggregateTypeInfo) getBaseName(name: [MAX_SYMBOL_NAME]char) : *const char {
    assert(this != null)

    var index = 0
    var n = this.name

    while(*n) {
        var c = *n
        if(c == '<') {
            break;
        }

        name[index] = c
        n+=1;
        index += 1;
    }


    name[index] = '\0'

    return name
}


public func (this: *AggregateTypeInfo) getFieldByPosition(position: i32) : FieldStmt {
    assert(this != null)
    if(position < 0 || position >= this.decl.fields.size()) {
        return FieldStmt {
            .kind = StmtKind.POISON_EXPR
        }
    }

    return this.decl.fields.get(position)
}

public func (this: *AggregateTypeInfo) getField(name: *const char) : FieldStmt {
    assert(this != null)

    for(var i = 0; i < this.decl.fields.size(); i+=1) {
        var field = this.decl.fields.get(i)
        switch(field.kind) {
            case StmtKind.VAR_FIELD_DECL: {
                var varField = field.varField
                if(varField.name.str.equals(name)) {
                    if(!field.typeInfo) {
                        goto err;
                    }
                    return field
                }
                break;
            }
            case StmtKind.ENUM_FIELD_DECL: {
                var enumField = field.enumField
                if(enumField.name.str.equals(name)) {
                    return field
                }
                break;
            }
            case StmtKind.UNION_FIELD_DECL:
            case StmtKind.STRUCT_FIELD_DECL: {
                var aggField = field.aggregateField

                // if this is an anonymous aggregate, the fields
                // should be looked at for matching
                if(aggField.name.type == TokenType.VOID) {
                    var aggType = aggField.sym.type as (*AggregateTypeInfo)
                    var result = aggType.getField(name)
                    if(result.kind != StmtKind.POISON_EXPR) {
                        return result
                    }
                }

                if(aggField.name.str.equals(name)) {
                    return field
                }
                // TODO: Account for using field aggregates
                break;
            }
            default: {
                goto err;
            }
        }
    }
err:
    return FieldStmt {
        .kind = StmtKind.POISON_EXPR
    }
}

@doc("Gets the field position in this aggregate type (including anonymous aggregates) only")
public func (this: *AggregateTypeInfo) getFieldIndex(name: *const char) : i32 {
    assert(this != null)

    var index = 0
    for(var i = 0; i < this.decl.fields.size(); i+=1) {
        var field = this.decl.fields.get(i)
        switch(field.kind) {
            case StmtKind.VAR_FIELD_DECL: {
                var varField = field.varField
                if(varField.name.str.equals(name)) {
                    if(!field.typeInfo) {
                        goto err;
                    }
                    return index
                }
                break;
            }
            case StmtKind.ENUM_FIELD_DECL: {
                var enumField = field.enumField
                if(enumField.name.str.equals(name)) {
                    return index
                }
                break;
            }
            case StmtKind.UNION_FIELD_DECL:
            case StmtKind.STRUCT_FIELD_DECL: {
                var aggField = field.aggregateField

                // if this is an anonymous aggregate, the fields
                // should be looked at for matching
                if(aggField.name.type == TokenType.VOID) {
                    var aggType = aggField.sym.type as (*AggregateTypeInfo)
                    var result = aggType.getFieldIndex(name)

                    // build the appropriate index
                    if(result < 0) {
                        index += aggType.decl.fields.size()
                    }
                    else {
                        return index + result
                    }
                }

                if(aggField.name.str.equals(name)) {
                    return index
                }
                // TODO: Account for using field aggregates
                break;
            }
            default: {
                goto err;
            }
        }
    }
err:
    return -1
}

public struct FieldPositionResult {
    aggInfo: *AggregateTypeInfo
    position: i32
}

@doc("Gets the field position in this aggregate type and any using sub aggregates")
public func (this: *AggregateTypeInfo) getFieldPosition(name: *const char) : FieldPositionResult {

    // Find the aggregate type of this field -- we have
    // to do some object traversels because of the 'using'
    var path = FieldPath{}
    if(this.getFieldPath(name, &path)) {
        var aggInfo = this
        var index = path.numOfFields - 1
        while(index > 0) {
            var fieldInfo = path.fields[index].typeInfo
            if(IsAggregate(fieldInfo)) {
                aggInfo = fieldInfo as (*AggregateTypeInfo)
                break
            }

            index -= 1
        }

        return FieldPositionResult {
            .aggInfo = aggInfo,
            .position = aggInfo.getFieldIndex(name)
        }
    }

    return FieldPositionResult {
        .aggInfo = null,
        .position = -1
    }
}


@doc("""
Gets the first field of the supplied type.  This should only be used for finding 'using'
fields to match against and the supplied type should be an aggregate (i.e., not a pointer)
""")
public func (this: *AggregateTypeInfo) getFieldByType(type: *AggregateTypeInfo, isParent: bool = true) : FieldStmt {
    assert(this != null)

    var isGenericCapable = type.sym.isGenericCapable()

    for(var i = 0; i < this.decl.fields.size(); i+=1) {
        var field = this.decl.fields.get(i)

        if(!IsAggregateLike(field.typeInfo)) {
            continue
        }

        if(isParent && field.kind == StmtKind.VAR_FIELD_DECL) {
            if(!field.varField.attributes.isUsing) {
                continue
            }
        }

        var fieldBaseType = field.typeInfo.getBaseType() as (*AggregateTypeInfo)

        if(fieldBaseType.sym.isGenericCapable() && isGenericCapable) {
            if(fieldBaseType.genericTypeid == type.genericTypeid) {
                return field
            }
        }

        if(fieldBaseType.typeid == type.typeid) {
            return field
        }

        switch(field.kind) {
            case StmtKind.VAR_FIELD_DECL: {
                break;
            }
            case StmtKind.ENUM_FIELD_DECL: {
                break;
            }
            case StmtKind.UNION_FIELD_DECL:
            case StmtKind.STRUCT_FIELD_DECL: {
                var aggField = field.aggregateField

                // if this is an anonymous aggregate, the fields
                // should be looked at for matching
                if(aggField.name.type == TokenType.VOID) {
                    var aggType = aggField.sym.type as (*AggregateTypeInfo)
                    var result = aggType.getFieldByType(type, false)
                    if(result.kind != StmtKind.POISON_EXPR) {
                        return result
                    }
                }
                break;
            }
            default: {
            }
        }
    }

    return FieldStmt {
        .kind = StmtKind.POISON_EXPR
    }
}


public func (this: *AggregateTypeInfo) getFieldWithUsing(name: *const char) : FieldStmt {
    assert(this != null)

    var fieldStmt = this.getField(name)
    if(fieldStmt.kind != StmtKind.POISON_EXPR) {
        return fieldStmt
    }

    for(var i = 0; i < this.decl.fields.size(); i+=1) {
        var field = this.decl.fields.get(i)
        switch(field.kind) {
            case StmtKind.VAR_FIELD_DECL: {
                var varField = field.varField
                if(!varField.attributes.isUsing) {
                    continue;
                }

                if(!IsAggregate(field.typeInfo) && !IsPtrAggregate(field.typeInfo)) {
                    continue;
                }

                var baseType = field.typeInfo.getBaseType() as (*AggregateTypeInfo)
                assert(baseType.kind == TypeKind.STRUCT || baseType.kind == TypeKind.UNION)

                fieldStmt = baseType.getFieldWithUsing(name)
                if(fieldStmt.kind != StmtKind.POISON_EXPR) {
                    return fieldStmt
                }

                break;
            }
            default: {
                continue;
            }
        }
    }

    return FieldStmt {
        .kind = StmtKind.POISON_EXPR
    }
}


public const MAX_FIELD_PATH = 256
public struct FieldPath {
    fields: [MAX_FIELD_PATH]FieldStmt
    numOfFields: i32
}

func (this: *FieldPath) add(field: FieldStmt) {
    this.fields[this.numOfFields] = field
    this.numOfFields += 1
    assert(this.numOfFields < MAX_FIELD_PATH)
}

func (this: *FieldPath) pop() {
    this.numOfFields -= 1
    if(this.numOfFields < 0) {
        this.numOfFields = 0
    }
}


public func (this: *AggregateTypeInfo) getFieldPath(name: *const char, path: *FieldPath) : bool {
    assert(this != null)

    var fieldStmt = this.getField(name)
    if(fieldStmt.kind != StmtKind.POISON_EXPR) {
        path.add(fieldStmt)
        return true
    }

    for(var i = 0; i < this.decl.fields.size(); i+=1) {
        var field = this.decl.fields.get(i)
        switch(field.kind) {
            case StmtKind.VAR_FIELD_DECL: {
                var varField = field.varField
                if(!varField.attributes.isUsing) {
                    continue;
                }

                if(!IsAggregate(field.typeInfo) && !IsPtrAggregate(field.typeInfo)) {
                    continue;
                }

                var baseType = field.typeInfo.getBaseType() as (*AggregateTypeInfo)
                assert(baseType.kind == TypeKind.STRUCT || baseType.kind == TypeKind.UNION)

                path.add(field)

                if(baseType.getFieldPath(name, path)) {
                    return true
                }

                path.pop()

                break;
            }
            default: {
                continue;
            }
        }
    }

    return false
}

public func (this: *AggregateTypeInfo) getFieldPathByType(type: *AggregateTypeInfo, path: *FieldPath) : bool {
    assert(this != null)

    var fieldStmt = this.getFieldByType(type)
    if(fieldStmt.kind != StmtKind.POISON_EXPR) {
        path.add(fieldStmt)
        return true
    }

    for(var i = 0; i < this.decl.fields.size(); i+=1) {
        var field = this.decl.fields.get(i)
        switch(field.kind) {
            case StmtKind.VAR_FIELD_DECL: {
                var varField = field.varField
                if(!varField.attributes.isUsing) {
                    continue;
                }

                if(!IsAggregateLike(field.typeInfo)) {
                    continue;
                }

                var baseType = field.typeInfo.getBaseType() as (*AggregateTypeInfo)
                assert(baseType.kind == TypeKind.STRUCT || baseType.kind == TypeKind.UNION)

                path.add(field)

                if(baseType.getFieldPathByType(type, path)) {
                    return true
                }

                path.pop()

                break;
            }
            case StmtKind.UNION_FIELD_DECL:
            case StmtKind.STRUCT_FIELD_DECL: {
                //var aggField = field.aggregateField
                // TODO: ?
                assert(false)
            }
            default: {
                continue;
            }
        }
    }

    return false
}

@doc("""
Given a method name, this will return the function name equivalent, which is:
AggregateName_MethodName
""")
public func (this: *AggregateTypeInfo) getFunctionName(result: [MAX_SYMBOL_NAME]char, methodName: *const char) : *const char {
    memset(result, 0, MAX_SYMBOL_NAME)
    this.getBaseName(result);

    strcat(result, "_")
    strcat(result, methodName)

    return (result)
}

public func (this: *AggregateTypeInfo) getMethod(module: *Module, methodName: *const char) : *Symbol {
    var funcName = [MAX_SYMBOL_NAME]char {0};
    this.getFunctionName(funcName, methodName)

    // first see if the aggregate declaration module has the method
    var methodSym = this.sym.declared.getType(funcName)
    if(methodSym == null || methodSym.kind != SymbolKind.FUNC) {
        // otherwise look in the current module
        methodSym = module.getType(funcName)
    }

    if(methodSym == null || methodSym.kind != SymbolKind.FUNC) {
        return null;
    }

    var decl = methodSym.decl as (*FuncDecl)
    if(!(decl.flags & FuncFlags.IS_METHOD)) {
        return null
    }

    if(decl.params.empty()) {
        return null
    }

    var base = decl.params.first().typeInfo.getBaseType()


    // If this is a generic type, we need to compare against the original
    // template types for equality
    if(methodSym.flags & SymbolFlags.IS_GENERIC_TEMPLATE) {
        var thisGenericType = this as (*GenericTypeInfo)
        var baseGenericType = base as (*GenericTypeInfo)
        if(thisGenericType.genericTypeid == baseGenericType.genericTypeid) {
            return methodSym;
        }
    }

    if(this.strictEquals(base)) {
        return methodSym;
    }

    // TODO: Check if this is 'using' base
    return null
}

public typedef i64 as Typeid;
var idGen: Typeid = TypeKind.MAX_TYPE_KINDS as (i64);

public func NextTypeId() : Typeid {
    idGen += 1
    return idGen;
}

public struct TypeInfo {
    kind: TypeKind
    typeid: Typeid
    name: *const char
    sym: *Symbol
}

public struct GenericTypeInfo {
    typeInfo: using TypeInfo
    genericTypeid: Typeid       // The typeid of the original Generic Template
}

public struct FuncTypeInfo {
    info: using GenericTypeInfo
    returnType: *TypeInfo
    decl: *FuncDecl
}

public struct ConstTypeInfo {
    info: using TypeInfo
    constOf: *TypeInfo
}

public struct PtrTypeInfo {
    info: using TypeInfo
    ptrOf: *TypeInfo
}

public struct ArrayTypeInfo {
    info: using TypeInfo
    arrayOf: *TypeInfo
    length: usize
    numOfElements: *Expr
    isLengthDefined: bool
}

public struct FuncPtrTypeInfo {
    info: using GenericTypeInfo
    genericParams: Array<GenericParam>
    returnType: *TypeInfo
    paramDecls: Array<*TypeInfo>
    hasVarargs: bool
}

public struct EnumTypeInfo {
    info: using TypeInfo
    decl: *EnumDecl
}

public struct AggregateTypeInfo {
    info: using GenericTypeInfo
    decl: *AggregateDecl
}

public const BOOL_TYPE = TypeInfo {
    .kind = TypeKind.BOOL,
    .typeid = TypeKind.BOOL as (Typeid),
    .name = "bool",
    .sym = null
}

public const CHAR_TYPE = TypeInfo {
    .kind = TypeKind.CHAR,
    .typeid = TypeKind.CHAR as (Typeid),
    .name = "char",
    .sym = null
}

public const I8_TYPE = TypeInfo {
    .kind = TypeKind.I8,
    .typeid = TypeKind.I8 as (Typeid),
    .name = "i8",
    .sym = null
}

public const U8_TYPE = TypeInfo {
    .kind = TypeKind.U8,
    .typeid = TypeKind.U8 as (Typeid),
    .name = "u8",
    .sym = null
}

public const I16_TYPE = TypeInfo {
    .kind = TypeKind.I16,
    .typeid = TypeKind.I16 as (Typeid),
    .name = "i16",
    .sym = null
}

public const U16_TYPE = TypeInfo {
    .kind = TypeKind.U16,
    .typeid = TypeKind.U16 as (Typeid),
    .name = "u16",
    .sym = null
}

public const I32_TYPE = TypeInfo {
    .kind = TypeKind.I32,
    .typeid = TypeKind.I32 as (Typeid),
    .name = "i32",
    .sym = null
}

public const U32_TYPE = TypeInfo {
    .kind = TypeKind.U32,
    .typeid = TypeKind.U32 as (Typeid),
    .name = "u32",
    .sym = null
}

public const I64_TYPE = TypeInfo {
    .kind = TypeKind.I64,
    .typeid = TypeKind.I64 as (Typeid),
    .name = "i64",
    .sym = null
}

public const U64_TYPE = TypeInfo {
    .kind = TypeKind.U64,
    .typeid = TypeKind.U64 as (Typeid),
    .name = "u64",
    .sym = null
}

public const F32_TYPE = TypeInfo {
    .kind = TypeKind.F32,
    .typeid = TypeKind.F32 as (Typeid),
    .name = "f32",
    .sym = null
}

public const F64_TYPE = TypeInfo {
    .kind = TypeKind.F64,
    .typeid = TypeKind.F64 as (Typeid),
    .name = "f64",
    .sym = null
}

public const USIZE_TYPE = TypeInfo {
    .kind = TypeKind.USIZE,
    .typeid = TypeKind.USIZE as (Typeid),
    .name = "usize",
    .sym = null
}

public const NULL_TYPE = TypeInfo {
    .kind = TypeKind.NULL,
    .typeid = TypeKind.NULL as (Typeid),
    .name = "null",
    .sym = null
}

public const VOID_TYPE = TypeInfo {
    .kind = TypeKind.VOID,
    .typeid = TypeKind.VOID as (Typeid),
    .name = "void",
    .sym = null
}

public const STR_TYPE = TypeInfo {
    .kind = TypeKind.STR,
    .typeid = TypeKind.STR as (Typeid),
    .name = "*const char",
    .sym = null
}

public const POISON_TYPE = TypeInfo {
    .kind = TypeKind.POISON,
    .typeid = TypeKind.POISON as (Typeid),
    .name = "<poison>",
    .sym = null
}