import "string_view"
import "string_buffer"
import "symbols"
import "ast"
import "lex"
import "array"
import "assert"
import "libc"

@asStr
public enum TypeKind {
    BOOL,
    CHAR,
    I8,
    U8,
    I16,
    U16,
    I32,
    U32,
    I64,
    U64,
    F32,
    F64,
    USIZE,
    NULL,
    VOID,

    STR,
    ARRAY,
    PTR,
    FUNC_PTR,

    STRUCT,
    UNION,
    ENUM,
    FUNC,

    CONST,
    GENERIC_PARAM,

    MAX_TYPE_KINDS
}

const typeKindText = []*const char {
    [TypeKind.BOOL] = "bool",
    [TypeKind.CHAR] = "char",
    [TypeKind.I8] = "i8",
    [TypeKind.U8] = "u8",
    [TypeKind.I16] = "i16",
    [TypeKind.U16] = "u16",
    [TypeKind.I32] = "i32",
    [TypeKind.U32] = "u32",
    [TypeKind.I64] = "i64",
    [TypeKind.U64] = "u64",
    [TypeKind.F32] = "f32",
    [TypeKind.F64] = "f64",
    [TypeKind.USIZE] = "usize",
    [TypeKind.NULL] = "null",
    [TypeKind.VOID] = "void",

    [TypeKind.STR] = "string",
    [TypeKind.ARRAY] = "array",
    [TypeKind.PTR] = "pointer",
    [TypeKind.FUNC_PTR] = "func_pointer",

    [TypeKind.STRUCT] = "struct",
    [TypeKind.UNION] = "union",
    [TypeKind.ENUM] = "enum",
    [TypeKind.FUNC] = "func",

    [TypeKind.CONST] = "const",
    [TypeKind.GENERIC_PARAM] = "generic_param",

    [TypeKind.MAX_TYPE_KINDS] = "",
}

public func TypeKindFromString(str: *const char, len: i32) : TypeKind {
    var view = StringViewInit(str, len)
    for(var i = TypeKind.BOOL; i < TypeKind.MAX_TYPE_KINDS; i += 1) {
        if(view.equals(typeKindText[i])) {
            return i;
        }
    }

    return TypeKind.MAX_TYPE_KINDS
}

public func IsPtr(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    if(type.kind == TypeKind.CONST) {
        var constInfo = type as (*ConstTypeInfo)
        return IsPtr(constInfo.constOf)
    }

    return type.kind == TypeKind.PTR
}

public func IsPtrLike(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.PTR:
        case TypeKind.STR:
        case TypeKind.ARRAY: {
            return true;
        }
        case TypeKind.CONST: {
            var constInfo = type as (*ConstTypeInfo)
            return IsPtrLike(constInfo.constOf)
        }
        default: {
            return false;
        }
    }
}

public func IsPtrOf(type: *TypeInfo, kind: TypeKind) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.PTR: {
            var ptrInfo = type as (*PtrTypeInfo)
            return ptrInfo.ptrOf.kind == kind
        }
        case TypeKind.STR: {
            return kind == TypeKind.CHAR
        }
        case TypeKind.ARRAY: {
            var arrayInfo = type as (*ArrayTypeInfo)
            return arrayInfo.arrayOf.kind == kind
        }
        case TypeKind.CONST: {
            var constInfo = type as (*ConstTypeInfo)
            return constInfo.constOf.kind == kind
        }
        default: {
            return false;
        }
    }
}

public func IsFuncLike(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.FUNC:
        case TypeKind.FUNC_PTR: {
            return true;
        }
        default: {
            return false;
        }
    }
}

public func IsPrimitive(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    return type.kind < TypeKind.STR
}

public func IsNumberLike(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.BOOL:
        case TypeKind.CHAR:
        case TypeKind.I8:
        case TypeKind.U8:
        case TypeKind.I16:
        case TypeKind.U16:
        case TypeKind.I32:
        case TypeKind.U32:
        case TypeKind.I64:
        case TypeKind.U64:
        case TypeKind.F32:
        case TypeKind.F64:
        case TypeKind.USIZE:
        case TypeKind.PTR:
        case TypeKind.STR:
        case TypeKind.ARRAY:
        case TypeKind.NULL:
        case TypeKind.ENUM: {
            return true;
        }
        case TypeKind.CONST: {
            var constInfo = type as (*ConstTypeInfo)
            return IsNumberLike(constInfo.constOf)
        }
        default: {
            return false
        }
    }
}

public func IsInteger(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.BOOL:
        case TypeKind.CHAR:
        case TypeKind.I8:
        case TypeKind.U8:
        case TypeKind.I16:
        case TypeKind.U16:
        case TypeKind.I32:
        case TypeKind.U32:
        case TypeKind.I64:
        case TypeKind.U64:        
        case TypeKind.USIZE:
        case TypeKind.ENUM: {
            return true;
        }
        case TypeKind.CONST: {
            var constInfo = type as (*ConstTypeInfo)
            return IsInteger(constInfo.constOf)
        }
        default: {
            return false
        }
    }
}

public func IsBooleanable(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.BOOL:
        case TypeKind.CHAR:
        case TypeKind.I8:
        case TypeKind.U8:
        case TypeKind.I16:
        case TypeKind.U16:
        case TypeKind.I32:
        case TypeKind.U32:
        case TypeKind.I64:
        case TypeKind.U64:
        case TypeKind.F32:
        case TypeKind.F64:
        case TypeKind.USIZE:
        case TypeKind.PTR:
        case TypeKind.STR:
        case TypeKind.ARRAY:
        case TypeKind.NULL:
        case TypeKind.ENUM: {
            return true;
        }
        case TypeKind.CONST: {
            var constInfo = type as (*ConstTypeInfo)
            return IsBooleanable(constInfo.constOf)
        }
        default: {
            return false
        }
    }
}

public func IsAggregate(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    if(type.kind == TypeKind.CONST) {
        var constInfo = type as (*ConstTypeInfo)
        return IsAggregate(constInfo.constOf)
    }

    return type.kind == TypeKind.STRUCT ||
           type.kind == TypeKind.UNION
}

public func IsPtrAggregate(type: *TypeInfo) : bool {
    if(!IsPtr(type)) {
        return false;
    }
    var ptrInfo: *TypeInfo = null
    if(type.kind == TypeKind.CONST) {
        var constInfo = type as (*ConstTypeInfo)
        ptrInfo = constInfo.constOf
    }
    else {
        ptrInfo = (type as (*PtrTypeInfo)).ptrOf
    }
    return IsAggregate(ptrInfo)
}

public func IsFieldAccessible(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    if(IsAggregate(type) || IsPtrAggregate(type) || type.kind == TypeKind.ENUM) {
        return true
    }

    return false
}

public func (this: *TypeInfo) getBaseType() : *TypeInfo {
    if(!this) return null;
    switch(this.kind) {
        case TypeKind.PTR: {
            var info = this as (*PtrTypeInfo)
            return info.ptrOf.getBaseType()
        }
        case TypeKind.CONST: {
            var info = this as (*ConstTypeInfo)
            return info.constOf.getBaseType()
        }
        case TypeKind.ARRAY: {
            var info = this as (*ArrayTypeInfo)
            return info.arrayOf.getBaseType()
        }
        case TypeKind.STR: {
            return &CHAR_TYPE
        }
        default: {
            return this
        }
    }
}

public func (this: *TypeInfo) toString(sb: *StringBuffer) {
    if(!this) return;

    switch(this.kind) {
        case TypeKind.BOOL:
        case TypeKind.CHAR:
        case TypeKind.I8:
        case TypeKind.U8:
        case TypeKind.I16:
        case TypeKind.U16:
        case TypeKind.I32:
        case TypeKind.U32:
        case TypeKind.I64:
        case TypeKind.U64:
        case TypeKind.F32:
        case TypeKind.F64:
        case TypeKind.USIZE:
        case TypeKind.NULL:
        case TypeKind.VOID:
        case TypeKind.STRUCT: 
        case TypeKind.UNION: 
        case TypeKind.ENUM:
            sb.append(this.name)
            break;
        case TypeKind.STR: {
            sb.append("*const char")
            break;
        }
        case TypeKind.ARRAY: {
            var arrayInfo = this as (*ArrayTypeInfo)
            if(arrayInfo.length) {
                sb.append("[%llu]", arrayInfo.length)
            }
            else {
                sb.append("[]")
            }
            arrayInfo.arrayOf.toString(sb)
            break;
        }
        case TypeKind.PTR: {
            var ptrInfo = this as (*PtrTypeInfo)
            sb.append("*")
            ptrInfo.ptrOf.toString(sb)
            break;
        }
        case TypeKind.CONST: {
            var constInfo = this as (*ConstTypeInfo)
            sb.append("const ")
            constInfo.constOf.toString(sb)
            break;
        }
        case TypeKind.FUNC_PTR: {
            var funcPtrInfo = this as (*FuncPtrTypeInfo)
            sb.append("func")
            if(!funcPtrInfo.genericParams.empty()) {
                sb.append("<")
                for(var i = 0; i < funcPtrInfo.genericParams.size(); i += 1) {
                    if(i > 0) sb.append(",")                    
                    var t = funcPtrInfo.genericParams.get(i).name                    
                    sb.append("%.*s", t.value.str.length, t.value.str.buffer)
                }
                sb.append(">")
            }
            sb.append("(")
            for(var i = 0; i < funcPtrInfo.paramDecls.size(); i += 1) {
                if(i > 0) sb.append(",")
                var paramType = funcPtrInfo.paramDecls.get(i)
                paramType.toString(sb)
            }
            sb.append(") : ")
            funcPtrInfo.returnType.toString(sb)
            break;
        }
        case TypeKind.FUNC: {
            var funcInfo = this as (*FuncTypeInfo)
            sb.append("func")
            if(!funcInfo.genericParams.empty()) {
                sb.append("<")
                for(var i = 0; i < funcInfo.genericParams.size(); i += 1) {
                    if(i > 0) sb.append(",")                    
                    var t = funcInfo.genericParams.get(i).name                    
                    sb.append("%.*s", t.value.str.length, t.value.str.buffer)
                }
                sb.append(">")
            }
            sb.append("(")
            for(var i = 0; i < funcInfo.decl.params.size(); i += 1) {
                if(i > 0) sb.append(",")
                var paramType = funcInfo.decl.params.get(i)
                paramType.typeInfo.toString(sb)
            }
            sb.append(") : ")
            funcInfo.returnType.toString(sb)
            break;
        }
        default: {
            assert(false)
        }
    }
}

public func (this: *TypeInfo) strictEquals(other: *TypeInfo) : bool {
    if(!other) {
        return false
    }

    if(other.kind != this.kind) {
        return false
    }

    switch(this.kind) {
        case TypeKind.PTR: {
            var thisInfo = this as (*PtrTypeInfo)
            var otherInfo = other as (*PtrTypeInfo)
            return thisInfo.ptrOf.strictEquals(otherInfo.ptrOf)
        }
        case TypeKind.CONST: {
            var thisInfo = this as (*ConstTypeInfo)
            var otherInfo = other as (*ConstTypeInfo)
            return thisInfo.constOf.strictEquals(otherInfo.constOf)
        }
        case TypeKind.ARRAY: {
            var thisInfo = this as (*ArrayTypeInfo)
            var otherInfo = other as (*ArrayTypeInfo)
            if(thisInfo.length != otherInfo.length) {
                return false;
            }
            return thisInfo.arrayOf.strictEquals(otherInfo.arrayOf)
        }
        case TypeKind.FUNC_PTR: {
            var thisInfo = this as (*FuncPtrTypeInfo)
            var otherInfo = other as (*FuncPtrTypeInfo)
            if(thisInfo.paramDecls.size() != otherInfo.paramDecls.size()) {
                return false;
            }
            if(!thisInfo.returnType.strictEquals(otherInfo.returnType)) {
                return false;
            }
            for(var i = 0; i < thisInfo.paramDecls.size(); i += 1) {
                var a = thisInfo.paramDecls.get(i)
                var b = otherInfo.paramDecls.get(i)
                if(a.strictEquals(b)) {
                    return false;
                }
            }
            return true
        }
        default: {
            return true
        }
    }

    return false
}

public func (this: *TypeInfo) isAssignable(other: *TypeInfo) : bool {
    assert(this != null)
    assert(other != null)

    // this = other    
    switch(this.kind) {
        case TypeKind.BOOL: {
            return other.kind == TypeKind.BOOL
        }
        case TypeKind.CHAR: {
            return other.kind <= TypeKind.CHAR
        }
        case TypeKind.I8: {
            return other.kind <= TypeKind.I8
        }
        case TypeKind.U8: {
            return other.kind <= TypeKind.U8
        }
        case TypeKind.I16: {
            return other.kind <= TypeKind.I16
        }
        case TypeKind.U16: {
            return other.kind <= TypeKind.U16
        }
        case TypeKind.I32: {
            return other.kind <= TypeKind.I32
        }
        case TypeKind.U32: {
            return other.kind <= TypeKind.U32
        }
        case TypeKind.I64: {
            return other.kind <= TypeKind.I64
        }
        case TypeKind.U64: {
            return other.kind <= TypeKind.U64
        }
        case TypeKind.F32: {
            return other.kind == TypeKind.F32
        }
        case TypeKind.F64: {
            return other.kind == TypeKind.F32 ||
                   other.kind == TypeKind.F64
        }
        case TypeKind.USIZE: {
            return other.kind <= TypeKind.USIZE || 
                   other.kind == TypeKind.NULL ||
                   IsPtrLike(other);
        }
        case TypeKind.NULL: {
            return other.kind == TypeKind.NULL
        }
        case TypeKind.VOID: {
            return other.kind == TypeKind.VOID
        }

        case TypeKind.STR: {            
            return other.kind == TypeKind.STR ||
                   IsPtrOf(other, TypeKind.CHAR)
        }
        case TypeKind.ARRAY: {
            return false
        }
        // TODO
        case TypeKind.PTR: {
            var thisInfo = this as (*PtrTypeInfo)
            if(thisInfo.ptrOf.kind == TypeKind.VOID) {
                return IsPtrLike(other)
            }

            if(other.kind == TypeKind.STR) {
                return thisInfo.ptrOf.isAssignable(&CHAR_TYPE)
            }

            if(other.kind != TypeKind.PTR) {
                return false
            }

            var otherInfo = other as (*PtrTypeInfo)
            return thisInfo.ptrOf.isAssignable(otherInfo.ptrOf)
        }        
        case TypeKind.CONST: {
            var thisInfo = this as (*ConstTypeInfo)

            // Allow for *const char = *char
            if(other.kind != TypeKind.CONST) {
                return thisInfo.constOf.isAssignable(other)
            }

            var otherInfo = other as (*ConstTypeInfo)
            return thisInfo.constOf.isAssignable(otherInfo.constOf)
        }
        case TypeKind.UNION:
        case TypeKind.STRUCT: {
            if(this.kind != other.kind) {
                return false
            }
            var thisInfo = this as (*AggregateTypeInfo)
            var otherInfo = other as (*AggregateTypeInfo)

            if(thisInfo.sym == otherInfo.sym) {
                return true
            }

            if(thisInfo.decl.fields.size() != otherInfo.decl.fields.size()) {
                return false
            }

            for(var i = 0; i < thisInfo.decl.fields.size(); i+=1) {
                var thisField = thisInfo.decl.fields.get(i)
                var otherField = otherInfo.decl.fields.get(i)
                if(!thisField.typeInfo.isAssignable(otherField.typeInfo)) {
                    return false
                }
            }

            return true
        }
        case TypeKind.ENUM: {
            break;
        }        
        case TypeKind.FUNC_PTR: {
            break;
        }
        case TypeKind.FUNC: {
            break;
        }
        default: {
            assert(false)
        }
    }    
    return false
}

public func (this: *TypeInfo) isDeclarable(other: *TypeInfo) : bool {
    // this = other    
    switch(this.kind) {
        case TypeKind.BOOL: {
            return other.kind == TypeKind.BOOL
        }
        case TypeKind.CHAR: {
            return other.kind <= TypeKind.CHAR
        }
        case TypeKind.I8: {
            return other.kind <= TypeKind.I8
        }
        case TypeKind.U8: {
            return other.kind <= TypeKind.U8
        }
        case TypeKind.I16: {
            return other.kind <= TypeKind.I16
        }
        case TypeKind.U16: {
            return other.kind <= TypeKind.U16
        }
        case TypeKind.I32: {
            return other.kind <= TypeKind.I32
        }
        case TypeKind.U32: {
            return other.kind <= TypeKind.U32
        }
        case TypeKind.I64: {
            return other.kind <= TypeKind.I64
        }
        case TypeKind.U64: {
            return other.kind <= TypeKind.U64
        }
        case TypeKind.F32: {
            return other.kind == TypeKind.F32
        }
        case TypeKind.F64: {
            return other.kind == TypeKind.F32 ||
                   other.kind == TypeKind.F64
        }
        case TypeKind.USIZE: {
            return other.kind == TypeKind.USIZE || 
                   other.kind == TypeKind.NULL ||
                   IsPtrLike(other);
        }
        case TypeKind.NULL: {
            return other.kind == TypeKind.NULL
        }
        case TypeKind.VOID: {
            return other.kind == TypeKind.VOID
        }

        case TypeKind.STR: {
            return other.kind == TypeKind.STR ||
                   IsPtrOf(other, TypeKind.CHAR)
        }
        case TypeKind.ARRAY: {
            if(other.kind != TypeKind.ARRAY) {
                return false
            }
            var thisArray = this as (*ArrayTypeInfo)
            var otherArray = other as (*ArrayTypeInfo)

            if(!thisArray.arrayOf.isDeclarable(otherArray.arrayOf)) {
                return false
            }

            if(!thisArray.length) {
                return true
            }
            return thisArray.length == otherArray.length
        }
        // TODO
        case TypeKind.PTR: {
            break;
        }        
        case TypeKind.CONST: {
            break;
        }

        case TypeKind.FUNC_PTR: {
            break;
        }

        case TypeKind.STRUCT: {
            break;
        }
        case TypeKind.UNION: {
            break;
        }
        case TypeKind.ENUM: {
            break;
        }
        case TypeKind.FUNC: {
            break;
        }
        default: {
            assert(false)
        }
    }    
    return false
}


public func (this: *TypeInfo) canCastTo(castTo: *TypeInfo) : bool {
    switch(this.kind) {
        case TypeKind.BOOL: {
            return IsNumberLike(castTo)
        }
        case TypeKind.CHAR: {
            return IsNumberLike(castTo)
        }
        case TypeKind.I8: {
            return IsNumberLike(castTo)
        }
        case TypeKind.U8: {
            return IsNumberLike(castTo)
        }
        case TypeKind.I16: {
            return IsNumberLike(castTo)
        }
        case TypeKind.U16: {
            return IsNumberLike(castTo)
        }
        case TypeKind.I32: {
            return IsNumberLike(castTo)
        }
        case TypeKind.U32: {
            return IsNumberLike(castTo)
        }
        case TypeKind.I64: {
            return IsNumberLike(castTo)
        }
        case TypeKind.U64: {
            return IsNumberLike(castTo)
        }
        case TypeKind.F32: {
            return IsNumberLike(castTo)
        }
        case TypeKind.F64: {
            return IsNumberLike(castTo)
        }
        case TypeKind.USIZE: {
            return IsNumberLike(castTo)
        }
        case TypeKind.NULL: {
            return IsPtrLike(castTo)
        }
        case TypeKind.VOID: {
            return castTo.kind == TypeKind.VOID
        }
        // TODO
        case TypeKind.STR: {
            break;
        }
        case TypeKind.ARRAY: {
            break;
        }
        case TypeKind.PTR: {
            break;
        }
        case TypeKind.FUNC_PTR: {
            break;
        }

        case TypeKind.STRUCT: {
            break;
        }
        case TypeKind.UNION: {
            break;
        }
        case TypeKind.ENUM: {
            break;
        }
        case TypeKind.FUNC: {
            break;
        }

        case TypeKind.CONST: {
            break;
        }
        default: {
            assert(false)
        }
    }
    return false
}

public func (this: *EnumTypeInfo) getField(name: *const char) : *EnumFieldEntryStmt {
    assert(this != null)
    for(var i = 0; i < this.decl.fields.size(); i+=1) {
        var field = this.decl.fields.get(i)        
        if(field.fieldName.str.equals(name)) {
            return field
        }
    }

    return null
}

public func (this: *AggregateTypeInfo) getFieldByPosition(position: i32) : FieldStmt {
    assert(this != null)
    if(position < 0 || position >= this.decl.fields.size()) {
        return FieldStmt {
            .kind = StmtKind.POISON_EXPR
        }
    }

    return this.decl.fields.get(position)
}

public func (this: *AggregateTypeInfo) getField(name: *const char) : FieldStmt {
    assert(this != null)

    for(var i = 0; i < this.decl.fields.size(); i+=1) {
        var field = this.decl.fields.get(i)
        switch(field.kind) {
            case StmtKind.VAR_FIELD_STMT: {
                var varField = field.varField
                if(varField.fieldName.str.equals(name)) {
                    return field
                }
                break;
            }
            case StmtKind.ENUM_FIELD_STMT: {
                var enumField = field.enumField
                if(enumField.name.str.equals(name)) {
                    return field
                }
                break;
            }
            case StmtKind.UNION_FIELD_STMT: 
            case StmtKind.STRUCT_FIELD_STMT: {
                var aggField = field.aggregateField

                // if this is an anonymous aggregate, the fields
                // should be looked at for matching
                if(aggField.name.type == TokenType.VOID) {
                    var aggType = aggField.sym.type as (*AggregateTypeInfo)
                    return aggType.getField(name)
                }

                if(aggField.name.str.equals(name)) {
                    return field
                }
                // TODO: Account for using field aggregates
                break;
            }
            default: {
                goto err;
            }
        }
    }
err:
    return FieldStmt {
        .kind = StmtKind.POISON_EXPR
    }    
}

public typedef i64 as Typeid;
var idGen: Typeid = TypeKind.MAX_TYPE_KINDS as (i64);

public func NextTypeId() : Typeid {
    idGen += 1
    return idGen;
}

public struct TypeInfo {
    kind: TypeKind
    typeid: Typeid
    name: *const char
    sym: *Symbol
}

public struct FuncTypeInfo {
    info: using TypeInfo   
    genericParams: Array<GenericParam> 
    returnType: *TypeInfo
    decl: *FuncDecl
}

public struct ConstTypeInfo {
    info: using TypeInfo
    constOf: *TypeInfo
}

public struct PtrTypeInfo {
    info: using TypeInfo
    ptrOf: *TypeInfo
}

public struct ArrayTypeInfo {
    info: using TypeInfo
    arrayOf: *TypeInfo
    length: usize
    numOfElements: *Expr
}

public struct FuncPtrTypeInfo {
    info: using TypeInfo
    genericParams: Array<GenericParam>
    returnType: *TypeInfo
    paramDecls: Array<*TypeInfo>
    hasVarargs: bool
}

public struct EnumTypeInfo {
    info: using TypeInfo
    decl: *EnumDecl
}

public struct AggregateTypeInfo {
    info: using TypeInfo
    decl: *AggregateDecl
}

public const BOOL_TYPE = TypeInfo {
    .kind = TypeKind.BOOL,
    .typeid = TypeKind.BOOL as (Typeid),
    .name = "bool",
    .sym = null
}

public const CHAR_TYPE = TypeInfo {
    .kind = TypeKind.CHAR,
    .typeid = TypeKind.CHAR as (Typeid),
    .name = "char",
    .sym = null
}

public const I8_TYPE = TypeInfo {
    .kind = TypeKind.I8,
    .typeid = TypeKind.I8 as (Typeid),
    .name = "i8",
    .sym = null
}

public const U8_TYPE = TypeInfo {
    .kind = TypeKind.U8,
    .typeid = TypeKind.U8 as (Typeid),
    .name = "u8",
    .sym = null
}

public const I16_TYPE = TypeInfo {
    .kind = TypeKind.I16,
    .typeid = TypeKind.I16 as (Typeid),
    .name = "i16",
    .sym = null
}

public const U16_TYPE = TypeInfo {
    .kind = TypeKind.U16,
    .typeid = TypeKind.U16 as (Typeid),
    .name = "u16",
    .sym = null
}

public const I32_TYPE = TypeInfo {
    .kind = TypeKind.I32,
    .typeid = TypeKind.I32 as (Typeid),
    .name = "i32",
    .sym = null
}

public const U32_TYPE = TypeInfo {
    .kind = TypeKind.U32,
    .typeid = TypeKind.U32 as (Typeid),
    .name = "u32",
    .sym = null
}

public const I64_TYPE = TypeInfo {
    .kind = TypeKind.I64,
    .typeid = TypeKind.I64 as (Typeid),
    .name = "i64",
    .sym = null
}

public const U64_TYPE = TypeInfo {
    .kind = TypeKind.U64,
    .typeid = TypeKind.U64 as (Typeid),
    .name = "u64",
    .sym = null
}

public const F32_TYPE = TypeInfo {
    .kind = TypeKind.F32,
    .typeid = TypeKind.F32 as (Typeid),
    .name = "f32",
    .sym = null
}

public const F64_TYPE = TypeInfo {
    .kind = TypeKind.F64,
    .typeid = TypeKind.F64 as (Typeid),
    .name = "f64",
    .sym = null
}

public const USIZE_TYPE = TypeInfo {
    .kind = TypeKind.USIZE,
    .typeid = TypeKind.USIZE as (Typeid),
    .name = "usize",
    .sym = null
}

public const NULL_TYPE = TypeInfo {
    .kind = TypeKind.NULL,
    .typeid = TypeKind.NULL as (Typeid),
    .name = "null",
    .sym = null
}

public const VOID_TYPE = TypeInfo {
    .kind = TypeKind.VOID,
    .typeid = TypeKind.VOID as (Typeid),
    .name = "void",
    .sym = null
}

public const STR_TYPE = TypeInfo {
    .kind = TypeKind.STR,
    .typeid = TypeKind.STR as (Typeid),
    .name = "*char",
    .sym = null
}