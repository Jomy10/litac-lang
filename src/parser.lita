import "ast"
import "ast_new"
import "ast_copy"
import "lex"
import "symbols"
import "types"
import "mem"
import "array"
import "phase_result"
import "error_codes"
import "state"
import "common"
import "libc"
import "assert"
import "string_buffer"

public struct Parser {
    allocator: *const Allocator    
    tokens: Array<Token>
    current: i32
    currentPos: SrcPos
    result: *PhaseResult
}

public func ParserInit(filename: *const char, 
                      text: *const char,
                      lita: *Lita) : Parser {

    var parser = Parser {
        .allocator = lita.allocator,
        .result = &lita.result
    }

    var lex = LexerInit(filename, text, lita.allocator)
    parser.tokens.init(512, lita.allocator)

    while(!lex.eof()) {
        var token = lex.nextToken()
        parser.tokens.add(token)
    }

    return parser
}

public func (p: *Parser) parseModule() : *ModuleStmt {
    var pos = p.pos()
    var moduleStmt = NewStmt(StmtKind.MODULE_STMT, pos, p.allocator) as (*ModuleStmt)

    if(p.atEnd()) {
        return moduleStmt
    }

    while(!p.atEnd()) {
        var errorCount = p.numOfErrors()
        p.parseModuleStmt(moduleStmt)

        if(p.numOfErrors() > errorCount) {
            p.adjust([]TokenType {
                TokenType.IMPORT, 
                TokenType.HASH, 
                TokenType.PUBLIC, 
                TokenType.VAR, 
                TokenType.CONST, 
                TokenType.FUNC, 
                TokenType.STRUCT, 
                TokenType.UNION, 
                TokenType.ENUM, 
                TokenType.TYPEDEF
            }, 10)
        }
    }

    return moduleStmt
}

func (p: *Parser) parseModuleStmt(moduleStmt: *ModuleStmt) {    

    if(p.match(TokenType.IMPORT)) {
        var importDecl = p.importDeclaration()
        moduleStmt.imports.add(importDecl)
    }
    else if(p.match(TokenType.HASH)) {
        // Ignore for now
    }
    else {        
        var notes = p.notes()
        var isPublic = p.match(TokenType.PUBLIC)

        if(p.match(TokenType.VAR)) {
            var decl = p.varDeclaration()            
            moduleStmt.declarations.add(&decl.decl)
        }
        else if(p.match(TokenType.CONST)) {
            var decl = p.constDeclaration()
            moduleStmt.declarations.add(&decl.decl)
        }
        else if(p.match(TokenType.FUNC)) {
            var decl = p.funcDeclaration()
            moduleStmt.declarations.add(&decl.decl)
        }
        else if(p.match(TokenType.STRUCT)) {
            var decl = p.structDeclaration()
            moduleStmt.declarations.add(&decl.decl)
        }
        else if(p.match(TokenType.UNION)) {
            var decl = p.unionDeclaration()
            moduleStmt.declarations.add(&decl.decl)
        }
        else if(p.match(TokenType.ENUM)) {
            var decl = p.enumDeclaration()
            moduleStmt.declarations.add(&decl.decl)
        }
        else if(p.match(TokenType.TYPEDEF)) {
            var decl = p.typedefDeclaration()
            moduleStmt.declarations.add(&decl.decl)
        }
        else if(p.match(TokenType.SEMICOLON)) {
            if(!notes.empty()) {
                moduleStmt.notes.addAll(notes)
            }
            return;
        }
        else {            
            p.errorAtToken(p.peek(), ErrorCode.UNEXPECTED_TOKEN)
        }

        var decl = moduleStmt.declarations.last()
        decl.attributes.notes.addAll(notes)
        decl.attributes.isPublic = isPublic
        decl.attributes.isGlobal = true
    }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                            Declarations
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


func (p: *Parser) importDeclaration() : *ImportDecl {    
    var decl = NewStmt(StmtKind.IMPORT_DECL, p.pos(), p.allocator) as (*ImportDecl)
    if(p.match(TokenType.USING)) {
        decl.isUsing = true
    }

    var moduleName = p.consume(TokenType.STRING, ErrorCode.MISSING_IDENTIFIER);
    if(moduleName) { 
        decl.moduleName = *moduleName
    }
    if(p.match(TokenType.AS)) {
        var alias = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER);
        if(alias) {
            decl.alias = *alias
        }
    }

    // TODO: Lookup physical file and calculate ModuleId
    //decl.moduleId = //
    return decl;
}

func (p: *Parser) notes() : Array<*NoteStmt> {
    var notes = Array<*NoteStmt>{}
    if(!p.check(TokenType.AT)) {
        return notes
    }

    notes.init(4, p.allocator)

    while(p.match(TokenType.AT)) {
        var note = NewStmt(StmtKind.NOTE_STMT, p.pos(), p.allocator) as (*NoteStmt)
        var name = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
        if(name) {
            note.name = *name
        }

        if(p.match(TokenType.LEFT_PAREN)) {
            do {
                if(p.check(TokenType.STRING)) {
                    note.attributes.add(*p.advance())
                }
            }
            while(p.match(TokenType.COMMA));
        }

        notes.add(note)
    }

    return notes
}

func (p: *Parser) varDeclaration() : *VarDecl {
    var decl = NewStmt(StmtKind.VAR_DECL, p.pos(), p.allocator) as (*VarDecl)
    var identifier = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
    if(identifier) {
        decl.name = *identifier
    }

    if(p.match(TokenType.COLON)) {
        // TODO 'using'
        decl.type = p.type()
        if(p.match(TokenType.EQUALS)) {
            decl.expr = p.expression()
        }
    }
    else {
        p.consume(TokenType.EQUALS, ErrorCode.MISSING_EQUALS)
        decl.expr = p.expression()
    }

    return decl
}

func (p: *Parser) constDeclaration() : *ConstDecl {
    var decl = NewStmt(StmtKind.CONST_DECL, p.pos(), p.allocator) as (*ConstDecl)
    var identifier = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
    if(identifier) {
        decl.name = *identifier
    }

    if(p.match(TokenType.COLON)) {        
        decl.type = p.type()
        if(p.match(TokenType.EQUALS)) {
            decl.expr = p.expression()
        }
    }
    else {
        p.consume(TokenType.EQUALS, ErrorCode.MISSING_EQUALS)
        decl.expr = p.expression()
    }

    return decl
}

func (p: *Parser) funcDeclaration() : *FuncDecl {
    return null;
}

func (p: *Parser) structDeclaration() : *AggregateDecl {
    return null;
}

func (p: *Parser) unionDeclaration() : *AggregateDecl {
    return null;
}

func (p: *Parser) enumDeclaration() : *EnumDecl {
    return null;
}

func (p: *Parser) typedefDeclaration() : *TypedefDecl {
    return null;
}



/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                            Expressions
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

func (p: *Parser) expression() : *Expr {
    var pos = p.pos()

    var errorCount = p.numOfErrors()
    var expr = p.assignment()
    if(p.numOfErrors() > errorCount) {
        p.adjust()
        return NewStmt(StmtKind.NULL_EXPR, p.pos(), p.allocator) as (*Expr)
    }

    if(expr) {
        expr.setSrcPos(pos, p.pos())
    }

    return expr
}


func (p: *Parser) assignment() : *Expr {
    var expr = p.ternary()
    if(!expr) return null;

    var pos = p.pos()
    while(p.matches([]TokenType{
            TokenType.EQUALS,
            TokenType.PLUS_EQ, 
            TokenType.MINUS_EQ, 
            TokenType.DIV_EQ, 
            TokenType.MUL_EQ,
            TokenType.MOD_EQ,
            TokenType.LSHIFT_EQ, 
            TokenType.RSHIFT_EQ, 
            TokenType.BNOT_EQ, 
            TokenType.XOR_EQ, 
            TokenType.BAND_EQ, 
            TokenType.BOR_EQ}, 12)) {
        var operator = p.previous().type
        var right = p.ternary()

        if(expr.kind == StmtKind.GET_EXPR) {
            var getExpr = expr as (*GetExpr)
            var setExpr = NewStmt(StmtKind.SET_EXPR, pos, p.allocator) as (*SetExpr)
            setExpr.object = setExpr.node.becomeParentOf(getExpr.object)
            setExpr.field = setExpr.node.becomeParentOf(getExpr.field)
            setExpr.operator = operator
            setExpr.value = setExpr.node.becomeParentOf(right)
            setExpr.endPos = p.pos()

            expr = setExpr as (*Expr)
        }
        else if(expr.kind == StmtKind.SUBSCRIPT_GET_EXPR) {
            var getExpr = expr as (*SubscriptGetExpr)
            var setExpr = NewStmt(StmtKind.SUBSCRIPT_SET_EXPR, pos, p.allocator) as (*SubscriptSetExpr)
            setExpr.object = setExpr.node.becomeParentOf(getExpr.object)
            setExpr.index = setExpr.node.becomeParentOf(getExpr.index)
            setExpr.operator = operator
            setExpr.value = setExpr.node.becomeParentOf(right)
            setExpr.endPos = p.pos()

            expr = setExpr as (*Expr)

        }
        else {
            expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
        }

        pos = p.pos()
    }

    return expr
}

func (p: *Parser) ternary() : *Expr {
    var expr = p.or()
    var pos = p.pos()
    
    if(p.match(TokenType.QUESTION_MARK)) {
        var then = p.expression()
        p.consume(TokenType.COLON, ErrorCode.MISSING_COLON)
        var other = p.expression()
        var ternaryExpr = NewStmt(StmtKind.TERNARY_EXPR, pos, p.allocator) as (*TernaryExpr)
        ternaryExpr.cond = ternaryExpr.node.becomeParentOf(expr)
        ternaryExpr.then = ternaryExpr.node.becomeParentOf(then)
        ternaryExpr.other = ternaryExpr.node.becomeParentOf(other)
        ternaryExpr.endPos = p.pos()
        expr = ternaryExpr as (*Expr)
    }

    return expr
}

func (p: *Parser) or() : *Expr {
    var expr = p.and()
    var pos = p.pos()

    while(p.match(TokenType.OR)) {
        var operator = p.previous().type 
        var right = p.and()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }
    
    return expr
}

func (p: *Parser) and() : *Expr {
    var expr = p.bitOr()
    var pos = p.pos()

    while(p.match(TokenType.AND)) {
        var operator = p.previous().type
        var right = p.bitOr()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }
    
    return expr
}

func (p: *Parser) bitOr() : *Expr {
    var expr = p.bitXor()
    var pos = p.pos()

    while(p.match(TokenType.BOR)) {
        var operator = p.previous().type
        var right = p.bitXor()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }
    
    return expr
}

func (p: *Parser) bitXor() : *Expr {
    var expr = p.bitAnd()
    var pos = p.pos()

    while(p.match(TokenType.XOR)) {
        var operator = p.previous().type
        var right = p.bitAnd()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }
    
    return expr
}

func (p: *Parser) bitAnd() : *Expr {
    var expr = p.equality()
    var pos = p.pos()

    while(p.match(TokenType.BAND)) {
        var operator = p.previous().type    
        var right = p.equality()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }
    
    return expr
}

func (p: *Parser) equality() : *Expr {
    var expr = p.comparison()
    var pos = p.pos()

    while(p.matches([]TokenType{
            TokenType.NOT_EQUALS, 
            TokenType.EQUALS_EQUALS}, 2)) {
        var operator = p.previous().type   
        var right = p.comparison()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }
    
    return expr
}

func (p: *Parser) comparison() : *Expr {
    var expr = p.bitShift()
    var pos = p.pos()

    while(p.matches([]TokenType{
            TokenType.GREATER_THAN, 
            TokenType.GREATER_EQUALS,
            TokenType.LESS_THAN,
            TokenType.LESS_EQUALS}, 4)) {
        var operator = p.previous().type     
        var right = p.bitShift()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }
    
    return expr
}

func (p: *Parser) bitShift() : *Expr {
    var expr = p.term()
    var pos = p.pos()

    var bitExpr = p.tryBitShiftRight(expr)
    if(bitExpr) {
        return bitExpr
    }

    while(p.matches([]TokenType{
            TokenType.LSHIFT, 
            TokenType.RSHIFT}, 2)) {
        var operator = p.previous().type    
        var right = p.term()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }
    
    return expr
}

func (p: *Parser) term() : *Expr {
    var expr = p.factor()
    var pos = p.pos()

    while(p.matches([]TokenType{
            TokenType.MINUS, 
            TokenType.PLUS}, 2)) {
        var operator = p.previous().type    
        var right = p.factor()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }
    
    return expr
}

func (p: *Parser) factor() : *Expr {
    var expr = p.unary()
    var pos = p.pos()

    while(p.matches([]TokenType{
            TokenType.SLASH, 
            TokenType.STAR,
            TokenType.MOD}, 3)) {
        var operator = p.previous().type        
        var right = p.unary()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }
    
    return expr    
}

func (p: *Parser) unary() : *Expr {
    var pos = p.pos()
    if(p.matches([]TokenType{
            TokenType.NOT, 
            TokenType.MINUS,
            TokenType.PLUS,
            TokenType.STAR,
            TokenType.BAND,
            TokenType.BNOT}, 6)) {
        var operator = p.previous().type
        var right = p.unary()

        return NewUnaryExpr(pos, p.pos(), operator, right, p.allocator)
    }
    
    return p.functionCall()
}

func (p: *Parser) functionCall() : *Expr {    
    var expr = p.primary()
    expr.endPos = p.pos()

    while(true) {
        if(p.match(TokenType.LEFT_PAREN)) {
            expr = p.finishFunctionCall(expr)
            expr.endPos = p.pos()
        }
        else if(p.match(TokenType.LEFT_BRACE)) {
            if(!p.isIdentifier(expr)) {
                return expr
            }

            p.advance()

            var idExpr = expr as (*IdentifierExpr) // delete idExpr??
            var arguments = p.structArguments()
            expr = NewInitExpr(expr.startPos, p.pos(), idExpr.type, arguments, p.allocator)
        }
        else if(p.match(TokenType.LEFT_BRACKET)) {
            var index = p.expression()
            p.consume(TokenType.RIGHT_BRACKET, ErrorCode.MISSING_RIGHT_BRACKET)

            expr = NewSubscriptGetExpr(expr.startPos, p.pos(), expr, index, p.allocator)
        }
        else if(p.match(TokenType.DOT)) {
            var identifier = p.identifierType(true)
            expr = NewGetExpr(expr.startPos, 
                              p.pos(), 
                              expr, 
                              NewIdentifierExpr(identifier.pos, p.pos(), identifier, p.allocator) as (*IdentifierExpr), 
                              p.allocator)
        }
        else if(p.match(TokenType.AS)) {            
            expr = p.cast(expr)
        }        
        else {
            break;
        }
    }

    return expr
}

func (p: *Parser) primary() : *Expr {
    var token = p.peek()
    if(p.match(TokenType.TRUE)) {
        var expr = NewStmt(StmtKind.BOOLEAN_EXPR, token.pos, p.allocator) as (*BooleanExpr)
        expr.boolean = true
        return expr as (*Expr)
    }

    if(p.match(TokenType.FALSE)) {
        var expr = NewStmt(StmtKind.BOOLEAN_EXPR, token.pos, p.allocator) as (*BooleanExpr)
        expr.boolean = false
        return expr as (*Expr)
    }

    if(p.match(TokenType.NULL)) {
        var expr = NewStmt(StmtKind.NULL_EXPR, token.pos, p.allocator) as (*NullExpr)        
        return expr as (*Expr)
    }

    if(p.match(TokenType.INT_NUMBER)) {
        var expr = NewStmt(StmtKind.NUMBER_EXPR, token.pos, p.allocator) as (*NumberExpr)
        expr.number = *token
        return expr as (*Expr)
    }

    if(p.match(TokenType.STRING)) {
        var expr = NewStmt(StmtKind.STRING_EXPR, token.pos, p.allocator) as (*StringExpr)
        expr.string = *token
        return expr as (*Expr)
    }

    if(p.match(TokenType.CHAR)) {
        var expr = NewStmt(StmtKind.CHAR_EXPR, token.pos, p.allocator) as (*CharExpr)
        expr.character = *token
        return expr as (*Expr)
    }

    p.errorAtToken(token, ErrorCode.UNEXPECTED_TOKEN)
    return NewPoisonExpr(token.pos, p.pos(), p.allocator)
}

func (p: *Parser) finishFunctionCall(expr: *Expr) : *Expr {
    var pos = p.pos()
    var arguments = p.arguments()
    var genericArgs = Array<*TypeSpec>{}
    if(p.isIdentifier(expr)) {
        expr.kind = StmtKind.FUNC_IDENTIFIER_EXPR
    }
    else if(expr.kind == StmtKind.GET_EXPR) {
        var getExpr = expr as (*GetExpr)        
        var idExpr = getExpr.field
        idExpr.kind = StmtKind.FUNC_IDENTIFIER_EXPR
        genericArgs = idExpr.type.genericArgs
    }
    //return NewPoisonExpr(expr.startPos, p.pos(), p.allocator)
    return NewFuncCallExpr(pos, p.pos(), expr, arguments, genericArgs, p.allocator)
}

func (p: *Parser) cast(expr: *Expr) : *Expr {
    p.consume(TokenType.LEFT_PAREN, ErrorCode.MISSING_LEFT_PAREN)
    var castTo = p.type(false)
    p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN)
    return NewCastExpr(expr.startPos, p.pos(), expr, castTo, p.allocator)
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                            Statements
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

func (p: *Parser) statement() : *Stmt {
    return NewPoisonExpr(p.pos(), p.pos(), p.allocator) as (*Stmt)
}


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        Type Specifications
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


func (p: *Parser) type(disambiguate: bool = false) : *TypeSpec {
    var token = p.peek()
    switch(token.type) {
        case TokenType.BOOL:
        case TokenType.CHAR:
        case TokenType.I8:
        case TokenType.U8:
        case TokenType.I16:
        case TokenType.U16:
        case TokenType.I32:
        case TokenType.U32:
        case TokenType.I64:
        case TokenType.U64:
        case TokenType.F32:
        case TokenType.F64:
        case TokenType.USIZE:
        case TokenType.VOID: {
            p.advance()
            var spec = NewTypeSpec(TypeSpecKind.NAME, token.pos, p.allocator) as (*NameTypeSpec)
            spec.name = TokenName(token, p.allocator)
            
            return spec as (*TypeSpec)
        }
        case TokenType.STAR: {
            p.advance()
            var base = p.type(disambiguate)

            var spec = NewTypeSpec(TypeSpecKind.PTR, token.pos, p.allocator)
            spec.base = base
            return spec as (*TypeSpec)
        }
        case TokenType.CONST: {
            p.advance()
            var base = p.type(disambiguate)

            var spec = NewTypeSpec(TypeSpecKind.CONST, token.pos, p.allocator)
            spec.base = base
            return spec as (*TypeSpec)
        }
        case TokenType.IDENTIFIER: {
            return p.identifierType(disambiguate) as (*TypeSpec)
        }
        case TokenType.LEFT_BRACKET: {
            var spec = p.arrayType()
            p.advance()

            spec.base = p.type(disambiguate)
            return spec as (*TypeSpec)
        }
        case TokenType.FUNC: {
            p.advance()
            return p.funcPtrType() as (*TypeSpec)
        }
        default: {
            p.errorAtToken(token, ErrorCode.UNEXPECTED_TOKEN)
            break;
        }
    }

    return null
}

func (p: *Parser) identifierType(disambiguate: bool) : *NameTypeSpec {
    var token = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
    var sb = StringBufferInit(token.value.str.length, p.allocator)
    sb.append("%.*s", token.value.str.length, token.value.str.buffer)

    if(p.match(TokenType.COLON_COLON)) {
        // TODO - packages
    }

    var spec = NewTypeSpec(TypeSpecKind.NAME, token.pos, p.allocator) as (*NameTypeSpec)
    spec.name = sb.cStr()

    if(p.check(TokenType.LESS_THAN)) {        
        spec.genericArgs = p.tryGenericArguments(disambiguate)
    }

    return spec;
}

func (p: *Parser) arrayType() : *ArrayTypeSpec {    
    var spec = NewTypeSpec(TypeSpecKind.ARRAY, p.pos(), p.allocator) as (*ArrayTypeSpec)    
    p.advance()

    if(p.check(TokenType.RIGHT_BRACKET)) {
        var expr = p.expression()

        if(!p.isConstNumberExpr(expr)) {
            p.errorAtToken(p.peek(), ErrorCode.INVALID_ARRAY_DIMENSION_EXPR)
        }
        else {
            spec.numElements = expr
        }
    }

    return spec
}

func (p: *Parser) funcPtrType() : *FuncPtrTypeSpec {   
    var token = p.peek()
    var spec = NewTypeSpec(TypeSpecKind.FUNC_PTR, p.pos(), p.allocator) as (*FuncPtrTypeSpec)    

    if(p.match(TokenType.LESS_THAN))  {
        // TODO: Generics
    }

    p.consume(TokenType.LEFT_PAREN, ErrorCode.MISSING_LEFT_PAREN)
    if(!p.check(TokenType.RIGHT_PAREN)) {
        do {
            if(p.match(TokenType.VAR_ARGS)) {
                spec.hasVarargs = true
                if(!p.check(TokenType.RIGHT_PAREN)) {
                    p.errorAtToken(p.peek(), ErrorCode.INVALID_VARARG_POSITION)
                }
            }
            else {
                var arg = p.type(false)
                spec.args.add(arg)
            }
        }
        while(p.match(TokenType.COMMA))
    }

    p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN)
    p.consume(TokenType.COLON, ErrorCode.MISSING_COLON)

    spec.ret = p.type(false)
    return spec
}


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                            Utility
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

func (p: *Parser) structArguments() : Array<*InitArgExpr> {
    var arguments = Array<*InitArgExpr>{}
    arguments.init(16, p.allocator)

    var argPosition = 0
    do {
        if(p.check(TokenType.RIGHT_BRACE)) {
            break;
        }

        var pos = p.pos()
        var fieldName = Token{}
        if(p.check(TokenType.DOT)) {
            var name = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
            if(name) {
                fieldName = *name
            }
            
            if(p.check(TokenType.COLON)) {
                p.consume(TokenType.COLON, ErrorCode.MISSING_COLON)
            }
            else if(p.check(TokenType.EQUALS)) {
                p.consume(TokenType.EQUALS, ErrorCode.MISSING_EQUALS)
            }
            else {
                p.errorAtToken(p.peek(), ErrorCode.MISSING_COLON)
            }
        }
        
        var value = p.expression()        
        var arg = NewInitArgExpr(pos, p.pos(), fieldName, argPosition, value, p.allocator) as (*InitArgExpr)
        arguments.add(arg)
        argPosition += 1        
    }
    while(p.match(TokenType.COMMA))

    p.consume(TokenType.RIGHT_BRACE, ErrorCode.MISSING_RIGHT_BRACE)
    return arguments    
}

func (p: *Parser) arguments() : Array<*Expr> {
    var arguments = Array<*Expr>{}
    if(!p.check(TokenType.RIGHT_PAREN)) {
        arguments.init(8, p.allocator)

        do {
            var expr = p.expression()
            arguments.add(expr)
        }
        while(p.match(TokenType.COMMA))
    }

    p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN)
    return arguments
}


func (p: *Parser) genericParameters() : Array<GenericParam> {
    var arguments = Array<GenericParam>{}
    if(!p.check(TokenType.GREATER_THAN)) {
        arguments.init(2, p.allocator)

        do {
            var typeName = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
            if(typeName) {
                arguments.add(GenericParam {
                    .name = *typeName
                })
            }
        }
        while(p.match(TokenType.COMMA))
    }

    p.consume(TokenType.GREATER_THAN, ErrorCode.MISSING_GENERIC_END)
    return arguments
}

func (p: *Parser) genericArguments() : Array<*TypeSpec> {
    var arguments = Array<*TypeSpec>{}
    if(!p.check(TokenType.GREATER_THAN)) {
        arguments.init(2, p.allocator)

        do {
            var type = p.type(false)
            if(type) {
                arguments.add(type)
            }
        }
        while(p.match(TokenType.COMMA))
    }

    p.consume(TokenType.GREATER_THAN, ErrorCode.MISSING_GENERIC_END)
    return arguments
}

func (p: *Parser) tryGenericArguments(disambiguate: bool) : Array<*TypeSpec> {
    var backtrack = p.current
    var numOfErrors = p.numOfErrors()
    var pos = p.pos()

    var arguments = p.genericArguments()
    var isFailed = false

    if(p.numOfErrors() == numOfErrors) {
        if(disambiguate) {
            var token = p.peek()
            switch(token.type) {
                case TokenType.LEFT_PAREN:
                case TokenType.RIGHT_PAREN:
                case TokenType.RIGHT_BRACKET:
                case TokenType.LEFT_BRACE:
                case TokenType.RIGHT_BRACE:
                case TokenType.COLON:
                case TokenType.SEMICOLON:
                case TokenType.COMMA:
                case TokenType.DOT:
                case TokenType.QUESTION_MARK:
                case TokenType.EQUALS_EQUALS:
                case TokenType.NOT_EQUALS:
                case TokenType.OR:
                case TokenType.XOR:
                case TokenType.STAR:
                    return arguments;
                default: {                  
                    isFailed = true;
                    break;
                }
            }
        }
    }

    if(p.numOfErrors() > numOfErrors) {
        p.rewindTo(backtrack, numOfErrors)
        isFailed = true;
    }

    if(isFailed) {
        for(var i = 0; i < arguments.size(); i += 1) {
            var type = arguments.get(i)
            p.allocator.free(type)
        }
        arguments.free()
    }

    return arguments
}

func (p: *Parser) arrayArguments() : Array<*Expr> {
    var arguments = Array<*Expr>{}
    arguments.init(16, p.allocator)

    do {
        if(p.check(TokenType.RIGHT_BRACE)) {
            break;
        }

        var expr: *Expr = null
        if(p.check(TokenType.LEFT_BRACKET)) {
            expr = p.tryArrayDesignationExpr()
        }

        if(!expr) {
            expr = p.expression()
        }

        if(expr) {
            arguments.add(expr)
        }
    }
    while(p.match(TokenType.COMMA))

    p.consume(TokenType.RIGHT_BRACE, ErrorCode.MISSING_RIGHT_BRACE)
    return arguments
}

func (p: *Parser) tryArrayDesignationExpr() : *Expr {
    var backtrack = p.current
    var numOfErrors = p.numOfErrors()
    var pos = p.pos()

    var designatorExpr: *Expr = null
    if(p.match(TokenType.LEFT_BRACKET)) {
        var index = p.expression()
        p.consume(TokenType.RIGHT_BRACKET, ErrorCode.MISSING_RIGHT_BRACKET)
        p.consume(TokenType.EQUALS, ErrorCode.MISSING_EQUALS)
        var value = p.expression()

        if(p.numOfErrors() == numOfErrors) {
            designatorExpr = NewArrayDesignationExpr(pos, p.pos(), index, value, p.allocator)
        }
        else {
            p.allocator.free(index)
            p.allocator.free(value)
        }
    }

    if(p.numOfErrors() > numOfErrors) {
        p.rewindTo(backtrack, numOfErrors)
    }

    return designatorExpr
}

func (p: *Parser) rewindTo(backtrack: i32, numOfErrors: i32) {
    assert(p.numOfErrors() > numOfErrors) 
    {
        // rewind the parser and errors
        p.current = backtrack
        for(var i = p.numOfErrors() - 1; i >= numOfErrors; i -= 1) {
            var error = p.result.errors.removeAt(i)
            p.allocator.free(error.message as (*void))
        }
    }
}

// account for generics, we must peek ahead to see if
// this is a bit shift operator or generics
func (p: *Parser) tryBitShiftRight(expr: *Expr) : *Expr {

    if(!p.check(TokenType.GREATER_THAN)) {
        return null
    }

    var prevToken = p.advance()
    if(!p.check(TokenType.GREATER_THAN)) {
        p.rewind()
        return null
    }

    var nextToken = p.advance()
    if((nextToken.pos.position - prevToken.pos.position) == 1) {
        var right = p.term()
        return NewBinaryExpr(expr.startPos, p.pos(), expr, TokenType.RSHIFT, right, p.allocator)
    }

    // this wasn't a bit shift attempt, abort!
    p.rewind() 
    p.rewind()
    return null
}

func (p: *Parser) isIdentifier(expr: *Expr) : bool {
    if(!expr) {
        return false
    }

    return expr.kind == StmtKind.IDENTIFIER_EXPR ||
           expr.kind == StmtKind.FUNC_IDENTIFIER_EXPR ||
           expr.kind == StmtKind.TYPE_IDENTIFIER_EXPR
}


func (p: *Parser) isConstNumberExpr(expr: *Expr) : bool {
    return false
}


func (p: *Parser) pos() : SrcPos {
    if(!p.atEnd()) {
        return p.peek().pos
    }

    return SrcPos{}
}

func (p: *Parser) peek() : *Token {
    assert(p.current < p.tokens.size())
    return &p.tokens.elements[p.current]
}

func (p: *Parser) rewind() {
    p.current -= 1
    if(p.current < 0) {
        p.current = 0
    }
}

func (p: *Parser) previous() : *Token {
    var index = p.current - 1;
    assert(index < p.tokens.size() && index >= 0)
    return &p.tokens.elements[index]
}

func (p: *Parser) atEnd() : bool {
    return p.tokens.empty() || p.peek().type == TokenType.END_OF_FILE
}

func (p: *Parser) advance() : *Token {
    if(!p.atEnd()) {
        p.current += 1
    }
    return p.previous()
}

func (p: *Parser) check(type: TokenType) : bool {
    if(p.atEnd()) return false
    return p.peek().type == type
}

func (p: *Parser) match(type: TokenType) : bool {
    if(p.check(type)) {
        p.advance()
        return true
    }
    return false
}

func (p: *Parser) matches(types: *TokenType, len: i32) : bool {
    for(var i = 0; i < len; i += 1) {
        var type = types[i]
        if(p.check(type)) {
            p.advance()
            return true
        }
    }
    return false
}

func (p: *Parser) consume(type: TokenType, errorCode: ErrorCode) : *Token {
    if(p.check(type)) {
        return p.advance()
    }

    p.errorAt(type, errorCode)
    return null
}

func (p: *Parser) adjust(types: *TokenType = null, len: i32 = 0) {
    if(!types || len < 1) {
        p.advance()
        return;
    }

    while(!p.atEnd()) {
        var type = p.peek().type
        for(var i = 0; i < len; i+=1) {
            if(types[i] == type) {
                return;
            }
        }

        p.advance()
    }
}

func (p: *Parser) errorAtToken(token: *Token, errorCode: ErrorCode) {
    if(!token) {
        // TODO: create an error message        
        p.result.addError(token.pos,"%s\n", errorCodeText[errorCode])
    }
    else {
        p.errorAt(token.type, errorCode)
    }
    
}

func (p: *Parser) errorAt(type: TokenType, errorCode: ErrorCode) {
    // TODO: create an error message
    p.result.addError(p.pos(), "Expected token: '%s' - %s\n", tokenText[type], errorCodeText[errorCode])
}

func (p: *Parser) numOfErrors() : i32 {
    return p.result.errors.size()
}