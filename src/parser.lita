import "ast"
import "ast_new"
import "ast_copy"
import "lex"
import "symbols"
import "types"
import "mem"
import "array"
import "phase_result"
import "error_codes"
import "state"
import "common"
import "libc"
import "assert"
import "string_buffer"

public struct Parser {
    allocator: *const Allocator    
    tokens: Array<Token>
    current: i32
    currentPos: SrcPos
    breakLevel: i32
    loopLevel: i32
    switchLevel: i32
    funcLevel: i32
    result: *PhaseResult
}

public func ParserInit(filename: *const char, 
                      text: *const char,
                      lita: *Lita) : Parser {

    var parser = Parser {
        .allocator = lita.allocator,
        .result = &lita.result,
        .breakLevel = 0,
        .loopLevel = 0,
        .switchLevel = 0,
        .funcLevel = 0,
    }

    var lex = LexerInit(filename, text, lita.allocator)
    parser.tokens.init(512, lita.allocator)

    while(!lex.eof()) {
        var token = lex.nextToken()
        parser.tokens.add(token)
    }

    return parser
}

public func (p: *Parser) parseModule() : *ModuleStmt {
    var pos = p.pos()

    var imports = Array<*ImportDecl>{}
    imports.init(16, p.allocator)

    var notes = Array<*NoteStmt>{}
    notes.init(2, p.allocator)
    
    var declarations = Array<*Decl>{}
    declarations.init(16, p.allocator)    

    var moduleStmt = NewModuleStmt(pos, pos, imports, notes, declarations, p.allocator) as (*ModuleStmt)

    if(p.atEnd()) {
        return moduleStmt
    }

    while(!p.atEnd()) {
        var errorCount = p.numOfErrors()
        p.parseModuleDeclaration(moduleStmt)

        if(p.numOfErrors() > errorCount) {
            p.adjust([]TokenType {
                TokenType.IMPORT, 
                TokenType.HASH, 
                TokenType.PUBLIC, 
                TokenType.VAR, 
                TokenType.CONST, 
                TokenType.FUNC, 
                TokenType.STRUCT, 
                TokenType.UNION, 
                TokenType.ENUM, 
                TokenType.TYPEDEF
            }, 10)
        }
    }

    moduleStmt.endPos = p.prevPos()
    return moduleStmt
}

func (p: *Parser) parseModuleDeclaration(moduleStmt: *ModuleStmt) {    

    if(p.match(TokenType.IMPORT)) {
        var importDecl = p.importDeclaration()
        moduleStmt.imports.add(importDecl)
    }
    else if(p.match(TokenType.HASH)) {
        // Ignore for now
    }
    else {        
        var notes = p.notes()
        var isPublic = p.match(TokenType.PUBLIC)

        if(p.match(TokenType.VAR)) {
            var decl = p.varDeclaration()            
            moduleStmt.declarations.add(decl)
        }
        else if(p.match(TokenType.CONST)) {
            var decl = p.constDeclaration()
            moduleStmt.declarations.add(decl)
        }
        else if(p.match(TokenType.FUNC)) {
            var decl = p.funcDeclaration()
            moduleStmt.declarations.add(decl)
        }
        else if(p.match(TokenType.STRUCT)) {
            var decl = p.structDeclaration()
            moduleStmt.declarations.add(decl)
        }
        else if(p.match(TokenType.UNION)) {
            var decl = p.unionDeclaration()
            moduleStmt.declarations.add(decl)
        }
        else if(p.match(TokenType.ENUM)) {
            var decl = p.enumDeclaration()
            moduleStmt.declarations.add(decl)
        }
        else if(p.match(TokenType.TYPEDEF)) {
            var decl = p.typedefDeclaration()
            moduleStmt.declarations.add(decl)
        }
        else if(p.match(TokenType.SEMICOLON)) {
            if(!notes.empty()) {
                moduleStmt.notes.addAll(notes)
            }
            return;
        }
        else {            
            p.errorAtToken(p.peek(), ErrorCode.UNEXPECTED_TOKEN)
            return;
        }

        var decl = moduleStmt.declarations.last()
        decl.attributes.notes.addAll(notes)
        decl.attributes.isPublic = isPublic
        decl.attributes.isGlobal = true
    }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                            Declarations
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


func (p: *Parser) importDeclaration() : *ImportDecl {    
    var pos = p.prevPos()

    var isUsing = p.match(TokenType.USING)
    var moduleName = Token {
        .type = TokenType.ERROR
    }
    var moduleNameStr = p.consume(TokenType.STRING, ErrorCode.MISSING_IDENTIFIER);
    if(moduleNameStr) {
        moduleName = *moduleNameStr
    }
    
    var alias = Token{
        .type = TokenType.END_OF_FILE
    }

    if(p.match(TokenType.AS)) {
        var aliasId = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER);
        if(aliasId) {
            alias = *aliasId
        }
    }

    // TODO: Lookup physical file and calculate ModuleId
    //decl.moduleId = //
    return NewImportDecl(pos, p.pos(), moduleName, alias, isUsing, p.allocator) as (*ImportDecl)    
}

func (p: *Parser) notes() : Array<*NoteStmt> {
    var notes = Array<*NoteStmt>{}
    if(!p.check(TokenType.AT)) {
        return notes
    }

    notes.init(4, p.allocator)


    while(p.match(TokenType.AT)) {
        var pos = p.prevPos()

        var name = p.identifier()

        var attributes = Array<Token>{}
        attributes.init(2, p.allocator)

        if(p.match(TokenType.LEFT_PAREN)) {
            do {
                if(p.check(TokenType.STRING)) {
                    attributes.add(*p.advance())
                }
            }
            while(p.match(TokenType.COMMA));
        }

        var note = NewNoteStmt(pos, p.pos(), name, attributes, p.allocator) as (*NoteStmt)
        notes.add(note)
    }

    return notes
}

func (p: *Parser) varDeclaration() : *Decl {
    var pos = p.prevPos()

    var name = p.identifier()

    var type: *TypeSpec = null
    var expr: *Expr = null

    if(p.match(TokenType.COLON)) {        
        type = p.type()
        if(p.match(TokenType.EQUALS)) {
            expr = p.expression()
        }
    }
    else {
        p.consume(TokenType.EQUALS, ErrorCode.MISSING_EQUALS)
        expr = p.expression()
    }

    return NewVarDecl(pos, p.pos(), name, type, expr, p.allocator)
}

func (p: *Parser) constDeclaration() : *Decl {
    var pos = p.prevPos()

    var name = p.identifier()

    var type: *TypeSpec = null
    var expr: *Expr = null

    if(p.match(TokenType.COLON)) {        
        type = p.type()
        if(p.match(TokenType.EQUALS)) {
            expr = p.expression()
        }
    }
    else {
        p.consume(TokenType.EQUALS, ErrorCode.MISSING_EQUALS)
        expr = p.expression()
    }

    return NewConstDecl(pos, p.pos(), name, type, expr, p.allocator)
}

func (p: *Parser) funcDeclaration() : *Decl {
    var pos = p.prevPos()
    p.funcLevel += 1;
    
    var objectParam: *ParameterDecl = null
    if(p.match(TokenType.LEFT_PAREN)) {
        objectParam = p.paramDeclaration()
        p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN)
    }
    
    var name = p.identifier()
    
    var genericParams = Array<GenericParam>{}
    if(p.match(TokenType.LESS_THAN)) {
        genericParams = p.genericParameters()
    }

    
    var parameters = p.parametersStatement();
    if(objectParam != null) {
        parameters.params.insertAt(0, objectParam);
    }
    
    
    var returnType: *TypeSpec = null
    if(p.match(TokenType.COLON)) {
        returnType = p.type();
    }
    else {
        returnType = NewVoidTypeSpec(p.pos(), p.allocator)
    }
    
    var flags = 0;
    if(parameters.isVararg) {
        flags |= FuncFlags.HAS_VARARGS;
    }
    
    if(objectParam != null) {
        flags |= FuncFlags.IS_METHOD;
    }
            
    var body: *Stmt = null;
    if(p.match(TokenType.SEMICOLON)) {
        body = NewEmptyStmt(p.prevPos(), p.pos(), p.allocator)
    }
    else {
        body = p.statement();
        
        // convert to FuncBodyStmt from a block stmt, so that
        // downstream systems don't have to do funky scope management
        // with function parameters
        if(body.kind == StmtKind.BLOCK_STMT) {
            body.kind = StmtKind.FUNC_BODY_STMT
        }
    }
    
    p.funcLevel -= 1;
    
    return NewFuncDecl(pos, p.pos(), name, genericParams, parameters, body, returnType, flags, p.allocator)
}

func (p: *Parser) structDeclaration() : *Decl {
    return null;
}

func (p: *Parser) unionDeclaration() : *Decl {
    return null;
}

func (p: *Parser) enumDeclaration() : *Decl {
    return null;
}

func (p: *Parser) typedefDeclaration() : *Decl {
    return null;
}

func (p: *Parser) paramDeclaration() : *ParameterDecl {
    var pos = p.pos()

    var name = p.identifier()
    p.consume(TokenType.COLON, ErrorCode.MISSING_COLON)
    
    var isUsing = p.match(TokenType.USING)
    var type = p.type()
    
    var defaultExpr: *Expr = null
    if(p.match(TokenType.EQUALS)) {
        defaultExpr = p.constExpression()
    }

    return NewParameterDecl(pos, p.pos(), name, type, defaultExpr, isUsing, p.allocator) as (*ParameterDecl)
}



/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                            Expressions
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

func (p: *Parser) expression() : *Expr {
    var pos = p.pos()

    var errorCount = p.numOfErrors()
    var expr = p.assignment()
    if(p.numOfErrors() > errorCount) {
        p.adjust()
        if(expr) {
            if(expr.kind == StmtKind.POISON_EXPR) {
                return expr
            }

            p.allocator.free(expr)
        }

        return NewPoisonExpr(pos, p.pos(), p.allocator)
    }

    return expr
}

func (p: *Parser) constExpression() : *Expr {
    var expr = p.expression()
    p.checkConstExpr(expr)

    return expr
}


func (p: *Parser) assignment() : *Expr {
    var expr = p.ternary()
    if(!expr) return null;

    var pos = p.pos()
    while(p.matches([]TokenType{
            TokenType.EQUALS,
            TokenType.PLUS_EQ, 
            TokenType.MINUS_EQ, 
            TokenType.DIV_EQ, 
            TokenType.MUL_EQ,
            TokenType.MOD_EQ,
            TokenType.LSHIFT_EQ, 
            TokenType.RSHIFT_EQ, 
            TokenType.BNOT_EQ, 
            TokenType.XOR_EQ, 
            TokenType.BAND_EQ, 
            TokenType.BOR_EQ}, 12)) {
        var operator = p.previous().type
        var right = p.ternary()

        if(expr.kind == StmtKind.GET_EXPR) {
            var getExpr = expr as (*GetExpr)
            expr = NewSetExpr(pos, p.pos(), getExpr.object, getExpr.field, operator, right, p.allocator)
        }
        else if(expr.kind == StmtKind.SUBSCRIPT_GET_EXPR) {
            var getExpr = expr as (*SubscriptGetExpr)
            expr = NewSubscriptSetExpr(pos, p.pos(), getExpr.object, getExpr.index, operator, right, p.allocator)
        }
        else {
            expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
        }

        pos = p.pos()
    }

    return expr
}

func (p: *Parser) ternary() : *Expr {
    var expr = p.or()
    var pos = p.pos()
    
    if(p.match(TokenType.QUESTION_MARK)) {
        var then = p.expression()
        p.consume(TokenType.COLON, ErrorCode.MISSING_COLON)
        var other = p.expression()
        expr = NewTernaryExpr(pos, p.pos(), expr, then, other, p.allocator)
    }

    return expr
}

func (p: *Parser) or() : *Expr {
    var expr = p.and()
    var pos = p.pos()

    while(p.match(TokenType.OR)) {
        var operator = p.previous().type 
        var right = p.and()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }
    
    return expr
}

func (p: *Parser) and() : *Expr {
    var expr = p.bitOr()
    var pos = p.pos()

    while(p.match(TokenType.AND)) {
        var operator = p.previous().type
        var right = p.bitOr()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }
    
    return expr
}

func (p: *Parser) bitOr() : *Expr {
    var expr = p.bitXor()
    var pos = p.pos()

    while(p.match(TokenType.BOR)) {
        var operator = p.previous().type
        var right = p.bitXor()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }
    
    return expr
}

func (p: *Parser) bitXor() : *Expr {
    var expr = p.bitAnd()
    var pos = p.pos()

    while(p.match(TokenType.XOR)) {
        var operator = p.previous().type
        var right = p.bitAnd()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }
    
    return expr
}

func (p: *Parser) bitAnd() : *Expr {
    var expr = p.equality()
    var pos = p.pos()

    while(p.match(TokenType.BAND)) {
        var operator = p.previous().type    
        var right = p.equality()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }
    
    return expr
}

func (p: *Parser) equality() : *Expr {
    var expr = p.comparison()
    var pos = p.pos()

    while(p.matches([]TokenType{
            TokenType.NOT_EQUALS, 
            TokenType.EQUALS_EQUALS}, 2)) {
        var operator = p.previous().type   
        var right = p.comparison()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }
    
    return expr
}

func (p: *Parser) comparison() : *Expr {
    var expr = p.bitShift()
    var pos = p.pos()

    while(p.matches([]TokenType{
            TokenType.GREATER_THAN, 
            TokenType.GREATER_EQUALS,
            TokenType.LESS_THAN,
            TokenType.LESS_EQUALS}, 4)) {
        var operator = p.previous().type     
        var right = p.bitShift()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }
    
    return expr
}

func (p: *Parser) bitShift() : *Expr {
    var expr = p.term()
    var pos = p.pos()

    var bitExpr = p.tryBitShiftRight(expr)
    if(bitExpr) {
        return bitExpr
    }

    while(p.matches([]TokenType{
            TokenType.LSHIFT, 
            TokenType.RSHIFT}, 2)) {
        var operator = p.previous().type    
        var right = p.term()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }
    
    return expr
}

func (p: *Parser) term() : *Expr {
    var expr = p.factor()
    var pos = p.pos()

    while(p.matches([]TokenType{
            TokenType.MINUS, 
            TokenType.PLUS}, 2)) {
        var operator = p.previous().type    
        var right = p.factor()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }
    
    return expr
}

func (p: *Parser) factor() : *Expr {
    var expr = p.unary()
    var pos = p.pos()

    while(p.matches([]TokenType{
            TokenType.SLASH, 
            TokenType.STAR,
            TokenType.MOD}, 3)) {
        var operator = p.previous().type        
        var right = p.unary()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }
    
    return expr    
}

func (p: *Parser) unary() : *Expr {
    var pos = p.pos()
    if(p.matches([]TokenType{
            TokenType.NOT, 
            TokenType.MINUS,
            TokenType.PLUS,
            TokenType.STAR,
            TokenType.BAND,
            TokenType.BNOT}, 6)) {
        var operator = p.previous().type
        var right = p.unary()

        return NewUnaryExpr(pos, p.pos(), operator, right, p.allocator)
    }
    
    return p.functionCall()
}

func (p: *Parser) functionCall() : *Expr {    
    var expr = p.primary()
    expr.endPos = p.pos()

    while(true) {
        if(p.match(TokenType.LEFT_PAREN)) {
            expr = p.finishFunctionCall(expr)
            expr.endPos = p.pos()
        }
        else if(p.match(TokenType.LEFT_BRACE)) {
            if(!p.isIdentifier(expr)) {
                return expr
            }

            p.advance()

            var idExpr = expr as (*IdentifierExpr) // delete idExpr??
            var arguments = p.structArguments()
            expr = NewInitExpr(expr.startPos, p.pos(), idExpr.type, arguments, p.allocator)
        }
        else if(p.match(TokenType.LEFT_BRACKET)) {
            var index = p.expression()
            p.consume(TokenType.RIGHT_BRACKET, ErrorCode.MISSING_RIGHT_BRACKET)

            expr = NewSubscriptGetExpr(expr.startPos, p.pos(), expr, index, p.allocator)
        }
        else if(p.match(TokenType.DOT)) {
            var identifier = p.identifierType(true)
            expr = NewGetExpr(expr.startPos, 
                              p.pos(), 
                              expr, 
                              NewIdentifierExpr(identifier.pos, p.pos(), identifier, p.allocator) as (*IdentifierExpr), 
                              p.allocator)
        }
        else if(p.match(TokenType.AS)) {            
            expr = p.cast(expr)
        }        
        else {
            break;
        }
    }

    return expr
}

func (p: *Parser) primary() : *Expr {
    var token = p.peek()
    var pos = token.pos
    if(p.match(TokenType.TRUE)) {        
        return NewBooleanExpr(pos, p.pos(), true, p.allocator)
    }

    if(p.match(TokenType.FALSE)) {
        return NewBooleanExpr(pos, p.pos(), false, p.allocator)
    }

    if(p.match(TokenType.NULL)) {
        return NewNullExpr(pos, p.pos(), p.allocator)
    }

    if(p.match(TokenType.INT_NUMBER) || p.match(TokenType.FLOAT_NUMBER)) {        
        return NewNumberExpr(pos, p.pos(), token, p.allocator)
    }

    if(p.match(TokenType.STRING)) {
        return NewStringExpr(pos, p.pos(), token, p.allocator)
    }

    if(p.match(TokenType.CHAR)) {
        return NewCharExpr(pos, p.pos(), token, p.allocator)
    }

    p.errorAtToken(token, ErrorCode.UNEXPECTED_TOKEN)
    return NewPoisonExpr(token.pos, p.pos(), p.allocator)
}

func (p: *Parser) finishFunctionCall(expr: *Expr) : *Expr {
    var pos = p.pos()
    var arguments = p.arguments()
    var genericArgs = Array<*TypeSpec>{}
    if(p.isIdentifier(expr)) {
        expr.kind = StmtKind.FUNC_IDENTIFIER_EXPR
    }
    else if(expr.kind == StmtKind.GET_EXPR) {
        var getExpr = expr as (*GetExpr)        
        var idExpr = getExpr.field
        idExpr.kind = StmtKind.FUNC_IDENTIFIER_EXPR
        genericArgs = idExpr.type.genericArgs
    }
    
    return NewFuncCallExpr(pos, p.pos(), expr, arguments, genericArgs, p.allocator)
}

func (p: *Parser) cast(expr: *Expr) : *Expr {
    p.consume(TokenType.LEFT_PAREN, ErrorCode.MISSING_LEFT_PAREN)
    var castTo = p.type(false)
    p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN)
    return NewCastExpr(expr.startPos, p.pos(), expr, castTo, p.allocator)
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                            Statements
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

func (p: *Parser) statement() : *Stmt {
    var pos = p.pos()

    var errorCount = p.numOfErrors()
    var stmt = p.tryStatement()
    if(p.numOfErrors() > errorCount) {
        p.adjust()
        if(stmt) {
            if(stmt.kind == StmtKind.POISON_EXPR) {
                return stmt
            }

            p.allocator.free(stmt)
        }

        return NewPoisonExpr(pos, p.pos(), p.allocator) as (*Stmt)
    }

    return stmt
}

func (p: *Parser) tryStatement() : *Stmt {
    var pos = p.pos()

    // check for note declarations
    if(p.check(TokenType.AT)) {
        var notes = p.notes()

        var decl: *Decl = null
        if(p.match(TokenType.VAR)) {
            decl = p.varDeclaration()
        }
        else if(p.match(TokenType.CONST)) {
            decl = p.constDeclaration()
        }
        else {
            p.errorAtToken(p.peek(), ErrorCode.INVALID_NOTE_DECL)
            return NewPoisonExpr(pos, p.pos(), p.allocator) as (*Stmt)
        }

        decl.attributes.notes = notes
        decl.startPos = pos
        return decl as (*Stmt)
    }

    if(p.match(TokenType.HASH)) {
        // TODO: Compile statement
    }

    if(p.match(TokenType.LEFT_BRACE)) {
        return p.blockStatement()
    }

    if(p.match(TokenType.VAR)) {
        return p.varDeclaration() as (*Stmt)
    }

    if(p.match(TokenType.CONST)) {
        return p.constDeclaration() as (*Stmt)
    }

    if(p.match(TokenType.IF)) {
        return p.ifStatement()
    }

    if(p.match(TokenType.WHILE)) {
        return p.whileStatement()
    }

    if(p.match(TokenType.DO)) {
        return p.doWhileStatement()
    }

    if(p.match(TokenType.FOR)) {
        return p.forStatement()
    }

    if(p.match(TokenType.SWITCH)) {
        return p.switchStatement()
    }

    if(p.match(TokenType.BREAK)) {
        return p.breakStatement()
    }

    if(p.match(TokenType.CONTINUE)) {
        return p.continueStatement()
    }

    if(p.match(TokenType.RETURN)) {
        return p.returnStatement()
    }

    if(p.match(TokenType.DEFER)) {
        return p.deferStatement()
    }

    if(p.match(TokenType.GOTO)) {
        return p.gotoStatement()
    }

    if(p.check(TokenType.IDENTIFIER)) {
        var stmt = p.tryLabelStatement()
        if(stmt) {
            return stmt
        }
    }

    return p.expression() as (*Stmt)
}

func (p: *Parser) blockStatement() : *Stmt {
    if(p.breakLevel > 0) {
        p.breakLevel -= 1
    }

    var pos = p.prevPos()

    var stmts = Array<*Stmt>{}
    stmts.init(16, p.allocator)

    do {
        if(p.check(TokenType.RIGHT_BRACE)) {
            break
        }

        var stmt = p.statement()
        stmts.add(stmt)

        p.eatSemicolon()
    }
    while(!p.atEnd())

    p.consume(TokenType.RIGHT_BRACE, ErrorCode.MISSING_RIGHT_BRACE)

    return NewBlockStmt(pos, p.pos(), stmts, p.allocator)
}

func (p: *Parser) ifStatement() : *Stmt {
    var pos = p.prevPos()

    p.consume(TokenType.LEFT_PAREN, ErrorCode.MISSING_LEFT_PAREN)
    var cond = p.expression()
    p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN)
    
    var then = p.statement();
    var elseStmt: *Stmt = null;
    if(p.match(TokenType.ELSE)) {
        elseStmt = p.statement();
    }
    
    return NewIfStmt(pos, p.pos(), cond, then, elseStmt, p.allocator);
}

func (p: *Parser) whileStatement() : *Stmt {
    var pos = p.prevPos()
    p.loopLevel += 1;
        
    p.consume(TokenType.LEFT_PAREN, ErrorCode.MISSING_LEFT_PAREN);
    var cond = p.expression();
    p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN);
    
    var body = p.statement();
    p.loopLevel -= 1;
    
    return NewWhileStmt(pos, p.pos(), cond, body, p.allocator);
}

func (p: *Parser) doWhileStatement() : *Stmt {
    var pos = p.prevPos()
    p.loopLevel += 1;
    var body = p.statement();

    p.consume(TokenType.WHILE, ErrorCode.MISSING_WHILE);
    p.consume(TokenType.LEFT_PAREN, ErrorCode.MISSING_LEFT_PAREN);
    var cond = p.expression();
    p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN);
    
    p.loopLevel -= 1;
    
    return NewDoWhileStmt(pos, p.pos(), cond, body, p.allocator);
}

func (p: *Parser) forStatement() : *Stmt {
    var pos = p.prevPos()
    p.consume(TokenType.LEFT_PAREN, ErrorCode.MISSING_LEFT_PAREN);
    
    var init = !p.check(TokenType.SEMICOLON) ? p.statement() : null;
    p.consume(TokenType.SEMICOLON, ErrorCode.MISSING_SEMICOLON);        
    
    var cond = !p.check(TokenType.SEMICOLON) ? p.expression() : null;    
    p.consume(TokenType.SEMICOLON, ErrorCode.MISSING_SEMICOLON);
    
    var post = !p.check(TokenType.RIGHT_PAREN) ? p.statement() : null;    
    p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN);
    
    p.loopLevel += 1;
    var body = p.statement();
    p.loopLevel -= 1;
    
    return NewForStmt(pos, p.pos(), init, cond, post, body, p.allocator);
}

func (p: *Parser) switchCaseStatement() : *Stmt {
    var pos = p.prevPos()

    var cond = p.expression()
    p.consume(TokenType.COLON, ErrorCode.MISSING_COLON);

    var bodyPos = p.pos()
    var stmts = Array<*Stmt>{}
    stmts.init(8, p.allocator)

    while(!p.atEnd()) {
        if(p.check(TokenType.RIGHT_BRACE) || 
           p.check(TokenType.CASE) ||
           p.check(TokenType.DEFAULT)) {
            break;
        }

        var stmt = p.statement()
        p.match(TokenType.SEMICOLON)

        stmts.add(stmt)
    }
    var body: *Stmt = null
    if(stmts.empty()) {
        body = NewEmptyStmt(bodyPos, p.pos(), p.allocator)
    }
    else {
        body = NewBlockStmt(bodyPos, p.pos(), stmts, p.allocator)
    }

    return NewSwitchCaseStmt(pos, p.pos(), cond, body, p.allocator);
}


func (p: *Parser) switchDefaultStatement() : *Stmt {
    var pos = p.prevPos()

    var breakCount = p.breakLevel
    
    var stmts = Array<*Stmt>{}
    stmts.init(8, p.allocator)

    while(!p.atEnd()) {
        if(p.check(TokenType.RIGHT_BRACE) || 
           p.check(TokenType.CASE)) {
            break;
        }

        var stmt = p.statement()
        p.eatSemicolon()

        stmts.add(stmt)

        if(breakCount != p.breakLevel) {
            p.breakLevel -= 1
            break
        }
    }

    return NewBlockStmt(pos, p.pos(), stmts, p.allocator)
}

func (p: *Parser) switchStatement() : *Stmt {
    var pos = p.prevPos()

    p.consume(TokenType.LEFT_PAREN, ErrorCode.MISSING_LEFT_PAREN);
    var cond = p.expression()
    p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN);

    var startBrace = p.match(TokenType.LEFT_BRACE)

    var cases = Array<*SwitchCaseStmt>{}
    cases.init(8, p.allocator)

    var defaultStmt: *Stmt = null

    p.switchLevel += 1
    while(!p.atEnd()) {
        if(p.check(TokenType.CASE)) {
            var caseStmt = p.switchCaseStatement() as (*SwitchCaseStmt)
            cases.add(caseStmt)

            p.eatSemicolon()
        }
        else if(p.check(TokenType.DEFAULT)) {
            p.consume(TokenType.COLON, ErrorCode.MISSING_COLON);
            defaultStmt = p.switchDefaultStatement()

            p.eatSemicolon()
        }
        else {
            break
        }
    }
    p.switchLevel -= 1

    if(startBrace) {
        p.consume(TokenType.RIGHT_BRACE, ErrorCode.MISSING_RIGHT_BRACE);
    }

    return NewSwitchStmt(pos, p.pos(), cond, cases, defaultStmt, p.allocator);
}


func (p: *Parser) breakStatement() : *Stmt {
    if(p.loopLevel < 1 && p.switchLevel < 1) {
        p.errorAtToken(p.previous(), ErrorCode.INVALID_BREAK)
    }

    if(p.switchLevel > 0 && p.loopLevel < 1) {
        p.breakLevel += 1
    }

    var pos = p.prevPos()
    return NewBreakStmt(pos, p.pos(), p.allocator)
}

func (p: *Parser) continueStatement() : *Stmt {
    if(p.loopLevel < 1) {
        p.errorAtToken(p.previous(), ErrorCode.INVALID_CONTINUE)
    }

    var pos = p.prevPos()
    return NewContinueStmt(pos, p.pos(), p.allocator)
}

func (p: *Parser) returnStatement() : *Stmt {    
    var pos = p.prevPos()
    var expr: *Expr = null
    if(!p.check(TokenType.SEMICOLON)) {
        expr = p.expression()
    }

    return NewReturnStmt(pos, p.pos(), expr, p.allocator)
}

func (p: *Parser) deferStatement() : *Stmt {    
    var pos = p.prevPos()
    var defered = p.statement()
    return NewDeferStmt(pos, p.pos(), defered, p.allocator)
}

func (p: *Parser) gotoStatement() : *Stmt {    
    var pos = p.prevPos()
    var label = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
    return NewGotoStmt(pos, p.pos(), label, p.allocator)
}

func (p: *Parser) tryLabelStatement() : *Stmt {    
    var backtrack = p.current    
    var pos = p.pos()

    var label = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
    if(!p.match(TokenType.COLON)) {
        p.current = backtrack
        return null
    }

    if(p.funcLevel < 1) {
        p.errorAtToken(p.peek(), ErrorCode.INVALID_LABEL_STMT)
    }

    return NewLabelStmt(pos, p.pos(), label, p.allocator)
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        Type Specifications
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


func (p: *Parser) type(disambiguate: bool = false) : *TypeSpec {
    var token = p.peek()
    switch(token.type) {
        case TokenType.BOOL:
        case TokenType.CHAR:
        case TokenType.I8:
        case TokenType.U8:
        case TokenType.I16:
        case TokenType.U16:
        case TokenType.I32:
        case TokenType.U32:
        case TokenType.I64:
        case TokenType.U64:
        case TokenType.F32:
        case TokenType.F64:
        case TokenType.USIZE:
        case TokenType.VOID: {
            p.advance()
            var spec = NewTypeSpec(TypeSpecKind.NAME, token.pos, p.allocator) as (*NameTypeSpec)
            spec.name = TokenName(token, p.allocator)
            
            return spec as (*TypeSpec)
        }
        case TokenType.STAR: {
            p.advance()
            var base = p.type(disambiguate)

            var spec = NewTypeSpec(TypeSpecKind.PTR, token.pos, p.allocator)
            spec.base = base
            return spec as (*TypeSpec)
        }
        case TokenType.CONST: {
            p.advance()
            var base = p.type(disambiguate)

            var spec = NewTypeSpec(TypeSpecKind.CONST, token.pos, p.allocator)
            spec.base = base
            return spec as (*TypeSpec)
        }
        case TokenType.IDENTIFIER: {
            return p.identifierType(disambiguate) as (*TypeSpec)
        }
        case TokenType.LEFT_BRACKET: {
            var spec = p.arrayType()
            p.advance()

            spec.base = p.type(disambiguate)
            return spec as (*TypeSpec)
        }
        case TokenType.FUNC: {
            p.advance()
            return p.funcPtrType() as (*TypeSpec)
        }
        default: {
            p.errorAtToken(token, ErrorCode.UNEXPECTED_TOKEN)
            break;
        }
    }

    return null
}

func (p: *Parser) identifierType(disambiguate: bool) : *NameTypeSpec {
    var token = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
    var sb = StringBufferInit(token.value.str.length, p.allocator)
    sb.append("%.*s", token.value.str.length, token.value.str.buffer)

    if(p.match(TokenType.COLON_COLON)) {
        // TODO - packages
    }

    var spec = NewTypeSpec(TypeSpecKind.NAME, token.pos, p.allocator) as (*NameTypeSpec)
    spec.name = sb.cStr()

    if(p.check(TokenType.LESS_THAN)) {        
        spec.genericArgs = p.tryGenericArguments(disambiguate)
    }

    return spec;
}

func (p: *Parser) arrayType() : *ArrayTypeSpec {    
    var spec = NewTypeSpec(TypeSpecKind.ARRAY, p.pos(), p.allocator) as (*ArrayTypeSpec)    
    p.advance()

    if(p.check(TokenType.RIGHT_BRACKET)) {
        var expr = p.expression()

        if(!p.isConstNumberExpr(expr)) {
            p.errorAtToken(p.peek(), ErrorCode.INVALID_ARRAY_DIMENSION_EXPR)
        }
        else {
            spec.numElements = expr
        }
    }

    return spec
}

func (p: *Parser) funcPtrType() : *FuncPtrTypeSpec {   
    var token = p.peek()
    var spec = NewTypeSpec(TypeSpecKind.FUNC_PTR, p.pos(), p.allocator) as (*FuncPtrTypeSpec)    

    if(p.match(TokenType.LESS_THAN))  {
        // TODO: Generics
    }

    p.consume(TokenType.LEFT_PAREN, ErrorCode.MISSING_LEFT_PAREN)
    if(!p.check(TokenType.RIGHT_PAREN)) {
        do {
            if(p.match(TokenType.VAR_ARGS)) {
                spec.hasVarargs = true
                if(!p.check(TokenType.RIGHT_PAREN)) {
                    p.errorAtToken(p.peek(), ErrorCode.INVALID_VARARG_POSITION)
                }
            }
            else {
                var arg = p.type(false)
                spec.args.add(arg)
            }
        }
        while(p.match(TokenType.COMMA))
    }

    p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN)
    p.consume(TokenType.COLON, ErrorCode.MISSING_COLON)

    spec.ret = p.type(false)
    return spec
}

func (p: *Parser) parametersStatement() : *ParametersStmt {
    var pos = p.pos()
    p.consume(TokenType.LEFT_PAREN, ErrorCode.MISSING_LEFT_PAREN);
    
    var params = Array<*ParameterDecl>{}
    var isVarargs = false;
    
    if(!p.check(TokenType.RIGHT_PAREN)) {
        params.init(8, p.allocator)

        do {                
            if(p.match(TokenType.VAR_ARGS)) {
                isVarargs = true;
                if(!p.check(TokenType.RIGHT_PAREN)) {
                    p.errorAtToken(p.peek(), ErrorCode.INVALID_VARARG_POSITION);
                }
            }
            else {               
                var param = p.paramDeclaration();
                params.add(param);
            }
        }
        while(p.match(TokenType.COMMA));
    }
    
    p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN);
    return NewParametersStmt(pos, p.pos(), params, isVarargs, p.allocator) as (*ParametersStmt)
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                            Utility
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

func (p: *Parser) structArguments() : Array<*InitArgExpr> {
    var arguments = Array<*InitArgExpr>{}
    arguments.init(16, p.allocator)

    var argPosition = 0
    do {
        if(p.check(TokenType.RIGHT_BRACE)) {
            break;
        }

        var pos = p.pos()
        var fieldName = Token{}
        if(p.check(TokenType.DOT)) {
            var name = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
            if(name) {
                fieldName = *name
            }
            
            if(p.check(TokenType.COLON)) {
                p.consume(TokenType.COLON, ErrorCode.MISSING_COLON)
            }
            else if(p.check(TokenType.EQUALS)) {
                p.consume(TokenType.EQUALS, ErrorCode.MISSING_EQUALS)
            }
            else {
                p.errorAtToken(p.peek(), ErrorCode.MISSING_COLON)
            }
        }
        
        var value = p.expression()        
        var arg = NewInitArgExpr(pos, p.pos(), fieldName, argPosition, value, p.allocator) as (*InitArgExpr)
        arguments.add(arg)
        argPosition += 1        
    }
    while(p.match(TokenType.COMMA))

    p.consume(TokenType.RIGHT_BRACE, ErrorCode.MISSING_RIGHT_BRACE)
    return arguments    
}

func (p: *Parser) arguments() : Array<*Expr> {
    var arguments = Array<*Expr>{}
    if(!p.check(TokenType.RIGHT_PAREN)) {
        arguments.init(8, p.allocator)

        do {
            var expr = p.expression()
            arguments.add(expr)
        }
        while(p.match(TokenType.COMMA))
    }

    p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN)
    return arguments
}


func (p: *Parser) genericParameters() : Array<GenericParam> {
    var arguments = Array<GenericParam>{}
    if(!p.check(TokenType.GREATER_THAN)) {
        arguments.init(2, p.allocator)

        do {
            var typeName = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
            if(typeName) {
                arguments.add(GenericParam {
                    .name = *typeName
                })
            }
        }
        while(p.match(TokenType.COMMA))
    }

    p.consume(TokenType.GREATER_THAN, ErrorCode.MISSING_GENERIC_END)
    return arguments
}

func (p: *Parser) genericArguments() : Array<*TypeSpec> {
    var arguments = Array<*TypeSpec>{}
    if(!p.check(TokenType.GREATER_THAN)) {
        arguments.init(2, p.allocator)

        do {
            var type = p.type(false)
            if(type) {
                arguments.add(type)
            }
        }
        while(p.match(TokenType.COMMA))
    }

    p.consume(TokenType.GREATER_THAN, ErrorCode.MISSING_GENERIC_END)
    return arguments
}

func (p: *Parser) tryGenericArguments(disambiguate: bool) : Array<*TypeSpec> {
    var backtrack = p.current
    var numOfErrors = p.numOfErrors()
    var pos = p.pos()

    var arguments = p.genericArguments()
    var isFailed = false

    if(p.numOfErrors() == numOfErrors) {
        if(disambiguate) {
            var token = p.peek()
            switch(token.type) {
                case TokenType.LEFT_PAREN:
                case TokenType.RIGHT_PAREN:
                case TokenType.RIGHT_BRACKET:
                case TokenType.LEFT_BRACE:
                case TokenType.RIGHT_BRACE:
                case TokenType.COLON:
                case TokenType.SEMICOLON:
                case TokenType.COMMA:
                case TokenType.DOT:
                case TokenType.QUESTION_MARK:
                case TokenType.EQUALS_EQUALS:
                case TokenType.NOT_EQUALS:
                case TokenType.OR:
                case TokenType.XOR:
                case TokenType.STAR:
                    return arguments;
                default: {                  
                    isFailed = true;
                    break;
                }
            }
        }
    }

    if(p.numOfErrors() > numOfErrors) {
        p.rewindTo(backtrack, numOfErrors)
        isFailed = true;
    }

    if(isFailed) {
        for(var i = 0; i < arguments.size(); i += 1) {
            var type = arguments.get(i)
            p.allocator.free(type)
        }
        arguments.free()
    }

    return arguments
}

func (p: *Parser) arrayArguments() : Array<*Expr> {
    var arguments = Array<*Expr>{}
    arguments.init(16, p.allocator)

    do {
        if(p.check(TokenType.RIGHT_BRACE)) {
            break;
        }

        var expr: *Expr = null
        if(p.check(TokenType.LEFT_BRACKET)) {
            expr = p.tryArrayDesignationExpr()
        }

        if(!expr) {
            expr = p.expression()
        }

        if(expr) {
            arguments.add(expr)
        }
    }
    while(p.match(TokenType.COMMA))

    p.consume(TokenType.RIGHT_BRACE, ErrorCode.MISSING_RIGHT_BRACE)
    return arguments
}

func (p: *Parser) tryArrayDesignationExpr() : *Expr {
    var backtrack = p.current
    var numOfErrors = p.numOfErrors()
    var pos = p.pos()

    var designatorExpr: *Expr = null
    if(p.match(TokenType.LEFT_BRACKET)) {
        var index = p.expression()
        p.consume(TokenType.RIGHT_BRACKET, ErrorCode.MISSING_RIGHT_BRACKET)
        p.consume(TokenType.EQUALS, ErrorCode.MISSING_EQUALS)
        var value = p.expression()

        if(p.numOfErrors() == numOfErrors) {
            designatorExpr = NewArrayDesignationExpr(pos, p.pos(), index, value, p.allocator)
        }
        else {
            p.allocator.free(index)
            p.allocator.free(value)
        }
    }

    if(p.numOfErrors() > numOfErrors) {
        p.rewindTo(backtrack, numOfErrors)
    }

    return designatorExpr
}

func (p: *Parser) rewindTo(backtrack: i32, numOfErrors: i32) {
    assert(p.numOfErrors() > numOfErrors) 
    {
        // rewind the parser and errors
        p.current = backtrack
        for(var i = p.numOfErrors() - 1; i >= numOfErrors; i -= 1) {
            var error = p.result.errors.removeAt(i)
            p.allocator.free(error.message as (*void))
        }
    }
}

// account for generics, we must peek ahead to see if
// this is a bit shift operator or generics
func (p: *Parser) tryBitShiftRight(expr: *Expr) : *Expr {

    if(!p.check(TokenType.GREATER_THAN)) {
        return null
    }

    var prevToken = p.advance()
    if(!p.check(TokenType.GREATER_THAN)) {
        p.rewind()
        return null
    }

    var nextToken = p.advance()
    if((nextToken.pos.position - prevToken.pos.position) == 1) {
        var right = p.term()
        return NewBinaryExpr(expr.startPos, p.pos(), expr, TokenType.RSHIFT, right, p.allocator)
    }

    // this wasn't a bit shift attempt, abort!
    p.rewind() 
    p.rewind()
    return null
}

func (p: *Parser) eatSemicolon() {
    p.match(TokenType.SEMICOLON)
}

func (p: *Parser) identifier() : Token {
    var name = Token {
        .type = TokenType.ERROR
    }
    var identifier = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
    if(identifier) {
        name = *identifier
    }

    return name
}

func (p: *Parser) isIdentifier(expr: *Expr) : bool {
    if(!expr) {
        return false
    }

    return expr.kind == StmtKind.IDENTIFIER_EXPR ||
           expr.kind == StmtKind.FUNC_IDENTIFIER_EXPR ||
           expr.kind == StmtKind.TYPE_IDENTIFIER_EXPR
}


func (p: *Parser) isConstNumberExpr(expr: *Expr) : bool {
    if(!expr) {
        return false;
    }
    
    switch(expr.kind) {
        case StmtKind.NUMBER_EXPR:
        case StmtKind.BOOLEAN_EXPR:
        //case STRING_EXPR:
        case StmtKind.CHAR_EXPR:
        //case NULL_EXPR:
        case StmtKind.IDENTIFIER_EXPR:
        case StmtKind.GET_EXPR: {
            return true
        }
        case StmtKind.GROUP_EXPR: {
            var groupExpr = expr as (*GroupExpr)
            return p.isConstNumberExpr(groupExpr.expr)
        }
        case StmtKind.BINARY_EXPR: {
            var binExpr = expr as (*BinaryExpr)
            return p.isConstNumberExpr(binExpr.left) &&
                   p.isConstNumberExpr(binExpr.right)
        }
        case StmtKind.UNARY_EXPR: {
            var unaryExpr = expr as (*UnaryExpr)
            return p.isConstNumberExpr(unaryExpr.unaryExpr)
        }
        default: {
            return false
        }
    }
    return false
}


func (p: *Parser) checkConstExpr(expr: *Expr) : bool {
    if(!expr) {
        return false;
    }

    switch(expr.kind) {
        case StmtKind.NUMBER_EXPR:
        case StmtKind.BOOLEAN_EXPR:
        case StmtKind.STRING_EXPR:
        case StmtKind.CHAR_EXPR:
        case StmtKind.NULL_EXPR:
        case StmtKind.IDENTIFIER_EXPR:
        case StmtKind.GET_EXPR: {
            return true
        }
        case StmtKind.GROUP_EXPR: {
            var groupExpr = expr as (*GroupExpr)
            return p.checkConstExpr(groupExpr.expr)
        }
        case StmtKind.BINARY_EXPR: {
            var binExpr = expr as (*BinaryExpr)
            return p.checkConstExpr(binExpr.left) &&
                   p.checkConstExpr(binExpr.right)
        }
        case StmtKind.UNARY_EXPR: {
            var unaryExpr = expr as (*UnaryExpr)
            return p.checkConstExpr(unaryExpr.unaryExpr)
        }
        default: {
            p.errorAtPos(expr.startPos, ErrorCode.INVALID_CONST_EXPR)
        }
    }
    return false
}

func (p: *Parser) pos() : SrcPos {
    if(!p.atEnd()) {
        return p.peek().pos
    }

    return SrcPos{}
}

func (p: *Parser) prevPos() : SrcPos {    
    return p.previous().pos
}

func (p: *Parser) peek() : *Token {
    assert(p.current < p.tokens.size())
    return &p.tokens.elements[p.current]
}

func (p: *Parser) rewind() {
    p.current -= 1
    if(p.current < 0) {
        p.current = 0
    }
}

func (p: *Parser) previous() : *Token {
    var index = p.current - 1;
    assert(index < p.tokens.size() && index >= 0)
    return &p.tokens.elements[index]
}

func (p: *Parser) atEnd() : bool {
    return p.tokens.empty() || p.peek().type == TokenType.END_OF_FILE
}

func (p: *Parser) advance() : *Token {
    if(!p.atEnd()) {
        p.current += 1
    }
    return p.previous()
}

func (p: *Parser) check(type: TokenType) : bool {
    if(p.atEnd()) return false
    return p.peek().type == type
}

func (p: *Parser) match(type: TokenType) : bool {
    if(p.check(type)) {
        p.advance()
        return true
    }
    return false
}

func (p: *Parser) matches(types: *TokenType, len: i32) : bool {
    for(var i = 0; i < len; i += 1) {
        var type = types[i]
        if(p.check(type)) {
            p.advance()
            return true
        }
    }
    return false
}

func (p: *Parser) consume(type: TokenType, errorCode: ErrorCode) : *Token {
    if(p.check(type)) {
        return p.advance()
    }

    p.errorAt(type, errorCode)
    return null
}

func (p: *Parser) adjust(types: *TokenType = null, len: i32 = 0) {
    if(!types || len < 1) {
        p.advance()
        return;
    }

    while(!p.atEnd()) {
        var type = p.peek().type
        for(var i = 0; i < len; i+=1) {
            if(types[i] == type) {
                return;
            }
        }

        p.advance()
    }
}

func (p: *Parser) errorAtToken(token: *Token, errorCode: ErrorCode) {
    if(!token) {
        // TODO: create an error message        
        p.result.addError(token.pos,"%s\n", errorCodeText[errorCode])
    }
    else {
        p.errorAt(token.type, errorCode)
    }
    
}

func (p: *Parser) errorAtPos(pos: SrcPos, errorCode: ErrorCode) {
    p.result.addError(pos,"%s\n", errorCodeText[errorCode])    
}

func (p: *Parser) errorAt(type: TokenType, errorCode: ErrorCode) {
    // TODO: create an error message
    p.result.addError(p.pos(), "Expected token: '%s' - %s\n", tokenText[type], errorCodeText[errorCode])
}

func (p: *Parser) numOfErrors() : i32 {
    return p.result.errors.size()
}