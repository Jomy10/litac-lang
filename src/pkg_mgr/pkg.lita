import "std/string_view"
import "std/string_buffer"
import "std/array"
import "std/mem"
import "std/json"
import "std/map"
import "std/libc"
import "std/assert"
import "std/io"
import "std/system"

import "pkg_mgr/pkg_mgr"
import "pkg_mgr/pkg_sync"

public const SEPARATOR = "|"
public const SEPARATOR_LENGTH = 1  /* we need better const support! */

public enum PackageType {
    EXECUTABLE,
    STATIC_LIBRARY,
    DYNAMIC_LIBRARY,
    SOURCE_LIBRARY,
}

public struct PackageDef {
    id: using PackageId

    // the physical path to this package when
    // it is installed
    path: [MAX_PATH]char

    type: PackageType
    dependencies: Array<PackageId>
}

public struct PackageId {
    id: *const char

    repo: StringView
    name: StringView
    version: StringView
}

public func PackageIdFromString(id: *const char) : PackageId {
    var view = StringViewInit(id)
    var nameIndex = view.indexOfAt(SEPARATOR, .len = SEPARATOR_LENGTH, .fromIndex = 0)
    if(nameIndex < 0) {
        goto invalid
    }
    var versionIndex = view.indexOfAt(SEPARATOR, .len = SEPARATOR_LENGTH, .fromIndex = nameIndex + 1)
    if(versionIndex < 0) {
        goto invalid
    }

    return PackageId {
        .id = id,
        .repo = StringView {
            .buffer = id,
            .length = nameIndex
        },
        .name = StringView {
            .buffer = id + nameIndex + 1,
            .length = versionIndex - nameIndex - 1
        },
        .version = StringView {
            .buffer = id + versionIndex + 1,
            .length = view.length - versionIndex - 1
        },
    }

invalid:
    return PackageId {
        .id = id
    }
}

public func ParsePackageFile(
        pm: *PackageManager,
        pkgFile: *const char,
        result: **PackageDef) : SyncStatus {

    var parser = JsonParser{}
    parser.init(pm.allocator)
    defer parser.free()

    var data: *char;
    var length: usize;

    if(ReadFile(pkgFile, &data, &length, pm.allocator) != FileStatus.Ok) {
        return SyncStatus.ERROR_READING_PKG_FILE
    }

    var node = parser.parseJson(data)
    defer if(node) node.free()

    if(parser.hasError()) {
        return SyncStatus.ERROR_PARSING_PKG_JSON;
    }

    return ParsePackage(pm, node, result)
}

public func ParsePackage(
        pm: *PackageManager,
        json: *JsonNode,
        result: **PackageDef) : SyncStatus {

    if(!json) {
        return SyncStatus.ERROR_READING_PKG_FILE
    }

    var pkgId = PackageId{};
    var code = ParsePackageId(json, &pkgId, pm.allocator)
    if(code != SyncStatus.OK) {
        return code
    }

    // if this is already in the registry, no need to further process
    if(pm.packages.contains(pkgId.id)) {
        *result = pm.packages.get(pkgId.id)
        return SyncStatus.OK
    }

    var pkg = new<PackageDef>(pm.allocator)
    pkg.id = pkgId

    pm.packages.put(pkgId.id, pkg)

    var type = json.getStr("type", "source")
    /* TODO parse type */

    var deps = json.getArray("dependencies")
    if(deps && deps.size() > 0) {
        pkg.dependencies.init(deps.size(), pm.allocator)

        for(var i = 0; i < deps.size(); i+=1) {
            var depNode = deps.at(i)

            pkg.dependencies.add(PackageId{})
            var pkgId = pkg.dependencies.getPtr(i)

            var code = ParsePackageId(depNode, pkgId, pm.allocator)
            if(code != SyncStatus.OK) {
                return code
            }
        }
    }

    (*result) = pkg

    return SyncStatus.OK
}


public func ParsePackageId(
        json: *JsonNode,
        pkg: *PackageId,
        allocator: *const Allocator = defaultAllocator) : SyncStatus {

    if(!json) {
        return SyncStatus.ERROR_PARSING_PKG_JSON
    }

    var repo = json.getStr("repo")
    if(!repo) return SyncStatus.ERROR_PARSING_PKG_JSON

    var name = json.getStr("name")
    if(!name) return SyncStatus.ERROR_PARSING_PKG_JSON

    var version = json.getStr("version")
    if(!version) return SyncStatus.ERROR_PARSING_PKG_JSON

    var repoLen = strlen(repo)
    var nameLen = strlen(name)
    var versionLen = strlen(version)

    var sb = StringBufferInit(repoLen + nameLen + versionLen + 1, allocator)
    sb.append("%s%s%s%s%s", repo, SEPARATOR, name, SEPARATOR, version)

    var id = sb.cStr();

    pkg.id = id;
    pkg.repo = StringViewInit(id, repoLen);
    pkg.name = StringViewInit(id + repoLen + SEPARATOR_LENGTH, nameLen);
    pkg.version = StringViewInit(
        id + repoLen + SEPARATOR_LENGTH + nameLen + SEPARATOR_LENGTH,
        versionLen);

    return SyncStatus.OK
}


public func (this: *PackageDef) equals(other: *PackageDef) : bool {
    return
        this.repo.equalsStringView(other.repo) &&
        this.name.equalsStringView(other.name) &&
        this.version.equalsStringView(other.version)
}

@test
func testParsePackage() {
    var parser = JsonParser{}
    parser.init()
    defer parser.free()

    var data =
    """
    {
        "repo" : "https://github.com/tonysparks",
        "name" : "litac-lang",
        "version" : "0.1.2-alpha",
        "type": "executable",
        "dependencies": [
        ]
    }
    """;

    //"

    var node = parser.parseJson(data)
    defer if(node) node.free()

    if(parser.hasError()) {
        printf("Error parsing JSON\n")
        return;
    }

    var pm = PackageManager {}
    pm.init(PackageSyncOptions{})
    defer pm.free()

    var pkg: *PackageDef;
    if(ParsePackage(&pm, node, &pkg) != SyncStatus.OK) {
        printf("Error parsing Package\n")
        return;
    }

    printf("Id: %s\n", pkg.id.id)
    printf("Repo: %.*s\n", pkg.repo.length, pkg.repo.buffer)
    printf("Name: %.*s\n", pkg.name.length, pkg.name.buffer)
    printf("Version: %.*s\n", pkg.version.length, pkg.version.buffer)
}

@test
func testPackageFromString() {
    var pkg = PackageIdFromString("repo|name|version")
    printf("%.*s\n", pkg.repo.length, pkg.repo.buffer)
    printf("%.*s\n", pkg.name.length, pkg.name.buffer)
    printf("%.*s\n", pkg.version.length, pkg.version.buffer)
    assert(pkg.repo.equals("repo"))
    assert(pkg.name.equals("name"))
    assert(pkg.version.equals("version"))
}