import "symbols"
import "types"
import "lex"
import "array"
import "mem"
import "common"
import "module"
import "string_view"
import "libc"
import "string"

@asStr
public enum StmtKind {
    IMPORT_DECL,
    CONST_DECL,
    VAR_DECL,
    STRUCT_DECL,
    UNION_DECL,
    ENUM_DECL,
    FUNC_DECL,
    TYPEDEF_DECL,
    PARAM_DECL,
    NATIVE_DECL,
    POISON_DECL,

    BLOCK_STMT,
    BREAK_STMT,
    COMP_STMT,
    CONTINUE_STMT,
    DEFER_STMT,
    DO_WHILE_STMT,
    EMPTY_STMT,
    ENUM_FIELD_ENTRY_STMT,
    ENUM_FIELD_STMT,
    //FIELD_STMT,
    FOR_STMT,
    FUNC_BODY_STMT,
    GOTO_STMT,
    IF_STMT,
    LABEL_STMT,
    MODULE_STMT,
    NOTE_STMT,
    PARAMETERS_STMT,
    RETURN_STMT,
    STRUCT_FIELD_STMT,
    SWITCH_CASE_STMT,
    SWITCH_STMT,
    UNION_FIELD_STMT,
    VAR_FIELD_STMT,
    WHILE_STMT,

    ARRAY_DESIGNATION_EXPR,
    ARRAY_INIT_EXPR,
    BINARY_EXPR,
    BOOLEAN_EXPR,
    CAST_EXPR,
    CHAR_EXPR,
    FUNC_CALL_EXPR,
    FUNC_IDENTIFIER_EXPR,
    GET_EXPR,
    GROUP_EXPR,
    IDENTIFIER_EXPR,
    INIT_EXPR,
    INIT_ARG_EXPR,
    NULL_EXPR,
    NUMBER_EXPR,
    OFFSET_OF_EXPR,
    SET_EXPR, 
    SIZE_OF_EXPR,
    STRING_EXPR,   
    SUBSCRIPT_GET_EXPR,
    SUBSCRIPT_SET_EXPR,
    TERNARY_EXPR,
    TYPE_IDENTIFIER_EXPR,
    TYPE_OF_EXPR,
    UNARY_EXPR,
    POISON_EXPR,

    MAX_STMT_KINDS
}

@asStr
public enum TypeSpecKind {
    NONE,
    ARRAY,
    PTR,
    CONST,
    NAME,
    FUNC_PTR,

    MAX_TYPESPEC_KINDS
}

public enum FuncFlags {
    HAS_VARARGS = (1<<0),
    IS_METHOD   = (1<<1),
}

public enum AggregateFlags {
    IS_EMBEDDED  = (1<<0),
    IS_ANONYMOUS = (1<<1),
}

public struct TypeSpec {
    kind: TypeSpecKind
    pos: SrcPos
    base: *TypeSpec
    typeInfo: *TypeInfo    // resolved from the type checker
}

public struct NameTypeSpec {
    spec: using TypeSpec
    name: *const char
    genericArgs: Array<*TypeSpec>
}

public struct ArrayTypeSpec {
    spec: using TypeSpec
    numElements: *Expr
}

public struct PtrTypeSpec {
    spec: using TypeSpec
}

public struct ConstTypeSpec {
    spec: using TypeSpec
}

public struct FuncPtrTypeSpec {
    spec: using TypeSpec
    args: Array<*TypeSpec>
    ret: *TypeSpec
    hasVarargs: bool
    genericParams: Array<GenericParam>
}

public struct GenericParam {
    name: Token
}

public struct Attributes {
    isPublic: bool
    isGlobal: bool
    isUsing: bool
    notes: Array<*NoteStmt>
}


public struct Node {
    kind: StmtKind
    parent: *Node
    startPos: SrcPos
    endPos: SrcPos
}

public func (n: *Node) setSrcPos(start: SrcPos, end: SrcPos) {
    n.startPos = start
    n.endPos = end
}

public func (n: *Node) becomeParentOf<T>(child: *T) : *T {
    if(!child) return null;

    child.parent = n as (*Node)
    return child
}

public func (n: *Node) becomeParentOfChildren<T>(children: *Array<T>) : *Array<T> {
    var size = children.size()
    for(var i = 0; i < size; i += 1) {
        var child = children.get(i)
        if(child) {
            n.becomeParentOf(child)
        }
    }

    return children
}

public struct Decl {
    stmt: using Stmt
    sym: *Symbol
    name: Token
    attributes: Attributes
}

public struct ImportDecl {
    decl: using Decl
    alias: Token // Identifier?
    isUsing: bool

    moduleId: *ModuleId
}

// For var or const declarations
public struct VarDecl {
    decl: using Decl
    typeSpec: *TypeSpec
    expr: *Expr
}

public struct ParameterDecl {
    decl: using Decl
    type: *TypeSpec
    defaultExpr: *Expr
    typeInfo: *TypeInfo
}

public struct FuncDecl {
    decl: using Decl
    genericParams: Array<GenericParam>
    params: *ParametersStmt
    body: *Stmt
    returnType: *TypeSpec
    flags: i32

}

public struct AggregateDecl {
    decl: using Decl
    genericParams: Array<GenericParam>
    fields: Array<FieldStmt>
    flags: i32
}

public struct EnumDecl {
    decl: using Decl
    fields: Array<*EnumFieldEntryStmt>
}

public struct TypedefDecl {
    decl: using Decl
    genericParams: Array<GenericParam>
    type: *TypeSpec    
}

public struct NativeDecl {
    decl: using Decl
    typeInfo: *TypeInfo
}

public struct PoisonDecl {
    decl: using Decl
}

public struct BlockStmt {
    stmt: using Stmt
    stmts: Array<*Stmt>
}

public struct BreakStmt {
    stmt: using Stmt
}

public struct CompStmt {
    stmt: using Stmt
    type: *const char
    expr: *const char
    body: Array<*Stmt>
    end: *CompStmt
    evaluatedStmt: *Stmt
}

public struct ContinueStmt {
    stmt: using Stmt
}

public struct DeferStmt {
    stmt: using Stmt
    deferedStmt: *Stmt
}

public struct DoWhileStmt {
    stmt: using Stmt
    cond: *Expr
    body: *Stmt
}

public struct EmptyStmt {
    stmt: using Stmt
}

public struct EnumFieldEntryStmt {
    stmt: using Stmt
    fieldName: Token
    value: *Expr
    attributes: Attributes
}

public struct EnumFieldStmt {
    stmt: using Stmt
    decl: *EnumDecl
}

public struct ForStmt {
    stmt: using Stmt
    init: *Stmt
    cond: *Expr
    post: *Stmt
    body: *Stmt
}

public struct FuncBodyStmt {
    stmt: using Stmt
    stmts: Array<*Stmt>
}

public struct GotoStmt {
    stmt: using Stmt
    label: Token // Identifer?
}

public struct IfStmt {
    stmt: using Stmt
    cond: *Expr
    then: *Stmt
    elseStmt: *Stmt
}


public struct LabelStmt {
    stmt: using Stmt
    label: Token // Identifier?
}

// TODO: should ths be a declaration?
public struct ModuleStmt {
    stmt: using Stmt
    imports: Array<*ImportDecl>
    notes: Array<*NoteStmt>
    declarations: Array<*Decl>
    //TODO: id: ModuleId
}

public struct NoteStmt {
    stmt: using Stmt
    name: Token // Identifier?
    attributes: Array<Token> // Identifier?
}

public struct ParametersStmt {
    stmt: using Stmt
    params: using Array<*ParameterDecl>
    isVararg: bool
}

public struct ReturnStmt {
    stmt: using Stmt
    expr: *Expr
}


public struct AggregateFieldStmt {
    stmt: using Stmt
    decl: *AggregateDecl
}

public struct SwitchCaseStmt {
    stmt: using Stmt
    cond: *Expr
    body: *Stmt
}

public struct SwitchStmt {
    stmt: using Stmt
    cond: *Expr
    cases: Array<*SwitchCaseStmt>
    defaultStmt: *Stmt
}

public struct VarFieldStmt {
    stmt: using Stmt
    fieldName: Token
    type: *TypeSpec
    attributes: Attributes
    defaultExpr: *Expr
}

public struct FieldStmt {
    kind: StmtKind
    typeInfo: *TypeInfo
    union {
        enumField: *EnumDecl
        aggregateField: *AggregateDecl
        varField: *VarFieldStmt
        poisonField: *Expr
    }
}

public struct WhileStmt {
    stmt: using Stmt
    cond: *Expr
    body: *Stmt
}


public struct Stmt {
    node: using Node
}

public struct ArrayDesignationExpr {
    expr: using Expr
    index: *Expr
    value: *Expr
}

public struct ArrayInitExpr {
    expr: using Expr
    type: *TypeSpec
    values: Array<*Expr>
}

public struct BinaryExpr {
    expr: using Expr
    left: *Expr
    operator: TokenType
    right: *Expr
}

public struct BooleanExpr {
    expr: using Expr
    boolean: bool
}

public struct CastExpr {
    expr: using Expr
    castTo: *TypeSpec
    exprToCast: *Expr
}

public struct CharExpr {
    expr: using Expr
    character: Token
}

public struct FuncCallExpr {
    expr: using Expr
    object: *Expr
    genericArgs: Array<*TypeSpec>
    arguments: Array<*Expr>
}

public struct GetExpr {
    expr: using Expr
    object: *Expr
    field: *IdentifierExpr
    isMethodCall: bool
}

public struct GroupExpr {
    expr: using Expr
    groupedExpr: *Expr
}

public struct IdentifierExpr {
    expr: using Expr
    //genericArgs: Array<*TypeSpec>
    type: *NameTypeSpec
    sym: *Symbol
}

public struct InitArgExpr {
    expr: using Expr
    fieldName: Token // Identifier?
    argPosition: i32
    value: *Expr
}

public struct InitExpr {
    expr: using Expr
    genericArgs: Array<*TypeSpec>
    type: *NameTypeSpec
    arguments: Array<*InitArgExpr>
}

public struct NullExpr {
    expr: using Expr
}

public struct NumberExpr {
    expr: using Expr
    number: Token // TODO: should this be the number value? or Token
}

public struct OffsetOfExpr {
    expr: using Expr
    type: *TypeSpec
    field: Token // Identifier?
}

public struct SetExpr {
    expr: using Expr
    object: *Expr
    field: *IdentifierExpr
    operator: TokenType
    value: *Expr
}

public struct SizeOfExpr {
    expr: using Expr
    sizeOfExpr: *Expr 
}

public struct StringExpr {
    expr: using Expr
    string: Token // Identifier or Token?
}

public struct SubscriptGetExpr {
    expr: using Expr
    object: *Expr
    index: *Expr
}

public struct SubscriptSetExpr {
    expr: using Expr
    object: *Expr
    index: *Expr
    operator: TokenType
    value: *Expr
}

public struct TernaryExpr {
    expr: using Expr
    cond: *Expr
    then: *Expr
    other: *Expr
}

public struct TypeIdentifierExpr {
    expr: using Expr
    //genericArgs: Array<*TypeSpec>
    type: *TypeSpec
    sym: *Symbol
}

public struct TypeOfExpr {
    expr: using Expr
    typeOfExpr: *Expr
    type: *TypeSpec
}

public struct UnaryExpr {
    expr: using Expr
    operator: TokenType
    unaryExpr: *Expr
}

public struct PoisonExpr {
    expr: using Expr
}

public struct Expr {
    stmt: using Stmt
    operand: Operand
    expectedType: *TypeInfo
}

public struct Operand {
    typeInfo: *TypeInfo
    isRightValue: bool
    isConst: bool
    val: Value
}

public func IsExpr(node: *Node) : bool {
    if(!node) return false;

    switch(node.kind) {
        case StmtKind.ARRAY_DESIGNATION_EXPR:
        case StmtKind.ARRAY_INIT_EXPR:
        case StmtKind.BINARY_EXPR:
        case StmtKind.BOOLEAN_EXPR:
        case StmtKind.CAST_EXPR:
        case StmtKind.CHAR_EXPR:
        case StmtKind.FUNC_CALL_EXPR:
        case StmtKind.FUNC_IDENTIFIER_EXPR:
        case StmtKind.GET_EXPR:
        case StmtKind.GROUP_EXPR:
        case StmtKind.IDENTIFIER_EXPR:
        case StmtKind.INIT_EXPR:
        case StmtKind.INIT_ARG_EXPR:
        case StmtKind.NULL_EXPR:
        case StmtKind.NUMBER_EXPR:
        case StmtKind.OFFSET_OF_EXPR:
        case StmtKind.SET_EXPR: 
        case StmtKind.SIZE_OF_EXPR:
        case StmtKind.STRING_EXPR:   
        case StmtKind.SUBSCRIPT_GET_EXPR:
        case StmtKind.SUBSCRIPT_SET_EXPR:
        case StmtKind.TERNARY_EXPR:
        case StmtKind.TYPE_IDENTIFIER_EXPR:
        case StmtKind.TYPE_OF_EXPR:
        case StmtKind.UNARY_EXPR:
        case StmtKind.POISON_EXPR:
            return true;
        default: 
            return false;
    }
}

public func IsDecl(node: *Node) : bool {
    if(!node) return false;

    switch(node.kind) {
        case StmtKind.IMPORT_DECL:
        case StmtKind.CONST_DECL:
        case StmtKind.VAR_DECL:
        case StmtKind.STRUCT_DECL:
        case StmtKind.UNION_DECL:
        case StmtKind.ENUM_DECL:
        case StmtKind.FUNC_DECL:
        case StmtKind.TYPEDEF_DECL:
        case StmtKind.PARAM_DECL:
        case StmtKind.NATIVE_DECL:
        case StmtKind.POISON_DECL:
            return true;
        default: 
            return false;
    }
}

public func (d: *Decl) hasNote(name: *const char) : bool {
    if(!d) return false;

    if(d.attributes.notes.empty()) {
        return false;
    }

    for(var i = 0; i < d.attributes.notes.size(); i += 1) {
        var note = d.attributes.notes.get(i)
        if(note.name.nameEquals(name)) {
            return true;
        }
    }
    return false;
}

public func (f: *FuncDecl) getName(name:[MAX_SYMBOL_NAME]char) : bool {
    if(f.name.type != TokenType.IDENTIFIER) {
        return false
    }

    if(f.flags & FuncFlags.IS_METHOD) {
        if(f.params.empty()) {
            return false
        }
        var first = f.params.first()
        if(!first.type) {
            return false
        }

        if(first.type.kind != TypeSpecKind.NAME) {
            return false
        }

        var type = first.type as (*NameTypeSpec)
        var totalLen = f.name.str.length + strlen(type.name) + 2 // _ and \0
        if(totalLen > MAX_SYMBOL_NAME) {
            return false
        }

        var nameStr = StringInit(name, MAX_SYMBOL_NAME)
        nameStr.format("%.*s_%s", f.name.str.length, f.name.str.buffer, type.name)
        return true
    }

    var nameStr = StringInit(name, MAX_SYMBOL_NAME)
    nameStr.format("%.*s", f.name.str.length, f.name.str.buffer)
    return true
}

public func (expr: *Expr) isIdentifier() : bool {
    if(!expr) {
        return false
    }

    return expr.kind == StmtKind.IDENTIFIER_EXPR ||
           expr.kind == StmtKind.FUNC_IDENTIFIER_EXPR ||
           expr.kind == StmtKind.TYPE_IDENTIFIER_EXPR
}


public func (expr: *Expr) isConstNumberExpr() : bool {
    if(!expr) {
        return false;
    }
    
    switch(expr.kind) {
        case StmtKind.NUMBER_EXPR:
        case StmtKind.BOOLEAN_EXPR:
        case StmtKind.CHAR_EXPR:
        case StmtKind.IDENTIFIER_EXPR:
        case StmtKind.GET_EXPR: {
            return true
        }
        case StmtKind.GROUP_EXPR: {
            var groupExpr = expr as (*GroupExpr)
            return groupExpr.expr.isConstNumberExpr()
        }
        case StmtKind.BINARY_EXPR: {
            var binExpr = expr as (*BinaryExpr)
            return binExpr.left.isConstNumberExpr() &&
                   binExpr.right.isConstNumberExpr()
        }
        case StmtKind.UNARY_EXPR: {
            var unaryExpr = expr as (*UnaryExpr)
            return unaryExpr.unaryExpr.isConstNumberExpr()
        }
        default: {
            return false
        }
    }
    return false
}