import "symbols"
import "types"
import "lex"
import "array"
import "mem"
import "common"

public enum StmtKind {
    IMPORT_DECL,
    CONST_DECL,
    VAR_DECL,
    STRUCT_DECL,
    UNION_DECL,
    ENUM_DECL,
    FUNC_DECL,
    TYPEDEF_DECL,
    PARAM_DECL,
    NATIVE_DECL,

    BLOCK_STMT,
    BREAK_STMT,
    COMP_STMT,
    CONTINUE_STMT,
    DEFER_STMT,
    DO_WHILE_STMT,
    EMPTY_STMT,
    ENUM_FIELD_ENTRY_STMT,
    ENUM_FIELD_STMT,
    //FIELD_STMT,
    FOR_STMT,
    FUNC_BODY_STMT,
    GOTO_STMT,
    IF_STMT,
    LABEL_STMT,
    MODULE_STMT,
    NOTE_STMT,
    PARAMETERS_STMT,
    RETURN_STMT,
    STRUCT_FIELD_STMT,
    SWITCH_CASE_STMT,
    SWITCH_STMT,
    UNION_FIELD_STMT,
    VAR_FIELD_STMT,
    WHILE_STMT,

    ARRAY_DESIGNATION_EXPR,
    ARRAY_INIT_EXPR,
    BINARY_EXPR,
    BOOLEAN_EXPR,
    CAST_EXPR,
    CHAR_EXPR,
    FUNC_CALL_EXPR,
    FUNC_IDENTIFIER_EXPR,
    GET_EXPR,
    GROUP_EXPR,
    IDENTIFIER_EXPR,
    INIT_EXPR,
    INIT_ARG_EXPR,
    NULL_EXPR,
    NUMBER_EXPR,
    OFFSET_OF_EXPR,
    SET_EXPR, 
    SIZE_OF_EXPR,
    STRING_EXPR,   
    SUBSCRIPT_GET_EXPR,
    SUBSCRIPT_SET_EXPR,
    TERNARY_EXPR,
    TYPE_IDENTIFIER_EXPR,
    TYPE_OF_EXPR,
    UNARY_EXPR,
    POISON_EXPR,

    MAX_STMT_KINDS
}

public enum TypeSpecKind {
    NONE,
    ARRAY,
    PTR,
    CONST,
    NAME,
    FUNC_PTR,

    MAX_TYPESPEC_KINDS
}

public struct TypeSpec {
    kind: TypeSpecKind
    pos: SrcPos
    base: *TypeSpec
}

public struct NameTypeSpec {
    spec: using TypeSpec
    name: *const char
    genericArgs: Array<*TypeSpec>
}

public struct ArrayTypeSpec {
    spec: using TypeSpec
    numElements: *Expr
}

public struct PtrTypeSpec {
    spec: using TypeSpec
}

public struct ConstTypeSpec {
    spec: using TypeSpec
}

public struct FuncPtrTypeSpec {
    spec: using TypeSpec
    args: Array<*TypeSpec>
    ret: *TypeSpec
    hasVarargs: bool
    genericParams: Array<GenericParam>
}

public struct GenericParam {
    name: Token
}

public struct Attributes {
    isPublic: bool
    isGlobal: bool
    notes: Array<*NoteStmt>
}


public struct Node {
    kind: StmtKind
    parent: *Node
    startPos: SrcPos
    endPos: SrcPos
}

public func (n: *Node) setSrcPos(start: SrcPos, end: SrcPos) {
    n.startPos = start
    n.endPos = end
}

public func (n: *Node) becomeParentOf<T>(child: *T) : *T {
    if(!child) return null;

    child.parent = n as (*Node)
    return child
}

public func (n: *Node) becomeParentOfChildren<T>(children: *Array<T>) : *Array<T> {
    var size = children.size()
    for(var i = 0; i < size; i += 1) {
        var child = children.get(i)
        if(child) {
            n.becomeParentOf(child)
        }
    }

    return children
}

public struct Identifier {
    // TODO: Is this needed?
}

public struct Decl {
    node: using Node
    sym: *Symbol
    name: Token
    attributes: Attributes
}

public struct ImportDecl {
    stmt: using Decl    
    alias: Token // Identifier?
    isUsing: bool
    // TODO: moduleId: ModuleId
}

public struct VarDecl {
    decl: using Decl
    type: *TypeSpec
    expr: *Expr
}

public struct ConstDecl {
    decl: using Decl
    type: *TypeSpec
    expr: *Expr
}

public struct ParameterDecl {
    decl: using Decl
    type: *TypeSpec
    defaultExpr: *Expr
}

public struct FuncDecl {
    decl: using Decl
    genericParams: Array<GenericParam>
    params: *ParametersStmt
    body: *FuncBodyStmt
    returnType: *TypeSpec
    flags: i32
}

public struct AggregateDecl {
    decl: using Decl
    genericParams: Array<GenericParam>
    fields: Array<*FieldStmt>
    flags: i32
}

public struct EnumDecl {
    decl: using Decl
    fields: Array<*EnumFieldEntryStmt>
}

public struct TypedefDecl {
    decl: using Decl
    type: *TypeSpec
    alias: *const char
}

public struct NativeDecl {
    decl: using Decl
    type: *TypeInfo
}

public struct BlockStmt {
    stmt: using Stmt
    stmts: Array<*Stmt>
}

public struct BreakStmt {
    stmt: using Stmt
}

public struct CompStmt {
    stmt: using Stmt
    type: *const char
    expr: *const char
    body: Array<*Stmt>
    end: *CompStmt
    evaluatedStmt: *Stmt
}

public struct ContinueStmt {
    stmt: using Stmt
}

public struct DeferStmt {
    stmt: using Stmt
    deferedStmt: *Stmt
}

public struct DoWhileStmt {
    stmt: using Stmt
    cond: *Expr
    body: *Stmt
}

public struct EmptyStmt {
    stmt: using Stmt
}

public struct EnumFieldEntryStmt {
    stmt: using Stmt
    fieldName: *Identifier
    value: *Expr
    attributes: Attributes
}

public struct EnumFieldStmt {
    stmt: using Stmt
    decl: *EnumDecl
}

public struct ForStmt {
    stmt: using Stmt
    init: *Stmt
    cond: *Expr
    post: *Stmt
    body: *Stmt
}

public struct FuncBodyStmt {
    stmt: using Stmt
    stmts: Array<*Stmt>
}

public struct GotoStmt {
    stmt: using Stmt
    label: Token // Identifer?
}

public struct IfStmt {
    stmt: using Stmt
    cond: *Expr
    then: *Stmt
    elseStmt: *Stmt
}


public struct LabelStmt {
    stmt: using Stmt
    label: Token // Identifier?
}

// TODO: should ths be a declaration?
public struct ModuleStmt {
    stmt: using Stmt
    imports: Array<*ImportDecl>
    notes: Array<*NoteStmt>
    declarations: Array<*Decl>
    //TODO: id: ModuleId
}

public struct NoteStmt {
    stmt: using Stmt
    name: Token // Identifier?
    attributes: Array<Token> // Identifier?
}

public struct ParametersStmt {
    stmt: using Stmt
    params: Array<*ParameterDecl>
    isVararg: bool
}

public struct ReturnStmt {
    stmt: using Stmt
    expr: *Expr
}

public struct AggregateFieldStmt {
    stmt: using Stmt
    decl: *AggregateDecl
}

public struct SwitchCaseStmt {
    stmt: using Stmt
    cond: *Expr
    body: *Stmt
}

public struct SwitchStmt {
    stmt: using Stmt
    cond: *Expr
    cases: Array<*SwitchCaseStmt>
    defaultStmt: *Stmt
}

public struct VarFieldStmt {
    stmt: using Stmt
    fieldName: *Identifier
    type: *TypeSpec
    attributes: Attributes
    defaultExpr: *Expr
}

public struct FieldStmt {
    kind: StmtKind
    union {
        enumField: *EnumFieldStmt
        aggregateField: *AggregateFieldStmt
        varField: *VarFieldStmt
    }
}

public struct WhileStmt {
    stmt: using Stmt
    cond: *Expr
    body: *Stmt
}


public struct Stmt {
    node: using Node
}

public struct ArrayDesignationExpr {
    expr: using Expr
    index: *Expr
    value: *Expr
}

public struct ArrayInitExpr {
    expr: using Expr
    type: *TypeSpec
    values: Array<*Expr>
}

public struct BinaryExpr {
    expr: using Expr
    left: *Expr
    operator: TokenType
    right: *Expr
}

public struct BooleanExpr {
    expr: using Expr
    boolean: bool
}

public struct CastExpr {
    expr: using Expr
    castTo: *TypeSpec
    exprToCast: *Expr
}

public struct CharExpr {
    expr: using Expr
    character: Token
}

public struct FuncCallExpr {
    expr: using Expr
    object: *Expr
    genericArgs: Array<*TypeSpec>
    arguments: Array<*Expr>
}

public struct GetExpr {
    expr: using Expr
    object: *Expr
    field: *IdentifierExpr
    isMethodCall: bool
}

public struct GroupExpr {
    expr: using Expr
    groupedExpr: *Expr
}

public struct IdentifierExpr {
    expr: using Expr
    //genericArgs: Array<*TypeSpec>
    type: *NameTypeSpec
    sym: Symbol
}

public struct InitArgExpr {
    expr: using Expr
    fieldName: Token // Identifier?
    argPosition: i32
    value: *Expr
}

public struct InitExpr {
    expr: using Expr
    genericArgs: Array<*TypeSpec>
    type: *NameTypeSpec
    arguments: Array<*InitArgExpr>
}

public struct NullExpr {
    expr: using Expr
}

public struct NumberExpr {
    expr: using Expr
    number: Token // TODO: should this be the number value? or Token
}

public struct OffsetOfExpr {
    expr: using Expr
    type: *TypeSpec
    field: *const char // Identifier?
}

public struct SetExpr {
    expr: using Expr
    object: *Expr
    field: *IdentifierExpr
    operator: TokenType
    value: *Expr
}

public struct SizeOfExpr {
    expr: using Expr
    sizeOfExpr: *Expr 
}

public struct StringExpr {
    expr: using Expr
    string: Token // Identifier or Token?
}

public struct SubscriptGetExpr {
    expr: using Expr
    object: *Expr
    index: *Expr
}

public struct SubscriptSetExpr {
    expr: using Expr
    object: *Expr
    index: *Expr
    operator: TokenType
    value: *Expr
}

public struct TernaryExpr {
    expr: using Expr
    cond: *Expr
    then: *Expr
    other: *Expr
}

public struct TypeIdentifierExpr {
    expr: using Expr
    genericArgs: Array<*TypeSpec>
    type: *TypeSpec
    sym: Symbol
}

public struct TypeOfExpr {
    expr: using Expr
    typeOfExpr: *Expr
    type: *TypeSpec
}

public struct UnaryExpr {
    expr: using Expr
    operator: TokenType
    unaryExpr: *Expr
}

public struct PoisonExpr {
    expr: using Expr
}

public struct Expr {
    stmt: using Stmt
}
