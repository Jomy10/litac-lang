import "std/unicode/utf8proc"
import "std/mem"
import "std/libc"

@doc("""
    A unicode codepoint
""")
public typedef i32 as rune;

@doc("'error' rune, unicode codepoint 'Replacement Character'")
public const INVALID_RUNE: rune = 0xefbfbd   // \uFFFD REPLACEMENT CHARACTER

@doc("Maximum valid unicode code point")
public const MAX_RUNE: rune     = 0x10_ffff  // \U0010FFFF

@doc("Maximum number of bytes for a UTF8 encoded unicode code point")
public const MAX_RUNE_BYTES = 4

@doc("""
    Reads a single codepoint from the UTF-8 sequence being pointed to by `str`. The maximum number of bytes read is `len`,
    unless `len` is negative (in which case up to 4 bytes are read).

    If a valid codepoint could be read, it is stored in the variable pointed to by `codepoints`, otherwise that variable will be set to -1.
    In case of success, the number of bytes read is returned; otherwise, a negative error code is returned.
""")
public func Utf8Decode(str: *const u8, len: i64, codepoints: *rune) : i64 {
    return utf8proc_iterate(str, len, codepoints) //as (i32)
}

public func Utf8HexDecode(str: *const char, len: i32) : rune {
    const buffer = [9]char{}
    len = len == 4 ? 4 : 8
    for(var i = 0; i < len; i += 1) {
        buffer[i] = str[i]
    }
    buffer[len] = '\0'

    return strtol(buffer, null, 16) as (rune)
}


@doc("""
    Encodes the codepoint as an UTF-8 string in the byte array pointed to by dst. This array must be at least 4 bytes long.

    In case of success the number of bytes written is returned, and otherwise 0 is returned.

    This function does not check whether codepoint is valid Unicode.
""")
public func Utf8Encode(codepoint: rune, dst: *u8) : i64 {
    return utf8proc_encode_char(codepoint, dst)
}

@doc("""
    Given a codepoint, return a character width.  Width of 0 is returned for
    non-printable codepoints
""")
public func Utf8CharWidth(codepoint: rune) : i32 {
    return utf8proc_charwidth(codepoint)
}

public func Utf8CodepointValid(codepoint: rune) : bool {
    return utf8proc_codepoint_valid(codepoint)
}

public enum NormalizeType {
    NFD  = (utf8proc_option_t.UTF8PROC_NULLTERM | utf8proc_option_t.UTF8PROC_STABLE | utf8proc_option_t.UTF8PROC_DECOMPOSE),
    NFC  = (utf8proc_option_t.UTF8PROC_NULLTERM | utf8proc_option_t.UTF8PROC_STABLE | utf8proc_option_t.UTF8PROC_COMPOSE),
    NFKD = (utf8proc_option_t.UTF8PROC_NULLTERM | utf8proc_option_t.UTF8PROC_STABLE | utf8proc_option_t.UTF8PROC_DECOMPOSE | utf8proc_option_t.UTF8PROC_COMPAT),
    NFKC = (utf8proc_option_t.UTF8PROC_NULLTERM | utf8proc_option_t.UTF8PROC_STABLE | utf8proc_option_t.UTF8PROC_COMPOSE | utf8proc_option_t.UTF8PROC_COMPAT),
    NFKC_CASEFOLD = (utf8proc_option_t.UTF8PROC_NULLTERM | utf8proc_option_t.UTF8PROC_STABLE | utf8proc_option_t.UTF8PROC_COMPOSE | utf8proc_option_t.UTF8PROC_COMPAT | utf8proc_option_t.UTF8PROC_CASEFOLD | utf8proc_option_t.UTF8PROC_IGNORE)
}

// TODO: avoid using malloc directly, and use the supplied allocator!!
public func Utf8Normalize(str: *const u8,
                          type: NormalizeType = NormalizeType.NFD,
                          allocator: *const Allocator = defaultAllocator) : *u8 {

    var retval: *u8;
    utf8proc_map(str, 0, &retval, type as (i32));
    return retval;
}


#if TESTING
    func decode(str: *const char) {
        var r: rune = 0
        //var len = Utf8Decode(str as (*const u8), -1, &r)
        var codepoint = strtol(str, null, 16) as (rune)

        printf("%s = %d\n", str, codepoint)
    }

    @test
    func Test_Uf8Decode() {
        //var x = []u8 { 0xC2_u8, 0xA3_u8, 0_u8 }
        //var x = []u8 { 0xe2_u8, 0xb5_u8, 0x93_u8, 0_u8 }
        //var x = []u8 { 0xe2_u8, 0x0_u8, 0x93_u8, 0_u8 }
        var xx = 'ⵙ'

        //var z = '\u0021'
        //printf("Z = '%c'\n", z)
        var x = []u8 { 0xe2_u8, 0xb5_u8, 0x9a_u8, 0_u8 }

        var r: rune = 0
        var len = Utf8Decode(x, strlen(x as (*const char)), &r)
        var width = Utf8CharWidth(r)
        printf("Hello '%s' Rune: %d Len: %zu Width: %d ⵓ ⵙ\n", x, r, len, width)

        var codepoint = strtol("2D5A'", null, 16) as (rune)
        printf("Codepoint: %d InString: '\u2d5a'Z\U0002B8B9z\n", codepoint)

        decode("0000")
        decode("009f")
        decode("0024")
        decode("0040")
        decode("0060")
        //var zzz = "\u2D5A"
        printf("\u2D59\n")
        /*
        printf("%s = %s\n", Utf8Normalize("ⵙ" as (*const u8)), Utf8Normalize("\u2D59"  as (*const u8)))
        {
            var u = "ⵙ" as (*const u8)
            for(var i = 0; i < strlen(u); i+=1) {
                var b = u[i]
                printf("%x ", b)
            }
        }
        printf("\n")
        {
            var u = "\u2D59" as (*const u8)
            for(var i = 0; i < strlen(u); i+=1) {
                var b = u[i]
                printf("%x ", b)
            }
        }
        printf("\n")

        printf("Comp: %d\n", strcmp(Utf8Normalize("ⵙ"), Utf8Normalize("\u2D59")))
        printf("Comp2: %d\n", strcmp("ⵙ", "\u2D59"))*/
    }

#end
