#ifndef _LITAC_HEADER_H
#define _LITAC_HEADER_H

// Generated on Fri Aug 27 20:28:59 2021

#include <stdint.h>
#include <stddef.h>
typedef int8_t    litaC_i8;
typedef int16_t   litaC_i16;
typedef int32_t   litaC_i32;
typedef int64_t   litaC_i64;
typedef uint8_t   litaC_u8;
typedef uint16_t  litaC_u16;
typedef uint32_t  litaC_u32;
typedef uint64_t  litaC_u64;
typedef float     litaC_f32;
typedef double    litaC_f64;
//typedef int8_t    litaC_bool;
typedef size_t    litaC_usize;

#if _MSC_VER
#define LITAC_THREADLOCAL __declspec(thread)
#define LITAC_INLINE static inline __forceinline
#define LITAC_NOINLINE __declspec(noinline)
#define LITAC_PACKED __pragma(pack(push, 1))
#define LITAC_PACKED_POP __pragma(pack(pop))
#define LITAC_EXPORT __declspec(dllexport)
#endif

#if __GNUC__
#define LITAC_THREADLOCAL __thread
#define LITAC_INLINE static inline __attribute__((always_inline))
#define LITAC_NOINLINE __attribute__((noinline))
#define LITAC_PACKED __attribute__((packed))
#define LITAC_PACKED_POP
#define LITAC_EXPORT __attribute__((visibility("default")))
#endif

#if __TINYC__
#define LITAC_THREADLOCAL
#define LITAC_INLINE
#define LITAC_NOINLINE
#define LITAC_PACKED __attribute__((packed))
#define LITAC_PACKED_POP
#define LITAC_EXPORT __attribute__((dllexport))
#endif

typedef int8_t litaC_bool;
#define litaC_true (1)
#define litaC_false (0)
#define litaC_void void
typedef char   litaC_char;
litaC_usize litaC_mem__PAGE_SIZE = (litaC_usize)4096UL;

#define litaC_mem__MAX_PATH (256)

#define litaC_array__MAX_LEVELS (300)

#define litaC_cmdline__MAX_MESSAGE_SIZE (256)

#define litaC_string_buffer__MAX_BUFFER_SIZE (32)

#define litaC_lex__MAX_KEYWORD_CACHE (9)

#define litaC_types__MAX_FIELD_PATH (256)

#define litaC_symbols__MAX_SYMBOL_NAME (256)

#define litaC_module__MAX_METHODS_FOR_TYPE (2048)

#define litaC_lita__MAX_PREFIX_SIZE (32)

#define litaC_checker__MAX_LABELS (256)

#define litaC_checker__MAX_LABEL_NAME (32)

#define litaC_generics__MAX_GENERIC_NAME (1024)

#define litaC_parser__DECL_ADJUST_TOKENS_COUNT (11)

#define litaC_cgen__MAX_COMPILATION_UNITS (256)

#define litaC_json__MAX_MESSAGE_SIZE (256)

#define litaC_lsp__IN_BUFFER_SIZE (1024 * 1024 * 2)

#include <stdlib.h>

#include <stdio.h>
#include <time.h>


typedef enum Lita_OSType {
    Lita_OSType_WINDOWS,
    Lita_OSType_ANDROID,
    Lita_OSType_LINUX,
    Lita_OSType_BSD,
    Lita_OSType_IOS,
    Lita_OSType_MAC,
    Lita_OSType_OTHER
} Lita_OSType;


#if defined(_WIN32)
    // Windows
    Lita_OSType litaOS = Lita_OSType_WINDOWS;
#elif defined(_WIN64)
    // Windows
    Lita_OSType litaOS = Lita_OSType_WINDOWS;
#elif defined(__CYGWIN__) && !defined(_WIN32)
    // Windows (Cygwin POSIX under Microsoft Window)
    Lita_OSType litaOS = Lita_OSType_WINDOWS;
#elif defined(__ANDROID__)
    // Android (implies Linux, so it must come first)
    Lita_OSType litaOS = Lita_OSType_ANDROID;
#elif defined(__linux__)
    // Debian, Ubuntu, Gentoo, Fedora, openSUSE, RedHat, Centos and other
    Lita_OSType litaOS = Lita_OSType_LINUX;
#elif defined(__unix__) || !defined(__APPLE__) && defined(__MACH__)
    #include <sys/param.h>
    #if defined(BSD)
        // FreeBSD, NetBSD, OpenBSD, DragonFly BSD
        Lita_OSType litaOS = Lita_OSType_BSD;
    #endif
#elif defined(__hpux)
    // HP-UX
    Lita_OSType litaOS = Lita_OSType_OTHER;
#elif defined(_AIX)
    // IBM AIX
    Lita_OSType litaOS = Lita_OSType_OTHER;
#elif defined(__APPLE__) && defined(__MACH__) // Apple OSX and iOS (Darwin)
    #include <TargetConditionals.h>
    #if TARGET_IPHONE_SIMULATOR == 1
        // Apple iOS
        Lita_OSType litaOS = Lita_OSType_IOS;
    #elif TARGET_OS_IPHONE == 1
        // Apple iOS
        Lita_OSType litaOS = Lita_OSType_IOS;
    #elif TARGET_OS_MAC == 1
        // Apple OSX
        Lita_OSType litaOS = Lita_OSType_MAC;
    #endif
#elif defined(__sun) && defined(__SVR4)
    // Oracle Solaris, Open Indiana
    Lita_OSType litaOS = Lita_OSType_OTHER;
#else
    Lita_OSType litaOS = Lita_OSType_OTHER;
#endif


typedef struct tm tm;


#include <ape.h>

/*
SPDX-License-Identifier: MIT

ape
https://github.com/kgabis/ape
Copyright (c) 2020 Krzysztof Gabis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#define APE_AMALGAMATED

#include "ape.h"

//-----------------------------------------------------------------------------
// Headers
//-----------------------------------------------------------------------------
//FILE_START:common.h
#ifndef common_h
#define common_h

#include <assert.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <math.h>
#include <float.h>

#ifndef APE_AMALGAMATED
#include "ape.h"
#endif

#define APE_STREQ(a, b) (strcmp((a), (b)) == 0)
#define APE_STRNEQ(a, b, n) (strncmp((a), (b), (n)) == 0)
#define APE_ARRAY_LEN(array) ((int)(sizeof(array) / sizeof(array[0])))
#define APE_DBLEQ(a, b) (fabs((a) - (b)) < DBL_EPSILON)

#ifdef APE_DEBUG
    #define APE_ASSERT(x) assert((x))
    #define APE_FILENAME (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)
    #define APE_LOG(...) ape_log(APE_FILENAME, __LINE__, __VA_ARGS__)
#else
    #define APE_ASSERT(x) ((void)0)
    #define APE_LOG(...) ((void)0)
#endif

#ifdef APE_AMALGAMATED
#define COLLECTIONS_AMALGAMATED
#define APE_INTERNAL static
#else
#define APE_INTERNAL
#endif

typedef struct compiled_file compiled_file_t;

typedef struct src_pos {
    const compiled_file_t *file;
    int line;
    int column;
} src_pos_t;

typedef void * (*ape_malloc_fn)(size_t size, void* mallocArg);
typedef void (*ape_free_fn)(void *ptr, void* freeArg);

typedef struct ape_config {
    struct {
        struct {
            ape_stdout_write_fn write;
            void *context;
        } write;
    } stdio;

    struct {
        struct {
            ape_read_file_fn read_file;
            void *context;
        } read_file;

        struct {
            ape_write_file_fn write_file;
            void *context;
        } write_file;
    } fileio;

    int gc_interval;

    bool repl_mode; // allows redefinition of symbols
} ape_config_t;

#ifndef APE_AMALGAMATED
extern const src_pos_t src_pos_invalid;
extern const src_pos_t src_pos_zero;
#endif

APE_INTERNAL src_pos_t src_pos_make(const compiled_file_t *file, int line, int column);
APE_INTERNAL char *ape_stringf(const char *format, ...);
APE_INTERNAL void ape_log(const char *file, int line, const char *format, ...);
APE_INTERNAL char* ape_strndup(const char *string, size_t n);
APE_INTERNAL char* ape_strdup(const char *string);

APE_INTERNAL uint64_t ape_double_to_uint64(double val);
APE_INTERNAL double ape_uint64_to_double(uint64_t val);

extern void* ape_mallocArg;
extern void* ape_freeArg;
extern ape_malloc_fn ape_malloc;
extern ape_free_fn ape_free;

#endif /* common_h */
//FILE_END
//FILE_START:collections.h
/*
Copyright (c) 2020 Krzysztof Gabis
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/


/* To update:
 curl https://raw.githubusercontent.com/kgabis/cutils/master/collections.h > collections.h
 curl https://raw.githubusercontent.com/kgabis/cutils/master/collections.c > collections.c
 */

#ifndef collections_h
#define collections_h

#include <stdbool.h>
#include <stddef.h>

#ifdef COLLECTIONS_AMALGAMATED
#define COLLECTIONS_API static
#else
#define COLLECTIONS_API
#endif

//-----------------------------------------------------------------------------
// Collections
//-----------------------------------------------------------------------------

typedef void * (*collections_malloc_fn)(size_t size, void* mallocArg);
typedef void (*collections_free_fn)(void *ptr, void* freeArg);
typedef unsigned long (*collections_hash_fn)(const void* val);
typedef bool (*collections_equals_fn)(const void *a, const void *b);

COLLECTIONS_API void collections_set_memory_functions(collections_malloc_fn malloc_fn, collections_free_fn free_fn);

//-----------------------------------------------------------------------------
// Dictionary
//-----------------------------------------------------------------------------

typedef struct dict_ dict_t_;

#define dict(TYPE) dict_t_

typedef void (*dict_item_destroy_fn)(void* item);
#define dict_destroy_with_items(dict, fn) dict_destroy_with_items_(dict, (dict_item_destroy_fn)(fn))

typedef void* (*dict_item_copy_fn)(void* item);
#define dict_copy_with_items(dict, fn) dict_copy_with_items_(dict, (dict_item_copy_fn)(fn))

COLLECTIONS_API dict_t_*     dict_make(void);
COLLECTIONS_API void         dict_destroy(dict_t_ *dict);
COLLECTIONS_API void         dict_destroy_with_items_(dict_t_ *dict, dict_item_destroy_fn destroy_fn);
COLLECTIONS_API dict_t_*     dict_copy_with_items_(dict_t_ *dict, dict_item_copy_fn copy_fn);
COLLECTIONS_API bool         dict_set(dict_t_ *dict, const char *key, void *value);
COLLECTIONS_API void *       dict_get(const dict_t_ *dict, const char *key);
COLLECTIONS_API void *       dict_get_value_at(const dict_t_ *dict, unsigned int ix);
COLLECTIONS_API const char * dict_get_key_at(const dict_t_ *dict, unsigned int ix);
COLLECTIONS_API int          dict_count(const dict_t_ *dict);
COLLECTIONS_API bool         dict_remove(dict_t_ *dict, const char *key);
COLLECTIONS_API void         dict_clear(dict_t_ *dict);

//-----------------------------------------------------------------------------
// Value dictionary
//-----------------------------------------------------------------------------

typedef struct valdict_ valdict_t_;

#define valdict(KEY_TYPE, VALUE_TYPE) valdict_t_

#define valdict_make(key_type, val_type) valdict_make_(sizeof(key_type), sizeof(val_type))

COLLECTIONS_API valdict_t_* valdict_make_(size_t key_size, size_t val_size);
COLLECTIONS_API valdict_t_* valdict_make_with_capacity(unsigned int min_capacity, size_t key_size, size_t val_size);
COLLECTIONS_API void        valdict_destroy(valdict_t_ *dict);
COLLECTIONS_API void        valdict_set_hash_function(valdict_t_ *dict, collections_hash_fn hash_fn);
COLLECTIONS_API void        valdict_set_equals_function(valdict_t_ *dict, collections_equals_fn equals_fn);
COLLECTIONS_API bool        valdict_set(valdict_t_ *dict, void *key, void *value);
COLLECTIONS_API void *      valdict_get(const valdict_t_ *dict, const void *key);
COLLECTIONS_API void *      valdict_get_key_at(const valdict_t_ *dict, unsigned int ix);
COLLECTIONS_API void *      valdict_get_value_at(const valdict_t_ *dict, unsigned int ix);
COLLECTIONS_API bool        valdict_set_value_at(const valdict_t_ *dict, unsigned int ix, const void *value);
COLLECTIONS_API int         valdict_count(const valdict_t_ *dict);
COLLECTIONS_API bool        valdict_remove(valdict_t_ *dict, void *key);
COLLECTIONS_API void        valdict_clear(valdict_t_ *dict);

//-----------------------------------------------------------------------------
// Pointer dictionary
//-----------------------------------------------------------------------------

typedef struct ptrdict_ ptrdict_t_;

#define ptrdict(KEY_TYPE, VALUE_TYPE) ptrdict_t_

COLLECTIONS_API ptrdict_t_* ptrdict_make(void);
COLLECTIONS_API void        ptrdict_destroy(ptrdict_t_ *dict);
COLLECTIONS_API void        ptrdict_set_hash_function(ptrdict_t_ *dict, collections_hash_fn hash_fn);
COLLECTIONS_API void        ptrdict_set_equals_function(ptrdict_t_ *dict, collections_equals_fn equals_fn);
COLLECTIONS_API bool        ptrdict_set(ptrdict_t_ *dict, void *key, void *value);
COLLECTIONS_API void *      ptrdict_get(const ptrdict_t_ *dict, const void *key);
COLLECTIONS_API void *      ptrdict_get_value_at(const ptrdict_t_ *dict, unsigned int ix);
COLLECTIONS_API void *      ptrdict_get_key_at(const ptrdict_t_ *dict, unsigned int ix);
COLLECTIONS_API int         ptrdict_count(const ptrdict_t_ *dict);
COLLECTIONS_API bool        ptrdict_remove(ptrdict_t_ *dict, void *key);
COLLECTIONS_API void        ptrdict_clear(ptrdict_t_ *dict);

//-----------------------------------------------------------------------------
// Array
//-----------------------------------------------------------------------------

typedef struct array_ array_t_;

#define array(TYPE) array_t_

#define array_make(type) array_make_(sizeof(type))
typedef void (*array_item_deinit_fn)(void* item);
#define array_destroy_with_items(arr, fn) array_destroy_with_items_(arr, (array_item_deinit_fn)(fn))
#define array_clear_and_deinit_items(arr, fn) array_clear_and_deinit_items_(arr, (array_item_deinit_fn)(fn))

COLLECTIONS_API array_t_*   array_make_(size_t element_size);
COLLECTIONS_API array_t_*   array_make_with_capacity(unsigned int capacity, size_t element_size);
COLLECTIONS_API void        array_destroy(array_t_ *arr);
COLLECTIONS_API void        array_destroy_with_items_(array_t_ *arr, array_item_deinit_fn deinit_fn);
COLLECTIONS_API array_t_*   array_copy(const array_t_ *arr);
COLLECTIONS_API bool        array_add(array_t_ *arr, const void *value);
COLLECTIONS_API bool        array_addn(array_t_ *arr, const void *values, int n);
COLLECTIONS_API bool        array_add_array(array_t_ *dest, const array_t_ *source);
COLLECTIONS_API bool        array_push(array_t_ *arr, const void *value);
COLLECTIONS_API bool        array_pop(array_t_ *arr, void *out_value);
COLLECTIONS_API void *      array_top(array_t_ *arr);
COLLECTIONS_API bool        array_set(array_t_ *arr, unsigned int ix, void *value);
COLLECTIONS_API bool        array_setn(array_t_ *arr, unsigned int ix, void *values, int n);
COLLECTIONS_API void *      array_get(const array_t_ *arr, unsigned int ix);
COLLECTIONS_API void *      array_get_last(const array_t_ *arr);
COLLECTIONS_API int         array_count(const array_t_ *arr);
COLLECTIONS_API bool        array_remove_at(array_t_ *arr, unsigned int ix);
COLLECTIONS_API bool        array_remove_item(array_t_ *arr, void *ptr);
COLLECTIONS_API void        array_clear(array_t_ *arr);
COLLECTIONS_API void        array_clear_and_deinit_items_(array_t_ *arr, array_item_deinit_fn deinit_fn);
COLLECTIONS_API void        array_lock_capacity(array_t_ *arr);
COLLECTIONS_API int         array_get_index(const array_t_ *arr, void *ptr);
COLLECTIONS_API bool        array_contains(const array_t_ *arr, void *ptr);
COLLECTIONS_API void*       array_data(array_t_ *arr);
COLLECTIONS_API const void* array_const_data(const array_t_ *arr);
COLLECTIONS_API bool        array_orphan_data(array_t_ *arr);
COLLECTIONS_API void        array_reverse(array_t_ *arr);

//-----------------------------------------------------------------------------
// Pointer Array
//-----------------------------------------------------------------------------

typedef struct ptrarray_ ptrarray_t_;

#define ptrarray(TYPE) ptrarray_t_

typedef void (*ptrarray_item_destroy_fn)(void* item);
#define ptrarray_destroy_with_items(arr, fn) ptrarray_destroy_with_items_(arr, (ptrarray_item_destroy_fn)(fn))
#define ptrarray_clear_and_destroy_items(arr, fn) ptrarray_clear_and_destroy_items_(arr, (ptrarray_item_destroy_fn)(fn))

typedef void* (*ptrarray_item_copy_fn)(void* item);
#define ptrarray_copy_with_items(arr, fn) ptrarray_copy_with_items_(arr, (ptrarray_item_copy_fn)(fn))

COLLECTIONS_API ptrarray_t_* ptrarray_make(void);
COLLECTIONS_API ptrarray_t_* ptrarray_make_with_capacity(unsigned int capacity);
COLLECTIONS_API void         ptrarray_destroy(ptrarray_t_ *arr);
COLLECTIONS_API void         ptrarray_destroy_with_items_(ptrarray_t_ *arr, ptrarray_item_destroy_fn destroy_fn);
COLLECTIONS_API ptrarray_t_* ptrarray_copy(ptrarray_t_ *arr);
COLLECTIONS_API ptrarray_t_* ptrarray_copy_with_items_(ptrarray_t_ *arr, ptrarray_item_copy_fn copy_fn);
COLLECTIONS_API bool         ptrarray_add(ptrarray_t_ *arr, void *ptr);
COLLECTIONS_API bool         ptrarray_set(ptrarray_t_ *arr, unsigned int ix, void *ptr);
COLLECTIONS_API bool         ptrarray_add_array(ptrarray_t_ *dest, const ptrarray_t_ *source);
COLLECTIONS_API void *       ptrarray_get(ptrarray_t_ *arr, unsigned int ix);
COLLECTIONS_API bool         ptrarray_push(ptrarray_t_ *arr, void *ptr);
COLLECTIONS_API void *       ptrarray_pop(ptrarray_t_ *arr);
COLLECTIONS_API void *       ptrarray_top(ptrarray_t_ *arr);
COLLECTIONS_API int          ptrarray_count(const ptrarray_t_ *arr);
COLLECTIONS_API bool         ptrarray_remove_at(ptrarray_t_ *arr, unsigned int ix);
COLLECTIONS_API bool         ptrarray_remove_item(ptrarray_t_ *arr, void *item);
COLLECTIONS_API void         ptrarray_clear(ptrarray_t_ *arr);
COLLECTIONS_API void         ptrarray_clear_and_destroy_items_(ptrarray_t_ *arr, ptrarray_item_destroy_fn destroy_fn);
COLLECTIONS_API void         ptrarray_lock_capacity(ptrarray_t_ *arr);
COLLECTIONS_API int          ptrarray_get_index(ptrarray_t_ *arr, void *ptr);
COLLECTIONS_API bool         ptrarray_contains(ptrarray_t_ *arr, void *ptr);
COLLECTIONS_API void *       ptrarray_get_addr(ptrarray_t_ *arr, unsigned int ix);
COLLECTIONS_API void*        ptrarray_data(ptrarray_t_ *arr);
COLLECTIONS_API void         ptrarray_reverse(ptrarray_t_ *arr);

//-----------------------------------------------------------------------------
// String buffer
//-----------------------------------------------------------------------------

typedef struct strbuf strbuf_t;

COLLECTIONS_API strbuf_t* strbuf_make(void);
COLLECTIONS_API strbuf_t* strbuf_make_with_capacity(unsigned int capacity);
COLLECTIONS_API void strbuf_destroy(strbuf_t *buf);
COLLECTIONS_API void strbuf_clear(strbuf_t *buf);
COLLECTIONS_API bool strbuf_append(strbuf_t *buf, const char *str);
COLLECTIONS_API bool strbuf_appendf(strbuf_t *buf, const char *fmt, ...)  __attribute__((format(printf, 2, 3)));
COLLECTIONS_API const char * strbuf_get_string(const strbuf_t *buf);
COLLECTIONS_API size_t strbuf_get_length(const strbuf_t *buf);
COLLECTIONS_API char * strbuf_get_string_and_destroy(strbuf_t *buf);

//-----------------------------------------------------------------------------
// Utils
//-----------------------------------------------------------------------------

COLLECTIONS_API ptrarray(char)* kg_split_string(const char *str, const char *delimiter);
COLLECTIONS_API char* kg_join(ptrarray(char) *items, const char *with);
COLLECTIONS_API char* kg_canonicalise_path(const char *path);
COLLECTIONS_API bool  kg_is_path_absolute(const char *path);
COLLECTIONS_API bool  kg_streq(const char *a, const char *b);

#endif /* collections_h */
//FILE_END
//FILE_START:error.h
#ifndef error_h
#define error_h

#ifndef APE_AMALGAMATED
#include "common.h"
#include "token.h"
#endif

typedef struct traceback traceback_t;

typedef enum error_type {
    ERROR_NONE = 0,
    ERROR_PARSING,
    ERROR_COMPILATION,
    ERROR_RUNTIME,
    ERROR_USER,
} error_type_t;

typedef struct error {
    error_type_t type;
    char *message;
    src_pos_t pos;
    traceback_t *traceback;
} error_t;

APE_INTERNAL error_t* error_make_no_copy(error_type_t type, src_pos_t pos, char *message);
APE_INTERNAL error_t* error_make(error_type_t type, src_pos_t pos, const char *message);
APE_INTERNAL error_t* error_makef(error_type_t type, src_pos_t pos, const char *format, ...) __attribute__ ((format (printf, 3, 4)));
APE_INTERNAL void error_destroy(error_t *error);
APE_INTERNAL const char *error_type_to_string(error_type_t type);

#endif /* error_h */
//FILE_END
//FILE_START:token.h
#ifndef token_h
#define token_h

#ifndef APE_AMALGAMATED
#include "common.h"
#endif

typedef enum {
    TOKEN_ILLEGAL = 0,
    TOKEN_EOF,

    // Operators
    TOKEN_ASSIGN,

    TOKEN_PLUS_ASSIGN,
    TOKEN_MINUS_ASSIGN,
    TOKEN_ASTERISK_ASSIGN,
    TOKEN_SLASH_ASSIGN,
    TOKEN_PERCENT_ASSIGN,
    TOKEN_BIT_AND_ASSIGN,
    TOKEN_BIT_OR_ASSIGN,
    TOKEN_BIT_XOR_ASSIGN,
    TOKEN_LSHIFT_ASSIGN,
    TOKEN_RSHIFT_ASSIGN,

    TOKEN_PLUS,
    TOKEN_MINUS,
    TOKEN_BANG,
    TOKEN_ASTERISK,
    TOKEN_SLASH,

    TOKEN_LT,
    TOKEN_LTE,
    TOKEN_GT,
    TOKEN_GTE,

    TOKEN_EQ,
    TOKEN_NOT_EQ,

    TOKEN_AND,
    TOKEN_OR,

    TOKEN_BIT_AND,
    TOKEN_BIT_OR,
    TOKEN_BIT_XOR,
    TOKEN_LSHIFT,
    TOKEN_RSHIFT,

    // Delimiters
    TOKEN_COMMA,
    TOKEN_SEMICOLON,
    TOKEN_COLON,
    TOKEN_LPAREN,
    TOKEN_RPAREN,
    TOKEN_LBRACE,
    TOKEN_RBRACE,
    TOKEN_LBRACKET,
    TOKEN_RBRACKET,
    TOKEN_DOT,
    TOKEN_PERCENT,

    // Keywords
    TOKEN_FUNCTION,
    TOKEN_CONST,
    TOKEN_VAR,
    TOKEN_TRUE,
    TOKEN_FALSE,
    TOKEN_IF,
    TOKEN_ELSE,
    TOKEN_RETURN,
    TOKEN_WHILE,
    TOKEN_BREAK,
    TOKEN_FOR,
    TOKEN_IN,
    TOKEN_CONTINUE,
    TOKEN_NULL,
    TOKEN_IMPORT,
    TOKEN_RECOVER,

    // Identifiers and literals
    TOKEN_IDENT,
    TOKEN_NUMBER,
    TOKEN_STRING,

    TOKEN_TYPE_MAX
} token_type_t;

typedef struct token {
    token_type_t type;
    const char *literal;
    int len;
    src_pos_t pos;
} token_t;

APE_INTERNAL void token_make(token_t *tok, token_type_t type, const char *literal, int len); // no need to destroy
APE_INTERNAL char *token_duplicate_literal(const token_t *tok);
APE_INTERNAL const char *token_type_to_string(token_type_t type);

#endif /* token_h */
//FILE_END
//FILE_START:lexer.h
#ifndef lexer_h
#define lexer_h

#include <stdbool.h>
#include <stddef.h>

#ifndef APE_AMALGAMATED
#include "common.h"
#include "token.h"
#endif

typedef struct lexer {
    const char *input;
    int input_len;
    int position;
    int next_position;
    char ch;
    int line;
    int column;
    compiled_file_t *file;
} lexer_t;

APE_INTERNAL bool lexer_init(lexer_t *lex, const char *input, compiled_file_t *file); // no need to deinit

APE_INTERNAL token_t lexer_next_token(lexer_t *lex);

#endif /* lexer_h */
//FILE_END
//FILE_START:ast.h
#ifndef ast_h
#define ast_h

#ifndef APE_AMALGAMATED
#include "common.h"
#include "collections.h"
#include "token.h"
#endif

typedef struct code_block {
    ptrarray(statement_t) *statements;
} code_block_t;

typedef struct expression expression_t;
typedef struct statement statement_t;

typedef struct map_literal {
    ptrarray(expression_t) *keys;
    ptrarray(expression_t) *values;
} map_literal_t;

typedef enum {
    OPERATOR_NONE,
    OPERATOR_ASSIGN,
    OPERATOR_PLUS,
    OPERATOR_MINUS,
    OPERATOR_BANG,
    OPERATOR_ASTERISK,
    OPERATOR_SLASH,
    OPERATOR_LT,
    OPERATOR_LTE,
    OPERATOR_GT,
    OPERATOR_GTE,
    OPERATOR_EQ,
    OPERATOR_NOT_EQ,
    OPERATOR_MODULUS,
    OPERATOR_LOGICAL_AND,
    OPERATOR_LOGICAL_OR,
    OPERATOR_BIT_AND,
    OPERATOR_BIT_OR,
    OPERATOR_BIT_XOR,
    OPERATOR_LSHIFT,
    OPERATOR_RSHIFT,
} operator_t;

typedef struct prefix {
    operator_t op;
    expression_t *right;
} prefix_expression_t;

typedef struct infix {
    operator_t op;
    expression_t *left;
    expression_t *right;
} infix_expression_t;

typedef struct if_case {
    expression_t *test;
    code_block_t *consequence;
} if_case_t;

typedef struct fn_literal {
    char *name;
    array(ident_t) *params;
    code_block_t *body;
} fn_literal_t;

typedef struct call_expression {
    expression_t *function;
    ptrarray(expression_t) *args;
} call_expression_t;

typedef struct index_expression {
    expression_t *left;
    expression_t *index;
} index_expression_t;

typedef struct assign_expression {
    expression_t *dest;
    expression_t *source;
} assign_expression_t;

typedef struct logical_expression {
    operator_t op;
    expression_t *left;
    expression_t *right;
} logical_expression_t;

typedef enum expression_type {
    EXPRESSION_NONE,
    EXPRESSION_IDENT,
    EXPRESSION_NUMBER_LITERAL,
    EXPRESSION_BOOL_LITERAL,
    EXPRESSION_STRING_LITERAL,
    EXPRESSION_NULL_LITERAL,
    EXPRESSION_ARRAY_LITERAL,
    EXPRESSION_MAP_LITERAL,
    EXPRESSION_PREFIX,
    EXPRESSION_INFIX,
    EXPRESSION_FUNCTION_LITERAL,
    EXPRESSION_CALL,
    EXPRESSION_INDEX,
    EXPRESSION_ASSIGN,
    EXPRESSION_LOGICAL,
} expression_type_t;

typedef struct ident {
    char *value;
    src_pos_t pos;
} ident_t;

typedef struct expression {
    expression_type_t type;
    union {
        ident_t ident;
        double number_literal;
        bool bool_literal;
        char *string_literal;
        ptrarray(expression_t) *array;
        map_literal_t map;
        prefix_expression_t prefix;
        infix_expression_t infix;
        fn_literal_t fn_literal;
        call_expression_t call_expr;
        index_expression_t index_expr;
        assign_expression_t assign;
        logical_expression_t logical;
    };
    src_pos_t pos;
} expression_t;

typedef enum statement_type {
    STATEMENT_NONE,
    STATEMENT_DEFINE,
    STATEMENT_IF,
    STATEMENT_RETURN_VALUE,
    STATEMENT_EXPRESSION,
    STATEMENT_WHILE_LOOP,
    STATEMENT_BREAK,
    STATEMENT_CONTINUE,
    STATEMENT_FOREACH,
    STATEMENT_FOR_LOOP,
    STATEMENT_BLOCK,
    STATEMENT_IMPORT,
    STATEMENT_RECOVER,
} statement_type_t;

typedef struct define_statement {
    ident_t name;
    expression_t *value;
    bool assignable;
} define_statement_t;

typedef struct if_statement {
    ptrarray(if_case_t) *cases;
    code_block_t *alternative;
} if_statement_t;

typedef struct while_loop_statement {
    expression_t *test;
    code_block_t *body;
} while_loop_statement_t;

typedef struct foreach_statement {
    ident_t iterator;
    expression_t *source;
    code_block_t *body;
} foreach_statement_t;

typedef struct for_loop_statement {
    statement_t *init;
    expression_t *test;
    expression_t *update;
    code_block_t *body;
} for_loop_statement_t;

typedef struct import_statement {
    char *path;
} import_statement_t;

typedef struct recover_statement {
    ident_t error_ident;
    code_block_t *body;
} recover_statement_t;

typedef struct statement {
    statement_type_t type;
    union {
        define_statement_t define;
        if_statement_t if_statement;
        expression_t *return_value;
        expression_t *expression;
        while_loop_statement_t while_loop;
        foreach_statement_t foreach;
        for_loop_statement_t for_loop;
        code_block_t *block;
        import_statement_t import;
        recover_statement_t recover;
    };
    src_pos_t pos;
} statement_t;

APE_INTERNAL char* statements_to_string(ptrarray(statement_t) *statements);

APE_INTERNAL statement_t* statement_make_define(ident_t name, expression_t *value, bool assignable);
APE_INTERNAL statement_t* statement_make_if(ptrarray(if_case_t) *cases, code_block_t *alternative);
APE_INTERNAL statement_t* statement_make_return(expression_t *value);
APE_INTERNAL statement_t* statement_make_expression(expression_t *value);
APE_INTERNAL statement_t* statement_make_while_loop(expression_t *test, code_block_t *body);
APE_INTERNAL statement_t* statement_make_break(void);
APE_INTERNAL statement_t* statement_make_foreach(ident_t iterator, expression_t *source, code_block_t *body);
APE_INTERNAL statement_t* statement_make_for_loop(statement_t *init, expression_t *test, expression_t *update, code_block_t *body);
APE_INTERNAL statement_t* statement_make_continue(void);
APE_INTERNAL statement_t* statement_make_block(code_block_t *block);
APE_INTERNAL statement_t* statement_make_import(char *path);
APE_INTERNAL statement_t* statement_make_recover(ident_t error_ident, code_block_t *body);

APE_INTERNAL void statement_destroy(statement_t *stmt);

APE_INTERNAL statement_t* statement_copy(statement_t *stmt);

APE_INTERNAL code_block_t* code_block_make(ptrarray(statement_t) *statements);
APE_INTERNAL void code_block_destroy(code_block_t *stmt);
APE_INTERNAL code_block_t* code_block_copy(code_block_t *block);

APE_INTERNAL expression_t* expression_make_ident(ident_t ident);
APE_INTERNAL expression_t* expression_make_number_literal(double val);
APE_INTERNAL expression_t* expression_make_bool_literal(bool val);
APE_INTERNAL expression_t* expression_make_string_literal(char *value);
APE_INTERNAL expression_t* expression_make_null_literal(void);
APE_INTERNAL expression_t* expression_make_array_literal(ptrarray(expression_t) *values);
APE_INTERNAL expression_t* expression_make_map_literal(ptrarray(expression_t) *keys, ptrarray(expression_t) *values);
APE_INTERNAL expression_t* expression_make_prefix(operator_t op, expression_t *right);
APE_INTERNAL expression_t* expression_make_infix(operator_t op, expression_t *left, expression_t *right);
APE_INTERNAL expression_t* expression_make_fn_literal(array(ident_t) *params, code_block_t *body);
APE_INTERNAL expression_t* expression_make_call(expression_t *function, ptrarray(expression_t) *args);
APE_INTERNAL expression_t* expression_make_index(expression_t *left, expression_t *index);
APE_INTERNAL expression_t* expression_make_assign(expression_t *dest, expression_t *source);
APE_INTERNAL expression_t* expression_make_logical(operator_t op, expression_t *left, expression_t *right);

APE_INTERNAL void expression_destroy(expression_t *expr);

APE_INTERNAL expression_t* expression_copy(expression_t *expr);

APE_INTERNAL void statement_to_string(const statement_t *stmt, strbuf_t *buf);
APE_INTERNAL void expression_to_string(expression_t *expr, strbuf_t *buf);

APE_INTERNAL void code_block_to_string(const code_block_t *stmt, strbuf_t *buf);
APE_INTERNAL const char* operator_to_string(operator_t op);

APE_INTERNAL const char *expression_type_to_string(expression_type_t type);

APE_INTERNAL void fn_literal_deinit(fn_literal_t *fn);

APE_INTERNAL ident_t ident_make(token_t tok);
APE_INTERNAL ident_t ident_copy(ident_t ident);
APE_INTERNAL void ident_deinit(ident_t *ident);

APE_INTERNAL if_case_t *if_case_make(expression_t *test, code_block_t *consequence);
APE_INTERNAL void if_case_destroy(if_case_t *cond);

#endif /* ast_h */
//FILE_END
//FILE_START:parser.h
#ifndef parser_h
#define parser_h

#ifndef APE_AMALGAMATED
#include "common.h"
#include "lexer.h"
#include "token.h"
#include "ast.h"
#include "collections.h"
#endif

typedef struct parser parser_t;
typedef struct error error_t;

typedef expression_t* (*prefix_parse_fn)(parser_t *p);
typedef expression_t* (*infix_parse_fn)(parser_t *p, expression_t *expr);

typedef struct parser {
    const ape_config_t *config;
    lexer_t lexer;
    token_t cur_token;
    token_t peek_token;
    ptrarray(error_t) *errors;

    prefix_parse_fn prefix_parse_fns[TOKEN_TYPE_MAX];
    infix_parse_fn infix_parse_fns[TOKEN_TYPE_MAX];

    int depth;
} parser_t;

APE_INTERNAL parser_t* parser_make(const ape_config_t *config, ptrarray(error_t) *errors);
APE_INTERNAL void parser_destroy(parser_t *parser);

APE_INTERNAL ptrarray(statement_t)* parser_parse_all(parser_t *parser,  const char *input, compiled_file_t *file);

#endif /* parser_h */
//FILE_END
//FILE_START:symbol_table.h
#ifndef symbol_table_h
#define symbol_table_h

#ifndef APE_AMALGAMATED
#include "common.h"
#include "token.h"
#include "collections.h"
#endif

typedef enum symbol_type {
    SYMBOL_NONE = 0,
    SYMBOL_GLOBAL,
    SYMBOL_LOCAL,
    SYMBOL_NATIVE_FUNCTION,
    SYMBOL_FREE,
    SYMBOL_FUNCTION,
    SYMBOL_THIS,
} symbol_type_t;

typedef struct symbol {
    symbol_type_t type;
    char *name;
    int index;
    bool assignable;
} symbol_t;

typedef struct block_scope {
    dict(symbol_t) *store;
    int offset;
    int num_definitions;
} block_scope_t;

typedef struct symbol_table {
    struct symbol_table *outer;
    ptrarray(block_scope_t) *block_scopes;
    ptrarray(symbol_t) *free_symbols;
    int max_num_definitions;
} symbol_table_t;

APE_INTERNAL symbol_t *symbol_make(const char *name, symbol_type_t type, int index, bool assignable);
APE_INTERNAL void symbol_destroy(symbol_t *symbol);
APE_INTERNAL symbol_t* symbol_copy(const symbol_t *symbol);

APE_INTERNAL symbol_table_t *symbol_table_make(symbol_table_t *outer);
APE_INTERNAL void symbol_table_destroy(symbol_table_t *st);
APE_INTERNAL symbol_table_t* symbol_table_copy(symbol_table_t *st);
APE_INTERNAL void symbol_table_add_module_symbol(symbol_table_t *st, const symbol_t *symbol);
APE_INTERNAL symbol_t *symbol_table_define(symbol_table_t *st, const char *name, bool assignable);
APE_INTERNAL symbol_t *symbol_table_define_native_function(symbol_table_t *st, const char *name, int ix);
APE_INTERNAL symbol_t *symbol_table_define_free(symbol_table_t *st, symbol_t *original);
APE_INTERNAL symbol_t *symbol_table_define_function_name(symbol_table_t *st, const char *name, bool assignable);
APE_INTERNAL symbol_t *symbol_table_define_this(symbol_table_t *st);

APE_INTERNAL symbol_t *symbol_table_resolve(symbol_table_t *st, const char *name);

APE_INTERNAL bool symbol_table_symbol_is_defined(symbol_table_t *st, const char *name);
APE_INTERNAL void symbol_table_push_block_scope(symbol_table_t *table);
APE_INTERNAL void symbol_table_pop_block_scope(symbol_table_t *table);
APE_INTERNAL block_scope_t* symbol_table_get_block_scope(symbol_table_t *table);

APE_INTERNAL bool symbol_table_is_global_scope(symbol_table_t *table);
APE_INTERNAL bool symbol_table_is_top_block_scope(symbol_table_t *table);
APE_INTERNAL bool symbol_table_is_top_global_scope(symbol_table_t *table);

#endif /* symbol_table_h */
//FILE_END
//FILE_START:code.h
#ifndef code_h
#define code_h

#include <stdint.h>

#ifndef APE_AMALGAMATED
#include "common.h"
#include "collections.h"
#endif

typedef uint8_t opcode_t;

typedef enum opcode_val {
    OPCODE_NONE = 0,
    OPCODE_CONSTANT,
    OPCODE_ADD,
    OPCODE_POP,
    OPCODE_SUB,
    OPCODE_MUL,
    OPCODE_DIV,
    OPCODE_MOD,
    OPCODE_TRUE,
    OPCODE_FALSE,
    OPCODE_COMPARE,
    OPCODE_EQUAL,
    OPCODE_NOT_EQUAL,
    OPCODE_GREATER_THAN,
    OPCODE_GREATER_THAN_EQUAL,
    OPCODE_MINUS,
    OPCODE_BANG,
    OPCODE_JUMP,
    OPCODE_JUMP_IF_FALSE,
    OPCODE_JUMP_IF_TRUE,
    OPCODE_NULL,
    OPCODE_GET_GLOBAL,
    OPCODE_SET_GLOBAL,
    OPCODE_DEFINE_GLOBAL,
    OPCODE_ARRAY,
    OPCODE_MAP_START,
    OPCODE_MAP_END,
    OPCODE_GET_THIS,
    OPCODE_GET_INDEX,
    OPCODE_SET_INDEX,
    OPCODE_GET_VALUE_AT,
    OPCODE_CALL,
    OPCODE_RETURN_VALUE,
    OPCODE_RETURN,
    OPCODE_GET_LOCAL,
    OPCODE_DEFINE_LOCAL,
    OPCODE_SET_LOCAL,
    OPCODE_GET_NATIVE_FUNCTION,
    OPCODE_FUNCTION,
    OPCODE_GET_FREE,
    OPCODE_SET_FREE,
    OPCODE_CURRENT_FUNCTION,
    OPCODE_DUP,
    OPCODE_NUMBER,
    OPCODE_LEN,
    OPCODE_SET_RECOVER,
    OPCODE_OR,
    OPCODE_XOR,
    OPCODE_AND,
    OPCODE_LSHIFT,
    OPCODE_RSHIFT,
    OPCODE_MAX,
} opcode_val_t;

typedef struct opcode_definition {
    const char *name;
    int num_operands;
    int operand_widths[2];
} opcode_definition_t;

APE_INTERNAL opcode_definition_t* opcode_lookup(opcode_t op);
APE_INTERNAL const char *opcode_get_name(opcode_t op);
APE_INTERNAL int code_make(opcode_t op, int operands_count, uint64_t *operands, array(uint8_t) *res);
APE_INTERNAL void code_to_string(uint8_t *code, src_pos_t *source_positions, size_t code_size, strbuf_t *res);
APE_INTERNAL bool code_read_operands(opcode_definition_t *def, uint8_t *instr, uint64_t out_operands[2]);

#endif /* code_h */
//FILE_END
//FILE_START:compilation_scope.h
#ifndef compilation_scope_h
#define compilation_scope_h

#ifndef APE_AMALGAMATED
#include "symbol_table.h"
#include "code.h"
#include "gc.h"
#endif

typedef struct compilation_result {
    uint8_t *bytecode;
    src_pos_t *src_positions;
    int count;
} compilation_result_t;

typedef struct compilation_scope {
    struct compilation_scope *outer;
    array(uint8_t) *bytecode;
    array(src_pos_t) *src_positions;
    opcode_t last_opcode;
} compilation_scope_t;

APE_INTERNAL compilation_scope_t* compilation_scope_make(compilation_scope_t *outer);
APE_INTERNAL void compilation_scope_destroy(compilation_scope_t *scope);
APE_INTERNAL compilation_result_t *compilation_scope_orphan_result(compilation_scope_t *scope);

APE_INTERNAL compilation_result_t* compilation_result_make(uint8_t *bytecode, src_pos_t *src_positions, int count);
APE_INTERNAL void compilation_result_destroy(compilation_result_t* res);

#endif /* compilation_scope_h */
//FILE_END
//FILE_START:compiler.h
#ifndef compiler_h
#define compiler_h

#ifndef APE_AMALGAMATED
#include "collections.h"
#include "common.h"
#include "parser.h"
#include "code.h"
#include "token.h"
#include "compilation_scope.h"
#endif

typedef struct ape_config ape_config_t;
typedef struct gcmem gcmem_t;
typedef struct symbol_table symbol_table_t;

typedef struct module {
    char *name;
    ptrarray(symbol_t) *symbols;
} module_t;

typedef struct compiled_file {
    char *dir_path;
    char *path;
    ptrarray(char*) *lines;
} compiled_file_t;

typedef struct file_scope {
    parser_t *parser;
    symbol_table_t *symbol_table;
    module_t *module;
    compiled_file_t *file;
    ptrarray(char) *loaded_module_names;
} file_scope_t;

typedef struct compiler {
    const ape_config_t *config;
    gcmem_t *mem;
    compilation_scope_t *compilation_scope;
    ptrarray(file_scope_t) *file_scopes;
    array(object_t) *constants;
    ptrarray(error_t) *errors;
    array(src_pos_t) *src_positions_stack;
    array(int) *break_ip_stack;
    array(int) *continue_ip_stack;
    dict(module_t) *modules;
    ptrarray(compiled_file_t) *files;
} compiler_t;

APE_INTERNAL compiler_t *compiler_make(const ape_config_t *config, gcmem_t *mem, ptrarray(error_t) *errors);
APE_INTERNAL void compiler_destroy(compiler_t *comp);
APE_INTERNAL compilation_result_t* compiler_compile(compiler_t *comp, const char *code);
APE_INTERNAL compilation_result_t* compiler_compile_file(compiler_t *comp, const char *path);
APE_INTERNAL int compiler_emit(compiler_t *comp, opcode_t op, int operands_count, uint64_t *operands);
APE_INTERNAL compilation_scope_t* compiler_get_compilation_scope(compiler_t *comp);
APE_INTERNAL void compiler_push_compilation_scope(compiler_t *comp);
APE_INTERNAL void compiler_pop_compilation_scope(compiler_t *comp);
APE_INTERNAL void compiler_push_symbol_table(compiler_t *comp);
APE_INTERNAL void compiler_pop_symbol_table(compiler_t *comp);
APE_INTERNAL symbol_table_t* compiler_get_symbol_table(compiler_t *comp);
APE_INTERNAL void compiler_set_symbol_table(compiler_t *comp, symbol_table_t *table);
APE_INTERNAL opcode_t compiler_last_opcode(compiler_t *comp);

#endif /* compiler_h */
//FILE_END
//FILE_START:object.h
#ifndef object_h
#define object_h

#include <stdint.h>

#ifndef APE_AMALGAMATED
#include "common.h"
#include "collections.h"
#include "ast.h"
#endif

typedef struct compilation_result compilation_result_t;
typedef struct traceback traceback_t;
typedef struct vm vm_t;
typedef struct gcmem gcmem_t;

#define OBJECT_STRING_BUF_SIZE 32

typedef enum {
    OBJECT_NONE      = 0,
    OBJECT_ERROR     = 1 << 0,
    OBJECT_NUMBER    = 1 << 1,
    OBJECT_BOOL      = 1 << 2,
    OBJECT_STRING    = 1 << 3,
    OBJECT_NULL      = 1 << 4,
    OBJECT_NATIVE_FUNCTION   = 1 << 5,
    OBJECT_ARRAY     = 1 << 6,
    OBJECT_MAP       = 1 << 7,
    OBJECT_FUNCTION  = 1 << 8,
    OBJECT_EXTERNAL  = 1 << 9,
    OBJECT_FREED     = 1 << 10,
    OBJECT_ANY       = 0xffff,
} object_type_t;

typedef struct object {
    union {
        uint64_t handle;
        double number;
    };
} object_t;

typedef struct function {
    union {
        object_t *free_vals_allocated;
        object_t free_vals_buf[2];
    };
    union {
        char *name;
        const char *const_name;
    };
    compilation_result_t *comp_result;
    int num_locals;
    int num_args;
    int free_vals_count;
    bool owns_data;
} function_t;

typedef object_t (*native_fn)(vm_t *vm, void *data, int argc, object_t *args);

typedef struct native_function {
    char *name;
    native_fn fn;
    void *data;
} native_function_t;

typedef void  (*external_data_destroy_fn)(void* data);
typedef void* (*external_data_copy_fn)(void* data);

typedef struct external_data {
    void *data;
    external_data_destroy_fn data_destroy_fn;
    external_data_copy_fn    data_copy_fn;
} external_data_t;

typedef struct object_error {
    char *message;
    traceback_t *traceback;
} object_error_t;

typedef struct object_string {
    union {
        char *value_allocated;
        char value_buf[OBJECT_STRING_BUF_SIZE];
    };
    unsigned long hash;
    bool is_allocated;
} object_string_t;

typedef struct object_data {
    gcmem_t *mem;
    union {
        object_string_t string;
        object_error_t error;
        array(object_t) *array;
        valdict(object_t, object_t) *map;
        function_t function;
        native_function_t native_function;
        external_data_t external;
    };
    bool gcmark;
    object_type_t type;
} object_data_t;

APE_INTERNAL object_t object_make_number(double val);
APE_INTERNAL object_t object_make_bool(bool val);
APE_INTERNAL object_t object_make_null(void);
APE_INTERNAL object_t object_make_string(gcmem_t *mem, const char *string);
APE_INTERNAL object_t object_make_string_no_copy(gcmem_t *mem, char *string);
APE_INTERNAL object_t object_make_stringf(gcmem_t *mem, const char *fmt, ...) __attribute__ ((format (printf, 2, 3)));
APE_INTERNAL object_t object_make_native_function(gcmem_t *mem, const char *name, native_fn fn, void *data);
APE_INTERNAL object_t object_make_array(gcmem_t *mem);
APE_INTERNAL object_t object_make_array_with_capacity(gcmem_t *mem, unsigned capacity);
APE_INTERNAL object_t object_make_array_with_array(gcmem_t *mem, array(object_t) *array);
APE_INTERNAL object_t object_make_map(gcmem_t *mem);
APE_INTERNAL object_t object_make_map_with_capacity(gcmem_t *mem, unsigned capacity);
APE_INTERNAL object_t object_make_error(gcmem_t *mem, const char *message);
APE_INTERNAL object_t object_make_error_no_copy(gcmem_t *mem, char *message);
APE_INTERNAL object_t object_make_errorf(gcmem_t *mem, const char *fmt, ...) __attribute__ ((format (printf, 2, 3)));
APE_INTERNAL object_t object_make_function(gcmem_t *mem, const char *name, compilation_result_t *comp_res,
                                           bool owns_data, int num_locals, int num_args,
                                           int free_vals_count);
APE_INTERNAL object_t object_make_external(gcmem_t *mem, void *data);

APE_INTERNAL void object_deinit(object_t obj);
APE_INTERNAL void object_data_deinit(object_data_t *obj);

APE_INTERNAL bool        object_is_allocated(object_t obj);
APE_INTERNAL gcmem_t*    object_get_mem(object_t obj);
APE_INTERNAL bool        object_is_hashable(object_t obj);
APE_INTERNAL void        object_to_string(object_t obj, strbuf_t *buf, bool quote_str);
APE_INTERNAL const char* object_get_type_name(const object_type_t type);
APE_INTERNAL char*       object_serialize(object_t object);
APE_INTERNAL object_t    object_deep_copy(gcmem_t *mem, object_t object);
APE_INTERNAL object_t    object_copy(gcmem_t *mem, object_t obj);
APE_INTERNAL double      object_compare(object_t a, object_t b);
APE_INTERNAL bool        object_equals(object_t a, object_t b);

APE_INTERNAL object_data_t* object_get_allocated_data(object_t object);

APE_INTERNAL bool           object_get_bool(object_t obj);
APE_INTERNAL double         object_get_number(object_t obj);
APE_INTERNAL function_t*    object_get_function(object_t obj);
APE_INTERNAL const char*    object_get_string(object_t obj);
APE_INTERNAL native_function_t*     object_get_native_function(object_t obj);
APE_INTERNAL object_type_t  object_get_type(object_t obj);

APE_INTERNAL bool object_is_numeric(object_t obj);
APE_INTERNAL bool object_is_null(object_t obj);
APE_INTERNAL bool object_is_callable(object_t obj);

APE_INTERNAL const char* object_get_function_name(object_t obj);
APE_INTERNAL object_t    object_get_function_free_val(object_t obj, int ix);
APE_INTERNAL void        object_set_function_free_val(object_t obj, int ix, object_t val);
APE_INTERNAL object_t*   object_get_function_free_vals(object_t obj);

APE_INTERNAL const char*  object_get_error_message(object_t obj);
APE_INTERNAL void         object_set_error_traceback(object_t obj, traceback_t *traceback);
APE_INTERNAL traceback_t* object_get_error_traceback(object_t obj);

APE_INTERNAL external_data_t* object_get_external_data(object_t object);
APE_INTERNAL bool object_set_external_destroy_function(object_t object, external_data_destroy_fn destroy_fn);
APE_INTERNAL bool object_set_external_copy_function(object_t object, external_data_copy_fn copy_fn);

APE_INTERNAL array(object_t)* object_get_array(object_t array);
APE_INTERNAL object_t         object_get_array_value_at(object_t array, int ix);
APE_INTERNAL bool             object_set_array_value_at(object_t obj, int ix, object_t val);
APE_INTERNAL bool             object_add_array_value(object_t array, object_t val);
APE_INTERNAL int              object_get_array_length(object_t array);

APE_INTERNAL int      object_get_map_length(object_t obj);
APE_INTERNAL object_t object_get_map_key_at(object_t obj, int ix);
APE_INTERNAL object_t object_get_map_value_at(object_t obj, int ix);
APE_INTERNAL bool     object_set_map_value_at(object_t obj, int ix, object_t val);
APE_INTERNAL object_t object_get_kv_pair_at(gcmem_t *mem, object_t obj, int ix);
APE_INTERNAL bool     object_set_map_value(object_t obj, object_t key, object_t val);
APE_INTERNAL object_t object_get_map_value(object_t obj, object_t key);
APE_INTERNAL bool     object_map_has_key(object_t obj, object_t key);

#endif /* object_h */
//FILE_END
//FILE_START:gc.h
#ifndef gc_h
#define gc_h

#ifndef APE_AMALGAMATED
#include "common.h"
#include "collections.h"
#include "object.h"
#endif

typedef struct object_data object_data_t;
typedef struct env env_t;

typedef struct gcmem gcmem_t;

APE_INTERNAL gcmem_t *gcmem_make(void);
APE_INTERNAL void gcmem_destroy(gcmem_t *mem);

APE_INTERNAL object_data_t* gcmem_alloc_object_data(gcmem_t *mem, object_type_t type);

APE_INTERNAL void gc_unmark_all(gcmem_t *mem);
APE_INTERNAL void gc_mark_objects(object_t *objects, int count);
APE_INTERNAL void gc_mark_object(object_t object);
APE_INTERNAL void gc_mark_object_data(object_data_t *data);
APE_INTERNAL void gc_sweep(gcmem_t *mem);

APE_INTERNAL void gc_disable_on_object(object_t obj);
APE_INTERNAL void gc_enable_on_object(object_t obj);

#endif /* gc_h */
//FILE_END
//FILE_START:builtins.h
#ifndef builtins_h
#define builtins_h

#include <stdint.h>

#ifndef APE_AMALGAMATED
#include "common.h"
#include "object.h"
#endif

typedef struct vm vm_t;

APE_INTERNAL int builtins_count(void);
APE_INTERNAL native_fn builtins_get_fn(int ix);
APE_INTERNAL const char* builtins_get_name(int ix);

#endif /* builtins_h */
//FILE_END
//FILE_START:traceback.h
#ifndef traceback_h
#define traceback_h

#ifndef APE_AMALGAMATED
#include "common.h"
#include "collections.h"
#endif

typedef struct vm vm_t;

typedef struct traceback_item {
    char *function_name;
    src_pos_t pos;
} traceback_item_t;

typedef struct traceback {
    array(traceback_item_t)* items;
} traceback_t;

APE_INTERNAL traceback_t* traceback_make(void);
APE_INTERNAL void traceback_destroy(traceback_t *traceback);
APE_INTERNAL void traceback_append(traceback_t *traceback, const char *function_name, src_pos_t pos);
APE_INTERNAL void traceback_append_from_vm(traceback_t *traceback, vm_t *vm);
APE_INTERNAL void traceback_to_string(const traceback_t *traceback, strbuf_t *buf);
APE_INTERNAL const char* traceback_item_get_line(traceback_item_t *item);
APE_INTERNAL const char* traceback_item_get_filepath(traceback_item_t *item);

#endif /* traceback_h */
//FILE_END
//FILE_START:frame.h
#ifndef frame_h
#define frame_h

#include <stdint.h>

#ifndef APE_AMALGAMATED
#include "common.h"
#include "object.h"
#include "collections.h"
#include "code.h"
#endif

typedef struct {
    object_t function;
    int ip;
    int base_pointer;
    const src_pos_t *src_positions;
    uint8_t *bytecode;
    int src_ip;
    int bytecode_size;
    int recover_ip;
    bool is_recovering;
} frame_t;

APE_INTERNAL bool frame_init(frame_t* frame, object_t function, int base_pointer);

APE_INTERNAL opcode_val_t frame_read_opcode(frame_t* frame);
APE_INTERNAL uint64_t frame_read_uint64(frame_t* frame);
APE_INTERNAL uint16_t frame_read_uint16(frame_t* frame);
APE_INTERNAL uint8_t frame_read_uint8(frame_t* frame);
APE_INTERNAL src_pos_t frame_src_position(const frame_t *frame);

#endif /* frame_h */
//FILE_END
//FILE_START:vm.h
#ifndef vm_h
#define vm_h

#ifndef APE_AMALGAMATED
#include "ape.h"
#include "common.h"
#include "ast.h"
#include "object.h"
#include "frame.h"
#include "error.h"
#endif

#define VM_STACK_SIZE 2048
#define VM_MAX_GLOBALS 2048
#define VM_MAX_FRAMES 2048
#define VM_THIS_STACK_SIZE 2048

typedef struct ape_config ape_config_t;
typedef struct compilation_result compilation_result_t;

typedef struct vm {
    const ape_config_t *config;
    gcmem_t *mem;
    object_t globals[VM_MAX_GLOBALS];
    int globals_count;
    array(object_t) *native_functions;
    object_t stack[VM_STACK_SIZE];
    int sp;
    object_t this_stack[VM_THIS_STACK_SIZE];
    int this_sp;
    frame_t frames[VM_MAX_FRAMES];
    int frames_count;
    ptrarray(error_t) *errors;
    object_t last_popped;
    frame_t *current_frame;
    bool running;
    error_t *runtime_error;
    object_t operator_oveload_keys[OPCODE_MAX];
} vm_t;

APE_INTERNAL vm_t* vm_make(const ape_config_t *config, gcmem_t *mem, ptrarray(error_t) *errors); // ape can be null (for internal testing purposes)
APE_INTERNAL void  vm_destroy(vm_t *vm);

APE_INTERNAL void  vm_reset(vm_t *vm);

APE_INTERNAL bool vm_run(vm_t *vm, compilation_result_t *comp_res, array(object_t) *constants);
APE_INTERNAL object_t vm_call(vm_t *vm, array(object_t) *constants, object_t callee, int argc, object_t *args);
APE_INTERNAL bool vm_execute_function(vm_t *vm, object_t function, array(object_t) *constants);

APE_INTERNAL object_t vm_get_last_popped(vm_t *vm);
APE_INTERNAL bool vm_has_errors(vm_t *vm);

APE_INTERNAL void vm_set_global(vm_t *vm, int ix, object_t val);
APE_INTERNAL object_t vm_get_global(vm_t *vm, int ix);

APE_INTERNAL void vm_set_runtime_error(vm_t *vm, error_t *error); // only allowed when vm is running

#endif /* vm_h */
//FILE_END

//-----------------------------------------------------------------------------
// C files
//-----------------------------------------------------------------------------
//FILE_START:common.c
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

#ifndef APE_AMALGAMATED
#include "common.h"
#endif

APE_INTERNAL const src_pos_t src_pos_invalid = { NULL, -1, -1 };
APE_INTERNAL const src_pos_t src_pos_zero = { NULL, 0, 0 };

APE_INTERNAL src_pos_t src_pos_make(const compiled_file_t *file, int line, int column) {
    return (src_pos_t) {
        .file = file,
        .line = line,
        .column = column,
    };
}

char *ape_stringf(const char *format, ...) {
    va_list args;
    va_start(args, format);
    int to_write = vsnprintf(NULL, 0, format, args);
    va_end(args);
    va_start(args, format);
    char *res = (char*)ape_malloc(to_write + 1, ape_mallocArg);
    int written = vsprintf(res, format, args);
    (void)written;
    APE_ASSERT(written == to_write);
    va_end(args);
    return res;
}

void ape_log(const char *file, int line, const char *format, ...) {
    char msg[4096];
    int written = snprintf(msg, APE_ARRAY_LEN(msg), "%s:%d: ", file, line);
    (void)written;
    va_list args;
    va_start(args, format);
    int written_msg = vsnprintf(msg + written, APE_ARRAY_LEN(msg) - written, format, args);
    (void)written_msg;
    va_end(args);

    APE_ASSERT(written_msg <= (APE_ARRAY_LEN(msg) - written));

    printf("%s", msg);
}

char* ape_strndup(const char *string, size_t n) {
    char *output_string = (char*)ape_malloc(n + 1, ape_mallocArg);
    if (!output_string) {
        return NULL;
    }
    output_string[n] = '\0';
    memcpy(output_string, string, n);
    return output_string;
}

char* ape_strdup(const char *string) {
    return ape_strndup(string, strlen(string));
}

uint64_t ape_double_to_uint64(double val) {
    union {
        uint64_t val_uint64;
        double val_double;
    } temp = {
        .val_double = val
    };
    return temp.val_uint64;
}

double ape_uint64_to_double(uint64_t val) {
    union {
        uint64_t val_uint64;
        double val_double;
    } temp = {
        .val_uint64 = val
    };
    return temp.val_double;
}
//FILE_END
//FILE_START:collections.c
/*
Copyright (c) 2020 Krzysztof Gabis
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef COLLECTIONS_AMALGAMATED
#include "collections.h"
#endif

#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdint.h>

#ifdef COLLECTIONS_DEBUG
#include <assert.h>
#define COLLECTIONS_ASSERT(x) assert(x)
#else
#define COLLECTIONS_ASSERT(x)
#endif

//-----------------------------------------------------------------------------
// Collections
//-----------------------------------------------------------------------------

#undef malloc
#undef free


static void* apeMalloc(size_t size, void* allocArgs) {
    return malloc(size);
}

static void apeFree(void* mem, void* freeArgs) {
    free(mem);
}

static char* collections_strndup(const char *string, size_t n);
static char* collections_strdup(const char *string);
static unsigned long collections_hash(const void *ptr, size_t len); /* djb2 */
static unsigned int upper_power_of_two(unsigned int v);

static collections_malloc_fn collections_malloc = apeMalloc;
static collections_free_fn collections_free = apeFree;

void collections_set_memory_functions(collections_malloc_fn malloc_fn, collections_free_fn free_fn) {
    collections_malloc = malloc_fn;
    collections_free = free_fn;
}

static char* collections_strndup(const char *string, size_t n) {
    char *output_string = (char*)collections_malloc(n + 1, ape_mallocArg);
    if (!output_string) {
        return NULL;
    }
    output_string[n] = '\0';
    memcpy(output_string, string, n);
    return output_string;
}

static char* collections_strdup(const char *string) {
    return collections_strndup(string, strlen(string));
}

static unsigned long collections_hash(const void *ptr, size_t len) { /* djb2 */
    const uint8_t *ptr_u8 = (const uint8_t*)ptr;
    unsigned long hash = 5381;
    for (size_t i = 0; i < len; i++) {
        uint8_t val = ptr_u8[i];
        hash = ((hash << 5) + hash) + val;
    }
    return hash;
}

static unsigned int upper_power_of_two(unsigned int v) {
    v--;
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    v++;
    return v;
}

//-----------------------------------------------------------------------------
// Dictionary
//-----------------------------------------------------------------------------

#define DICT_INVALID_IX UINT_MAX
#define DICT_INITIAL_SIZE 32

typedef struct dict_ {
    unsigned int *cells;
    unsigned long *hashes;
    char **keys;
    void **values;
    unsigned int *cell_ixs;
    unsigned int count;
    unsigned int item_capacity;
    unsigned int cell_capacity;
} dict_t_;

// Private declarations
static bool dict_init(dict_t_ *dict, unsigned int initial_capacity);
static void dict_deinit(dict_t_ *dict, bool free_keys);
static unsigned int dict_get_cell_ix(const dict_t_ *dict,
                                     const char *key,
                                     unsigned long hash,
                                     bool *out_found);
static unsigned long hash_string(const char *str);
static bool dict_grow_and_rehash(dict_t_ *dict);
static bool dict_set_internal(dict_t_ *dict, const char *ckey, char *mkey, void *value);

// Public
dict_t_* dict_make(void) {
    dict_t_ *dict = collections_malloc(sizeof(dict_t_), ape_mallocArg);
    if (dict == NULL) {
        return NULL;
    }
    bool succeeded = dict_init(dict, DICT_INITIAL_SIZE);
    if (succeeded == false) {
        collections_free(dict, ape_freeArg);
        return NULL;
    }
    return dict;
}

void dict_destroy(dict_t_ *dict) {
    if (dict == NULL) {
        return;
    }
    dict_deinit(dict, true);
    collections_free(dict, ape_freeArg);
}

void dict_destroy_with_items_(dict_t_ *dict, dict_item_destroy_fn destroy_fn) {
    if (dict == NULL) {
        return;
    }

    if (destroy_fn) {
        for (unsigned int i = 0; i < dict->count; i++) {
            destroy_fn(dict->values[i]);
        }
    }

    dict_destroy(dict);
}

dict_t_* dict_copy_with_items_(dict_t_ *dict, dict_item_copy_fn copy_fn) {
    dict_t_ *dict_copy = dict_make();
    for (int i = 0; i < dict_count(dict); i++) {
        const char *key = dict_get_key_at(dict, i);
        void *item = dict_get_value_at(dict, i);
        void *item_copy = copy_fn(item);
        dict_set(dict_copy, key, item_copy);
    }
    return dict_copy;
}

bool dict_set(dict_t_ *dict, const char *key, void *value) {
    return dict_set_internal(dict, key, NULL, value);
}

void* dict_get(const dict_t_ *dict, const char *key) {
    unsigned long hash = hash_string(key);
    bool found = false;
    unsigned long cell_ix = dict_get_cell_ix(dict, key, hash, &found);
    if (found == false) {
        return NULL;
    }
    unsigned int item_ix = dict->cells[cell_ix];
    return dict->values[item_ix];
}

void *dict_get_value_at(const dict_t_ *dict, unsigned int ix) {
    if (ix >= dict->count) {
        return NULL;
    }
    return dict->values[ix];
}

const char *dict_get_key_at(const dict_t_ *dict, unsigned int ix) {
    if (ix >= dict->count) {
        return NULL;
    }
    return dict->keys[ix];
}

int dict_count(const dict_t_ *dict) {
    if (!dict) {
        return 0;
    }
    return dict->count;
}

bool dict_remove(dict_t_ *dict, const char *key) {
    unsigned long hash = hash_string(key);
    bool found = false;
    unsigned int cell = dict_get_cell_ix(dict, key, hash, &found);
    if (!found) {
        return false;
    }

    unsigned int item_ix = dict->cells[cell];
    collections_free(dict->keys[item_ix], ape_freeArg);
    unsigned int last_item_ix = dict->count - 1;
    if (item_ix < last_item_ix) {
        dict->keys[item_ix] = dict->keys[last_item_ix];
        dict->values[item_ix] = dict->values[last_item_ix];
        dict->cell_ixs[item_ix] = dict->cell_ixs[last_item_ix];
        dict->hashes[item_ix] = dict->hashes[last_item_ix];
        dict->cells[dict->cell_ixs[item_ix]] = item_ix;
    }
    dict->count--;

    unsigned int i = cell;
    unsigned int j = i;
    for (unsigned int x = 0; x < (dict->cell_capacity - 1); x++) {
        j = (j + 1) & (dict->cell_capacity - 1);
        if (dict->cells[j] == DICT_INVALID_IX) {
            break;
        }
        unsigned int k = dict->hashes[dict->cells[j]] & (dict->cell_capacity - 1);
        if ((j > i && (k <= i || k > j))
            || (j < i && (k <= i && k > j))) {
            dict->cell_ixs[dict->cells[j]] = i;
            dict->cells[i] = dict->cells[j];
            i = j;
        }
    }
    dict->cells[i] = DICT_INVALID_IX;
    return true;
}

void dict_clear(dict_t_ *dict) {
    for (unsigned int i = 0; i < dict->count; i++) {
        collections_free(dict->keys[i], ape_freeArg);
    }
    dict->count = 0;
    for (unsigned int i = 0; i < dict->cell_capacity; i++) {
        dict->cells[i] = DICT_INVALID_IX;
    }
}

// Private definitions
static bool dict_init(dict_t_ *dict, unsigned int initial_capacity) {
    dict->cells = NULL;
    dict->keys = NULL;
    dict->values = NULL;
    dict->cell_ixs = NULL;
    dict->hashes = NULL;

    dict->count = 0;
    dict->cell_capacity = initial_capacity;
    dict->item_capacity = (unsigned int)(initial_capacity * 0.7f);

    dict->cells = collections_malloc(dict->cell_capacity * sizeof(*dict->cells), ape_mallocArg);
    dict->keys = collections_malloc(dict->item_capacity * sizeof(*dict->keys), ape_mallocArg);
    dict->values = collections_malloc(dict->item_capacity * sizeof(*dict->values), ape_mallocArg);
    dict->cell_ixs = collections_malloc(dict->item_capacity * sizeof(*dict->cell_ixs), ape_mallocArg);
    dict->hashes = collections_malloc(dict->item_capacity * sizeof(*dict->hashes), ape_mallocArg);
    if (dict->cells == NULL
        || dict->keys == NULL
        || dict->values == NULL
        || dict->cell_ixs == NULL
        || dict->hashes == NULL) {
        goto error;
    }
    for (unsigned int i = 0; i < dict->cell_capacity; i++) {
        dict->cells[i] = DICT_INVALID_IX;
    }
    return true;
error:
    collections_free(dict->cells, ape_freeArg);
    collections_free(dict->keys, ape_freeArg);
    collections_free(dict->values, ape_freeArg);
    collections_free(dict->cell_ixs, ape_freeArg);
    collections_free(dict->hashes, ape_freeArg);
    return false;
}

static void dict_deinit(dict_t_ *dict, bool free_keys) {
    if (free_keys) {
        for (unsigned int i = 0; i < dict->count; i++) {
            collections_free(dict->keys[i], ape_freeArg);
        }
    }
    dict->count = 0;
    dict->item_capacity = 0;
    dict->cell_capacity = 0;

    collections_free(dict->cells, ape_freeArg);
    collections_free(dict->keys, ape_freeArg);
    collections_free(dict->values, ape_freeArg);
    collections_free(dict->cell_ixs, ape_freeArg);
    collections_free(dict->hashes, ape_freeArg);

    dict->cells = NULL;
    dict->keys = NULL;
    dict->values = NULL;
    dict->cell_ixs = NULL;
    dict->hashes = NULL;
}

static unsigned int dict_get_cell_ix(const dict_t_ *dict,
                                     const char *key,
                                     unsigned long hash,
                                     bool *out_found)
{
    *out_found = false;
    unsigned int cell_ix = hash & (dict->cell_capacity - 1);
    for (unsigned int i = 0; i < dict->cell_capacity; i++) {
        unsigned int ix = (cell_ix + i) & (dict->cell_capacity - 1);
        unsigned int cell = dict->cells[ix];
        if (cell == DICT_INVALID_IX) {
            return ix;
        }
        unsigned long hash_to_check = dict->hashes[cell];
        if (hash != hash_to_check) {
            continue;
        }
        const char *key_to_check = dict->keys[cell];
        if (strcmp(key, key_to_check) == 0) {
            *out_found = true;
            return ix;
        }
    }
    return DICT_INVALID_IX;
}

static unsigned long hash_string(const char *str) { /* djb2 */
    unsigned long hash = 5381;
    uint8_t c;
    while ((c = *str++)) {
        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
    }
    return hash;
}

static bool dict_grow_and_rehash(dict_t_ *dict) {
    dict_t_ new_dict;
    bool succeeded = dict_init(&new_dict, dict->cell_capacity * 2);
    if (succeeded == false) {
        return false;
    }
    for (unsigned int i = 0; i < dict->count; i++) {
        char *key = dict->keys[i];
        void *value = dict->values[i];
        succeeded = dict_set_internal(&new_dict, key, key, value);
        if (succeeded == false) {
            dict_deinit(&new_dict, false);
            return false;
        }
    }
    dict_deinit(dict, false);
    *dict = new_dict;
    return true;
}

static bool dict_set_internal(dict_t_ *dict, const char *ckey, char *mkey, void *value) {
    unsigned long hash = hash_string(ckey);
    bool found = false;
    unsigned int cell_ix = dict_get_cell_ix(dict, ckey, hash, &found);
    if (found) {
        unsigned int item_ix = dict->cells[cell_ix];
        dict->values[item_ix] = value;
        return true;
    }
    if (dict->count >= dict->item_capacity) {
        bool succeeded = dict_grow_and_rehash(dict);
        if (succeeded == false) {
            return false;
        }
        cell_ix = dict_get_cell_ix(dict, ckey, hash, &found);
    }
    dict->cells[cell_ix] = dict->count;
    dict->keys[dict->count] = mkey != NULL ? mkey : collections_strdup(ckey);
    dict->values[dict->count] = value;
    dict->cell_ixs[dict->count] = cell_ix;
    dict->hashes[dict->count] = hash;
    dict->count++;
    return true;
}
//-----------------------------------------------------------------------------
// Value dictionary
//-----------------------------------------------------------------------------
#define VALDICT_INVALID_IX UINT_MAX

typedef struct valdict_ {
    size_t key_size;
    size_t val_size;
    unsigned int *cells;
    unsigned long *hashes;
    void *keys;
    void *values;
    unsigned int *cell_ixs;
    unsigned int count;
    unsigned int item_capacity;
    unsigned int cell_capacity;
    collections_hash_fn _hash_key;
    collections_equals_fn _keys_equals;
} valdict_t_;

// Private declarations
static bool valdict_init(valdict_t_ *dict, size_t key_size, size_t val_size, unsigned int initial_capacity);
static void valdict_deinit(valdict_t_ *dict);
static unsigned int valdict_get_cell_ix(const valdict_t_ *dict,
                                        const void *key,
                                        unsigned long hash,
                                        bool *out_found);
static bool valdict_grow_and_rehash(valdict_t_ *dict);
static bool valdict_set_key_at(valdict_t_ *dict, unsigned int ix, void *key);
static bool valdict_keys_are_equal(const valdict_t_ *dict, const void *a, const void *b);
static unsigned long valdict_hash_key(const valdict_t_ *dict, const void *key);

// Public
valdict_t_* valdict_make_(size_t key_size, size_t val_size) {
    return valdict_make_with_capacity(DICT_INITIAL_SIZE, key_size, val_size);
}

valdict_t_* valdict_make_with_capacity(unsigned int min_capacity, size_t key_size, size_t val_size) {
    unsigned int capacity = upper_power_of_two(min_capacity * 2);

    valdict_t_ *dict = collections_malloc(sizeof(valdict_t_), ape_mallocArg);
    if (dict == NULL) {
        return NULL;
    }
    bool succeeded = valdict_init(dict, key_size, val_size, capacity);
    if (succeeded == false) {
        collections_free(dict, ape_freeArg);
        return NULL;
    }
    return dict;
}

void valdict_destroy(valdict_t_ *dict) {
    if (dict == NULL) {
        return;
    }
    valdict_deinit(dict);
    collections_free(dict, ape_freeArg);
}

void  valdict_set_hash_function(valdict_t_ *dict, collections_hash_fn hash_fn) {
    dict->_hash_key = hash_fn;
}

void valdict_set_equals_function(valdict_t_ *dict, collections_equals_fn equals_fn) {
    dict->_keys_equals = equals_fn;
}

bool valdict_set(valdict_t_ *dict, void *key, void *value) {
    unsigned long hash = valdict_hash_key(dict, key);
    bool found = false;
    unsigned int cell_ix = valdict_get_cell_ix(dict, key, hash, &found);
    if (found) {
        unsigned int item_ix = dict->cells[cell_ix];
        valdict_set_value_at(dict, item_ix, value);
        return true;
    }
    if (dict->count >= dict->item_capacity) {
        bool succeeded = valdict_grow_and_rehash(dict);
        if (succeeded == false) {
            return false;
        }
        cell_ix = valdict_get_cell_ix(dict, key, hash, &found);
    }
    unsigned int last_ix = dict->count;
    dict->count++;
    dict->cells[cell_ix] = last_ix;
    valdict_set_key_at(dict, last_ix, key);
    valdict_set_value_at(dict, last_ix, value);
    dict->cell_ixs[last_ix] = cell_ix;
    dict->hashes[last_ix] = hash;
    return true;
}

void* valdict_get(const valdict_t_ *dict, const void *key) {
    unsigned long hash = valdict_hash_key(dict, key);
    bool found = false;
    unsigned long cell_ix = valdict_get_cell_ix(dict, key, hash, &found);
    if (found == false) {
        return NULL;
    }
    unsigned int item_ix = dict->cells[cell_ix];
    return valdict_get_value_at(dict, item_ix);
}

void* valdict_get_key_at(const valdict_t_ *dict, unsigned int ix) {
    if (ix >= dict->count) {
        return NULL;
    }
    return (char*)dict->keys + (dict->key_size * ix);
}

void *valdict_get_value_at(const valdict_t_ *dict, unsigned int ix) {
    if (ix >= dict->count) {
        return NULL;
    }
    return (char*)dict->values + (dict->val_size * ix);
}

bool valdict_set_value_at(const valdict_t_ *dict, unsigned int ix, const void *value) {
    if (ix >= dict->count) {
        return false;
    }
    size_t offset = ix * dict->val_size;
    memcpy((char*)dict->values + offset, value, dict->val_size);
    return true;
}

int valdict_count(const valdict_t_ *dict) {
    if (!dict) {
        return 0;
    }
    return dict->count;
}

bool valdict_remove(valdict_t_ *dict, void *key) {
    unsigned long hash = valdict_hash_key(dict, key);
    bool found = false;
    unsigned int cell = valdict_get_cell_ix(dict, key, hash, &found);
    if (!found) {
        return false;
    }

    unsigned int item_ix = dict->cells[cell];
    unsigned int last_item_ix = dict->count - 1;
    if (item_ix < last_item_ix) {
        void *last_key = valdict_get_key_at(dict, last_item_ix);
        valdict_set_key_at(dict, item_ix, last_key);
        void *last_value = valdict_get_key_at(dict, last_item_ix);
        valdict_set_value_at(dict, item_ix, last_value);
        dict->cell_ixs[item_ix] = dict->cell_ixs[last_item_ix];
        dict->hashes[item_ix] = dict->hashes[last_item_ix];
        dict->cells[dict->cell_ixs[item_ix]] = item_ix;
    }
    dict->count--;

    unsigned int i = cell;
    unsigned int j = i;
    for (unsigned int x = 0; x < (dict->cell_capacity - 1); x++) {
        j = (j + 1) & (dict->cell_capacity - 1);
        if (dict->cells[j] == VALDICT_INVALID_IX) {
            break;
        }
        unsigned int k = dict->hashes[dict->cells[j]] & (dict->cell_capacity - 1);
        if ((j > i && (k <= i || k > j))
            || (j < i && (k <= i && k > j))) {
            dict->cell_ixs[dict->cells[j]] = i;
            dict->cells[i] = dict->cells[j];
            i = j;
        }
    }
    dict->cells[i] = VALDICT_INVALID_IX;
    return true;
}

void valdict_clear(valdict_t_ *dict) {
    dict->count = 0;
    for (unsigned int i = 0; i < dict->cell_capacity; i++) {
        dict->cells[i] = VALDICT_INVALID_IX;
    }
}

// Private definitions
static bool valdict_init(valdict_t_ *dict, size_t key_size, size_t val_size, unsigned int initial_capacity) {
    dict->key_size = key_size;
    dict->val_size = val_size;
    dict->cells = NULL;
    dict->keys = NULL;
    dict->values = NULL;
    dict->cell_ixs = NULL;
    dict->hashes = NULL;

    dict->count = 0;
    dict->cell_capacity = initial_capacity;
    dict->item_capacity = (unsigned int)(initial_capacity * 0.7f);

    dict->_keys_equals = NULL;
    dict->_hash_key = NULL;

    dict->cells = collections_malloc(dict->cell_capacity * sizeof(*dict->cells), ape_mallocArg);
    dict->keys = collections_malloc(dict->item_capacity * key_size, ape_mallocArg);
    dict->values = collections_malloc(dict->item_capacity * val_size, ape_mallocArg);
    dict->cell_ixs = collections_malloc(dict->item_capacity * sizeof(*dict->cell_ixs), ape_mallocArg);
    dict->hashes = collections_malloc(dict->item_capacity * sizeof(*dict->hashes), ape_mallocArg);
    if (dict->cells == NULL
        || dict->keys == NULL
        || dict->values == NULL
        || dict->cell_ixs == NULL
        || dict->hashes == NULL) {
        goto error;
    }
    for (unsigned int i = 0; i < dict->cell_capacity; i++) {
        dict->cells[i] = VALDICT_INVALID_IX;
    }
    return true;
error:
    collections_free(dict->cells, ape_freeArg);
    collections_free(dict->keys, ape_freeArg);
    collections_free(dict->values, ape_freeArg);
    collections_free(dict->cell_ixs, ape_freeArg);
    collections_free(dict->hashes, ape_freeArg);
    return false;
}

static void valdict_deinit(valdict_t_ *dict) {
    dict->key_size = 0;
    dict->val_size = 0;
    dict->count = 0;
    dict->item_capacity = 0;
    dict->cell_capacity = 0;

    collections_free(dict->cells, ape_freeArg);
    collections_free(dict->keys, ape_freeArg);
    collections_free(dict->values, ape_freeArg);
    collections_free(dict->cell_ixs, ape_freeArg);
    collections_free(dict->hashes, ape_freeArg);

    dict->cells = NULL;
    dict->keys = NULL;
    dict->values = NULL;
    dict->cell_ixs = NULL;
    dict->hashes = NULL;
}

static unsigned int valdict_get_cell_ix(const valdict_t_ *dict,
                                        const void *key,
                                        unsigned long hash,
                                        bool *out_found)
{
    *out_found = false;
    unsigned int cell_ix = hash & (dict->cell_capacity - 1);
    for (unsigned int i = 0; i < dict->cell_capacity; i++) {
        unsigned int ix = (cell_ix + i) & (dict->cell_capacity - 1);
        unsigned int cell = dict->cells[ix];
        if (cell == VALDICT_INVALID_IX) {
            return ix;
        }
        unsigned long hash_to_check = dict->hashes[cell];
        if (hash != hash_to_check) {
            continue;
        }
        void *key_to_check = valdict_get_key_at(dict, cell);
        bool are_equal = valdict_keys_are_equal(dict, key, key_to_check);
        if (are_equal) {
            *out_found = true;
            return ix;
        }
    }
    return VALDICT_INVALID_IX;
}

static bool valdict_grow_and_rehash(valdict_t_ *dict) {
    valdict_t_ new_dict;
    unsigned new_capacity = dict->cell_capacity == 0 ? DICT_INITIAL_SIZE : dict->cell_capacity * 2;
    bool succeeded = valdict_init(&new_dict, dict->key_size, dict->val_size, new_capacity);
    if (succeeded == false) {
        return false;
    }
    new_dict._keys_equals = dict->_keys_equals;
    new_dict._hash_key = dict->_hash_key;
    for (unsigned int i = 0; i < dict->count; i++) {
        char *key = valdict_get_key_at(dict, i);
        void *value = valdict_get_value_at(dict, i);
        succeeded = valdict_set(&new_dict, key, value);
        if (succeeded == false) {
            valdict_deinit(&new_dict);
            return false;
        }
    }
    valdict_deinit(dict);
    *dict = new_dict;
    return true;
}

static bool valdict_set_key_at(valdict_t_ *dict, unsigned int ix, void *key) {
    if (ix >= dict->count) {
        return false;
    }
    size_t offset = ix * dict->key_size;
    memcpy((char*)dict->keys + offset, key, dict->key_size);
    return true;
}

static bool valdict_keys_are_equal(const valdict_t_ *dict, const void *a, const void *b) {
    if (dict->_keys_equals) {
        return dict->_keys_equals(a, b);
    } else {
        return memcmp(a, b, dict->key_size) == 0;
    }
}

static unsigned long valdict_hash_key(const valdict_t_ *dict, const void *key) {
    if (dict->_hash_key) {
        return dict->_hash_key(key);
    } else {
        return collections_hash(key, dict->key_size);
    }
}

//-----------------------------------------------------------------------------
// Pointer dictionary
//-----------------------------------------------------------------------------
typedef struct ptrdict_ {
    valdict_t_ vd;
} ptrdict_t_;

// Public
ptrdict_t_* ptrdict_make(void) {
    ptrdict_t_ *dict = collections_malloc(sizeof(ptrdict_t_), ape_mallocArg);
    if (dict == NULL) {
        return NULL;
    }
    bool succeeded = valdict_init(&dict->vd, sizeof(void*), sizeof(void*), DICT_INITIAL_SIZE);
    if (succeeded == false) {
        collections_free(dict, ape_freeArg);
        return NULL;
    }
    return dict;
}

void ptrdict_destroy(ptrdict_t_ *dict) {
    if (dict == NULL) {
        return;
    }
    valdict_deinit(&dict->vd);
    collections_free(dict, ape_freeArg);
}

void  ptrdict_set_hash_function(ptrdict_t_ *dict, collections_hash_fn hash_fn) {
    valdict_set_hash_function(&dict->vd, hash_fn);
}

void ptrdict_set_equals_function(ptrdict_t_ *dict, collections_equals_fn equals_fn) {
    valdict_set_equals_function(&dict->vd, equals_fn);
}

bool ptrdict_set(ptrdict_t_ *dict, void *key, void *value) {
    return valdict_set(&dict->vd, &key, &value);
}

void* ptrdict_get(const ptrdict_t_ *dict, const void *key) {
    void* res = valdict_get(&dict->vd, &key);
    if (!res) {
        return NULL;
    }
    return *(void**)res;
}

void* ptrdict_get_value_at(const ptrdict_t_ *dict, unsigned int ix) {
    void* res = valdict_get_value_at(&dict->vd, ix);
    if (!res) {
        return NULL;
    }
    return *(void**)res;
}

void* ptrdict_get_key_at(const ptrdict_t_ *dict, unsigned int ix) {
    void* res = valdict_get_key_at(&dict->vd, ix);
    if (!res) {
        return NULL;
    }
    return *(void**)res;
}

int ptrdict_count(const ptrdict_t_ *dict) {
    return valdict_count(&dict->vd);
}

bool ptrdict_remove(ptrdict_t_ *dict, void *key) {
    return valdict_remove(&dict->vd, &key);
}

void ptrdict_clear(ptrdict_t_ *dict) {
    valdict_clear(&dict->vd);
}

//-----------------------------------------------------------------------------
// Array
//-----------------------------------------------------------------------------

typedef struct array_ {
    unsigned char *data;
    unsigned int count;
    unsigned int capacity;
    size_t element_size;
    bool lock_capacity;
} array_t_;

static bool array_init_with_capacity(array_t_ *arr, unsigned int capacity, size_t element_size);
static void array_deinit(array_t_ *arr);

array_t_* array_make_(size_t element_size) {
    return array_make_with_capacity(32, element_size);
}

array_t_* array_make_with_capacity(unsigned int capacity, size_t element_size) {
    array_t_ *arr = collections_malloc(sizeof(array_t_), ape_mallocArg);
    if (arr == NULL) {
        return NULL;
    }
    bool succeeded = array_init_with_capacity(arr, capacity, element_size);
    if (succeeded == false) {
        collections_free(arr, ape_freeArg);
        return NULL;
    }
    return arr;
}

void array_destroy(array_t_ *arr) {
    if (arr == NULL) {
        return;
    }
    array_deinit(arr);
    collections_free(arr, ape_freeArg);
}

void array_destroy_with_items_(array_t_ *arr, array_item_deinit_fn deinit_fn) {
    for (int i = 0; i < array_count(arr); i++) {
        void *item = array_get(arr, i);
        deinit_fn(item);
    }
    array_destroy(arr);
}

array_t_* array_copy(const array_t_ *arr) {
    array_t_ *copy = collections_malloc(sizeof(array_t_), ape_mallocArg);
    if (!copy) {
        return NULL;
    }
    copy->capacity = arr->capacity;
    copy->count = arr->count;
    copy->element_size = arr->element_size;
    copy->lock_capacity = arr->lock_capacity;
    copy->data = collections_malloc(arr->capacity * arr->element_size, ape_mallocArg);
    memcpy(copy->data, arr->data, arr->capacity * arr->element_size);
    if (!copy->data) {
        collections_free(copy, ape_freeArg);
        return NULL;
    }
    return copy;
}


bool array_add(array_t_ *arr, const void *value) {
    if (arr->count >= arr->capacity) {
        COLLECTIONS_ASSERT(!arr->lock_capacity);
        if (arr->lock_capacity) {
            return false;
        }
        unsigned int new_capacity = arr->capacity > 0 ? arr->capacity * 2 : 1;
        unsigned char *new_data = collections_malloc(new_capacity * arr->element_size, ape_mallocArg);
        if (new_data == NULL) {
            return false;
        }
        memcpy(new_data, arr->data, arr->count * arr->element_size);
        collections_free(arr->data, ape_freeArg);
        arr->data = new_data;
        arr->capacity = new_capacity;
    }
    if (value) {
        memcpy(arr->data + (arr->count * arr->element_size), value, arr->element_size);
    }
    arr->count++;
    return true;
}

bool array_addn(array_t_ *arr, const void *values, int n) {
    for (int i = 0; i < n; i++) {
        const uint8_t *value = NULL;
        if (values) {
            value = (const uint8_t*)values + (i * arr->element_size);
        }
        bool ok = array_add(arr, value);
        if (!ok) {
            return false;
        }
    }
    return true;
}

bool array_add_array(array_t_ *dest, const array_t_ *source) {
    COLLECTIONS_ASSERT(dest->element_size == source->element_size);
    if (dest->element_size != source->element_size) {
        return false;
    }
    for (int i = 0; i < array_count(source); i++) {
        void *item = array_get(source, i);
        bool ok = array_add(dest, item);
        if (!ok) {
            return false;
        }
    }
    return true;
}

bool array_push(array_t_ *arr, const void *value) {
    return array_add(arr, value);
}

bool array_pop(array_t_ *arr, void *out_value) {
    if (arr->count <= 0) {
        return false;
    }
    if (out_value) {
        void *res = array_get(arr, arr->count - 1);
        memcpy(out_value, res, arr->element_size);
    }
    array_remove_at(arr, arr->count - 1);
    return true;
}

void* array_top(array_t_ *arr) {
    if (arr->count <= 0) {
        return NULL;
    }
    return array_get(arr, arr->count - 1);
}

bool array_set(array_t_ *arr, unsigned int ix, void *value) {
    if (ix >= arr->count) {
        COLLECTIONS_ASSERT(false);
        return false;
    }
    size_t offset = ix * arr->element_size;
    memmove(arr->data + offset, value, arr->element_size);
    return true;
}

bool array_setn(array_t_ *arr, unsigned int ix, void *values, int n) {
    for (int i = 0; i < n; i++) {
        int dest_ix = ix + i;
        unsigned char *value = (unsigned char*)values + (i * arr->element_size);
        if (dest_ix < array_count(arr)) {
            bool ok = array_set(arr, dest_ix, value);
            if (!ok) {
                return false;
            }
        } else {
            bool ok = array_add(arr, value);
            if (!ok) {
                return false;
            }
        }
    }
    return true;
}

void * array_get(const array_t_ *arr, unsigned int ix) {
    if (ix >= arr->count) {
        COLLECTIONS_ASSERT(false);
        return NULL;
    }
    size_t offset = ix * arr->element_size;
    return arr->data + offset;
}

void * array_get_last(const array_t_ *arr) {
    if (arr->count <= 0) {
        return NULL;
    }
    return array_get(arr, arr->count - 1);
}

int array_count(const array_t_ *arr) {
    if (!arr) {
        return 0;
    }
    return arr->count;
}

bool array_remove_at(array_t_ *arr, unsigned int ix) {
    if (ix >= arr->count) {
        return false;
    }
    if (ix == (arr->count - 1)) {
        arr->count--;
        return true;
    }
    size_t to_move_bytes = (arr->count - 1 - ix) * arr->element_size;
    void *dest = arr->data + (ix * arr->element_size);
    void *src = arr->data + ((ix + 1) * arr->element_size);
    memmove(dest, src, to_move_bytes);
    arr->count--;
    return true;
}

bool array_remove_item(array_t_ *arr, void *ptr) {
    int ix = array_get_index(arr, ptr);
    if (ix < 0) {
        return false;
    }
    return array_remove_at(arr, ix);
}

void array_clear(array_t_ *arr) {
    arr->count = 0;
}

void array_clear_and_deinit_items_(array_t_ *arr, array_item_deinit_fn deinit_fn) {
    for (int i = 0; i < array_count(arr); i++) {
        void *item = array_get(arr, i);
        deinit_fn(item);
    }
    arr->count = 0;
}

void array_lock_capacity(array_t_ *arr) {
    arr->lock_capacity = true;
}

int array_get_index(const array_t_ *arr, void *ptr) {
    for (int i = 0; i < array_count(arr); i++) {
        if (array_get(arr, i) == ptr) {
            return i;
        }
    }
    return -1;
}

bool array_contains(const array_t_ *arr, void *ptr) {
    return array_get_index(arr, ptr) >= 0;
}

void* array_data(array_t_ *arr) {
    return arr->data;
}

const void*  array_const_data(const array_t_ *arr) {
    return arr->data;
}

bool array_orphan_data(array_t_ *arr) {
    return array_init_with_capacity(arr, 0, arr->element_size);
}

void array_reverse(array_t_ *arr) {
    int count = array_count(arr);
    if (count < 2) {
        return;
    }
    void *temp = collections_malloc(arr->element_size, ape_mallocArg);
    for (int a_ix = 0; a_ix < (count / 2); a_ix++) {
        int b_ix = count - a_ix - 1;
        void *a = array_get(arr, a_ix);
        void *b = array_get(arr, b_ix);
        memcpy(temp, a, arr->element_size);
        array_set(arr, a_ix, b);
        array_set(arr, b_ix, temp);
    }
    collections_free(temp, ape_freeArg);
}

static bool array_init_with_capacity(array_t_ *arr, unsigned int capacity, size_t element_size) {
    if (capacity > 0) {
        arr->data = collections_malloc(capacity * element_size, ape_mallocArg);
        if (arr->data == NULL) {
            return false;
        }
    } else {
        arr->data = NULL;
    }
    arr->capacity = capacity;
    arr->count = 0;
    arr->element_size = element_size;
    arr->lock_capacity = false;
    return true;
}

static void array_deinit(array_t_ *arr) {
    collections_free(arr->data, ape_freeArg);
}

//-----------------------------------------------------------------------------
// Pointer Array
//-----------------------------------------------------------------------------

typedef struct ptrarray_ {
    array_t_ arr;
} ptrarray_t_;

ptrarray_t_* ptrarray_make(void) {
    return ptrarray_make_with_capacity(0);
}

ptrarray_t_* ptrarray_make_with_capacity(unsigned int capacity) {
    ptrarray_t_ *ptrarr = collections_malloc(sizeof(ptrarray_t_), ape_mallocArg);
    if (ptrarr == NULL) {
        return NULL;
    }
    bool succeeded = array_init_with_capacity(&ptrarr->arr, capacity, sizeof(void*));
    if (succeeded == false) {
        collections_free(ptrarr, ape_freeArg);
        return NULL;
    }
    return ptrarr;
}

void ptrarray_destroy(ptrarray_t_ *arr) {
    if (arr == NULL) {
        return;
    }
    array_deinit(&arr->arr);
    collections_free(arr, ape_freeArg);
}

void ptrarray_destroy_with_items_(ptrarray_t_ *arr, ptrarray_item_destroy_fn destroy_fn){
    if (arr == NULL) {
        return;
    }

    if (destroy_fn) {
        ptrarray_clear_and_destroy_items_(arr, destroy_fn);
    }

    ptrarray_destroy(arr);
}

ptrarray_t_* ptrarray_copy(ptrarray_t_ *arr) {
    ptrarray_t_ *arr_copy = ptrarray_make_with_capacity(arr->arr.capacity);
    for (int i = 0; i < ptrarray_count(arr); i++) {
        void *item = ptrarray_get(arr, i);
        ptrarray_add(arr_copy, item);
    }
    return arr_copy;
}

ptrarray_t_* ptrarray_copy_with_items_(ptrarray_t_ *arr, ptrarray_item_copy_fn copy_fn) {
    ptrarray_t_ *arr_copy = ptrarray_make_with_capacity(arr->arr.capacity);
    for (int i = 0; i < ptrarray_count(arr); i++) {
        void *item = ptrarray_get(arr, i);
        void *item_copy = copy_fn(item);
        ptrarray_add(arr_copy, item_copy);
    }
    return arr_copy;
}

bool ptrarray_add(ptrarray_t_ *arr, void *ptr) {
    return array_add(&arr->arr, &ptr);
}

bool ptrarray_set(ptrarray_t_ *arr, unsigned int ix, void *ptr) {
    return array_set(&arr->arr, ix, &ptr);
}

bool ptrarray_add_array(ptrarray_t_ *dest, const ptrarray_t_ *source) {
    return array_add_array(&dest->arr, &source->arr);
}

void * ptrarray_get(ptrarray_t_ *arr, unsigned int ix) {
    void* res = array_get(&arr->arr, ix);
    if (!res) {
        return NULL;
    }
    return *(void**)res;
}

bool ptrarray_push(ptrarray_t_ *arr, void *ptr) {
    return ptrarray_add(arr, ptr);
}

void *ptrarray_pop(ptrarray_t_ *arr) {
    int ix = ptrarray_count(arr) - 1;
    void *res = ptrarray_get(arr, ix);
    ptrarray_remove_at(arr, ix);
    return res;
}

void *ptrarray_top(ptrarray_t_ *arr) {
    int count = ptrarray_count(arr);
    return ptrarray_get(arr, count - 1);
}

int ptrarray_count(const ptrarray_t_ *arr) {
    if (!arr) {
        return 0;
    }
    return array_count(&arr->arr);
}

bool ptrarray_remove_at(ptrarray_t_ *arr, unsigned int ix) {
    return array_remove_at(&arr->arr, ix);
}

bool ptrarray_remove_item(ptrarray_t_ *arr, void *item) {
    for (int i = 0; i < ptrarray_count(arr); i++) {
        if (item == ptrarray_get(arr, i)) {
            ptrarray_remove_at(arr, i);
            return true;
        }
    }
    COLLECTIONS_ASSERT(false);
    return false;
}

void ptrarray_clear(ptrarray_t_ *arr) {
    array_clear(&arr->arr);
}

void ptrarray_clear_and_destroy_items_(ptrarray_t_ *arr, ptrarray_item_destroy_fn destroy_fn) {
    for (int i = 0; i < ptrarray_count(arr); i++) {
        void *item = ptrarray_get(arr, i);
        destroy_fn(item);
    }
    ptrarray_clear(arr);
}

void ptrarray_lock_capacity(ptrarray_t_ *arr) {
    array_lock_capacity(&arr->arr);
}

int ptrarray_get_index(ptrarray_t_ *arr, void *ptr) {
    for (int i = 0; i < ptrarray_count(arr); i++) {
        if (ptrarray_get(arr, i) == ptr) {
            return i;
        }
    }
    return -1;
}

bool ptrarray_contains(ptrarray_t_ *arr, void *item) {
    return ptrarray_get_index(arr, item) >= 0;
}

void * ptrarray_get_addr(ptrarray_t_ *arr, unsigned int ix) {
    void* res = array_get(&arr->arr, ix);
    if (res == NULL) {
        return NULL;
    }
    return res;
}

void* ptrarray_data(ptrarray_t_ *arr) {
    return array_data(&arr->arr);
}

void ptrarray_reverse(ptrarray_t_ *arr) {
    array_reverse(&arr->arr);
}

//-----------------------------------------------------------------------------
// String buffer
//-----------------------------------------------------------------------------

typedef struct strbuf {
    char *data;
    size_t capacity;
    size_t len;
} strbuf_t;

static bool strbuf_grow(strbuf_t *buf, size_t new_capacity);

strbuf_t* strbuf_make(void) {
    strbuf_t *res = strbuf_make_with_capacity(1);
    return res;
}

strbuf_t* strbuf_make_with_capacity(unsigned int capacity) {
    strbuf_t *buf = collections_malloc(sizeof(strbuf_t), ape_mallocArg);
    if (buf == NULL) {
        return NULL;
    }
    memset(buf, 0, sizeof(strbuf_t));
    buf->data = collections_malloc(capacity, ape_mallocArg);
    if (buf->data == NULL) {
        collections_free(buf, ape_freeArg);
        return NULL;
    }
    buf->capacity = capacity;
    buf->len = 0;
    buf->data[0] = '\0';
    return buf;
}

void strbuf_destroy(strbuf_t *buf) {
    if (buf == NULL) {
        return;
    }
    collections_free(buf->data, ape_freeArg);
    collections_free(buf, ape_freeArg);
}

void strbuf_clear(strbuf_t *buf) {
    buf->len = 0;
    buf->data[0] = '\0';
}

bool strbuf_append(strbuf_t *buf, const char *str) {
    size_t str_len = strlen(str);
    if (str_len == 0) {
        return true;
    }
    size_t required_capacity = buf->len + str_len + 1;
    if (required_capacity > buf->capacity) {
        bool ok = strbuf_grow(buf, required_capacity * 2);
        if (!ok) {
            return false;
        }
    }
    memcpy(buf->data + buf->len, str, str_len);
    buf->len = buf->len + str_len;
    buf->data[buf->len] = '\0';
    return true;
}

bool strbuf_appendf(strbuf_t *buf, const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    int to_write = vsnprintf(NULL, 0, fmt, args);
    va_end(args);
    if (to_write == 0) {
        return true;
    }
    size_t required_capacity = buf->len + to_write + 1;
    if (required_capacity > buf->capacity) {
        bool ok = strbuf_grow(buf, required_capacity * 2);
        if (!ok) {
            return false;
        }
    }
    va_start(args, fmt);
    int written = vsprintf(buf->data + buf->len, fmt, args);
    (void)written;
    va_end(args);
    if (written != to_write) {
        return false;
    }
    buf->len = buf->len + to_write;
    buf->data[buf->len] = '\0';
    return true;
}

const char * strbuf_get_string(const strbuf_t *buf) {
    return buf->data;
}

size_t strbuf_get_length(const strbuf_t *buf) {
    return buf->len;
}

char * strbuf_get_string_and_destroy(strbuf_t *buf) {
    char *res = buf->data;
    buf->data = NULL;
    strbuf_destroy(buf);
    return res;
}

static bool strbuf_grow(strbuf_t *buf, size_t new_capacity) {
    char *new_data = collections_malloc(new_capacity, ape_mallocArg);
    if (new_data == NULL) {
        return false;
    }
    memcpy(new_data, buf->data, buf->len);
    new_data[buf->len] = '\0';
    collections_free(buf->data, ape_freeArg);
    buf->data = new_data;
    buf->capacity = new_capacity;
    return true;
}

//-----------------------------------------------------------------------------
// Utils
//-----------------------------------------------------------------------------

ptrarray(char)* kg_split_string(const char *str, const char *delimiter) {
    ptrarray(char)* res = ptrarray_make();
    if (!str) {
        return res;
    }
    const char *line_start = str;
    const char *line_end = strstr(line_start, delimiter);
    while (line_end != NULL) {
        long len = line_end - line_start;
        char *line = collections_strndup(line_start, len);
        ptrarray_add(res, line);
        line_start = line_end + 1;
        line_end = strstr(line_start, delimiter);
    }
    char *rest = collections_strdup(line_start);
    ptrarray_add(res, rest);
    return res;
}

char* kg_join(ptrarray(char) *items, const char *with) {
    strbuf_t *res = strbuf_make();
    for (int i = 0; i < ptrarray_count(items); i++) {
        char *item = ptrarray_get(items, i);
        strbuf_append(res, item);
        if (i < (ptrarray_count(items) - 1)) {
            strbuf_append(res, with);
        }
    }
    return strbuf_get_string_and_destroy(res);
}

char* kg_canonicalise_path(const char *path) {
    if (!strchr(path, '/') || (!strstr(path, "/../") && !strstr(path, "./"))) {
        return collections_strdup(path);
    }

    ptrarray(char) *split = kg_split_string(path, "/");

    for (int i = 0; i < ptrarray_count(split) - 1; i++) {
        char *item = ptrarray_get(split, i);
        char *next_item = ptrarray_get(split, i + 1);
        if (kg_streq(item, ".")) {
            collections_free(item, ape_freeArg);
            ptrarray_remove_at(split, i);
            i = -1;
            continue;
        }
        if (kg_streq(next_item, "..")) {
            collections_free(item, ape_freeArg);
            collections_free(next_item, ape_freeArg);
            ptrarray_remove_at(split, i);
            ptrarray_remove_at(split, i);
            i = -1;
            continue;
        }
    }

    char *joined = kg_join(split, "/");
    ptrarray_destroy_with_items(split, collections_free);
    return joined;
}

bool kg_is_path_absolute(const char *path) {
    return path[0] == '/';
}

bool kg_streq(const char *a, const char *b) {
    return strcmp(a, b) == 0;
}
//FILE_END
//FILE_START:error.c
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

#ifndef APE_AMALGAMATED
#include "error.h"
#include "traceback.h"
#endif

error_t* error_make_no_copy(error_type_t type, src_pos_t pos, char *message) {
    error_t *err = ape_malloc(sizeof(error_t), ape_mallocArg);
    memset(err, 0, sizeof(error_t));
    err->type = type;
    err->message = message;
    err->pos = pos;
    err->traceback = NULL;
    return err;
}

error_t* error_make(error_type_t type, src_pos_t pos, const char *message) {
    return error_make_no_copy(type, pos, ape_strdup(message));
}

error_t* error_makef(error_type_t type, src_pos_t pos, const char *format, ...) {
    va_list args;
    va_start(args, format);
    int to_write = vsnprintf(NULL, 0, format, args);
    va_end(args);
    va_start(args, format);
    char *res = (char*)ape_malloc(to_write + 1, ape_mallocArg);
    vsprintf(res, format, args);
    va_end(args);
    return error_make_no_copy(type, pos, res);
}

void error_destroy(error_t *error) {
    if (!error) {
        return;
    }
    traceback_destroy(error->traceback);
    ape_free(error->message, ape_freeArg);
    ape_free(error, ape_freeArg);
}

const char *error_type_to_string(error_type_t type) {
    switch (type) {
        case ERROR_PARSING: return "PARSING";
        case ERROR_COMPILATION: return "COMPILATION";
        case ERROR_RUNTIME: return "RUNTIME";
        case ERROR_USER: return "USER";
        default: return "INVALID";
    }
}
//FILE_END
//FILE_START:token.c
#include <string.h>
#include <stdlib.h>

#ifndef APE_AMALGAMATED
#include "token.h"
#endif

static const char *g_type_names[] = {
    "ILLEGAL",
    "EOF",
    "=",
    "+=",
    "-=",
    "*=",
    "/=",
    "%=",
    "&=",
    "|=",
    "^=",
    "<<=",
    ">>=",
    "+",
    "-",
    "!",
    "*",
    "/",
    "<",
    "<=",
    ">",
    ">=",
    "==",
    "!=",
    "&&",
    "||",
    "&",
    "|",
    "^",
    "<<",
    ">>",
    ",",
    ";",
    ":",
    "(",
    ")",
    "{",
    "}",
    "[",
    "]",
    ".",
    "%",
    "FUNCTION",
    "CONST",
    "VAR",
    "TRUE",
    "FALSE",
    "IF",
    "ELSE",
    "RETURN",
    "WHILE",
    "BREAK",
    "FOR",
    "IN",
    "CONTINUE",
    "NULL",
    "IMPORT",
    "RECOVER",
    "IDENT",
    "NUMBER",
    "STRING",
};

void token_make(token_t *tok, token_type_t type, const char *literal, int len) {
    tok->type = type;
    tok->literal = literal;
    tok->len = len;
}

char* token_duplicate_literal(const token_t *tok) {
    return ape_strndup(tok->literal, tok->len);
}

const char* token_type_to_string(token_type_t type) {
    return g_type_names[type];
}
//FILE_END
//FILE_START:lexer.c
#include <stdlib.h>
#include <string.h>

#ifndef APE_AMALGAMATED
#include "lexer.h"
#include "collections.h"
#include "compiler.h"
#endif

static void read_char(lexer_t *lex);
static char peek_char(lexer_t *lex);
static bool is_letter(char ch);
static bool is_digit(char ch);
static bool is_one_of(char ch, const char* allowed, int allowed_len);
static const char* read_identifier(lexer_t *lex, int *out_len);
static const char* read_number(lexer_t *lex, int *out_len);
static const char* read_string(lexer_t *lex, char delimiter, int *out_len);
static token_type_t lookup_identifier(const char *ident, int len);
static void skip_whitespace(lexer_t *lex);
static void add_line(lexer_t *lex, int offset);

bool lexer_init(lexer_t *lex, const char *input, compiled_file_t *file) {
    lex->input = input;
    lex->input_len = (int)strlen(input);
    lex->position = 0;
    lex->next_position = 0;
    lex->ch = '\0';
    if (file) {
        lex->line = ptrarray_count(file->lines);
    } else {
        lex->line = 0;
    }
    lex->column = -1;
    lex->file = file;
    add_line(lex, 0);
    read_char(lex);
    return true;
}

token_t lexer_next_token(lexer_t *lex) {
    while (true) {
        skip_whitespace(lex);

        token_t out_tok;
        out_tok.type = TOKEN_ILLEGAL;
        out_tok.literal = lex->input + lex->position;
        out_tok.len = 1;
        out_tok.pos = src_pos_make(lex->file, lex->line, lex->column);

        switch (lex->ch) {
            case '\0': token_make(&out_tok, TOKEN_EOF, "EOF", 3); break;
            case '=': {
                if (peek_char(lex) == '=') {
                    token_make(&out_tok, TOKEN_EQ, "==", 2);
                    read_char(lex);
                } else {
                    token_make(&out_tok, TOKEN_ASSIGN, "=", 1);
                }
                break;
            }
            case '&': {
                if (peek_char(lex) == '&') {
                    token_make(&out_tok, TOKEN_AND, "&&", 2);
                    read_char(lex);
                } else if (peek_char(lex) == '=') {
                    token_make(&out_tok, TOKEN_BIT_AND_ASSIGN, "&=", 2);
                    read_char(lex);
                } else {
                    token_make(&out_tok, TOKEN_BIT_AND, "&", 1);
                }
                break;
            }
            case '|': {
                if (peek_char(lex) == '|') {
                    token_make(&out_tok, TOKEN_OR, "||", 2);
                    read_char(lex);
                } else if (peek_char(lex) == '=') {
                    token_make(&out_tok, TOKEN_BIT_OR_ASSIGN, "|=", 2);
                    read_char(lex);
                } else {
                    token_make(&out_tok, TOKEN_BIT_OR, "|", 1);
                }
                break;
            }
            case '^': {
                if (peek_char(lex) == '=') {
                    token_make(&out_tok, TOKEN_BIT_XOR_ASSIGN, "^=", 2);
                    read_char(lex);
                } else {
                    token_make(&out_tok, TOKEN_BIT_XOR, "^", 1); break;
                }
                break;
            }
            case '+': {
                if (peek_char(lex) == '=') {
                    token_make(&out_tok, TOKEN_PLUS_ASSIGN, "+=", 2);
                    read_char(lex);
                } else {
                    token_make(&out_tok, TOKEN_PLUS, "+", 1); break;
                }
                break;
            }
            case '-': {
                if (peek_char(lex) == '=') {
                    token_make(&out_tok, TOKEN_MINUS_ASSIGN, "-=", 2);
                    read_char(lex);
                } else {
                    token_make(&out_tok, TOKEN_MINUS, "-", 1); break;
                }
                break;
            }
            case '!': {
                if (peek_char(lex) == '=') {
                    token_make(&out_tok, TOKEN_NOT_EQ, "!=", 2);
                    read_char(lex);
                } else {
                    token_make(&out_tok, TOKEN_BANG, "!", 1);
                }
                break;
            }
            case '*': {
                if (peek_char(lex) == '=') {
                    token_make(&out_tok, TOKEN_ASTERISK_ASSIGN, "*=", 2);
                    read_char(lex);
                } else {
                    token_make(&out_tok, TOKEN_ASTERISK, "*", 1); break;
                }
                break;
            }
            case '/': {
                if (peek_char(lex) == '/') {
                    read_char(lex);
                    while (lex->ch != '\n' && lex->ch != '\0') {
                        read_char(lex);
                    }
                    continue;
                } else if (peek_char(lex) == '=') {
                    token_make(&out_tok, TOKEN_SLASH_ASSIGN, "/=", 2);
                    read_char(lex);
                } else {
                    token_make(&out_tok, TOKEN_SLASH, "/", 1); break;
                }
                break;
            }
            case '<': {
                if (peek_char(lex) == '=') {
                    token_make(&out_tok, TOKEN_LTE, "<=", 2);
                    read_char(lex);
                } else if (peek_char(lex) == '<') {
                    read_char(lex);
                    if (peek_char(lex) == '=') {
                        token_make(&out_tok, TOKEN_LSHIFT_ASSIGN, "<<=", 3);
                        read_char(lex);
                    } else {
                        token_make(&out_tok, TOKEN_LSHIFT, "<<", 2);
                    }
                } else {
                    token_make(&out_tok, TOKEN_LT, "<", 1); break;
                }
                break;
            }
            case '>': {
                if (peek_char(lex) == '=') {
                    token_make(&out_tok, TOKEN_GTE, ">=", 2);
                    read_char(lex);
                } else if (peek_char(lex) == '>') {
                    read_char(lex);
                    if (peek_char(lex) == '=') {
                        token_make(&out_tok, TOKEN_RSHIFT_ASSIGN, ">>=", 3);
                        read_char(lex);
                    } else {
                        token_make(&out_tok, TOKEN_RSHIFT, ">>", 2);
                    }
                } else {
                    token_make(&out_tok, TOKEN_GT, ">", 1);
                }
                break;
            }
            case ',': token_make(&out_tok, TOKEN_COMMA, ",", 1); break;
            case ';': token_make(&out_tok, TOKEN_SEMICOLON, ";", 1); break;
            case ':': token_make(&out_tok, TOKEN_COLON, ":", 1); break;
            case '(': token_make(&out_tok, TOKEN_LPAREN, "(", 1); break;
            case ')': token_make(&out_tok, TOKEN_RPAREN, ")", 1); break;
            case '{': token_make(&out_tok, TOKEN_LBRACE, "{", 1); break;
            case '}': token_make(&out_tok, TOKEN_RBRACE, "}", 1); break;
            case '[': token_make(&out_tok, TOKEN_LBRACKET, "[", 1); break;
            case ']': token_make(&out_tok, TOKEN_RBRACKET, "]", 1); break;
            case '.': token_make(&out_tok, TOKEN_DOT, ".", 1); break;
            case '%': {
                if (peek_char(lex) == '=') {
                    token_make(&out_tok, TOKEN_PERCENT_ASSIGN, "%=", 2);
                    read_char(lex);
                } else {
                    token_make(&out_tok, TOKEN_PERCENT, "%", 1); break;
                }
                break;
            }
            case '"': {
                int len;
                const char *str = read_string(lex, '"', &len);
                if (str) {
                    token_make(&out_tok, TOKEN_STRING, str, len);
                } else {
                    token_make(&out_tok, TOKEN_ILLEGAL, NULL, 0);
                }
                break;
            }
            case '\'': {
                int len;
                const char *str = read_string(lex, '\'', &len);
                if (str) {
                    token_make(&out_tok, TOKEN_STRING, str, len);
                } else {
                    token_make(&out_tok, TOKEN_ILLEGAL, NULL, 0);
                }
                break;
            }
            default: {
                if (is_letter(lex->ch)) {
                    int ident_len = 0;
                    const char *ident = read_identifier(lex, &ident_len);
                    token_type_t type = lookup_identifier(ident, ident_len);
                    token_make(&out_tok, type, ident, ident_len);
                    return out_tok;
                } else if (is_digit(lex->ch)) {
                    int number_len = 0;
                    const char *number = read_number(lex, &number_len);
                    token_make(&out_tok, TOKEN_NUMBER, number, number_len);
                    return out_tok;
                }
                break;
            }
        }
        read_char(lex);
        return out_tok;
    }
}

// INTERNAL
static void read_char(lexer_t *lex) {
    if (lex->next_position >= lex->input_len) {
        lex->ch = '\0';
    } else {
        lex->ch = lex->input[lex->next_position];
    }
    lex->position = lex->next_position;
    lex->next_position++;

    if (lex->ch == '\n') {
        lex->line++;
        lex->column = -1;
        add_line(lex, lex->next_position);
    } else {
        lex->column++;
    }
}

static char peek_char(lexer_t *lex) {
    if (lex->next_position >= lex->input_len) {
        return '\0';
    } else {
        return lex->input[lex->next_position];
    }
}

static bool is_letter(char ch) {
    return ('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z') || ch == '_';
}

static bool is_digit(char ch) {
    return ch >= '0' && ch <= '9';
}

static bool is_one_of(char ch, const char* allowed, int allowed_len) {
    for (int i = 0; i < allowed_len; i++) {
        if (ch == allowed[i]) {
            return true;
        }
    }
    return false;
}

static const char* read_identifier(lexer_t *lex, int *out_len) {
    int position = lex->position;
    int len = 0;
    while (is_digit(lex->ch) || is_letter(lex->ch) || lex->ch == ':') {
        if (lex->ch == ':') {
            if (peek_char(lex) != ':') {
                goto end;
            }
            read_char(lex);
        }
        read_char(lex);
    }
end:
    len = lex->position - position;
    *out_len = len;
    return lex->input + position;
}

static const char* read_number(lexer_t *lex, int *out_len) {
    char allowed[] = ".xXaAbBcCdDeEfF";
    int position = lex->position;
    while (is_digit(lex->ch) || is_one_of(lex->ch, allowed, APE_ARRAY_LEN(allowed) - 1)) {
        read_char(lex);
    }
    int len = lex->position - position;
    *out_len = len;
    return lex->input + position;
}

static const char* read_string(lexer_t *lex, char delimiter, int *out_len) {
    *out_len = 0;

    bool escaped = false;
    int position = lex->position + 1;
    while (true) {
        read_char(lex);
        if (lex->ch == '\0') {
            return NULL;
        }
        if (lex->ch == delimiter && !escaped) {
            break;
        }
        escaped = false;
        if (lex->ch == '\\') {
            escaped = true;
        }
    }
    int len = lex->position - position;
    *out_len = len;
    return lex->input + position;
}

static token_type_t lookup_identifier(const char *ident, int len) {
    struct {
        const char *value;
        int len;
        token_type_t type;
    } keywords[] = {
        {"fn", 2, TOKEN_FUNCTION},
        {"const", 5, TOKEN_CONST},
        {"var", 3, TOKEN_VAR},
        {"true", 4, TOKEN_TRUE},
        {"false", 5, TOKEN_FALSE},
        {"if", 2, TOKEN_IF},
        {"else", 4, TOKEN_ELSE},
        {"return", 6, TOKEN_RETURN},
        {"while", 5, TOKEN_WHILE},
        {"break", 5, TOKEN_BREAK},
        {"for", 3, TOKEN_FOR},
        {"in", 2, TOKEN_IN},
        {"continue", 8, TOKEN_CONTINUE},
        {"null", 4, TOKEN_NULL},
        {"import", 6, TOKEN_IMPORT},
        {"recover", 7, TOKEN_RECOVER},
    };

    for (int i = 0; i < APE_ARRAY_LEN(keywords); i++) {
        if (keywords[i].len == len && APE_STRNEQ(ident, keywords[i].value, len)) {
            return keywords[i].type;
        }
    }

    return TOKEN_IDENT;
}

static void skip_whitespace(lexer_t *lex) {
    char ch = lex->ch;
    while (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r') {
        read_char(lex);
        ch = lex->ch;
    }
}

static void add_line(lexer_t *lex, int offset) {
    if (!lex->file) {
        return;
    }
    const char *line_start = lex->input + offset;
    const char *new_line_ptr = strchr(line_start, '\n');
    char *line = NULL;
    if (!new_line_ptr) {
        line = ape_strdup(line_start);
    } else {
        size_t line_len = new_line_ptr - line_start;
        line = ape_strndup(line_start, line_len);
    }
    ptrarray_add(lex->file->lines, line);
}
//FILE_END
//FILE_START:ast.c
#include <stdlib.h>
#include <string.h>

#ifndef APE_AMALGAMATED
#include "ast.h"
#include "common.h"
#endif

static expression_t* expression_make(expression_type_t type);
static statement_t* statement_make(statement_type_t type);

expression_t* expression_make_ident(ident_t ident) {
    expression_t *res = expression_make(EXPRESSION_IDENT);
    res->ident = ident;
    return res;
}

expression_t* expression_make_number_literal(double val) {
    expression_t *res = expression_make(EXPRESSION_NUMBER_LITERAL);
    res->number_literal = val;
    return res;
}

expression_t* expression_make_bool_literal(bool val) {
    expression_t *res = expression_make(EXPRESSION_BOOL_LITERAL);
    res->bool_literal = val;
    return res;
}

expression_t* expression_make_string_literal(char *value) {
    expression_t *res = expression_make(EXPRESSION_STRING_LITERAL);
    res->string_literal = value;
    return res;
}

expression_t* expression_make_null_literal() {
    expression_t *res = expression_make(EXPRESSION_NULL_LITERAL);
    return res;
}

expression_t* expression_make_array_literal(ptrarray(expression_t) *values) {
    expression_t *res = expression_make(EXPRESSION_ARRAY_LITERAL);
    res->array = values;
    return res;
}

expression_t* expression_make_map_literal(ptrarray(expression_t) *keys, ptrarray(expression_t) *values) {
    expression_t *res = expression_make(EXPRESSION_MAP_LITERAL);
    res->map.keys = keys;
    res->map.values = values;
    return res;
}

expression_t* expression_make_prefix(operator_t op, expression_t *right) {
    expression_t *res = expression_make(EXPRESSION_PREFIX);
    res->prefix.op = op;
    res->prefix.right = right;
    return res;
}

expression_t* expression_make_infix(operator_t op, expression_t *left, expression_t *right) {
    expression_t *res = expression_make(EXPRESSION_INFIX);
    res->infix.op = op;
    res->infix.left = left;
    res->infix.right = right;
    return res;
}

expression_t* expression_make_fn_literal(array(ident_t) *params, code_block_t *body) {
    expression_t *res = expression_make(EXPRESSION_FUNCTION_LITERAL);
    res->fn_literal.name = NULL;
    res->fn_literal.params = params;
    res->fn_literal.body = body;
    return res;
}

expression_t* expression_make_call(expression_t *function, ptrarray(expression_t) *args) {
    expression_t *res = expression_make(EXPRESSION_CALL);
    res->call_expr.function = function;
    res->call_expr.args = args;
    return res;
}

expression_t* expression_make_index(expression_t *left, expression_t *index) {
    expression_t *res = expression_make(EXPRESSION_INDEX);
    res->index_expr.left = left;
    res->index_expr.index = index;
    return res;
}

expression_t* expression_make_assign(expression_t *dest, expression_t *source) {
    expression_t *res = expression_make(EXPRESSION_ASSIGN);
    res->assign.dest = dest;
    res->assign.source = source;
    return res;
}

expression_t* expression_make_logical(operator_t op, expression_t *left, expression_t *right) {
    expression_t *res = expression_make(EXPRESSION_LOGICAL);
    res->logical.op = op;
    res->logical.left = left;
    res->logical.right = right;
    return res;
}

void expression_destroy(expression_t *expr) {
    if (!expr) {
        return;
    }

    switch (expr->type) {
        case EXPRESSION_NONE: {
            APE_ASSERT(false);
            break;
        }
        case EXPRESSION_IDENT: {
            ident_deinit(&expr->ident);
            break;
        }
        case EXPRESSION_NUMBER_LITERAL:
        case EXPRESSION_BOOL_LITERAL: {
            break;
        }
        case EXPRESSION_STRING_LITERAL: {
            ape_free(expr->string_literal, ape_freeArg);
            break;
        }
        case EXPRESSION_NULL_LITERAL: {
            break;
        }
        case EXPRESSION_ARRAY_LITERAL: {
            ptrarray_destroy_with_items(expr->array, expression_destroy);
            break;
        }
        case EXPRESSION_MAP_LITERAL: {
            ptrarray_destroy_with_items(expr->map.keys, expression_destroy);
            ptrarray_destroy_with_items(expr->map.values, expression_destroy);
            break;
        }
        case EXPRESSION_PREFIX: {
            expression_destroy(expr->prefix.right);
            break;
        }
        case EXPRESSION_INFIX: {
            expression_destroy(expr->infix.left);
            expression_destroy(expr->infix.right);
            break;
        }
        case EXPRESSION_FUNCTION_LITERAL: {
            fn_literal_deinit(&expr->fn_literal);
            break;
        }
        case EXPRESSION_CALL: {
            ptrarray_destroy_with_items(expr->call_expr.args, expression_destroy);
            expression_destroy(expr->call_expr.function);
            break;
        }
        case EXPRESSION_INDEX: {
            expression_destroy(expr->index_expr.left);
            expression_destroy(expr->index_expr.index);
            break;
        }
        case EXPRESSION_ASSIGN: {
            expression_destroy(expr->assign.dest);
            expression_destroy(expr->assign.source);
            break;
        }
        case EXPRESSION_LOGICAL: {
            expression_destroy(expr->logical.left);
            expression_destroy(expr->logical.right);
            break;
        }
    }
    ape_free(expr, ape_freeArg);
}

expression_t* expression_copy(expression_t *expr) {
    APE_ASSERT(expr);
    if (!expr) {
        return NULL;
    }
    expression_t *res = NULL;
    switch (expr->type) {
        case EXPRESSION_NONE: {
            APE_ASSERT(false);
            break;
        }
        case EXPRESSION_IDENT: {
            ident_t ident = ident_copy(expr->ident);
            res = expression_make_ident(ident);
            break;
        }
        case EXPRESSION_NUMBER_LITERAL: {
            res = expression_make_number_literal(expr->number_literal);
            break;
        }
        case EXPRESSION_BOOL_LITERAL: {
            res = expression_make_bool_literal(expr->bool_literal);
            break;
        }
        case EXPRESSION_STRING_LITERAL: {
            res = expression_make_string_literal(ape_strdup(expr->string_literal));
            break;
        }
        case EXPRESSION_NULL_LITERAL: {
            res = expression_make_null_literal();
            break;
        }
        case EXPRESSION_ARRAY_LITERAL: {
            ptrarray(expression_t) *values_copy = ptrarray_copy_with_items(expr->array, expression_copy);
            res = expression_make_array_literal(values_copy);
            break;
        }
        case EXPRESSION_MAP_LITERAL: {
            ptrarray(expression_t) *keys_copy = ptrarray_copy_with_items(expr->map.keys, expression_copy);
            ptrarray(expression_t) *values_copy = ptrarray_copy_with_items(expr->map.values, expression_copy);
            res = expression_make_map_literal(keys_copy, values_copy);
            break;
        }
        case EXPRESSION_PREFIX: {
            expression_t *right_copy = expression_copy(expr->prefix.right);
            res = expression_make_prefix(expr->prefix.op, right_copy);
            break;
        }
        case EXPRESSION_INFIX: {
            expression_t *left_copy = expression_copy(expr->infix.left);
            expression_t *right_copy = expression_copy(expr->infix.right);
            res = expression_make_infix(expr->infix.op, left_copy, right_copy);
            break;
        }
        case EXPRESSION_FUNCTION_LITERAL: {
            array(ident_t) *params_copy = array_make(ident_t);
            for (int i = 0; i < array_count(expr->fn_literal.params); i++) {
                ident_t *param = array_get(expr->fn_literal.params, i);
                ident_t copy = ident_copy(*param);
                array_add(params_copy, &copy);
            }
            code_block_t *body_copy = code_block_copy(expr->fn_literal.body);
            res = expression_make_fn_literal(params_copy, body_copy);
            res->fn_literal.name = ape_strdup(expr->fn_literal.name);
            break;
        }
        case EXPRESSION_CALL: {
            expression_t *function_copy = expression_copy(expr->call_expr.function);
            ptrarray(expression_t) *args_copy = ptrarray_copy_with_items(expr->call_expr.args, expression_copy);
            res = expression_make_call(function_copy, args_copy);
            break;
        }
        case EXPRESSION_INDEX: {
            expression_t *left_copy = expression_copy(expr->index_expr.left);
            expression_t *index_copy = expression_copy(expr->index_expr.index);
            res = expression_make_index(left_copy, index_copy);
            break;
        }
        case EXPRESSION_ASSIGN: {
            expression_t *dest_copy = expression_copy(expr->assign.dest);
            expression_t *source_copy = expression_copy(expr->assign.source);
            res = expression_make_assign(dest_copy, source_copy);
            break;
        }
        case EXPRESSION_LOGICAL: {
            expression_t *left_copy = expression_copy(expr->logical.left);
            expression_t *right_copy = expression_copy(expr->logical.right);
            res = expression_make_logical(expr->logical.op, left_copy, right_copy);
            break;
        }
    }
    res->pos = expr->pos;
    return res;
}

statement_t* statement_make_define(ident_t name, expression_t *value, bool assignable) {
    statement_t *res = statement_make(STATEMENT_DEFINE);
    res->define.name = name;
    res->define.value = value;
    res->define.assignable = assignable;
    return res;
}

statement_t* statement_make_if(ptrarray(if_case_t) *cases, code_block_t *alternative) {
    statement_t *res = statement_make(STATEMENT_IF);
    res->if_statement.cases = cases;
    res->if_statement.alternative = alternative;
    return res;
}

statement_t* statement_make_return(expression_t *value) {
    statement_t *res = statement_make(STATEMENT_RETURN_VALUE);
    res->return_value = value;
    return res;
}

statement_t* statement_make_expression(expression_t *value) {
    statement_t *res = statement_make(STATEMENT_EXPRESSION);
    res->expression = value;
    return res;
}

statement_t* statement_make_while_loop(expression_t *test, code_block_t *body) {
    statement_t *res = statement_make(STATEMENT_WHILE_LOOP);
    res->while_loop.test = test;
    res->while_loop.body = body;
    return res;
}

statement_t* statement_make_break() {
    statement_t *res = statement_make(STATEMENT_BREAK);
    return res;
}

statement_t* statement_make_foreach(ident_t iterator, expression_t *source, code_block_t *body) {
    statement_t *res = statement_make(STATEMENT_FOREACH);
    res->foreach.iterator = iterator;
    res->foreach.source = source;
    res->foreach.body = body;
    return res;
}

statement_t* statement_make_for_loop(statement_t *init, expression_t *test, expression_t *update, code_block_t *body) {
    statement_t *res = statement_make(STATEMENT_FOR_LOOP);
    res->for_loop.init = init;
    res->for_loop.test = test;
    res->for_loop.update = update;
    res->for_loop.body = body;
    return res;
}

statement_t* statement_make_continue() {
    statement_t *res = statement_make(STATEMENT_CONTINUE);
    return res;
}

statement_t* statement_make_block(code_block_t *block) {
    statement_t *res = statement_make(STATEMENT_BLOCK);
    res->block = block;
    return res;
}

statement_t* statement_make_import(char *path) {
    statement_t *res = statement_make(STATEMENT_IMPORT);
    res->import.path = path;
    return res;
}

statement_t* statement_make_recover(ident_t error_ident, code_block_t *body) {
    statement_t *res = statement_make(STATEMENT_RECOVER);
    res->recover.error_ident = error_ident;
    res->recover.body = body;
    return res;
}

void statement_destroy(statement_t *stmt) {
    if (!stmt) {
        return;
    }
    switch (stmt->type) {
        case STATEMENT_NONE: {
            APE_ASSERT(false);
            break;
        }
        case STATEMENT_DEFINE: {
            ident_deinit(&stmt->define.name);
            expression_destroy(stmt->define.value);
            break;
        }
        case STATEMENT_IF: {
            ptrarray_destroy_with_items(stmt->if_statement.cases, if_case_destroy);
            code_block_destroy(stmt->if_statement.alternative);
            break;
        }
        case STATEMENT_RETURN_VALUE: {
            expression_destroy(stmt->return_value);
            break;
        }
        case STATEMENT_EXPRESSION: {
            expression_destroy(stmt->expression);
            break;
        }
        case STATEMENT_WHILE_LOOP: {
            expression_destroy(stmt->while_loop.test);
            code_block_destroy(stmt->while_loop.body);
            break;
        }
        case STATEMENT_BREAK: {
            break;
        }
        case STATEMENT_CONTINUE: {
            break;
        }
        case STATEMENT_FOREACH: {
            ident_deinit(&stmt->foreach.iterator);
            expression_destroy(stmt->foreach.source);
            code_block_destroy(stmt->foreach.body);
            break;
        }
        case STATEMENT_FOR_LOOP: {
            statement_destroy(stmt->for_loop.init);
            expression_destroy(stmt->for_loop.test);
            expression_destroy(stmt->for_loop.update);
            code_block_destroy(stmt->for_loop.body);
            break;
        }
        case STATEMENT_BLOCK: {
            code_block_destroy(stmt->block);
            break;
        }
        case STATEMENT_IMPORT: {
            ape_free(stmt->import.path, ape_freeArg);
            break;
        }
        case STATEMENT_RECOVER: {
            code_block_destroy(stmt->recover.body);
            ident_deinit(&stmt->recover.error_ident);
            break;
        }
    }
    ape_free(stmt, ape_freeArg);
}

statement_t* statement_copy(statement_t *stmt) {
    APE_ASSERT(stmt);
    if (!stmt) {
        return NULL;
    }
    statement_t *res = NULL;
    switch (stmt->type) {
        case STATEMENT_NONE: {
            APE_ASSERT(false);
            break;
        }
        case STATEMENT_DEFINE: {
            expression_t *value_copy = expression_copy(stmt->define.value);
            res = statement_make_define(ident_copy(stmt->define.name), value_copy, stmt->define.assignable);
            break;
        }
        case STATEMENT_IF: {
            ptrarray(expression_t) *cases_copy = ptrarray_copy_with_items(stmt->if_statement.cases, expression_copy);
            code_block_t *alternative_copy = code_block_copy(stmt->if_statement.alternative);
            res = statement_make_if(cases_copy, alternative_copy);
            break;
        }
        case STATEMENT_RETURN_VALUE: {
            expression_t *value_copy = expression_copy(stmt->return_value);
            res = statement_make_return(value_copy);
            break;
        }
        case STATEMENT_EXPRESSION: {
            expression_t *value_copy = expression_copy(stmt->expression);
            res = statement_make_expression(value_copy);
            break;
        }
        case STATEMENT_WHILE_LOOP: {
            expression_t *test_copy = expression_copy(stmt->while_loop.test);
            code_block_t *body_copy = code_block_copy(stmt->while_loop.body);
            res = statement_make_while_loop(test_copy, body_copy);
            break;
        }
        case STATEMENT_BREAK: {
            res = statement_make_break();
            break;
        }
        case STATEMENT_CONTINUE: {
            res = statement_make_continue();
            break;
        }
        case STATEMENT_FOREACH: {
            expression_t *source_copy = expression_copy(stmt->foreach.source);
            code_block_t *body_copy = code_block_copy(stmt->foreach.body);
            res = statement_make_foreach(ident_copy(stmt->foreach.iterator), source_copy, body_copy);
            break;
        }
        case STATEMENT_FOR_LOOP: {
            statement_t *init_copy = statement_copy(stmt->for_loop.init);
            expression_t *test_copy = expression_copy(stmt->for_loop.test);
            expression_t *update_copy = expression_copy(stmt->for_loop.update);
            code_block_t *body_copy = code_block_copy(stmt->for_loop.body);
            res = statement_make_for_loop(init_copy, test_copy, update_copy, body_copy);
            break;
        }
        case STATEMENT_BLOCK: {
            code_block_t *block_copy = code_block_copy(stmt->block);
            res = statement_make_block(block_copy);
            break;
        }
        case STATEMENT_IMPORT: {
            res = statement_make_import(ape_strdup(stmt->import.path));
            break;
        }
        case STATEMENT_RECOVER: {
            code_block_t *body_copy = code_block_copy(stmt->recover.body);
            res = statement_make_recover(ident_copy(stmt->recover.error_ident), body_copy);
            break;
        }
    }
    res->pos = stmt->pos;
    return NULL;
}

code_block_t* code_block_make(ptrarray(statement_t) *statements) {
    code_block_t *stmt = ape_malloc(sizeof(code_block_t), ape_mallocArg);
    stmt->statements = statements;
    return stmt;
}

void code_block_destroy(code_block_t *block) {
    if (!block) {
        return;
    }
    ptrarray_destroy_with_items(block->statements, statement_destroy);
    ape_free(block, ape_freeArg);
}

code_block_t* code_block_copy(code_block_t *block) {
    ptrarray(statement_t) *statements_copy = ptrarray_make();
    for (int i = 0; i < ptrarray_count(block->statements); i++) {
        statement_t *statement = ptrarray_get(block->statements, i);
        statement_t *copy = statement_copy(statement);
        ptrarray_add(statements_copy, copy);
    }
    return code_block_make(statements_copy);
}

char* statements_to_string(ptrarray(statement_t) *statements) {
    strbuf_t *buf = strbuf_make();
    int count =  ptrarray_count(statements);
    for (int i = 0; i < count; i++) {
        const statement_t *stmt = ptrarray_get(statements, i);
        statement_to_string(stmt, buf);
        if (i < (count - 1)) {
            strbuf_append(buf, "\n");
        }
    }
    return strbuf_get_string_and_destroy(buf);
}

void statement_to_string(const statement_t *stmt, strbuf_t *buf) {
    switch (stmt->type) {
        case STATEMENT_DEFINE: {
            const define_statement_t *def_stmt = &stmt->define;
            if (stmt->define.assignable) {
                strbuf_append(buf, "var ");
            } else {
                strbuf_append(buf, "const ");
            }
            strbuf_append(buf, def_stmt->name.value);
            strbuf_append(buf, " = ");

            if (def_stmt->value) {
                expression_to_string(def_stmt->value, buf);
            }

            break;
        }
        case STATEMENT_IF: {
            if_case_t *if_case = ptrarray_get(stmt->if_statement.cases, 0);
            strbuf_append(buf, "if (");
            expression_to_string(if_case->test, buf);
            strbuf_append(buf, ") ");
            code_block_to_string(if_case->consequence, buf);
            for (int i = 1; i < ptrarray_count(stmt->if_statement.cases); i++) {
                if_case_t *elif_case = ptrarray_get(stmt->if_statement.cases, i);
                strbuf_append(buf, " elif (");
                expression_to_string(elif_case->test, buf);
                strbuf_append(buf, ") ");
                code_block_to_string(elif_case->consequence, buf);
            }
            if (stmt->if_statement.alternative) {
                strbuf_append(buf, " else ");
                code_block_to_string(stmt->if_statement.alternative, buf);
            }
            break;
        }
        case STATEMENT_RETURN_VALUE: {
            strbuf_append(buf, "return ");
            if (stmt->return_value) {
                expression_to_string(stmt->return_value, buf);
            }
            break;
        }
        case STATEMENT_EXPRESSION: {
            if (stmt->expression) {
                expression_to_string(stmt->expression, buf);
            }
            break;
        }
        case STATEMENT_WHILE_LOOP: {
            strbuf_append(buf, "while (");
            expression_to_string(stmt->while_loop.test, buf);
            strbuf_append(buf, ")");
            code_block_to_string(stmt->while_loop.body, buf);
            break;
        }
        case STATEMENT_FOR_LOOP: {
            strbuf_append(buf, "for (");
            if (stmt->for_loop.init) {
                statement_to_string(stmt->for_loop.init, buf);
                strbuf_append(buf, " ");
            } else {
                strbuf_append(buf, ";");
            }
            if (stmt->for_loop.test) {
                expression_to_string(stmt->for_loop.test, buf);
                strbuf_append(buf, "; ");
            } else {
                strbuf_append(buf, ";");
            }
            if (stmt->for_loop.update) {
                expression_to_string(stmt->for_loop.test, buf);
            }
            strbuf_append(buf, ")");
            code_block_to_string(stmt->for_loop.body, buf);
            break;
        }
        case STATEMENT_FOREACH: {
            strbuf_append(buf, "for (");
            strbuf_appendf(buf, "%s", stmt->foreach.iterator.value);
            strbuf_append(buf, " in ");
            expression_to_string(stmt->foreach.source, buf);
            strbuf_append(buf, ")");
            code_block_to_string(stmt->foreach.body, buf);
            break;
        }
        case STATEMENT_BLOCK: {
            code_block_to_string(stmt->block, buf);
            break;
        }
        case STATEMENT_BREAK: {
            strbuf_append(buf, "break");
            break;
        }
        case STATEMENT_CONTINUE: {
            strbuf_append(buf, "continue");
            break;
        }
        case STATEMENT_IMPORT: {
            strbuf_appendf(buf, "import \"%s\"", stmt->import.path);
            break;
        }
        case STATEMENT_NONE: {
            strbuf_append(buf, "STATEMENT_NONE");
            break;
        }
        case STATEMENT_RECOVER: {
            strbuf_appendf(buf, "recover (%s)", stmt->recover.error_ident.value);
            code_block_to_string(stmt->recover.body, buf);
            break;
        }
    }
}

void expression_to_string(expression_t *expr, strbuf_t *buf) {
    switch (expr->type) {
        case EXPRESSION_IDENT: {
            strbuf_append(buf, expr->ident.value);
            break;
        }
        case EXPRESSION_NUMBER_LITERAL: {
            strbuf_appendf(buf, "%1.17g", expr->number_literal);
            break;
        }
        case EXPRESSION_BOOL_LITERAL: {
            strbuf_appendf(buf, "%s", expr->bool_literal ? "true" : "false");
            break;
        }
        case EXPRESSION_STRING_LITERAL: {
            strbuf_appendf(buf, "\"%s\"", expr->string_literal);
            break;
        }
        case EXPRESSION_NULL_LITERAL: {
            strbuf_append(buf, "null");
            break;
        }
        case EXPRESSION_ARRAY_LITERAL: {
            strbuf_append(buf, "[");
            for (int i = 0; i < ptrarray_count(expr->array); i++) {
                expression_t *arr_expr = ptrarray_get(expr->array, i);
                expression_to_string(arr_expr, buf);
                if (i < (ptrarray_count(expr->array) - 1)) {
                    strbuf_append(buf, ", ");
                }
            }
            strbuf_append(buf, "]");
            break;
        }
        case EXPRESSION_MAP_LITERAL: {
            map_literal_t *map = &expr->map;

            strbuf_append(buf, "{");
            for (int i = 0; i < ptrarray_count(map->keys); i++) {
                expression_t *key_expr = ptrarray_get(map->keys, i);
                expression_t *val_expr = ptrarray_get(map->values, i);

                expression_to_string(key_expr, buf);
                strbuf_append(buf, " : ");
                expression_to_string(val_expr, buf);

                if (i < (ptrarray_count(map->keys) - 1)) {
                    strbuf_append(buf, ", ");
                }
            }
            strbuf_append(buf, "}");
            break;
        }
        case EXPRESSION_PREFIX: {
            strbuf_append(buf, "(");
            strbuf_append(buf, operator_to_string(expr->infix.op));
            expression_to_string(expr->prefix.right, buf);
            strbuf_append(buf, ")");
            break;
        }
        case EXPRESSION_INFIX: {
            strbuf_append(buf, "(");
            expression_to_string(expr->infix.left, buf);
            strbuf_append(buf, " ");
            strbuf_append(buf, operator_to_string(expr->infix.op));
            strbuf_append(buf, " ");
            expression_to_string(expr->infix.right, buf);
            strbuf_append(buf, ")");
            break;
        }
        case EXPRESSION_FUNCTION_LITERAL: {
            fn_literal_t *fn = &expr->fn_literal;

            strbuf_append(buf, "fn");

            strbuf_append(buf, "(");
            for (int i = 0; i < array_count(fn->params); i++) {
                ident_t *param = array_get(fn->params, i);
                strbuf_append(buf, param->value);
                if (i < (array_count(fn->params) - 1)) {
                    strbuf_append(buf, ", ");
                }
            }
            strbuf_append(buf, ") ");

            code_block_to_string(fn->body, buf);

            break;
        }
        case EXPRESSION_CALL: {
            call_expression_t *call_expr = &expr->call_expr;

            expression_to_string(call_expr->function, buf);

            strbuf_append(buf, "(");
            for (int i = 0; i < ptrarray_count(call_expr->args); i++) {
                expression_t *arg = ptrarray_get(call_expr->args, i);
                expression_to_string(arg, buf);
                if (i < (ptrarray_count(call_expr->args) - 1)) {
                    strbuf_append(buf, ", ");
                }
            }
            strbuf_append(buf, ")");

            break;
        }
        case EXPRESSION_INDEX: {
            strbuf_append(buf, "(");
            expression_to_string(expr->index_expr.left, buf);
            strbuf_append(buf, "[");
            expression_to_string(expr->index_expr.index, buf);
            strbuf_append(buf, "])");
            break;
        }
        case EXPRESSION_ASSIGN: {
            expression_to_string(expr->assign.dest, buf);
            strbuf_append(buf, " = ");
            expression_to_string(expr->assign.source, buf);
            break;
        }
        case EXPRESSION_LOGICAL: {
            expression_to_string(expr->logical.left, buf);
            strbuf_append(buf, " ");
            strbuf_append(buf, operator_to_string(expr->infix.op));
            strbuf_append(buf, " ");
            expression_to_string(expr->logical.right, buf);
            break;
        }
        case EXPRESSION_NONE: {
            strbuf_append(buf, "EXPRESSION_NONE");
            break;
        }
    }
}

void code_block_to_string(const code_block_t *stmt, strbuf_t *buf) {
    strbuf_append(buf, "{ ");
    for (int i = 0; i < ptrarray_count(stmt->statements); i++) {
        statement_t *istmt = ptrarray_get(stmt->statements, i);
        statement_to_string(istmt, buf);
        strbuf_append(buf, "\n");
    }
    strbuf_append(buf, " }");
}

const char* operator_to_string(operator_t op) {
    switch (op) {
        case OPERATOR_NONE:        return "OPERATOR_NONE";
        case OPERATOR_ASSIGN:      return "=";
        case OPERATOR_PLUS:        return "+";
        case OPERATOR_MINUS:       return "-";
        case OPERATOR_BANG:        return "!";
        case OPERATOR_ASTERISK:    return "*";
        case OPERATOR_SLASH:       return "/";
        case OPERATOR_LT:          return "<";
        case OPERATOR_GT:          return ">";
        case OPERATOR_EQ:          return "==";
        case OPERATOR_NOT_EQ:      return "!=";
        case OPERATOR_MODULUS:     return "%";
        case OPERATOR_LOGICAL_AND: return "&&";
        case OPERATOR_LOGICAL_OR:  return "||";
        case OPERATOR_BIT_AND:     return "&";
        case OPERATOR_BIT_OR:      return "|";
        case OPERATOR_BIT_XOR:     return "^";
        case OPERATOR_LSHIFT:      return "<<";
        case OPERATOR_RSHIFT:      return ">>";
        default:                   return "OPERATOR_UNKNOWN";
    }
}

const char *expression_type_to_string(expression_type_t type) {
    switch (type) {
        case EXPRESSION_NONE:             return "NONE";
        case EXPRESSION_IDENT:            return "IDENT";
        case EXPRESSION_NUMBER_LITERAL:   return "INT_LITERAL";
        case EXPRESSION_BOOL_LITERAL:     return "BOOL_LITERAL";
        case EXPRESSION_STRING_LITERAL:   return "STRING_LITERAL";
        case EXPRESSION_ARRAY_LITERAL:    return "ARRAY_LITERAL";
        case EXPRESSION_MAP_LITERAL:      return "MAP_LITERAL";
        case EXPRESSION_PREFIX:           return "PREFIX";
        case EXPRESSION_INFIX:            return "INFIX";
        case EXPRESSION_FUNCTION_LITERAL: return "FN_LITERAL";
        case EXPRESSION_CALL:             return "CALL";
        case EXPRESSION_INDEX:            return "INDEX";
        case EXPRESSION_ASSIGN:           return "ASSIGN";
        case EXPRESSION_LOGICAL:          return "LOGICAL";
        default:                          return "UNKNOWN";
    }
}

void fn_literal_deinit(fn_literal_t *fn) {
    ape_free(fn->name, ape_freeArg);
    array_destroy_with_items(fn->params, ident_deinit);
    code_block_destroy(fn->body);
}

ident_t ident_make(token_t tok) {
    ident_t res;
    res.value = token_duplicate_literal(&tok);
    res.pos = tok.pos;
    return res;
}

ident_t ident_copy(ident_t ident) {
    ident_t res;
    res.value = ape_strdup(ident.value);
    res.pos = ident.pos;
    return res;
}

void ident_deinit(ident_t *ident) {
    ape_free(ident->value, ape_freeArg);
    ident->value = NULL;
    ident->pos = src_pos_invalid;
}

if_case_t *if_case_make(expression_t *test, code_block_t *consequence) {
    if_case_t *res = ape_malloc(sizeof(if_case_t), ape_mallocArg);
    res->test = test;
    res->consequence = consequence;
    return res;
}

void if_case_destroy(if_case_t *cond) {
    if (!cond) {
        return;
    }

    expression_destroy(cond->test);
    code_block_destroy(cond->consequence);
    ape_free(cond, ape_freeArg);
}

// INTERNAL
static expression_t *expression_make(expression_type_t type) {
    expression_t *res = ape_malloc(sizeof(expression_t), ape_mallocArg);
    res->type = type;
    res->pos = src_pos_invalid;
    return res;
}

static statement_t* statement_make(statement_type_t type) {
    statement_t *res = ape_malloc(sizeof(statement_t), ape_mallocArg);
    res->type = type;
    res->pos = src_pos_invalid;
    return res;
}
//FILE_END
//FILE_START:parser.c
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>
#include <errno.h>

#ifndef APE_AMALGAMATED
#include "parser.h"
#include "error.h"
#endif

typedef enum precedence {
    PRECEDENCE_LOWEST = 0,
    PRECEDENCE_ASSIGN,      // a = b
    PRECEDENCE_LOGICAL_OR,  // ||
    PRECEDENCE_LOGICAL_AND, // &&
    PRECEDENCE_BIT_OR,      // |
    PRECEDENCE_BIT_XOR,     // ^
    PRECEDENCE_BIT_AND,     // &
    PRECEDENCE_EQUALS,      // == !=
    PRECEDENCE_LESSGREATER, // >, >=, <, <=
    PRECEDENCE_SHIFT,       // << >>
    PRECEDENCE_SUM,         // + -
    PRECEDENCE_PRODUCT,     // * / %
    PRECEDENCE_PREFIX,      // -X or !X
    PRECEDENCE_CALL,        // myFunction(X)
    PRECEDENCE_INDEX,       // arr[x]
    PRECEDENCE_DOT,         // obj.foo
} precedence_t;

static void next_token(parser_t *parser);
static statement_t* parse_statement(parser_t *p);
static statement_t* parse_define_statement(parser_t *p);
static statement_t* parse_if_statement(parser_t *p);
static statement_t* parse_return_statement(parser_t *p);
static statement_t* parse_expression_statement(parser_t *p);
static statement_t* parse_while_loop_statement(parser_t *p);
static statement_t* parse_break_statement(parser_t *p);
static statement_t* parse_continue_statement(parser_t *p);
static statement_t* parse_for_loop_statement(parser_t *p);
static statement_t* parse_foreach(parser_t *p);
static statement_t* parse_classic_for_loop(parser_t *p);
static statement_t* parse_function_statement(parser_t *p);
static statement_t* parse_block_statement(parser_t *p);
static statement_t* parse_import_statement(parser_t *p);
static statement_t* parse_recover_statement(parser_t *p);

static code_block_t* parse_code_block(parser_t *p);

static expression_t* parse_expression(parser_t *p, precedence_t prec);
static expression_t* parse_identifier(parser_t *p);
static expression_t* parse_number_literal(parser_t *p);
static expression_t* parse_bool_literal(parser_t *p);
static expression_t* parse_string_literal(parser_t *p);
static expression_t* parse_null_literal(parser_t *p);
static expression_t* parse_array_literal(parser_t *p);
static expression_t* parse_map_literal(parser_t *p);
static expression_t* parse_prefix_expression(parser_t *p);
static expression_t* parse_infix_expression(parser_t *p, expression_t *left);
static expression_t* parse_grouped_expression(parser_t *p);
static expression_t* parse_function_literal(parser_t *p);
static bool parse_function_parameters(parser_t *p, array(ident_t) *out_params);
static expression_t* parse_call_expression(parser_t *p, expression_t *left);
static ptrarray(expression_t)* parse_expression_list(parser_t *p, token_type_t start_token, token_type_t end_token, bool trailing_comma_allowed);
static expression_t* parse_index_expression(parser_t *p, expression_t *left);
static expression_t* parse_dot_expression(parser_t *p, expression_t *left);
static expression_t* parse_assign_expression(parser_t *p, expression_t *left);
static expression_t* parse_logical_expression(parser_t *p, expression_t *left);

static precedence_t get_precedence(token_type_t tk);
static operator_t token_to_operator(token_type_t tk);

static bool cur_token_is(parser_t *p, token_type_t type);
static bool peek_token_is(parser_t *p, token_type_t type);
static bool expect_current(parser_t *p, token_type_t type);

static char escape_char(const char c);
static char* process_and_copy_string(const char *input, size_t len);

parser_t* parser_make(const ape_config_t *config, ptrarray(error_t) *errors) {
    parser_t *parser = ape_malloc(sizeof(parser_t), ape_mallocArg);
    memset(parser, 0, sizeof(parser_t));
    APE_ASSERT(config);

    parser->config = config;
    parser->errors = errors;

    parser->prefix_parse_fns[TOKEN_IDENT] = parse_identifier;
    parser->prefix_parse_fns[TOKEN_NUMBER] = parse_number_literal;
    parser->prefix_parse_fns[TOKEN_TRUE] = parse_bool_literal;
    parser->prefix_parse_fns[TOKEN_FALSE] = parse_bool_literal;
    parser->prefix_parse_fns[TOKEN_STRING] = parse_string_literal;
    parser->prefix_parse_fns[TOKEN_NULL] = parse_null_literal;
    parser->prefix_parse_fns[TOKEN_BANG] = parse_prefix_expression;
    parser->prefix_parse_fns[TOKEN_MINUS] = parse_prefix_expression;
    parser->prefix_parse_fns[TOKEN_LPAREN] = parse_grouped_expression;
    parser->prefix_parse_fns[TOKEN_FUNCTION] = parse_function_literal;
    parser->prefix_parse_fns[TOKEN_LBRACKET] = parse_array_literal;
    parser->prefix_parse_fns[TOKEN_LBRACE] = parse_map_literal;

    parser->infix_parse_fns[TOKEN_PLUS] = parse_infix_expression;
    parser->infix_parse_fns[TOKEN_MINUS] = parse_infix_expression;
    parser->infix_parse_fns[TOKEN_SLASH] = parse_infix_expression;
    parser->infix_parse_fns[TOKEN_ASTERISK] = parse_infix_expression;
    parser->infix_parse_fns[TOKEN_PERCENT] = parse_infix_expression;
    parser->infix_parse_fns[TOKEN_EQ] = parse_infix_expression;
    parser->infix_parse_fns[TOKEN_NOT_EQ] = parse_infix_expression;
    parser->infix_parse_fns[TOKEN_LT] = parse_infix_expression;
    parser->infix_parse_fns[TOKEN_LTE] = parse_infix_expression;
    parser->infix_parse_fns[TOKEN_GT] = parse_infix_expression;
    parser->infix_parse_fns[TOKEN_GTE] = parse_infix_expression;
    parser->infix_parse_fns[TOKEN_LPAREN] = parse_call_expression;
    parser->infix_parse_fns[TOKEN_LBRACKET] = parse_index_expression;
    parser->infix_parse_fns[TOKEN_ASSIGN] = parse_assign_expression;
    parser->infix_parse_fns[TOKEN_PLUS_ASSIGN] = parse_assign_expression;
    parser->infix_parse_fns[TOKEN_MINUS_ASSIGN] = parse_assign_expression;
    parser->infix_parse_fns[TOKEN_SLASH_ASSIGN] = parse_assign_expression;
    parser->infix_parse_fns[TOKEN_ASTERISK_ASSIGN] = parse_assign_expression;
    parser->infix_parse_fns[TOKEN_PERCENT_ASSIGN] = parse_assign_expression;
    parser->infix_parse_fns[TOKEN_BIT_AND_ASSIGN] = parse_assign_expression;
    parser->infix_parse_fns[TOKEN_BIT_OR_ASSIGN] = parse_assign_expression;
    parser->infix_parse_fns[TOKEN_BIT_XOR_ASSIGN] = parse_assign_expression;
    parser->infix_parse_fns[TOKEN_LSHIFT_ASSIGN] = parse_assign_expression;
    parser->infix_parse_fns[TOKEN_RSHIFT_ASSIGN] = parse_assign_expression;
    parser->infix_parse_fns[TOKEN_DOT] = parse_dot_expression;
    parser->infix_parse_fns[TOKEN_AND] = parse_logical_expression;
    parser->infix_parse_fns[TOKEN_OR] = parse_logical_expression;
    parser->infix_parse_fns[TOKEN_BIT_AND] = parse_infix_expression;
    parser->infix_parse_fns[TOKEN_BIT_OR] = parse_infix_expression;
    parser->infix_parse_fns[TOKEN_BIT_XOR] = parse_infix_expression;
    parser->infix_parse_fns[TOKEN_LSHIFT] = parse_infix_expression;
    parser->infix_parse_fns[TOKEN_RSHIFT] = parse_infix_expression;

    parser->depth = 0;

    return parser;
}

void parser_destroy(parser_t *parser) {
    if (!parser) {
        return;
    }
    memset(parser, 0, sizeof(parser_t));
    ape_free(parser, ape_freeArg);
}

ptrarray(statement_t)* parser_parse_all(parser_t *parser,  const char *input, compiled_file_t *file) {
    parser->depth = 0;

    lexer_init(&parser->lexer, input, file);

    next_token(parser);
    next_token(parser);

    ptrarray(statement_t)* statements = ptrarray_make();

    while (!cur_token_is(parser, TOKEN_EOF)) {
        if (cur_token_is(parser, TOKEN_SEMICOLON)) {
            next_token(parser);
            continue;
        }
        statement_t *stmt = parse_statement(parser);
        if (stmt) {
            ptrarray_add(statements, stmt);
        } else {
            goto err;
        }
    }

    if (ptrarray_count(parser->errors) > 0) {
        goto err;
    }

    return statements;
err:
    ptrarray_destroy_with_items(statements, statement_destroy);
    return NULL;
}

// INTERNAL
static void next_token(parser_t *p) {
    p->cur_token = p->peek_token;
    p->peek_token = lexer_next_token(&p->lexer);
}

static statement_t* parse_statement(parser_t *p) {
    src_pos_t pos = p->cur_token.pos;

    statement_t *res = NULL;
    switch (p->cur_token.type) {
        case TOKEN_VAR:
        case TOKEN_CONST: {
            res = parse_define_statement(p);
            break;
        }
        case TOKEN_IF: {
            res = parse_if_statement(p);
            break;
        }
        case TOKEN_RETURN: {
            res = parse_return_statement(p);
            break;
        }
        case TOKEN_WHILE: {
            res = parse_while_loop_statement(p);
            break;
        }
        case TOKEN_BREAK: {
            res = parse_break_statement(p);
            break;
        }
        case TOKEN_FOR: {
            res = parse_for_loop_statement(p);
            break;
        }
        case TOKEN_FUNCTION: {
            if (peek_token_is(p, TOKEN_IDENT)) {
                res = parse_function_statement(p);
            } else {
                res = parse_expression_statement(p);
            }
            break;
        }
        case TOKEN_LBRACE: {
            if (p->config->repl_mode && p->depth == 0) {
                res = parse_expression_statement(p);
            } else {
                res = parse_block_statement(p);
            }
            break;
        }
        case TOKEN_CONTINUE: {
            res = parse_continue_statement(p);
            break;
        }
        case TOKEN_IMPORT: {
            res = parse_import_statement(p);
            break;
        }
        case TOKEN_RECOVER: {
            res = parse_recover_statement(p);
            break;
        }
        default: {
            res = parse_expression_statement(p);
            break;
        }
    }
    if (res) {
        res->pos = pos;
    }
    return res;
}

static statement_t* parse_define_statement(parser_t *p) {
    ident_t name_ident;
    expression_t *value = NULL;

    bool assignable = cur_token_is(p, TOKEN_VAR);

    next_token(p);

    if (!expect_current(p, TOKEN_IDENT)) {
        goto err;
    }

    name_ident = ident_make(p->cur_token);

    next_token(p);

    if (!expect_current(p, TOKEN_ASSIGN)) {
        goto err;
    }

    next_token(p);

    value = parse_expression(p, PRECEDENCE_LOWEST);
    if (!value) {
        goto err;
    }

    if (value->type == EXPRESSION_FUNCTION_LITERAL) {
        value->fn_literal.name = ape_strdup(name_ident.value);
    }

    return statement_make_define(name_ident, value, assignable);
err:
    expression_destroy(value);
    ident_deinit(&name_ident);
    return NULL;
}

static statement_t* parse_if_statement(parser_t *p) {
    ptrarray(if_case_t) *cases = ptrarray_make();
    code_block_t *alternative = NULL;

    next_token(p);

    if (!expect_current(p, TOKEN_LPAREN)) {
        goto err;
    }

    next_token(p);

    if_case_t *cond = if_case_make(NULL, NULL);
    ptrarray_add(cases, cond);

    cond->test = parse_expression(p, PRECEDENCE_LOWEST);
    if (!cond->test) {
        goto err;
    }

    if (!expect_current(p, TOKEN_RPAREN)) {
        goto err;
    }

    next_token(p);

    cond->consequence = parse_code_block(p);
    if (!cond->consequence) {
        goto err;
    }

    while (cur_token_is(p, TOKEN_ELSE)) {
        next_token(p);

        if (cur_token_is(p, TOKEN_IF)) {
            next_token(p);

            if (!expect_current(p, TOKEN_LPAREN)) {
                goto err;
            }

            next_token(p);

            if_case_t *elif = if_case_make(NULL, NULL);
            ptrarray_add(cases, elif);

            elif->test = parse_expression(p, PRECEDENCE_LOWEST);
            if (!cond->test) {
                goto err;
            }

            if (!expect_current(p, TOKEN_RPAREN)) {
                goto err;
            }

            next_token(p);

            elif->consequence = parse_code_block(p);
            if (!cond->consequence) {
                goto err;
            }
        } else {
            alternative = parse_code_block(p);
            if (!alternative) {
                goto err;
            }
        }
    }

    return statement_make_if(cases, alternative);
err:
    ptrarray_destroy_with_items(cases, if_case_destroy);
    code_block_destroy(alternative);
    return NULL;
}

static statement_t* parse_return_statement(parser_t *p) {
    expression_t *expr = NULL;

    next_token(p);

    if (!cur_token_is(p, TOKEN_SEMICOLON) && !cur_token_is(p, TOKEN_RBRACE) && !cur_token_is(p, TOKEN_EOF)) {
        expr = parse_expression(p, PRECEDENCE_LOWEST);
        if (!expr) {
            return NULL;
        }
    }

    return statement_make_return(expr);
}

static statement_t* parse_expression_statement(parser_t *p) {
    expression_t *expr = parse_expression(p, PRECEDENCE_LOWEST);
    if (!expr) {
        return NULL;
    }

    if (expr && (!p->config->repl_mode || p->depth > 0)) {
        if (expr->type != EXPRESSION_ASSIGN && expr->type != EXPRESSION_CALL) {
            error_t *err = error_makef(ERROR_PARSING, expr->pos,
                                       "Only assignments and function calls can be expression statements");
            ptrarray_add(p->errors, err);
            expression_destroy(expr);
            return NULL;
        }
    }

    return statement_make_expression(expr);
}

static statement_t* parse_while_loop_statement(parser_t *p) {
    expression_t *test = NULL;

    next_token(p);

    if (!expect_current(p, TOKEN_LPAREN)) {
        goto err;
    }

    next_token(p);

    test = parse_expression(p, PRECEDENCE_LOWEST);
    if (!test) {
        goto err;
    }

    if (!expect_current(p, TOKEN_RPAREN)) {
        goto err;
    }

    next_token(p);

    code_block_t *body = parse_code_block(p);
    if (!body) {
        goto err;
    }

    return statement_make_while_loop(test, body);
err:
    expression_destroy(test);
    return NULL;
}

static statement_t* parse_break_statement(parser_t *p) {
    next_token(p);
    return statement_make_break();
}

static statement_t* parse_continue_statement(parser_t *p) {
    next_token(p);
    return statement_make_continue();
}

static statement_t* parse_block_statement(parser_t *p) {
    code_block_t *block = parse_code_block(p);
    if (!block) {
        return NULL;
    }
    return statement_make_block(block);
}

static statement_t* parse_import_statement(parser_t *p) {
    next_token(p);

    if (!expect_current(p, TOKEN_STRING)) {
        return NULL;
    }

    char *processed_name = process_and_copy_string(p->cur_token.literal, p->cur_token.len);
    if (!processed_name) {
        error_t *err = error_make(ERROR_PARSING, p->cur_token.pos, "Error when parsing module name");
        ptrarray_add(p->errors, err);
        return NULL;
    }
    next_token(p);
    statement_t *result = statement_make_import(processed_name);
    return result;
}

static statement_t* parse_recover_statement(parser_t *p) {
    next_token(p);

    if (!expect_current(p, TOKEN_LPAREN)) {
        return NULL;
    }
    next_token(p);


    if (!expect_current(p, TOKEN_IDENT)) {
        return NULL;
    }

    ident_t error_ident = ident_make(p->cur_token);
    next_token(p);

    if (!expect_current(p, TOKEN_RPAREN)) {
        goto err;
    }
    next_token(p);

    code_block_t *body = parse_code_block(p);
    if (!body) {
        goto err;
    }

    return statement_make_recover(error_ident, body);
err:
    ident_deinit(&error_ident);
    return NULL;

}

static statement_t* parse_for_loop_statement(parser_t *p) {
    next_token(p);

    if (!expect_current(p, TOKEN_LPAREN)) {
        return NULL;
    }

    next_token(p);

    if (cur_token_is(p, TOKEN_IDENT) && peek_token_is(p, TOKEN_IN)) {
        return parse_foreach(p);
    } else {
        return parse_classic_for_loop(p);
    }
}

static statement_t* parse_foreach(parser_t *p) {
    expression_t *source = NULL;
    ident_t iterator_ident = ident_make(p->cur_token);

    next_token(p);

    if (!expect_current(p, TOKEN_IN)) {
        goto err;
    }

    next_token(p);

    source = parse_expression(p, PRECEDENCE_LOWEST);
    if (!source) {
        goto err;
    }

    if (!expect_current(p, TOKEN_RPAREN)) {
        goto err;
    }

    next_token(p);

    code_block_t *body = parse_code_block(p);
    if (!body) {
        goto err;
    }

    return statement_make_foreach(iterator_ident, source, body);
err:
    ident_deinit(&iterator_ident);
    expression_destroy(source);
    return NULL;
}

static statement_t* parse_classic_for_loop(parser_t *p) {
    statement_t *init = NULL;
    expression_t *test = NULL;
    expression_t *update = NULL;
    code_block_t *body = NULL;

    if (!cur_token_is(p, TOKEN_SEMICOLON)) {
        init = parse_statement(p);
        if (!init) {
            goto err;
        }
        if (init->type != STATEMENT_DEFINE && init->type != STATEMENT_EXPRESSION) {
            error_t *err = error_makef(ERROR_PARSING, init->pos,
                                       "for loop's init clause should be a define statement or an expression");
            ptrarray_add(p->errors, err);
            goto err;
        }
        if (!expect_current(p, TOKEN_SEMICOLON)) {
            goto err;
        }
    }

    next_token(p);

    if (!cur_token_is(p, TOKEN_SEMICOLON)) {
        test = parse_expression(p, PRECEDENCE_LOWEST);
        if (!test) {
            goto err;
        }
        if (!expect_current(p, TOKEN_SEMICOLON)) {
            goto err;
        }
    }

    next_token(p);

    if (!cur_token_is(p, TOKEN_RPAREN)) {
        update = parse_expression(p, PRECEDENCE_LOWEST);
        if (!update) {
            goto err;
        }
        if (!expect_current(p, TOKEN_RPAREN)) {
            goto err;
        }
    }

    next_token(p);

    body = parse_code_block(p);
    if (!body) {
        goto err;
    }

    return statement_make_for_loop(init, test, update, body);
err:
    statement_destroy(init);
    expression_destroy(test);
    expression_destroy(update);
    code_block_destroy(body);
    return NULL;
}

static statement_t* parse_function_statement(parser_t *p) {
    ident_t name_ident;

    expression_t* value = NULL;

    src_pos_t pos = p->cur_token.pos;

    next_token(p);

    if (!expect_current(p, TOKEN_IDENT)) {
        goto err;
    }

    name_ident = ident_make(p->cur_token);

    next_token(p);

    value = parse_function_literal(p);
    if (!value) {
        goto err;
    }

    value->pos = pos;
    value->fn_literal.name = ape_strdup(name_ident.value);

    return statement_make_define(name_ident, value, false);
err:
    expression_destroy(value);
    ident_deinit(&name_ident);
    return NULL;
}

static code_block_t* parse_code_block(parser_t *p) {
    if (!expect_current(p, TOKEN_LBRACE)) {
        return NULL;
    }

    next_token(p);
    p->depth++;

    ptrarray(statement_t)* statements = ptrarray_make();

    while (!cur_token_is(p, TOKEN_RBRACE)) {
        if (cur_token_is(p, TOKEN_EOF)) {
            error_t *err = error_make(ERROR_PARSING, p->cur_token.pos, "Unexpected EOF");
            ptrarray_add(p->errors, err);
            goto err;
        }
        if (cur_token_is(p, TOKEN_SEMICOLON)) {
            next_token(p);
            continue;
        }
        statement_t *stmt = parse_statement(p);
        if (stmt) {
            ptrarray_add(statements, stmt);
        } else {
            goto err;
        }
    }

    next_token(p);

    p->depth--;

    return code_block_make(statements);

err:
    p->depth--;
    ptrarray_destroy_with_items(statements, statement_destroy);
    return NULL;
}

static expression_t* parse_expression(parser_t *p, precedence_t prec) {
    src_pos_t pos = p->cur_token.pos;

    if (p->cur_token.type == TOKEN_ILLEGAL) {
        error_t *err = error_make(ERROR_PARSING, p->cur_token.pos, "Illegal token");
        ptrarray_add(p->errors, err);
        return NULL;
    }

    prefix_parse_fn prefix = p->prefix_parse_fns[p->cur_token.type];
    if (!prefix) {
        char *literal = token_duplicate_literal(&p->cur_token);
        error_t *err = error_makef(ERROR_PARSING, p->cur_token.pos,
                                  "No prefix parse function for \"%s\" found", literal);
        ptrarray_add(p->errors, err);
        ape_free(literal, ape_freeArg);
        return NULL;
    }

    expression_t *left_expr = prefix(p);
    if (!left_expr) {
        return NULL;
    }
    left_expr->pos = pos;

    while (!cur_token_is(p, TOKEN_SEMICOLON) && prec < get_precedence(p->cur_token.type)) {
        infix_parse_fn infix = p->infix_parse_fns[p->cur_token.type];
        if (!infix) {
            return left_expr;
        }
        pos = p->cur_token.pos;
        expression_t *new_left_expr = infix(p, left_expr);
        if (!new_left_expr) {
            expression_destroy(left_expr);
            return NULL;
        }
        new_left_expr->pos = pos;
        left_expr = new_left_expr;
    }

    return left_expr;
}

static expression_t* parse_identifier(parser_t *p) {
    ident_t ident = ident_make(p->cur_token);
    expression_t *res = expression_make_ident(ident);
    next_token(p);
    return res;
}

static expression_t* parse_number_literal(parser_t *p) {
    char *end;
    double number = 0;
    errno = 0;
    number = strtod(p->cur_token.literal, &end);
    long parsed_len = end - p->cur_token.literal;
    if (errno || parsed_len != p->cur_token.len) {
        char *literal = token_duplicate_literal(&p->cur_token);
        error_t *err = error_makef(ERROR_PARSING, p->cur_token.pos,
                                  "Parsing number literal \"%s\" failed", literal);
        ptrarray_add(p->errors, err);
        ape_free(literal, ape_freeArg);
        return NULL;
    }
    next_token(p);
    return expression_make_number_literal(number);
}

static expression_t* parse_bool_literal(parser_t *p) {
    expression_t *res = expression_make_bool_literal(p->cur_token.type == TOKEN_TRUE);
    next_token(p);
    return res;
}

static expression_t* parse_string_literal(parser_t *p) {
    char *processed_literal = process_and_copy_string(p->cur_token.literal, p->cur_token.len);
    if (!processed_literal) {
        error_t *err = error_make(ERROR_PARSING, p->cur_token.pos, "Error when parsing string literal");
        ptrarray_add(p->errors, err);
        return NULL;
    }
    next_token(p);
    return expression_make_string_literal(processed_literal);
}

static expression_t* parse_null_literal(parser_t *p) {
    next_token(p);
    return expression_make_null_literal();
}

static expression_t* parse_array_literal(parser_t *p) {
    ptrarray(expression_t) *array = parse_expression_list(p, TOKEN_LBRACKET, TOKEN_RBRACKET, true);
    if (!array) {
        return NULL;
    }
    return expression_make_array_literal(array);
}

static expression_t* parse_map_literal(parser_t *p) {
    ptrarray(expression_t) *keys = ptrarray_make();
    ptrarray(expression_t) *values = ptrarray_make();

    next_token(p);

    while (!cur_token_is(p, TOKEN_RBRACE)) {
        expression_t *key = NULL;
        if (cur_token_is(p, TOKEN_IDENT)) {
            key = expression_make_string_literal(token_duplicate_literal(&p->cur_token));
            key->pos = p->cur_token.pos;
            next_token(p);
        } else {
            key = parse_expression(p, PRECEDENCE_LOWEST);
            if (!key) {
                goto err;
            }
            switch (key->type) {
                case EXPRESSION_STRING_LITERAL:
                case EXPRESSION_NUMBER_LITERAL:
                case EXPRESSION_BOOL_LITERAL: {
                    break;
                }
                default: {
                    error_t *err = error_makef(ERROR_PARSING, key->pos, "Invalid map literal key type");
                    ptrarray_add(p->errors, err);
                    expression_destroy(key);
                    goto err;
                }
            }
        }

        if (!key) {
            goto err;
        }

        ptrarray_add(keys, key);

        if (!expect_current(p, TOKEN_COLON)) {
            goto err;
        }

        next_token(p);

        expression_t *value = parse_expression(p, PRECEDENCE_LOWEST);
        if (!value) {
            goto err;
        }
        ptrarray_add(values, value);

        if (cur_token_is(p, TOKEN_RBRACE)) {
            break;
        }

        if (!expect_current(p, TOKEN_COMMA)) {
            goto err;
        }

        next_token(p);
    }

    next_token(p);

    return expression_make_map_literal(keys, values);
err:
    ptrarray_destroy_with_items(keys, expression_destroy);
    ptrarray_destroy_with_items(values, expression_destroy);
    return NULL;
}

static expression_t* parse_prefix_expression(parser_t *p) {
    operator_t op = token_to_operator(p->cur_token.type);
    next_token(p);
    expression_t *right = parse_expression(p, PRECEDENCE_PREFIX);
    if (!right) {
        return NULL;
    }
    return expression_make_prefix(op, right);
}

static expression_t* parse_infix_expression(parser_t *p, expression_t *left) {
    operator_t op = token_to_operator(p->cur_token.type);
    precedence_t prec = get_precedence(p->cur_token.type);
    next_token(p);
    expression_t *right = parse_expression(p, prec);
    if (!right) {
        return NULL;
    }
    return expression_make_infix(op, left, right);
}

static expression_t* parse_grouped_expression(parser_t *p) {
    next_token(p);
    expression_t *expr = parse_expression(p, PRECEDENCE_LOWEST);
    if (!expr || !expect_current(p, TOKEN_RPAREN)) {
        expression_destroy(expr);
        return NULL;
    }
    next_token(p);
    return expr;
}

static expression_t* parse_function_literal(parser_t *p) {
    p->depth += 1;
    array(ident) *params = NULL;
    code_block_t *body = NULL;

    if (cur_token_is(p, TOKEN_FUNCTION)) {
        next_token(p);
    }

    params = array_make(ident_t);

    bool ok = parse_function_parameters(p, params);

    if (!ok) {
        goto err;
    }

    body = parse_code_block(p);
    if (!body) {
        goto err;
    }

    p->depth -= 1;

    return expression_make_fn_literal(params, body);
err:
    array_destroy_with_items(params, ident_deinit);
    p->depth -= 1;
    return NULL;
}

static bool parse_function_parameters(parser_t *p, array(ident_t) *out_params) {
    if (!expect_current(p, TOKEN_LPAREN)) {
        return false;
    }

    next_token(p);

    if (cur_token_is(p, TOKEN_RPAREN)) {
        next_token(p);
        return true;
    }

    if (!expect_current(p, TOKEN_IDENT)) {
        return false;
    }

    ident_t ident = ident_make(p->cur_token);
    array_add(out_params, &ident);

    next_token(p);

    while (cur_token_is(p, TOKEN_COMMA)) {
        next_token(p);

        if (!expect_current(p, TOKEN_IDENT)) {
            return false;
        }

        ident_t ident = ident_make(p->cur_token);
        array_add(out_params, &ident);

        next_token(p);
    }

    if (!expect_current(p, TOKEN_RPAREN)) {
        return false;
    }

    next_token(p);

    return true;
}

static expression_t* parse_call_expression(parser_t *p, expression_t *left) {
    expression_t *function = left;
    ptrarray(expression_t) *args = parse_expression_list(p, TOKEN_LPAREN, TOKEN_RPAREN, false);
    if (!args) {
        return NULL;
    }
    return expression_make_call(function, args);
}

static ptrarray(expression_t)* parse_expression_list(parser_t *p, token_type_t start_token, token_type_t end_token, bool trailing_comma_allowed) {
    if (!expect_current(p, start_token)) {
        return NULL;
    }

    next_token(p);

    ptrarray(expression_t)* res = ptrarray_make();

    if (cur_token_is(p, end_token)) {
        next_token(p);
        return res;
    }

    expression_t *arg_expr = parse_expression(p, PRECEDENCE_LOWEST);
    if (!arg_expr) {
        goto err;
    }
    ptrarray_add(res, arg_expr);

    while (cur_token_is(p, TOKEN_COMMA)) {
        next_token(p);

        if (cur_token_is(p, end_token)) {
            break;
        }
        arg_expr = parse_expression(p, PRECEDENCE_LOWEST);
        if (!arg_expr) {
            goto err;
        }
        ptrarray_add(res, arg_expr);
    }

    if (!expect_current(p, end_token)) {
        goto err;
    }

    next_token(p);

    return res;
err:
    ptrarray_destroy_with_items(res, expression_destroy);
    return NULL;
}

static expression_t* parse_index_expression(parser_t *p, expression_t *left) {
    next_token(p);

    expression_t *index = parse_expression(p, PRECEDENCE_LOWEST);
    if (!index) {
        return NULL;
    }

    if (!expect_current(p, TOKEN_RBRACKET)) {
        expression_destroy(index);
        return NULL;
    }

    next_token(p);

    return expression_make_index(left, index);
}

static expression_t* parse_assign_expression(parser_t *p, expression_t *left) {
    expression_t *source = NULL;
    expression_t *left_copy = NULL;
    token_type_t assign_type = p->cur_token.type;

    next_token(p);

    source = parse_expression(p, PRECEDENCE_LOWEST);
    if (!source) {
        goto err;
    }

    switch (assign_type) {
        case TOKEN_PLUS_ASSIGN:
        case TOKEN_MINUS_ASSIGN:
        case TOKEN_SLASH_ASSIGN:
        case TOKEN_ASTERISK_ASSIGN:
        case TOKEN_PERCENT_ASSIGN:
        case TOKEN_BIT_AND_ASSIGN:
        case TOKEN_BIT_OR_ASSIGN:
        case TOKEN_BIT_XOR_ASSIGN:
        case TOKEN_LSHIFT_ASSIGN:
        case TOKEN_RSHIFT_ASSIGN:
        {
            operator_t op = token_to_operator(assign_type);
            expression_t *left_copy = expression_copy(left);
            if (!left_copy) {
                goto err;
            }
            src_pos_t pos = source->pos;
            expression_t *new_source = expression_make_infix(op, left_copy, source);
            if (!new_source) {
                goto err;
            }
            new_source->pos = pos;
            source = new_source;
            break;
        }
        case TOKEN_ASSIGN: break;
        default: APE_ASSERT(false); break;
    }

    return expression_make_assign(left, source);
err:
    expression_destroy(left_copy);
    expression_destroy(source);
    return NULL;
}

static expression_t* parse_logical_expression(parser_t *p, expression_t *left) {
    operator_t op = token_to_operator(p->cur_token.type);
    precedence_t prec = get_precedence(p->cur_token.type);
    next_token(p);
    expression_t *right = parse_expression(p, prec);
    if (!right) {
        return NULL;
    }
    return expression_make_logical(op, left, right);
}

static expression_t* parse_dot_expression(parser_t *p, expression_t *left) {
    next_token(p);

    if (!expect_current(p, TOKEN_IDENT)) {
        return NULL;
    }

    expression_t *index = expression_make_string_literal(token_duplicate_literal(&p->cur_token));
    if (!index) {
        return NULL;
    }
    index->pos = p->cur_token.pos;

    next_token(p);

    return expression_make_index(left, index);
}

static precedence_t get_precedence(token_type_t tk) {
    switch (tk) {
        case TOKEN_EQ:              return PRECEDENCE_EQUALS;
        case TOKEN_NOT_EQ:          return PRECEDENCE_EQUALS;
        case TOKEN_LT:              return PRECEDENCE_LESSGREATER;
        case TOKEN_LTE:             return PRECEDENCE_LESSGREATER;
        case TOKEN_GT:              return PRECEDENCE_LESSGREATER;
        case TOKEN_GTE:             return PRECEDENCE_LESSGREATER;
        case TOKEN_PLUS:            return PRECEDENCE_SUM;
        case TOKEN_MINUS:           return PRECEDENCE_SUM;
        case TOKEN_SLASH:           return PRECEDENCE_PRODUCT;
        case TOKEN_ASTERISK:        return PRECEDENCE_PRODUCT;
        case TOKEN_PERCENT:         return PRECEDENCE_PRODUCT;
        case TOKEN_LPAREN:          return PRECEDENCE_CALL;
        case TOKEN_LBRACKET:        return PRECEDENCE_INDEX;
        case TOKEN_ASSIGN:          return PRECEDENCE_ASSIGN;
        case TOKEN_PLUS_ASSIGN:     return PRECEDENCE_ASSIGN;
        case TOKEN_MINUS_ASSIGN:    return PRECEDENCE_ASSIGN;
        case TOKEN_ASTERISK_ASSIGN: return PRECEDENCE_ASSIGN;
        case TOKEN_SLASH_ASSIGN:    return PRECEDENCE_ASSIGN;
        case TOKEN_PERCENT_ASSIGN:  return PRECEDENCE_ASSIGN;
        case TOKEN_BIT_AND_ASSIGN:  return PRECEDENCE_ASSIGN;
        case TOKEN_BIT_OR_ASSIGN:   return PRECEDENCE_ASSIGN;
        case TOKEN_BIT_XOR_ASSIGN:  return PRECEDENCE_ASSIGN;
        case TOKEN_LSHIFT_ASSIGN:   return PRECEDENCE_ASSIGN;
        case TOKEN_RSHIFT_ASSIGN:   return PRECEDENCE_ASSIGN;
        case TOKEN_DOT:             return PRECEDENCE_DOT;
        case TOKEN_AND:             return PRECEDENCE_LOGICAL_AND;
        case TOKEN_OR:              return PRECEDENCE_LOGICAL_OR;
        case TOKEN_BIT_OR:          return PRECEDENCE_BIT_OR;
        case TOKEN_BIT_XOR:         return PRECEDENCE_BIT_XOR;
        case TOKEN_BIT_AND:         return PRECEDENCE_BIT_AND;
        case TOKEN_LSHIFT:          return PRECEDENCE_SHIFT;
        case TOKEN_RSHIFT:          return PRECEDENCE_SHIFT;
        default:                    return PRECEDENCE_LOWEST;
    }
}

static operator_t token_to_operator(token_type_t tk) {
    switch (tk) {
        case TOKEN_ASSIGN:          return OPERATOR_ASSIGN;
        case TOKEN_PLUS:            return OPERATOR_PLUS;
        case TOKEN_MINUS:           return OPERATOR_MINUS;
        case TOKEN_BANG:            return OPERATOR_BANG;
        case TOKEN_ASTERISK:        return OPERATOR_ASTERISK;
        case TOKEN_SLASH:           return OPERATOR_SLASH;
        case TOKEN_LT:              return OPERATOR_LT;
        case TOKEN_LTE:             return OPERATOR_LTE;
        case TOKEN_GT:              return OPERATOR_GT;
        case TOKEN_GTE:             return OPERATOR_GTE;
        case TOKEN_EQ:              return OPERATOR_EQ;
        case TOKEN_NOT_EQ:          return OPERATOR_NOT_EQ;
        case TOKEN_PERCENT:         return OPERATOR_MODULUS;
        case TOKEN_AND:             return OPERATOR_LOGICAL_AND;
        case TOKEN_OR:              return OPERATOR_LOGICAL_OR;
        case TOKEN_PLUS_ASSIGN:     return OPERATOR_PLUS;
        case TOKEN_MINUS_ASSIGN:    return OPERATOR_MINUS;
        case TOKEN_ASTERISK_ASSIGN: return OPERATOR_ASTERISK;
        case TOKEN_SLASH_ASSIGN:    return OPERATOR_SLASH;
        case TOKEN_PERCENT_ASSIGN:  return OPERATOR_MODULUS;
        case TOKEN_BIT_AND_ASSIGN:  return OPERATOR_BIT_AND;
        case TOKEN_BIT_OR_ASSIGN:   return OPERATOR_BIT_OR;
        case TOKEN_BIT_XOR_ASSIGN:  return OPERATOR_BIT_XOR;
        case TOKEN_LSHIFT_ASSIGN:   return OPERATOR_LSHIFT;
        case TOKEN_RSHIFT_ASSIGN:   return OPERATOR_RSHIFT;
        case TOKEN_BIT_AND:         return OPERATOR_BIT_AND;
        case TOKEN_BIT_OR:          return OPERATOR_BIT_OR;
        case TOKEN_BIT_XOR:         return OPERATOR_BIT_XOR;
        case TOKEN_LSHIFT:          return OPERATOR_LSHIFT;
        case TOKEN_RSHIFT:          return OPERATOR_RSHIFT;
        default: {
            APE_ASSERT(false);
            return OPERATOR_NONE;
        }
    }
}

static bool cur_token_is(parser_t *p, token_type_t type) {
    return p->cur_token.type == type;
}

static bool peek_token_is(parser_t *p, token_type_t type) {
    return p->peek_token.type == type;
}

static bool expect_current(parser_t *p, token_type_t type) {
    if (!cur_token_is(p, type)) {
        const char *expected_type_str = token_type_to_string(type);
        const char *actual_type_str = token_type_to_string(p->cur_token.type);
        error_t *err = error_makef(ERROR_PARSING, p->cur_token.pos,
                                   "Expected current token to be \"%s\", got \"%s\" instead",
                                   expected_type_str, actual_type_str);
        ptrarray_add(p->errors, err);
        return false;
    }
    return true;
}

static char escape_char(const char c) {
    switch (c) {
        case '\"': return '\"';
        case '\\': return '\\';
        case '/':  return '/';
        case 'b':  return '\b';
        case 'f':  return '\f';
        case 'n':  return '\n';
        case 'r':  return '\r';
        case 't':  return '\t';
        case '0':  return '\0';
        default: {
            APE_ASSERT(false);
            return -1;
        }
    }
}

static char* process_and_copy_string(const char *input, size_t len) {
    char *output = ape_malloc(len + 1, ape_mallocArg);

    size_t in_i = 0;
    size_t out_i = 0;

    while (input[in_i] != '\0' && in_i < len) {
        if (input[in_i] == '\\') {
            in_i++;
            output[out_i] = escape_char(input[in_i]);
            if (output[out_i] < 0) {
                goto error;
            }
        } else {
            output[out_i] = input[in_i];
        }
        out_i++;
        in_i++;
    }
    output[out_i] = '\0';
    return output;
error:
    ape_free(output, ape_freeArg);
    return NULL;
}
//FILE_END
//FILE_START:symbol_table.c
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#ifndef APE_AMALGAMATED
#include "symbol_table.h"
#include "builtins.h"
#endif

static block_scope_t* block_scope_copy(block_scope_t *scope);
static void set_symbol(symbol_table_t *table, symbol_t *symbol);
static int next_symbol_index(symbol_table_t *table);
static int count_num_definitions(symbol_table_t *table);

symbol_t *symbol_make(const char *name, symbol_type_t type, int index, bool assignable) {
    symbol_t *symbol = ape_malloc(sizeof(symbol_t), ape_mallocArg);
    symbol->name = ape_strdup(name);
    symbol->type = type;
    symbol->index = index;
    symbol->assignable = assignable;
    return symbol;
}

void symbol_destroy(symbol_t *symbol) {
    if (!symbol) {
        return;
    }
    ape_free(symbol->name, ape_freeArg);
    ape_free(symbol, ape_freeArg);
}

symbol_t* symbol_copy(const symbol_t *symbol) {
    return symbol_make(symbol->name, symbol->type, symbol->index, symbol->assignable);
}

symbol_table_t *symbol_table_make(symbol_table_t *outer) {
    symbol_table_t *table = ape_malloc(sizeof(symbol_table_t), ape_mallocArg);
    memset(table, 0, sizeof(symbol_table_t));
    table->max_num_definitions = 0;
    table->outer = outer;
    table->block_scopes = ptrarray_make();
    symbol_table_push_block_scope(table);
    table->free_symbols = ptrarray_make();
    if (!outer) {
        for (int i = 0; i < builtins_count(); i++) {
            const char *name = builtins_get_name(i);
            symbol_table_define_native_function(table, name, i);
        }
    }
    return table;
}

void symbol_table_destroy(symbol_table_t *table) {
    if (!table) {
        return;
    }

    while (ptrarray_count(table->block_scopes) > 0) {
        symbol_table_pop_block_scope(table);
    }
    ptrarray_destroy(table->block_scopes);
    ptrarray_destroy_with_items(table->free_symbols, symbol_destroy);
    ape_free(table, ape_freeArg);
}

symbol_table_t* symbol_table_copy(symbol_table_t *table) {
    symbol_table_t *copy = ape_malloc(sizeof(symbol_table_t), ape_mallocArg);
    memset(copy, 0, sizeof(symbol_table_t));
    copy->outer = table->outer;
    copy->block_scopes = ptrarray_copy_with_items(table->block_scopes, block_scope_copy);
    copy->free_symbols = ptrarray_copy_with_items(table->free_symbols, symbol_copy);
    copy->max_num_definitions = table->max_num_definitions;
    return copy;
}

void symbol_table_add_module_symbol(symbol_table_t *st, const symbol_t *symbol) {
    if (symbol->type != SYMBOL_GLOBAL) {
        APE_ASSERT(false);
        return;
    }
    if (symbol_table_symbol_is_defined(st, symbol->name)) {
        return;
    }
    symbol_t *copy = symbol_copy(symbol);
    set_symbol(st, copy);
}

symbol_t *symbol_table_define(symbol_table_t *table, const char *name, bool assignable) {
    if (strchr(name, ':')) {
        return NULL; // module symbol
    }
    if (APE_STREQ(name, "this")) {
        return NULL; // this is reserved
    }
    symbol_type_t symbol_type = table->outer == NULL ? SYMBOL_GLOBAL : SYMBOL_LOCAL;
    int ix = next_symbol_index(table);
    symbol_t *symbol = symbol_make(name, symbol_type, ix, assignable);
    set_symbol(table, symbol);
    block_scope_t *top_scope = ptrarray_top(table->block_scopes);
    top_scope->num_definitions++;
    int definitions_count = count_num_definitions(table);
    if (definitions_count > table->max_num_definitions) {
        table->max_num_definitions = definitions_count;
    }
    return symbol;
}

symbol_t *symbol_table_define_native_function(symbol_table_t *st, const char *name, int ix) {
    symbol_t *symbol = symbol_make(name, SYMBOL_NATIVE_FUNCTION, ix, false);
    set_symbol(st, symbol);
    return symbol;
}

symbol_t *symbol_table_define_free(symbol_table_t *st, symbol_t *original) {
    symbol_t *copy = symbol_make(original->name, original->type, original->index, original->assignable);
    ptrarray_add(st->free_symbols, copy);

    symbol_t *symbol = symbol_make(original->name, SYMBOL_FREE, ptrarray_count(st->free_symbols) - 1, original->assignable);
    set_symbol(st, symbol);

    return symbol;
}

symbol_t * symbol_table_define_function_name(symbol_table_t *st, const char *name, bool assignable) {
    if (strchr(name, ':')) {
        return NULL; // module symbol
    }
    symbol_t *symbol = symbol_make(name, SYMBOL_FUNCTION, 0, assignable);
    set_symbol(st, symbol);
    return symbol;
}

symbol_t *symbol_table_define_this(symbol_table_t *st) {
    symbol_t *symbol = symbol_make("this", SYMBOL_THIS, 0, false);
    set_symbol(st, symbol);
    return symbol;
}

symbol_t *symbol_table_resolve(symbol_table_t *table, const char *name) {
    symbol_t *symbol = NULL;
    block_scope_t *scope = NULL;
    for (int i = ptrarray_count(table->block_scopes) - 1; i >= 0; i--) {
        scope = ptrarray_get(table->block_scopes, i);
        symbol = dict_get(scope->store, name);
        if (symbol) {
            break;
        }
    }

    if (symbol && symbol->type == SYMBOL_THIS) {
        symbol = symbol_table_define_free(table, symbol);
    }

    if (!symbol && table->outer) {
        symbol = symbol_table_resolve(table->outer, name);
        if (!symbol || symbol->type == SYMBOL_GLOBAL || symbol->type == SYMBOL_NATIVE_FUNCTION) {
            return symbol;
        }
        symbol = symbol_table_define_free(table, symbol);
    }
    return symbol;
}

bool symbol_table_symbol_is_defined(symbol_table_t *table, const char *name) { // todo: rename to something more obvious
    block_scope_t *top_scope = ptrarray_top(table->block_scopes);
    symbol_t *existing = dict_get(top_scope->store, name);
    if (existing) {
        return true;
    }
    return false;
}

void symbol_table_push_block_scope(symbol_table_t *table) {
    block_scope_t *new_scope = ape_malloc(sizeof(block_scope_t), ape_mallocArg);
    new_scope->store = dict_make();
    new_scope->num_definitions = 0;
    new_scope->offset = count_num_definitions(table);
    ptrarray_push(table->block_scopes, new_scope);
}

void symbol_table_pop_block_scope(symbol_table_t *table) {
    block_scope_t *top_scope = ptrarray_top(table->block_scopes);
    ptrarray_pop(table->block_scopes);
    dict_destroy_with_items(top_scope->store, symbol_destroy);
    ape_free(top_scope, ape_freeArg);
}

block_scope_t* symbol_table_get_block_scope(symbol_table_t *table) {
    block_scope_t *top_scope = ptrarray_top(table->block_scopes);
    return top_scope;
}


bool symbol_table_is_global_scope(symbol_table_t *table) {
    return table->outer == NULL;
}

bool symbol_table_is_top_block_scope(symbol_table_t *table) {
    return ptrarray_count(table->block_scopes) == 1;
}

bool symbol_table_is_top_global_scope(symbol_table_t *table) {
    return symbol_table_is_global_scope(table) && symbol_table_is_top_block_scope(table);
}

// INTERNAL
static block_scope_t* block_scope_copy(block_scope_t *scope) {
    block_scope_t *copy = ape_malloc(sizeof(block_scope_t), ape_mallocArg);
    copy->num_definitions = scope->num_definitions;
    copy->offset = scope->offset;
    copy->store = dict_copy_with_items(scope->store, symbol_copy);
    return copy;
}

static void set_symbol(symbol_table_t *table, symbol_t *symbol) {
    block_scope_t *top_scope = ptrarray_top(table->block_scopes);
    symbol_t *existing = dict_get(top_scope->store, symbol->name);
    if (existing) {
        symbol_destroy(existing);
    }
    dict_set(top_scope->store, symbol->name, symbol);
}

static int next_symbol_index(symbol_table_t *table) {
    block_scope_t *top_scope = ptrarray_top(table->block_scopes);
    int ix = top_scope->offset + top_scope->num_definitions;
    return ix;
}

static int count_num_definitions(symbol_table_t *table) {
    int count = 0;
    for (int i = ptrarray_count(table->block_scopes) - 1; i >= 0; i--) {
        block_scope_t *scope = ptrarray_get(table->block_scopes, i);
        count += scope->num_definitions;
    }
    return count;
}
//FILE_END
//FILE_START:code.c
#include <stdlib.h>

#ifndef APE_AMALGAMATED
#include "code.h"

#include "common.h"
#include "collections.h"
#endif

static opcode_definition_t g_definitions[OPCODE_MAX + 1] = {
    {"NONE", 0, {0}},
    {"CONSTANT", 1, {2}},
    {"ADD", 0, {0}},
    {"POP", 0, {0}},
    {"SUB", 0, {0}},
    {"MUL", 0, {0}},
    {"DIV", 0, {0}},
    {"MOD", 0, {0}},
    {"TRUE", 0, {0}},
    {"FALSE", 0, {0}},
    {"COMPARE", 0, {0}},
    {"EQUAL", 0, {0}},
    {"NOT_EQUAL", 0, {0}},
    {"GREATER_THAN", 0, {0}},
    {"GREATER_THAN_EQUAL", 0, {0}},
    {"MINUS", 0, {0}},
    {"BANG", 0, {0}},
    {"JUMP", 1, {2}},
    {"JUMP_IF_FALSE", 1, {2}},
    {"JUMP_IF_TRUE", 1, {2}},
    {"NULL", 0, {0}},
    {"GET_GLOBAL", 1, {2}},
    {"SET_GLOBAL", 1, {2}},
    {"DEFINE_GLOBAL", 1, {2}},
    {"ARRAY", 1, {2}},
    {"MAP_START", 1, {2}},
    {"MAP_END", 1, {2}},
    {"GET_THIS", 0, {0}},
    {"GET_INDEX", 0, {0}},
    {"SET_INDEX", 0, {0}},
    {"GET_VALUE_AT", 0, {0}},
    {"CALL", 1, {1}},
    {"RETURN_VALUE", 0, {0}},
    {"RETURN", 0, {0}},
    {"GET_LOCAL", 1, {1}},
    {"DEFINE_LOCAL", 1, {1}},
    {"SET_LOCAL", 1, {1}},
    {"GET_NATIVE_FUNCTION", 1, {2}},
    {"FUNCTION", 2, {2, 1}},
    {"GET_FREE", 1, {1}},
    {"SET_FREE", 1, {1}},
    {"CURRENT_FUNCTION", 0, {0}},
    {"DUP", 0, {0}},
    {"NUMBER", 1, {8}},
    {"LEN", 0, {0}},
    {"SET_RECOVER", 1, {2}},
    {"OR", 0, {0}},
    {"XOR", 0, {0}},
    {"AND", 0, {0}},
    {"LSHIFT", 0, {0}},
    {"RSHIFT", 0, {0}},
    {"INVALID_MAX", 0, {0}},
};

opcode_definition_t* opcode_lookup(opcode_t op) {
    if (op <= OPCODE_NONE || op >= OPCODE_MAX) {
        return NULL;
    }
    return &g_definitions[op];
}

const char *opcode_get_name(opcode_t op) {
    if (op <= OPCODE_NONE || op >= OPCODE_MAX) {
        return NULL;
    }
    return g_definitions[op].name;
}

int code_make(opcode_t op, int operands_count, uint64_t *operands, array(uint8_t) *res) {
    opcode_definition_t *def = opcode_lookup(op);
    if (!def) {
        return 0;
    }

    int instr_len = 1;
    for (int i = 0; i < def->num_operands; i++) {
        instr_len += def->operand_widths[i];
    }

    uint8_t val = op;
    array_add(res, &val);

    for (int i = 0; i < operands_count; i++) {
        int width = def->operand_widths[i];
        switch (width) {
            case 1: {
                val = operands[i];
                array_add(res, &val);
                break;
            }
            case 2: {
                val = operands[i] >> 8;
                array_add(res, &val);
                val = operands[i] >> 0;
                array_add(res, &val);
                break;
            }
            case 4: {
                val = operands[i] >> 24;
                array_add(res, &val);
                val = operands[i] >> 16;
                array_add(res, &val);
                val = operands[i] >> 8;
                array_add(res, &val);
                val = operands[i] >> 0;
                array_add(res, &val);
                break;
            }
            case 8: {
                val = operands[i] >> 56;
                array_add(res, &val);
                val = operands[i] >> 48;
                array_add(res, &val);
                val = operands[i] >> 40;
                array_add(res, &val);
                val = operands[i] >> 32;
                array_add(res, &val);
                val = operands[i] >> 24;
                array_add(res, &val);
                val = operands[i] >> 16;
                array_add(res, &val);
                val = operands[i] >> 8;
                array_add(res, &val);
                val = operands[i] >> 0;
                array_add(res, &val);
                break;
            }
            default: {
                APE_ASSERT(false);
                break;
            }
        }
    }

    return instr_len;
}

void code_to_string(uint8_t *code, src_pos_t *source_positions, size_t code_size, strbuf_t *res) {
    unsigned pos = 0;
    while (pos < code_size) {
        uint8_t op = code[pos];
        opcode_definition_t *def = opcode_lookup(op);
        APE_ASSERT(def);
        if (source_positions) {
            src_pos_t src_pos = source_positions[pos];
            strbuf_appendf(res, "%d:%-4d\t%04d\t%s", src_pos.line, src_pos.column, pos, def->name);
        } else {
            strbuf_appendf(res, "%04d %s", pos, def->name);
        }
        pos += 1;

        uint64_t operands[2];
        code_read_operands(def, code + pos, operands);
        for (int i = 0; i < def->num_operands; i++) {
            if (op == OPCODE_NUMBER) {
                double val_double = ape_uint64_to_double(operands[i]);
                strbuf_appendf(res, " %1.17g", val_double);
            } else {
                strbuf_appendf(res, " %lu", operands[i]);
            }
            pos += def->operand_widths[i];
        }
        strbuf_append(res, "\n");

    }
    return;
}

bool code_read_operands(opcode_definition_t *def, uint8_t *instr, uint64_t out_operands[2]) {
    int offset = 0;
    for (int i = 0; i < def->num_operands; i++) {
        int operand_width = def->operand_widths[i];
        switch (operand_width) {
            case 1: {
                out_operands[i] = instr[offset];
                break;
            }
            case 2: {
                uint64_t operand = 0;
                operand = operand | (instr[offset] << 8);
                operand = operand | (instr[offset + 1]);
                out_operands[i] = operand;
                break;
            }
            case 4: {
                uint64_t operand = 0;
                operand = operand | (instr[offset + 0] << 24);
                operand = operand | (instr[offset + 1] << 16);
                operand = operand | (instr[offset + 2] << 8);
                operand = operand | (instr[offset + 3]);
                out_operands[i] = operand;
                break;
            }
            case 8: {
                uint64_t operand = 0;
                operand = operand | ((uint64_t)instr[offset + 0] << 56);
                operand = operand | ((uint64_t)instr[offset + 1] << 48);
                operand = operand | ((uint64_t)instr[offset + 2] << 40);
                operand = operand | ((uint64_t)instr[offset + 3] << 32);
                operand = operand | ((uint64_t)instr[offset + 4] << 24);
                operand = operand | ((uint64_t)instr[offset + 5] << 16);
                operand = operand | ((uint64_t)instr[offset + 6] << 8);
                operand = operand | ((uint64_t)instr[offset + 7]);
                out_operands[i] = operand;
                break;
            }
            default: {
                APE_ASSERT(false);
                return false;
            }
        }
        offset += operand_width;
    }
    return true;;
}
//FILE_END
//FILE_START:compilation_scope.c
#ifndef APE_AMALGAMATED
#include "compilation_scope.h"
#endif

compilation_scope_t *compilation_scope_make(compilation_scope_t *outer) {
    compilation_scope_t *scope = ape_malloc(sizeof(compilation_scope_t), ape_mallocArg);
    memset(scope, 0, sizeof(compilation_scope_t));
    scope->outer = outer;
    scope->bytecode = array_make(uint8_t);
    scope->src_positions = array_make(src_pos_t);
    return scope;
}

void compilation_scope_destroy(compilation_scope_t *scope) {
    array_destroy(scope->bytecode);
    array_destroy(scope->src_positions);
    ape_free(scope, ape_freeArg);
}

compilation_result_t* compilation_scope_orphan_result(compilation_scope_t *scope) {
    compilation_result_t *res = compilation_result_make(array_data(scope->bytecode),
                                                        array_data(scope->src_positions),
                                                        array_count(scope->bytecode));
    array_orphan_data(scope->bytecode);
    array_orphan_data(scope->src_positions);
    return res;
}

compilation_result_t* compilation_result_make(uint8_t *bytecode, src_pos_t *src_positions, int count) {
    compilation_result_t *res = ape_malloc(sizeof(compilation_result_t), ape_mallocArg);
    memset(res, 0, sizeof(compilation_result_t));
    res->bytecode = bytecode;
    res->src_positions = src_positions;
    res->count = count;
    return res;
}

void compilation_result_destroy(compilation_result_t *res) {
    if (!res) {
        return;
    }
    ape_free(res->bytecode, ape_freeArg);
    ape_free(res->src_positions, ape_freeArg);
    ape_free(res, ape_freeArg);
}
//FILE_END
//FILE_START:compiler.c
#include <stdlib.h>
#include <math.h>

#ifndef APE_AMALGAMATED
#include "compiler.h"

#include "ape.h"
#include "ast.h"
#include "object.h"
#include "gc.h"
#include "code.h"
#include "symbol_table.h"
#include "error.h"
#endif

static bool compile_code(compiler_t *comp, const char *code);
static bool compile_statements(compiler_t *comp, ptrarray(statement_t) *statements);
static bool import_module(compiler_t *comp, const statement_t *import_stmt);
static bool compile_statement(compiler_t *comp, const statement_t *stmt);
static bool compile_expression(compiler_t *comp, const expression_t *expr);
static bool compile_code_block(compiler_t *comp, const code_block_t *block);
static int  add_constant(compiler_t *comp, object_t obj);
static void change_uint16_operand(compiler_t *comp, int ip, uint16_t operand);
static bool last_opcode_is(compiler_t *comp, opcode_t op);
static void read_symbol(compiler_t *comp, symbol_t *symbol);
static void write_symbol(compiler_t *comp, symbol_t *symbol, bool define);

static void push_break_ip(compiler_t *comp, int ip);
static void pop_break_ip(compiler_t *comp);
static int  get_break_ip(compiler_t *comp);

static void push_continue_ip(compiler_t *comp, int ip);
static void pop_continue_ip(compiler_t *comp);
static int  get_continue_ip(compiler_t *comp);

static int  get_ip(compiler_t *comp);

static array(src_pos_t)* get_src_positions(compiler_t *comp);
static array(uint8_t)*   get_bytecode(compiler_t *comp);

static void push_file_scope(compiler_t *comp, const char *filepath, module_t *module);
static void pop_file_scope(compiler_t *comp);

static void set_compilation_scope(compiler_t *comp, compilation_scope_t *scope);

static module_t* get_current_module(compiler_t *comp);
static module_t* module_make(const char *name);
static void module_destroy(module_t *module);
static void module_add_symbol(module_t *module, const symbol_t *symbol);

static compiled_file_t* compiled_file_make(const char *path);
static void compiled_file_destroy(compiled_file_t *file);

static const char* get_module_name(const char *path);
static symbol_t* define_symbol(compiler_t *comp, src_pos_t pos, const char *name, bool assignable, bool can_shadow);

static bool is_comparison(operator_t op);

compiler_t *compiler_make(const ape_config_t *config, gcmem_t *mem, ptrarray(error_t) *errors) {
    compiler_t *comp = ape_malloc(sizeof(compiler_t), ape_mallocArg);
    memset(comp, 0, sizeof(compiler_t));
    APE_ASSERT(config);
    comp->config = config;
    comp->mem = mem;
    comp->file_scopes = ptrarray_make();
    comp->constants = array_make(object_t);
    comp->errors = errors;
    comp->break_ip_stack = array_make(int);
    comp->continue_ip_stack = array_make(int);
    comp->src_positions_stack = array_make(src_pos_t);
    comp->modules = dict_make();
    comp->files = ptrarray_make();
    compiler_push_compilation_scope(comp);
    push_file_scope(comp, "none", NULL);
    return comp;
}

void compiler_destroy(compiler_t *comp) {
    if (!comp) {
        return;
    }
    array_destroy(comp->constants);
    array_destroy(comp->continue_ip_stack);
    array_destroy(comp->break_ip_stack);
    array_destroy(comp->src_positions_stack);
    while (compiler_get_compilation_scope(comp)) {
        compiler_pop_compilation_scope(comp);
    }
    while (ptrarray_count(comp->file_scopes) > 0) {
        pop_file_scope(comp);
    }
    ptrarray_destroy(comp->file_scopes);
    ptrarray_destroy_with_items(comp->files, compiled_file_destroy);
    dict_destroy_with_items(comp->modules, module_destroy);
    ape_free(comp, ape_freeArg);
}

compilation_result_t* compiler_compile(compiler_t *comp, const char *code) {
    // todo: make compiler_reset function
    array_clear(comp->src_positions_stack);
    array_clear(comp->break_ip_stack);
    array_clear(comp->continue_ip_stack);

    compilation_scope_t *compilation_scope = compiler_get_compilation_scope(comp);
    array_clear(compilation_scope->bytecode);
    array_clear(compilation_scope->src_positions);

    symbol_table_t *global_table_copy = symbol_table_copy(compiler_get_symbol_table(comp));

    bool ok = compile_code(comp, code);

    compilation_scope = compiler_get_compilation_scope(comp);

    while (compilation_scope->outer != NULL) {
        compiler_pop_compilation_scope(comp);
        compilation_scope = compiler_get_compilation_scope(comp);
    }

    if (!ok) {
        while (compiler_get_symbol_table(comp) != NULL) {
            compiler_pop_symbol_table(comp);
        }
        compiler_set_symbol_table(comp, global_table_copy);
        return NULL;
    }

    symbol_table_destroy(global_table_copy);

    compilation_scope = compiler_get_compilation_scope(comp);
    return compilation_scope_orphan_result(compilation_scope);
}

compilation_result_t* compiler_compile_file(compiler_t *comp, const char *path) {
    if (!comp->config->fileio.read_file.read_file) {
        error_t *err = error_make(ERROR_COMPILATION, src_pos_invalid, "File read function not configured");
        ptrarray_add(comp->errors, err);
        return NULL;
    }

    char *code = comp->config->fileio.read_file.read_file(comp->config->fileio.read_file.context, path);
    if (!code) {
        error_t *err = error_makef(ERROR_COMPILATION, src_pos_invalid, "Reading file \"%s\" failed", path);
        ptrarray_add(comp->errors, err);
        return NULL;
    }

    compiled_file_t *file = compiled_file_make(path);
    ptrarray_add(comp->files, file);

    APE_ASSERT(ptrarray_count(comp->file_scopes) == 1);
    file_scope_t *file_scope = ptrarray_top(comp->file_scopes);
    if (!file_scope) {
        APE_ASSERT(false);
        ape_free(code, ape_freeArg);
        return NULL;
    }
    compiled_file_t *prev_file = file_scope->file;
    file_scope->file = file;

    compilation_result_t *res = compiler_compile(comp, code);

    file_scope->file = prev_file;
    ape_free(code, ape_freeArg);
    return res;
}

compilation_scope_t* compiler_get_compilation_scope(compiler_t *comp) {
    return comp->compilation_scope;
}

void compiler_push_compilation_scope(compiler_t *comp) {
    compilation_scope_t *current_scope = compiler_get_compilation_scope(comp);
    compilation_scope_t *new_scope = compilation_scope_make(current_scope);
    set_compilation_scope(comp, new_scope);
}

void compiler_pop_compilation_scope(compiler_t *comp) {
    compilation_scope_t *current_scope = compiler_get_compilation_scope(comp);
    APE_ASSERT(current_scope);
    set_compilation_scope(comp, current_scope->outer);
    compilation_scope_destroy(current_scope);
}

void compiler_push_symbol_table(compiler_t *comp) {
    file_scope_t *file_scope = ptrarray_top(comp->file_scopes);
    if (!file_scope) {
        APE_ASSERT(false);
        return;
    }
    symbol_table_t *current_table = file_scope->symbol_table;
    file_scope->symbol_table = symbol_table_make(current_table);
}

void compiler_pop_symbol_table(compiler_t *comp) {
    file_scope_t *file_scope = ptrarray_top(comp->file_scopes);
    if (!file_scope) {
        APE_ASSERT(false);
        return;
    }
    symbol_table_t *current_table = file_scope->symbol_table;
    if (!current_table) {
        APE_ASSERT(false);
        return;
    }
    file_scope->symbol_table = current_table->outer;
    symbol_table_destroy(current_table);
}

symbol_table_t* compiler_get_symbol_table(compiler_t *comp) {
    file_scope_t *file_scope = ptrarray_top(comp->file_scopes);
    if (!file_scope) {
        APE_ASSERT(false);
        return NULL;
    }
    symbol_table_t *current_table = file_scope->symbol_table;
    if (!current_table) {
        return NULL;
    }
    return current_table;
}

void compiler_set_symbol_table(compiler_t *comp, symbol_table_t *table) {
    file_scope_t *file_scope = ptrarray_top(comp->file_scopes);
    if (!file_scope) {
        APE_ASSERT(false);
        return;
    }
    file_scope->symbol_table = table;
}

opcode_t compiler_last_opcode(compiler_t *comp) {
    compilation_scope_t *current_scope = compiler_get_compilation_scope(comp);
    return current_scope->last_opcode;
}

// INTERNAL
static bool compile_code(compiler_t *comp, const char *code) {
    file_scope_t *file_scope = ptrarray_top(comp->file_scopes);
    APE_ASSERT(file_scope);

    ptrarray(statement_t) *statements = parser_parse_all(file_scope->parser, code, file_scope->file);
    if (!statements) {
        // errors are added by parser
        return false;
    }

    bool ok = compile_statements(comp, statements);

    ptrarray_destroy_with_items(statements, statement_destroy);

    return ok;
}

static bool compile_statements(compiler_t *comp, ptrarray(statement_t) *statements) {
    bool ok = true;
    for (int i = 0; i < ptrarray_count(statements); i++) {
        const statement_t *stmt = ptrarray_get(statements, i);
        ok = compile_statement(comp, stmt);
        if (!ok) {
            break;
        }
    }
    return ok;
}

static bool import_module(compiler_t *comp, const statement_t *import_stmt) {
    bool result = false;
    char *filepath = NULL;

    file_scope_t *file_scope = ptrarray_top(comp->file_scopes);

    const char *module_path = import_stmt->import.path;
    const char *module_name = get_module_name(module_path);

    for (int i = 0; i < ptrarray_count(file_scope->loaded_module_names); i++) {
        const char *loaded_name = ptrarray_get(file_scope->loaded_module_names, i);
        if (kg_streq(loaded_name, module_name)) {
            error_t *err = error_makef(ERROR_COMPILATION, import_stmt->pos, "Module \"%s\" was already imported", module_name);
            ptrarray_add(comp->errors, err);
            result = false;
            goto end;
        }
    }

    strbuf_t *filepath_buf = strbuf_make();
    if (kg_is_path_absolute(module_path)) {
        strbuf_appendf(filepath_buf, "%s.bn", module_path);
    } else {
        strbuf_appendf(filepath_buf, "%s%s.bn", file_scope->file->dir_path, module_path);
    }
    const char *filepath_non_canonicalised = strbuf_get_string(filepath_buf);
    filepath = kg_canonicalise_path(filepath_non_canonicalised);
    strbuf_destroy(filepath_buf);

    symbol_table_t *symbol_table = compiler_get_symbol_table(comp);
    if (symbol_table->outer != NULL || ptrarray_count(symbol_table->block_scopes) > 1) {
        error_t *err = error_make(ERROR_COMPILATION, import_stmt->pos, "Modules can only be imported in global scope");
        ptrarray_add(comp->errors, err);
        result = false;
        goto end;
    }

    for (int i = 0; i < ptrarray_count(comp->file_scopes); i++) {
        file_scope_t *fs = ptrarray_get(comp->file_scopes, i);
        if (APE_STREQ(fs->file->path, filepath)) {
            error_t *err = error_makef(ERROR_COMPILATION, import_stmt->pos, "Cyclic reference of file \"%s\"", filepath);
            ptrarray_add(comp->errors, err);
            result = false;
            goto end;
        }
    }

    module_t *module = dict_get(comp->modules, filepath);
    if (!module) {
        if (!comp->config->fileio.read_file.read_file) {
            error_t *err = error_makef(ERROR_COMPILATION, import_stmt->pos, "Cannot import module \"%s\", file read function not configured", filepath);
            ptrarray_add(comp->errors, err);
            result = false;
            goto end;
        }

        char *code = comp->config->fileio.read_file.read_file(comp->config->fileio.read_file.context, filepath);
        if (!code) {
            error_t *err = error_makef(ERROR_COMPILATION, import_stmt->pos, "Reading module file \"%s\" failed", filepath);
            ptrarray_add(comp->errors, err);
            result = false;
            goto end;
        }

        module = module_make(module_name);
        push_file_scope(comp, filepath, module);
        bool ok = compile_code(comp, code);
        pop_file_scope(comp);
        ape_free(code, ape_freeArg);

        if (!ok) {
            module_destroy(module);
            result = false;
            goto end;
        }

        dict_set(comp->modules, filepath, module);
    }

    for (int i = 0; i < ptrarray_count(module->symbols); i++) {
        symbol_t *symbol = ptrarray_get(module->symbols, i);
        symbol_table_add_module_symbol(symbol_table, symbol);
    }

    ptrarray_add(file_scope->loaded_module_names, ape_strdup(module_name));

    result = true;

end:
    ape_free(filepath, ape_freeArg);
    return result;
}

static bool compile_statement(compiler_t *comp, const statement_t *stmt) {
    bool ok = false;
    array_push(comp->src_positions_stack, &stmt->pos);
    compilation_scope_t *compilation_scope = compiler_get_compilation_scope(comp);
    symbol_table_t *symbol_table = compiler_get_symbol_table(comp);
    switch (stmt->type) {
        case STATEMENT_EXPRESSION: {
            ok = compile_expression(comp, stmt->expression);
            if (!ok) {
                return false;
            }
            compiler_emit(comp, OPCODE_POP, 0, NULL);
            break;
        }
        case STATEMENT_DEFINE: {
            ok = compile_expression(comp, stmt->define.value);
            if (!ok) {
                return false;
            }

            symbol_t *symbol = define_symbol(comp, stmt->define.name.pos, stmt->define.name.value, stmt->define.assignable, false);
            if (!symbol) {
                return false;
            }

            if (symbol->type == SYMBOL_GLOBAL) {
                module_t *module = get_current_module(comp);
                if (module) {
                    module_add_symbol(module, symbol);
                }
            }

            write_symbol(comp, symbol, true);

            break;
        }
        case STATEMENT_IF: {
            const if_statement_t *if_stmt = &stmt->if_statement;

            array(int) *jump_to_end_ips = array_make(int);
            for (int i = 0; i < ptrarray_count(if_stmt->cases); i++) {
                if_case_t *if_case = ptrarray_get(if_stmt->cases, i);

                ok = compile_expression(comp, if_case->test);
                if (!ok) {
                    array_destroy(jump_to_end_ips);
                    return false;
                }

                int next_case_jump_ip = compiler_emit(comp, OPCODE_JUMP_IF_FALSE, 1, (uint64_t[]){0xbeef});

                ok = compile_code_block(comp, if_case->consequence);
                if (!ok) {
                    array_destroy(jump_to_end_ips);
                    return false;
                }

                int jump_to_end_ip = compiler_emit(comp, OPCODE_JUMP, 1, (uint64_t[]){0xbeef});
                array_add(jump_to_end_ips, &jump_to_end_ip);

                int after_elif_ip = get_ip(comp);
                change_uint16_operand(comp, next_case_jump_ip + 1, after_elif_ip);
            }

            if (if_stmt->alternative) {
                ok = compile_code_block(comp, if_stmt->alternative);
                if (!ok) {
                    array_destroy(jump_to_end_ips);
                    return false;
                }
            }

            int after_alt_ip = get_ip(comp);

            for (int i = 0; i < array_count(jump_to_end_ips); i++) {
                int *pos = array_get(jump_to_end_ips, i);
                change_uint16_operand(comp, *pos + 1, after_alt_ip);
            }

            array_destroy(jump_to_end_ips);

            break;
        }
        case STATEMENT_RETURN_VALUE: {
            if (compilation_scope->outer == NULL) {
                error_t *err = error_makef(ERROR_COMPILATION, stmt->pos, "Nothing to return from");
                ptrarray_add(comp->errors, err);
                return false;
            }
            if (stmt->return_value) {
                ok = compile_expression(comp, stmt->return_value);
                if (!ok) {
                    return false;
                }
                compiler_emit(comp, OPCODE_RETURN_VALUE, 0, NULL);
            } else {
                compiler_emit(comp, OPCODE_RETURN, 0, NULL);
            }
            break;
        }
        case STATEMENT_WHILE_LOOP: {
            const while_loop_statement_t *loop = &stmt->while_loop;

            int before_test_ip = get_ip(comp);

            ok = compile_expression(comp, loop->test);
            if (!ok) {
                return false;
            }

            int after_test_ip = get_ip(comp);
            compiler_emit(comp, OPCODE_JUMP_IF_TRUE, 1, (uint64_t[]){after_test_ip + 6});
            int jump_to_after_body_ip = compiler_emit(comp, OPCODE_JUMP, 1, (uint64_t[]){0xdead});

            push_continue_ip(comp, before_test_ip);
            push_break_ip(comp, jump_to_after_body_ip);
            ok = compile_code_block(comp, loop->body);
            if (!ok) {
                return false;
            }
            pop_break_ip(comp);
            pop_continue_ip(comp);

            compiler_emit(comp, OPCODE_JUMP, 1, (uint64_t[]){before_test_ip});

            int after_body_ip = get_ip(comp);
            change_uint16_operand(comp, jump_to_after_body_ip + 1, after_body_ip);

            break;
        }
        case STATEMENT_BREAK: {
            int break_ip = get_break_ip(comp);
            if (break_ip < 0) {
                error_t *err = error_makef(ERROR_COMPILATION, stmt->pos, "Nothing to break from.");
                ptrarray_add(comp->errors, err);
                return false;
            }
            compiler_emit(comp, OPCODE_JUMP, 1, (uint64_t[]){break_ip});
            break;
        }
        case STATEMENT_CONTINUE: {
            int continue_ip = get_continue_ip(comp);
            if (continue_ip < 0) {
                error_t *err = error_makef(ERROR_COMPILATION, stmt->pos, "Nothing to continue from.");
                ptrarray_add(comp->errors, err);
                return false;
            }
            compiler_emit(comp, OPCODE_JUMP, 1, (uint64_t[]){continue_ip});
            break;
        }
        case STATEMENT_FOREACH: {
            const foreach_statement_t *foreach = &stmt->foreach;
            symbol_table_push_block_scope(symbol_table);

            // Init
            symbol_t *index_symbol = define_symbol(comp, stmt->pos, "@i", false, true);
            if (!index_symbol) {
                APE_ASSERT(false);
                return false;
            }

            compiler_emit(comp, OPCODE_NUMBER, 1, (uint64_t[]){0});
            write_symbol(comp, index_symbol, true);
            symbol_t *source_symbol = NULL;
            if (foreach->source->type == EXPRESSION_IDENT) {
                source_symbol = symbol_table_resolve(symbol_table, foreach->source->ident.value);
                if (!source_symbol) {
                    error_t *err = error_makef(ERROR_COMPILATION, foreach->source->pos,
                                              "Symbol \"%s\" could not be resolved", foreach->source->ident.value);
                    ptrarray_add(comp->errors, err);
                    return false;
                }
            } else {
                ok = compile_expression(comp, foreach->source);
                if (!ok) {
                    return false;
                }
                source_symbol = define_symbol(comp, foreach->source->pos, "@source", false, true);
                if (!source_symbol) {
                    APE_ASSERT(false);
                    return false;
                }
                write_symbol(comp, source_symbol, true);
            }

            // Update
            int jump_to_after_update_ip = compiler_emit(comp, OPCODE_JUMP, 1, (uint64_t[]){0xbeef});
            int update_ip = get_ip(comp);
            read_symbol(comp, index_symbol);
            compiler_emit(comp, OPCODE_NUMBER, 1, (uint64_t[]){ape_double_to_uint64(1)});
            compiler_emit(comp, OPCODE_ADD, 0, NULL);
            write_symbol(comp, index_symbol, false);
            int after_update_ip = get_ip(comp);
            change_uint16_operand(comp, jump_to_after_update_ip + 1, after_update_ip);

            // Test
            array_push(comp->src_positions_stack, &foreach->source->pos);
            read_symbol(comp, source_symbol);
            compiler_emit(comp, OPCODE_LEN, 0, NULL);
            array_pop(comp->src_positions_stack, NULL);
            read_symbol(comp, index_symbol);
            compiler_emit(comp, OPCODE_COMPARE, 0, NULL);
            compiler_emit(comp, OPCODE_EQUAL, 0, NULL);

            int after_test_ip = get_ip(comp);
            compiler_emit(comp, OPCODE_JUMP_IF_FALSE, 1, (uint64_t[]){after_test_ip + 6});
            int jump_to_after_body_ip = compiler_emit(comp, OPCODE_JUMP, 1, (uint64_t[]){0xdead});

            read_symbol(comp, source_symbol);
            read_symbol(comp, index_symbol);
            compiler_emit(comp, OPCODE_GET_VALUE_AT, 0, NULL);

            symbol_t *iter_symbol  = define_symbol(comp, foreach->iterator.pos, foreach->iterator.value, false, false);
            if (!iter_symbol) {
                return false;
            }

            write_symbol(comp, iter_symbol, true);

            // Body
            push_continue_ip(comp, update_ip);
            push_break_ip(comp, jump_to_after_body_ip);
            ok = compile_code_block(comp, foreach->body);
            if (!ok) {
                return false;
            }
            pop_break_ip(comp);
            pop_continue_ip(comp);
            compiler_emit(comp, OPCODE_JUMP, 1, (uint64_t[]){update_ip});

            int after_body_ip = get_ip(comp);
            change_uint16_operand(comp, jump_to_after_body_ip + 1, after_body_ip);

            symbol_table_pop_block_scope(symbol_table);
            break;
        }
        case STATEMENT_FOR_LOOP: {
            const for_loop_statement_t *loop = &stmt->for_loop;

            symbol_table_push_block_scope(symbol_table);

            // Init
            bool ok = false;
            if (loop->init) {
                ok = compile_statement(comp, loop->init);
                if (!ok) {
                    return false;
                }
            }
            int jump_to_after_update_ip = compiler_emit(comp, OPCODE_JUMP, 1, (uint64_t[]){0xbeef});

            // Update
            int update_ip = get_ip(comp);
            if (loop->update) {
                ok = compile_expression(comp, loop->update);
                if (!ok) {
                    return false;
                }
                compiler_emit(comp, OPCODE_POP, 0, NULL);
            }
            int after_update_ip = get_ip(comp);
            change_uint16_operand(comp, jump_to_after_update_ip + 1, after_update_ip);

            // Test
            if (loop->test) {
                ok = compile_expression(comp, loop->test);
                if (!ok) {
                    return false;
                }
            } else {
                compiler_emit(comp, OPCODE_TRUE, 0, NULL);
            }
            int after_test_ip = get_ip(comp);

            compiler_emit(comp, OPCODE_JUMP_IF_TRUE, 1, (uint64_t[]){after_test_ip + 6});
            int jmp_to_after_body_ip = compiler_emit(comp, OPCODE_JUMP, 1, (uint64_t[]){0xdead});

            // Body
            push_continue_ip(comp, update_ip);
            push_break_ip(comp, jmp_to_after_body_ip);
            ok = compile_code_block(comp, loop->body);
            if (!ok) {
                return false;
            }
            pop_break_ip(comp);
            pop_continue_ip(comp);
            compiler_emit(comp, OPCODE_JUMP, 1, (uint64_t[]){update_ip});

            int after_body_ip = get_ip(comp);
            change_uint16_operand(comp, jmp_to_after_body_ip + 1, after_body_ip);

            symbol_table_pop_block_scope(symbol_table);
            break;
        }
        case STATEMENT_BLOCK: {
            ok = compile_code_block(comp, stmt->block);
            if (!ok) {
                return false;
            }
            break;
        }
        case STATEMENT_IMPORT: {
            ok = import_module(comp, stmt);
            if (!ok) {
                return false;
            }
            break;
        }
        case STATEMENT_RECOVER: {
            const recover_statement_t *recover = &stmt->recover;

            if (symbol_table_is_global_scope(symbol_table)) {
                error_t *err = error_make(ERROR_COMPILATION, stmt->pos,
                                          "Recover statement cannot be defined in global scope");
                ptrarray_add(comp->errors, err);
                return false;
            }

            if (!symbol_table_is_top_block_scope(symbol_table)) {
                error_t *err = error_make(ERROR_COMPILATION, stmt->pos,
                                          "Recover statement cannot be defined within other statements");
                ptrarray_add(comp->errors, err);
                return false;
            }

            int recover_ip = compiler_emit(comp, OPCODE_SET_RECOVER, 1, (uint64_t[]){0xbeef});
            int jump_to_after_recover_ip = compiler_emit(comp, OPCODE_JUMP, 1, (uint64_t[]){0xbeef});
            int after_jump_to_recover_ip = get_ip(comp);
            change_uint16_operand(comp, recover_ip + 1, after_jump_to_recover_ip);

            symbol_table_push_block_scope(symbol_table);

            symbol_t *error_symbol = define_symbol(comp, recover->error_ident.pos, recover->error_ident.value, false, false);
            if (!error_symbol) {
                return false;
            }

            write_symbol(comp, error_symbol, true);

            ok = compile_code_block(comp, recover->body);
            if (!ok) {
                return false;
            }

            if (!last_opcode_is(comp, OPCODE_RETURN) && !last_opcode_is(comp, OPCODE_RETURN_VALUE)) {
                error_t *err = error_make(ERROR_COMPILATION, stmt->pos,
                                          "Recover body must end with a return statement");
                ptrarray_add(comp->errors, err);
                return false;
            }

            symbol_table_pop_block_scope(symbol_table);

            int after_recover_ip = get_ip(comp);
            change_uint16_operand(comp, jump_to_after_recover_ip + 1, after_recover_ip);

            break;
        }
        default: {
            APE_ASSERT(false);
            return false;
        }
    }
    array_pop(comp->src_positions_stack, NULL);
    return true;
}

static bool compile_expression(compiler_t *comp, const expression_t *expr) {
    bool ok = false;
    array_push(comp->src_positions_stack, &expr->pos);
    compilation_scope_t *compilation_scope = compiler_get_compilation_scope(comp);
    symbol_table_t *symbol_table = compiler_get_symbol_table(comp);

    switch (expr->type) {
        case EXPRESSION_INFIX: {
            bool rearrange = false;

            opcode_t op = OPCODE_NONE;
            switch (expr->infix.op) {
                case OPERATOR_PLUS:        op = OPCODE_ADD; break;
                case OPERATOR_MINUS:       op = OPCODE_SUB; break;
                case OPERATOR_ASTERISK:    op = OPCODE_MUL; break;
                case OPERATOR_SLASH:       op = OPCODE_DIV; break;
                case OPERATOR_MODULUS:     op = OPCODE_MOD; break;
                case OPERATOR_EQ:          op = OPCODE_EQUAL; break;
                case OPERATOR_NOT_EQ:      op = OPCODE_NOT_EQUAL; break;
                case OPERATOR_GT:          op = OPCODE_GREATER_THAN; break;
                case OPERATOR_GTE:         op = OPCODE_GREATER_THAN_EQUAL; break;
                case OPERATOR_LT:          op = OPCODE_GREATER_THAN; rearrange = true; break;
                case OPERATOR_LTE:         op = OPCODE_GREATER_THAN_EQUAL; rearrange = true; break;
                case OPERATOR_BIT_OR:      op = OPCODE_OR; break;
                case OPERATOR_BIT_XOR:     op = OPCODE_XOR; break;
                case OPERATOR_BIT_AND:     op = OPCODE_AND; break;
                case OPERATOR_LSHIFT:      op = OPCODE_LSHIFT; break;
                case OPERATOR_RSHIFT:      op = OPCODE_RSHIFT; break;
                default: {
                    error_t *err = error_makef(ERROR_COMPILATION, expr->pos, "Unknown infix operator");
                    ptrarray_add(comp->errors, err);
                    return false;
                }
            }

            const expression_t *left = rearrange ? expr->infix.right : expr->infix.left;
            const expression_t *right = rearrange ? expr->infix.left : expr->infix.right;

            ok = compile_expression(comp, left);
            if (!ok) {
                return false;
            }

            ok = compile_expression(comp, right);
            if (!ok) {
                return false;
            }

            if (is_comparison(expr->infix.op)) {
                compiler_emit(comp, OPCODE_COMPARE, 0, NULL);
            }

            compiler_emit(comp, op, 0, NULL);

            break;
        }
        case EXPRESSION_NUMBER_LITERAL: {
            double number = expr->number_literal;
            compiler_emit(comp, OPCODE_NUMBER, 1, (uint64_t[]){ape_double_to_uint64(number)});
            break;
        }
        case EXPRESSION_STRING_LITERAL: {
            object_t obj = object_make_string(comp->mem, expr->string_literal);
            int pos = add_constant(comp, obj);
            compiler_emit(comp, OPCODE_CONSTANT, 1, (uint64_t[]){pos});
            break;
        }
        case EXPRESSION_NULL_LITERAL: {
            compiler_emit(comp, OPCODE_NULL, 0, NULL);
            break;
        }
        case EXPRESSION_BOOL_LITERAL: {
            compiler_emit(comp, expr->bool_literal ? OPCODE_TRUE : OPCODE_FALSE, 0, NULL);
            break;
        }
        case EXPRESSION_ARRAY_LITERAL: {
            for (int i = 0; i < ptrarray_count(expr->array); i++) {
                ok = compile_expression(comp, ptrarray_get(expr->array, i));
                if (!ok) {
                    return false;
                }
            }
            compiler_emit(comp, OPCODE_ARRAY, 1, (uint64_t[]){ptrarray_count(expr->array)});
            break;
        }
        case EXPRESSION_MAP_LITERAL: {
            const map_literal_t *map = &expr->map;
            int len = ptrarray_count(map->keys);
            compiler_emit(comp, OPCODE_MAP_START, 1, (uint64_t[]){len * 2});
            for (int i = 0; i < len; i++) {
                const expression_t *key = ptrarray_get(map->keys, i);
                const expression_t *val = ptrarray_get(map->values, i);

                ok = compile_expression(comp, key);
                if (!ok) {
                    return false;
                }

                ok = compile_expression(comp, val);
                if (!ok) {
                    return false;
                }
            }
            compiler_emit(comp, OPCODE_MAP_END, 1, (uint64_t[]){len * 2});
            break;
        }
        case EXPRESSION_PREFIX: {
            ok = compile_expression(comp, expr->prefix.right);
            if (!ok) {
                return false;
            }
            opcode_t op = OPCODE_NONE;
            switch (expr->prefix.op) {
                case OPERATOR_MINUS: op = OPCODE_MINUS; break;
                case OPERATOR_BANG: op = OPCODE_BANG; break;
                default: {
                    error_t *err = error_makef(ERROR_COMPILATION, expr->pos, "Unknown prefix operator.");
                    ptrarray_add(comp->errors, err);
                    return false;
                }
            }
            compiler_emit(comp, op, 0, NULL);
            break;
        }
        case EXPRESSION_IDENT: {
            const ident_t *ident = &expr->ident;
            symbol_t *symbol = symbol_table_resolve(symbol_table, ident->value);
            if (!symbol) {
                error_t *err = error_makef(ERROR_COMPILATION, ident->pos,
                                           "Symbol \"%s\" could not be resolved", ident->value);
                ptrarray_add(comp->errors, err);
                return false;
            }
            read_symbol(comp, symbol);
            break;
        }
        case EXPRESSION_INDEX: {
            const index_expression_t *index = &expr->index_expr;
            ok = compile_expression(comp, index->left);
            if (!ok) {
                return false;
            }
            ok = compile_expression(comp, index->index);
            if (!ok) {
                return false;
            }
            compiler_emit(comp, OPCODE_GET_INDEX, 0, NULL);
            break;
        }
        case EXPRESSION_FUNCTION_LITERAL: {
            const fn_literal_t *fn = &expr->fn_literal;

            compiler_push_compilation_scope(comp);
            compiler_push_symbol_table(comp);
            compilation_scope = compiler_get_compilation_scope(comp);
            symbol_table = compiler_get_symbol_table(comp);

            if (fn->name) {
                symbol_t *fn_symbol = symbol_table_define_function_name(symbol_table, fn->name, false);
                if (!fn_symbol) {
                    error_t *err = error_makef(ERROR_COMPILATION, expr->pos,
                                               "Cannot define symbol \"%s\"", fn->name);
                    ptrarray_add(comp->errors, err);
                    return false;
                }
            }

            symbol_t *this_symbol = symbol_table_define_this(symbol_table);
            if (!this_symbol) {
                error_t *err = error_make(ERROR_COMPILATION, expr->pos, "Cannot define \"this\" symbol");
                ptrarray_add(comp->errors, err);
                return false;
            }

            for (int i = 0; i < array_count(expr->fn_literal.params); i++) {
                ident_t *param = array_get(expr->fn_literal.params, i);
                symbol_t *param_symbol = define_symbol(comp, param->pos, param->value, true, false);
                if (!param_symbol) {
                    return false;
                }
            }

            ok = compile_statements(comp, fn->body->statements);
            if (!ok) {
                return false;
            }

            if (!last_opcode_is(comp, OPCODE_RETURN_VALUE) && !last_opcode_is(comp, OPCODE_RETURN)) {
                compiler_emit(comp, OPCODE_RETURN, 0, NULL);
            }

            ptrarray(symbol_t) *free_symbols = symbol_table->free_symbols;
            symbol_table->free_symbols = NULL; // because it gets destroyed with compiler_pop_compilation_scope()

            int num_locals = symbol_table->max_num_definitions;

            compilation_result_t *comp_res = compilation_scope_orphan_result(compilation_scope);
            compiler_pop_symbol_table(comp);
            compiler_pop_compilation_scope(comp);
            compilation_scope = compiler_get_compilation_scope(comp);
            symbol_table = compiler_get_symbol_table(comp);

            object_t obj = object_make_function(comp->mem, fn->name, comp_res, true,
                                                num_locals, array_count(fn->params), 0);

            for (int i = 0; i < ptrarray_count(free_symbols); i++) {
                symbol_t *symbol = ptrarray_get(free_symbols, i);
                read_symbol(comp, symbol);
            }

            int pos = add_constant(comp, obj);
            compiler_emit(comp, OPCODE_FUNCTION, 2, (uint64_t[]){pos, ptrarray_count(free_symbols)});

            ptrarray_destroy_with_items(free_symbols, symbol_destroy);

            break;
        }
        case EXPRESSION_CALL: {
            ok = compile_expression(comp, expr->call_expr.function);
            if (!ok) {
                return false;
            }

            for (int i = 0; i < ptrarray_count(expr->call_expr.args); i++) {
                const expression_t *arg_expr = ptrarray_get(expr->call_expr.args, i);
                ok = compile_expression(comp, arg_expr);
                if (!ok) {
                    return false;
                }
            }

            compiler_emit(comp, OPCODE_CALL, 1, (uint64_t[]){ptrarray_count(expr->call_expr.args)});
            break;
        }
        case EXPRESSION_ASSIGN: {
            const assign_expression_t *assign = &expr->assign;
            if (assign->dest->type != EXPRESSION_IDENT && assign->dest->type != EXPRESSION_INDEX) {
                error_t *err = error_makef(ERROR_COMPILATION, assign->dest->pos,
                                          "Expression is not assignable.");
                ptrarray_add(comp->errors, err);
                return false;
            }

            ok = compile_expression(comp, assign->source);
            if (!ok) {
                return false;
            }

            compiler_emit(comp, OPCODE_DUP, 0, NULL);

            array_push(comp->src_positions_stack, &assign->dest->pos);
            if (assign->dest->type == EXPRESSION_IDENT) {
                const ident_t *ident = &assign->dest->ident;
                symbol_t *symbol = symbol_table_resolve(symbol_table, ident->value);
                if (!symbol) {
                    error_t *err = error_makef(ERROR_COMPILATION, assign->dest->pos,
                                              "Symbol \"%s\" could not be resolved", ident->value);
                    ptrarray_add(comp->errors, err);
                    return false;
                }
                if (!symbol->assignable) {
                    error_t *err = error_makef(ERROR_COMPILATION, assign->dest->pos,
                                              "Symbol \"%s\" is not assignable", ident->value);
                    ptrarray_add(comp->errors, err);
                    return false;
                }
                write_symbol(comp, symbol, false);
            } else if (assign->dest->type == EXPRESSION_INDEX) {
                const index_expression_t *index = &assign->dest->index_expr;
                ok = compile_expression(comp, index->left);
                if (!ok) {
                    return false;
                }
                ok = compile_expression(comp, index->index);
                if (!ok) {
                    return false;
                }
                compiler_emit(comp, OPCODE_SET_INDEX, 0, NULL);
            }
            array_pop(comp->src_positions_stack, NULL);
            break;
        }
        case EXPRESSION_LOGICAL: {
            const logical_expression_t* logi = &expr->logical;

            ok = compile_expression(comp, logi->left);
            if (!ok) {
                return false;
            }

            compiler_emit(comp, OPCODE_DUP, 0, NULL);

            int after_left_jump_ip = 0;
            if (logi->op == OPERATOR_LOGICAL_AND) {
                after_left_jump_ip = compiler_emit(comp, OPCODE_JUMP_IF_FALSE, 1, (uint64_t[]){0xbeef});
            } else {
                after_left_jump_ip = compiler_emit(comp, OPCODE_JUMP_IF_TRUE, 1, (uint64_t[]){0xbeef});
            }

            compiler_emit(comp, OPCODE_POP, 0, NULL);

            ok = compile_expression(comp, logi->right);
            if (!ok) {
                return false;
            }

            int after_right_ip = get_ip(comp);
            change_uint16_operand(comp, after_left_jump_ip + 1, after_right_ip);

            break;
        }
        default: {
            APE_ASSERT(false);
            break;
        }
    }
    array_pop(comp->src_positions_stack, NULL);
    return true;
}

static bool compile_code_block(compiler_t *comp, const code_block_t *block) {
    symbol_table_t *symbol_table = compiler_get_symbol_table(comp);
    symbol_table_push_block_scope(symbol_table);
    if (ptrarray_count(block->statements) == 0) {
        compiler_emit(comp, OPCODE_NULL, 0, NULL);
        compiler_emit(comp, OPCODE_POP, 0, NULL);
    }
    for (int i = 0; i < ptrarray_count(block->statements); i++) {
        const statement_t *stmt = ptrarray_get(block->statements, i);
        bool ok = compile_statement(comp, stmt);
        if (!ok) {
            return false;
        }
    }
    symbol_table_pop_block_scope(symbol_table);
    return true;
}

static int add_constant(compiler_t *comp, object_t obj) {
    array_add(comp->constants, &obj);
    int pos = array_count(comp->constants) - 1;
    return pos;
}

int compiler_emit(compiler_t *comp, opcode_t op, int operands_count, uint64_t *operands) {
    int ip = get_ip(comp);
    int len = code_make(op, operands_count, operands, get_bytecode(comp));
    for (int i = 0; i < len; i++) {
        src_pos_t *src_pos = array_top(comp->src_positions_stack);
        APE_ASSERT(src_pos->line >= 0);
        APE_ASSERT(src_pos->column >= 0);
        array_add(get_src_positions(comp), src_pos);
    }
    compilation_scope_t *compilation_scope = compiler_get_compilation_scope(comp);
    compilation_scope->last_opcode = op;
    return ip;
}

static void change_uint16_operand(compiler_t *comp, int ip, uint16_t operand) {
    array(uint8_t) *bytecode = get_bytecode(comp);
    if ((ip + 1) >= array_count(bytecode)) {
        APE_ASSERT(false);
        return;
    }
    uint8_t hi = operand >> 8;
    array_set(bytecode, ip, &hi);
    uint8_t lo = operand;
    array_set(bytecode, ip + 1, &lo);
}

static bool last_opcode_is(compiler_t *comp, opcode_t op) {
    opcode_t last_opcode = compiler_last_opcode(comp);
    return last_opcode == op;
}

static void read_symbol(compiler_t *comp, symbol_t *symbol) {
    if (symbol->type == SYMBOL_GLOBAL) {
        compiler_emit(comp, OPCODE_GET_GLOBAL, 1, (uint64_t[]){symbol->index});
    } else if (symbol->type == SYMBOL_NATIVE_FUNCTION) {
        compiler_emit(comp, OPCODE_GET_NATIVE_FUNCTION, 1, (uint64_t[]){symbol->index});
    } else if (symbol->type == SYMBOL_LOCAL) {
        compiler_emit(comp, OPCODE_GET_LOCAL, 1, (uint64_t[]){symbol->index});
    } else if (symbol->type == SYMBOL_FREE) {
        compiler_emit(comp, OPCODE_GET_FREE, 1, (uint64_t[]){symbol->index});
    } else if (symbol->type == SYMBOL_FUNCTION) {
        compiler_emit(comp, OPCODE_CURRENT_FUNCTION, 0, NULL);
    } else if (symbol->type == SYMBOL_THIS) {
        compiler_emit(comp, OPCODE_GET_THIS, 0, NULL);
    }
}

static void write_symbol(compiler_t *comp, symbol_t *symbol, bool define) {
    if (symbol->type == SYMBOL_GLOBAL) {
        if (define) {
            compiler_emit(comp, OPCODE_DEFINE_GLOBAL, 1, (uint64_t[]){symbol->index});
        } else {
            compiler_emit(comp, OPCODE_SET_GLOBAL, 1, (uint64_t[]){symbol->index});
        }
    } else if (symbol->type == SYMBOL_LOCAL) {
        if (define) {
            compiler_emit(comp, OPCODE_DEFINE_LOCAL, 1, (uint64_t[]){symbol->index});
        } else {
            compiler_emit(comp, OPCODE_SET_LOCAL, 1, (uint64_t[]){symbol->index});
        }
    } else if (symbol->type == SYMBOL_FREE) {
        compiler_emit(comp, OPCODE_SET_FREE, 1, (uint64_t[]){symbol->index});
    }
}

static void push_break_ip(compiler_t *comp, int ip) {
    array_push(comp->break_ip_stack, &ip);
}

static void pop_break_ip(compiler_t *comp) {
    if (array_count(comp->break_ip_stack) == 0) {
        APE_ASSERT(false);
        return;
    }
    array_pop(comp->break_ip_stack, NULL);
}

static int get_break_ip(compiler_t *comp) {
    if (array_count(comp->break_ip_stack) == 0) {
        APE_ASSERT(false);
        return -1;
    }
    int *res = array_top(comp->break_ip_stack);
    return *res;
}

static void push_continue_ip(compiler_t *comp, int ip) {
    array_push(comp->continue_ip_stack, &ip);
}

static void pop_continue_ip(compiler_t *comp) {
    if (array_count(comp->continue_ip_stack) == 0) {
        APE_ASSERT(false);
        return;
    }
    array_pop(comp->continue_ip_stack, NULL);
}

static int get_continue_ip(compiler_t *comp) {
    if (array_count(comp->continue_ip_stack) == 0) {
        return -1;
    }
    int *res = array_top(comp->continue_ip_stack);
    return *res;
}

static int get_ip(compiler_t *comp) {
    compilation_scope_t *compilation_scope = compiler_get_compilation_scope(comp);
    return array_count(compilation_scope->bytecode);
}

static array(src_pos_t)* get_src_positions(compiler_t *comp) {
    compilation_scope_t *compilation_scope = compiler_get_compilation_scope(comp);
    return compilation_scope->src_positions;
}

static array(uint8_t)* get_bytecode(compiler_t *comp) {
    compilation_scope_t *compilation_scope = compiler_get_compilation_scope(comp);
    return compilation_scope->bytecode;
}

static void push_file_scope(compiler_t *comp, const char *filepath, module_t *module) {
    symbol_table_t *prev_st = NULL;
    if (ptrarray_count(comp->file_scopes) > 0) {
        prev_st = compiler_get_symbol_table(comp);
    }
    file_scope_t *file_scope = ape_malloc(sizeof(file_scope_t), ape_mallocArg);
    memset(file_scope, 0, sizeof(file_scope_t));
    file_scope->parser = parser_make(comp->config, comp->errors);
    file_scope->symbol_table = NULL;
    file_scope->module = module;
    file_scope->file = compiled_file_make(filepath);
    ptrarray_add(comp->files, file_scope->file);
    file_scope->loaded_module_names = ptrarray_make();

    ptrarray_push(comp->file_scopes, file_scope);
    compiler_push_symbol_table(comp);

    if (prev_st) {
        block_scope_t *prev_st_top_scope = symbol_table_get_block_scope(prev_st);
        symbol_table_t *new_st = compiler_get_symbol_table(comp);
        block_scope_t *new_st_top_scope = symbol_table_get_block_scope(new_st);
        new_st_top_scope->offset = prev_st_top_scope->offset + prev_st_top_scope->num_definitions;
    }
}

static void pop_file_scope(compiler_t *comp) {
    symbol_table_t *popped_st = compiler_get_symbol_table(comp);
    block_scope_t *popped_st_top_scope = symbol_table_get_block_scope(popped_st);
    int popped_num_defs = popped_st_top_scope->num_definitions;

    file_scope_t *scope = ptrarray_top(comp->file_scopes);
    if (!scope) {
        APE_ASSERT(false);
        return;
    }
    while (compiler_get_symbol_table(comp)) {
        compiler_pop_symbol_table(comp);
    }
    ptrarray_destroy_with_items(scope->loaded_module_names, ape_free);
    scope->loaded_module_names = NULL;

    parser_destroy(scope->parser);

    ape_free(scope, ape_freeArg);
    ptrarray_pop(comp->file_scopes);

    if (ptrarray_count(comp->file_scopes) > 0) {
        symbol_table_t *current_st = compiler_get_symbol_table(comp);
        block_scope_t *current_st_top_scope = symbol_table_get_block_scope(current_st);
        current_st_top_scope->num_definitions += popped_num_defs;
    }
}

static void set_compilation_scope(compiler_t *comp, compilation_scope_t *scope) {
    comp->compilation_scope = scope;
}

static module_t* get_current_module(compiler_t *comp) {
    file_scope_t *scope = ptrarray_top(comp->file_scopes);
    return scope->module;
}

static module_t* module_make(const char *name) {
    module_t *module = ape_malloc(sizeof(module_t), ape_mallocArg);
    module->name = ape_strdup(name);
    module->symbols = ptrarray_make();
    return module;
}

static void module_destroy(module_t *module) {
    ape_free(module->name, ape_freeArg);
    ptrarray_destroy_with_items(module->symbols, symbol_destroy);
    ape_free(module, ape_freeArg);
}

static void module_add_symbol(module_t *module, const symbol_t *symbol) {
    strbuf_t *name_buf = strbuf_make();
    strbuf_appendf(name_buf, "%s::%s", module->name, symbol->name);
    symbol_t *module_symbol = symbol_make(strbuf_get_string(name_buf), SYMBOL_GLOBAL, symbol->index, false);
    strbuf_destroy(name_buf);
    ptrarray_add(module->symbols, module_symbol);
}

static compiled_file_t* compiled_file_make(const char *path) {
    compiled_file_t *file = ape_malloc(sizeof(compiled_file_t), ape_mallocArg);
    const char *last_slash_pos = strrchr(path, '/');
    if (last_slash_pos) {
        size_t len = last_slash_pos - path + 1;
        file->dir_path = ape_strndup(path, len);
    } else {
        file->dir_path = ape_strdup("");
    }
    file->path = ape_strdup(path);
    file->lines = ptrarray_make();
    return file;
}

static void compiled_file_destroy(compiled_file_t *file) {
    if (!file) {
        return;
    }
    ptrarray_destroy_with_items(file->lines, ape_free);
    ape_free(file->dir_path, ape_freeArg);
    ape_free(file->path, ape_freeArg);
    ape_free(file, ape_freeArg);
}

static const char* get_module_name(const char *path) {
    const char *last_slash_pos = strrchr(path, '/');
    if (last_slash_pos) {
        return last_slash_pos + 1;
    }
    return path;
}

static symbol_t* define_symbol(compiler_t *comp, src_pos_t pos, const char *name, bool assignable, bool can_shadow) {
    symbol_table_t *symbol_table = compiler_get_symbol_table(comp);
    if (!can_shadow && !symbol_table_is_top_global_scope(symbol_table)) {
        symbol_t *current_symbol = symbol_table_resolve(symbol_table, name);
        if (current_symbol) {
            error_t *err = error_makef(ERROR_COMPILATION, pos, "Symbol \"%s\" is already defined", name);
            ptrarray_add(comp->errors, err);
            return NULL;
        }
    }

    symbol_t *symbol = symbol_table_define(symbol_table, name, assignable);
    if (!symbol) {
        error_t *err = error_makef(ERROR_COMPILATION, pos, "Cannot define symbol \"%s\"", name);
        ptrarray_add(comp->errors, err);
        return false;
    }

    return symbol;
}

static bool is_comparison(operator_t op) {
    switch (op) {
        case OPERATOR_EQ:
        case OPERATOR_NOT_EQ:
        case OPERATOR_GT:
        case OPERATOR_GTE:
        case OPERATOR_LT:
        case OPERATOR_LTE:
            return true;
        default:
            return false;
    }
    return false;
}
//FILE_END
//FILE_START:object.c
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <float.h>
#include <math.h>

#ifndef APE_AMALGAMATED
#include "object.h"
#include "code.h"
#include "compiler.h"
#include "traceback.h"
#include "gc.h"
#endif

#define OBJECT_PATTERN          0xfff8000000000000
#define OBJECT_HEADER_MASK      0xffff000000000000
#define OBJECT_ALLOCATED_HEADER 0xfffc000000000000
#define OBJECT_BOOL_HEADER      0xfff9000000000000
#define OBJECT_NULL_PATTERN     0xfffa000000000000

static object_t object_make(object_type_t type, object_data_t *data);
static object_t object_deep_copy_internal(gcmem_t *mem, object_t obj, valdict(object_t, object_t) *copies);
static bool object_equals_wrapped(const object_t *a, const object_t *b);
static unsigned long object_hash(object_t *obj_ptr);
static unsigned long object_hash_string(const char *str);
static unsigned long object_hash_double(double val);
static bool object_is_number(object_t obj);
static uint64_t get_type_tag(object_type_t type);
static bool freevals_are_allocated(function_t *fun);

object_t object_make_number(double val) {
    object_t o = { .number = val };
    if ((o.handle & OBJECT_PATTERN) == OBJECT_PATTERN) {
        o.handle = 0x7ff8000000000000;
    }
    return o;
}

object_t object_make_bool(bool val) {
    return (object_t) { .handle = OBJECT_BOOL_HEADER | val };
}

object_t object_make_null() {
    return (object_t) { .handle = OBJECT_NULL_PATTERN };
}

object_t object_make_string(gcmem_t *mem, const char *string) {
    object_data_t *obj = gcmem_alloc_object_data(mem, OBJECT_STRING);
    int len = (int)strlen(string);
    if ((len + 1) < OBJECT_STRING_BUF_SIZE) {
        memcpy(obj->string.value_buf, string, len + 1);
        obj->string.is_allocated = false;
    } else {
        obj->string.value_allocated = ape_strdup(string);
        obj->string.is_allocated = true;
    }
    obj->string.hash = object_hash_string(string);
    return object_make(OBJECT_STRING, obj);
}

object_t object_make_string_no_copy(gcmem_t *mem, char *string) {
    object_data_t *obj = gcmem_alloc_object_data(mem, OBJECT_STRING);
    int len = (int)strlen(string);
    if ((len + 1) < OBJECT_STRING_BUF_SIZE) {
        memcpy(obj->string.value_buf, string, len + 1);
        obj->string.hash = object_hash_string(string);
        ape_free(string, ape_freeArg);
        obj->string.is_allocated = false;
    } else {
        obj->string.hash = object_hash_string(string);
        obj->string.value_allocated = string;
        obj->string.is_allocated = true;
    }

    return object_make(OBJECT_STRING, obj);
}

object_t object_make_stringf(gcmem_t *mem, const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    int to_write = vsnprintf(NULL, 0, fmt, args);
    va_end(args);
    va_start(args, fmt);
    char *res = (char*)ape_malloc(to_write + 1, ape_mallocArg);
    int written = vsprintf(res, fmt, args);
    (void)written;
    APE_ASSERT(written == to_write);
    va_end(args);
    return object_make_string_no_copy(mem, res);
}

object_t object_make_native_function(gcmem_t *mem, const char *name, native_fn fn, void *data) {
    object_data_t *obj = gcmem_alloc_object_data(mem, OBJECT_NATIVE_FUNCTION);
    obj->native_function.name = ape_strdup(name);
    obj->native_function.fn = fn;
    obj->native_function.data = data;
    return object_make(OBJECT_NATIVE_FUNCTION, obj);
}

object_t object_make_array(gcmem_t *mem) {
    return object_make_array_with_capacity(mem, 8);
}

object_t object_make_array_with_capacity(gcmem_t *mem, unsigned capacity) {
    array(object_t) *arr = array_make_with_capacity(capacity, sizeof(object_t));
    return object_make_array_with_array(mem, arr);
}

object_t object_make_array_with_array(gcmem_t *mem, array(object_t) *array) {
    object_data_t *data = gcmem_alloc_object_data(mem, OBJECT_ARRAY);
    data->array = array;
    return object_make(OBJECT_ARRAY, data);
}

object_t object_make_map(gcmem_t *mem) {
    return object_make_map_with_capacity(mem, 32);
}

object_t object_make_map_with_capacity(gcmem_t *mem, unsigned capacity) {
    object_data_t *data = gcmem_alloc_object_data(mem, OBJECT_MAP);
    data->map = valdict_make_with_capacity(capacity, sizeof(object_t), sizeof(object_t));
    valdict_set_hash_function(data->map, (collections_hash_fn)object_hash);
    valdict_set_equals_function(data->map, (collections_equals_fn)object_equals_wrapped);
    return object_make(OBJECT_MAP, data);
}

object_t object_make_error(gcmem_t *mem, const char *error) {
    return object_make_error_no_copy(mem, ape_strdup(error));
}

object_t object_make_error_no_copy(gcmem_t *mem, char *error) {
    object_data_t *data = gcmem_alloc_object_data(mem, OBJECT_ERROR);
    data->error.message = error;
    data->error.traceback = NULL;
    return object_make(OBJECT_ERROR, data);
}

object_t object_make_errorf(gcmem_t *mem, const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    int to_write = vsnprintf(NULL, 0, fmt, args);
    va_end(args);
    va_start(args, fmt);
    char *res = (char*)ape_malloc(to_write + 1, ape_mallocArg);
    int written = vsprintf(res, fmt, args);
    (void)written;
    APE_ASSERT(written == to_write);
    va_end(args);
    return object_make_error_no_copy(mem, res);
}

object_t object_make_function(gcmem_t *mem, const char *name, compilation_result_t *comp_res, bool owns_data,
                              int num_locals, int num_args,
                              int free_vals_count) {
    object_data_t *obj = gcmem_alloc_object_data(mem, OBJECT_FUNCTION);
    if (owns_data) {
        obj->function.name = name ? ape_strdup(name) : ape_strdup("anonymous");
    } else {
        obj->function.const_name = name ? name : "anonymous";
    }
    obj->function.comp_result = comp_res;
    obj->function.owns_data = owns_data;
    obj->function.num_locals = num_locals;
    obj->function.num_args = num_args;
    obj->function.free_vals_count = free_vals_count;
    if (free_vals_count >= APE_ARRAY_LEN(obj->function.free_vals_buf)) {
        obj->function.free_vals_allocated = ape_malloc(sizeof(object_t) * free_vals_count, ape_mallocArg);
    }
    return object_make(OBJECT_FUNCTION, obj);
}

object_t object_make_external(gcmem_t *mem, void *data) {
    object_data_t *obj = gcmem_alloc_object_data(mem, OBJECT_EXTERNAL);
    obj->external.data = data;
    obj->external.data_destroy_fn = NULL;
    obj->external.data_copy_fn = NULL;
    return object_make(OBJECT_EXTERNAL, obj);
}

void object_deinit(object_t obj) {
    if (object_is_allocated(obj)) {
        object_data_t *data = object_get_allocated_data(obj);
        object_data_deinit(data);
    }
}

void object_data_deinit(object_data_t *data) {
    switch (data->type) {
        case OBJECT_FREED: {
            APE_ASSERT(false);
            return;
        }
        case OBJECT_STRING: {
            if (data->string.is_allocated) {
                ape_free(data->string.value_allocated, ape_freeArg);
            }
            break;
        }
        case OBJECT_FUNCTION: {
            if (data->function.owns_data) {
                ape_free(data->function.name, ape_freeArg);
                compilation_result_destroy(data->function.comp_result);
            }
            if (freevals_are_allocated(&data->function)) {
                ape_free(data->function.free_vals_allocated, ape_freeArg);
            }
            break;
        }
        case OBJECT_ARRAY: {
            array_destroy(data->array);
            break;
        }
        case OBJECT_MAP: {
            valdict_destroy(data->map);
            break;
        }
        case OBJECT_NATIVE_FUNCTION: {
            ape_free(data->native_function.name, ape_freeArg);
            break;
        }
        case OBJECT_EXTERNAL: {
            if (data->external.data_destroy_fn) {
                data->external.data_destroy_fn(data->external.data);
            }
            break;
        }
        case OBJECT_ERROR: {
            ape_free(data->error.message, ape_freeArg);
            traceback_destroy(data->error.traceback);
            break;
        }
        default: {
            break;
        }
    }
    data->type = OBJECT_FREED;
}

bool object_is_allocated(object_t object) {
    return (object.handle & OBJECT_ALLOCATED_HEADER) == OBJECT_ALLOCATED_HEADER;
}

gcmem_t* object_get_mem(object_t obj) {
    object_data_t *data = object_get_allocated_data(obj);
    return data->mem;
}

bool object_is_hashable(object_t obj) {
    object_type_t type = object_get_type(obj);
    switch (type) {
        case OBJECT_STRING: return true;
        case OBJECT_NUMBER: return true;
        case OBJECT_BOOL: return true;
        default: return false;
    }
}

void object_to_string(object_t obj, strbuf_t *buf, bool quote_str) {
    object_type_t type = object_get_type(obj);
    switch (type) {
        case OBJECT_FREED: {
            strbuf_append(buf, "FREED");
            break;
        }
        case OBJECT_NONE: {
            strbuf_append(buf, "NONE");
            break;
        }
        case OBJECT_NUMBER: {
            double number = object_get_number(obj);
            strbuf_appendf(buf, "%1.10g", number);
            break;
        }
        case OBJECT_BOOL: {
            strbuf_append(buf, object_get_bool(obj) ? "true" : "false");
            break;
        }
        case OBJECT_STRING: {
            const char *string = object_get_string(obj);
            if (quote_str) {
                strbuf_appendf(buf, "\"%s\"", string);
            } else {
                strbuf_append(buf, string);
            }
            break;
        }
        case OBJECT_NULL: {
            strbuf_append(buf, "null");
            break;
        }
        case OBJECT_FUNCTION: {
            const function_t *function = object_get_function(obj);
            strbuf_appendf(buf, "CompiledFunction: %s\n", object_get_function_name(obj));
            code_to_string(function->comp_result->bytecode, function->comp_result->src_positions, function->comp_result->count, buf);
            break;
        }
        case OBJECT_ARRAY: {
            strbuf_append(buf, "[");
            for (int i = 0; i < object_get_array_length(obj); i++) {
                object_t iobj = object_get_array_value_at(obj, i);
                object_to_string(iobj, buf, true);
                if (i < (object_get_array_length(obj) - 1)) {
                    strbuf_append(buf, ", ");
                }
            }
            strbuf_append(buf, "]");
            break;
        }
        case OBJECT_MAP: {
            strbuf_append(buf, "{");
            for (int i = 0; i < object_get_map_length(obj); i++) {
                object_t key = object_get_map_key_at(obj, i);
                object_t val = object_get_map_value_at(obj, i);
                object_to_string(key, buf, true);
                strbuf_append(buf, ": ");
                object_to_string(val, buf, true);
                if (i < (object_get_map_length(obj) - 1)) {
                    strbuf_append(buf, ", ");
                }
            }
            strbuf_append(buf, "}");
            break;
        }
        case OBJECT_NATIVE_FUNCTION: {
            strbuf_append(buf, "NATIVE_FUNCTION");
            break;
        }
        case OBJECT_EXTERNAL: {
            strbuf_append(buf, "EXTERNAL");
            break;
        }
        case OBJECT_ERROR: {
            strbuf_appendf(buf, "ERROR: %s\n", object_get_error_message(obj));
            traceback_t *traceback = object_get_error_traceback(obj);
            APE_ASSERT(traceback);
            if (traceback) {
                strbuf_append(buf, "Traceback:\n");
                traceback_to_string(traceback, buf);
            }
            break;
        }
        case OBJECT_ANY: {
            APE_ASSERT(false);
        }
    }
}

const char *object_get_type_name(const object_type_t type) {
    switch (type) {
        case OBJECT_NONE:            return "NONE";
        case OBJECT_FREED:           return "NONE";
        case OBJECT_NUMBER:          return "NUMBER";
        case OBJECT_BOOL:            return "BOOL";
        case OBJECT_STRING:          return "STRING";
        case OBJECT_NULL:            return "NULL";
        case OBJECT_NATIVE_FUNCTION: return "NATIVE_FUNCTION";
        case OBJECT_ARRAY:           return "ARRAY";
        case OBJECT_MAP:             return "MAP";
        case OBJECT_FUNCTION:        return "FUNCTION";
        case OBJECT_EXTERNAL:        return "EXTERNAL";
        case OBJECT_ERROR:           return "ERROR";
        case OBJECT_ANY:             return "ANY";
    }
    return "NONE";
}

char* object_serialize(object_t object) {
    strbuf_t *buf = strbuf_make();
    object_to_string(object, buf, true);
    char *string = strbuf_get_string_and_destroy(buf);
    return string;
}

object_t object_deep_copy(gcmem_t *mem, object_t obj) {
    valdict(object_t, object_t) *copies = valdict_make(object_t, object_t);
    object_t res = object_deep_copy_internal(mem, obj, copies);
    valdict_destroy(copies);
    return res;
}

object_t object_copy(gcmem_t *mem, object_t obj) {
    object_t copy = object_make_null();
    object_type_t type = object_get_type(obj);
    switch (type) {
        case OBJECT_ANY:
        case OBJECT_FREED:
        case OBJECT_NONE: {
            APE_ASSERT(false);
            copy = object_make_null();
            break;
        }
        case OBJECT_NUMBER:
        case OBJECT_BOOL:
        case OBJECT_NULL:
        case OBJECT_FUNCTION:
        case OBJECT_NATIVE_FUNCTION:
        case OBJECT_ERROR: {
            copy = obj;
            break;
        }
        case OBJECT_STRING: {
            const char *str = object_get_string(obj);
            copy = object_make_string(mem, str);
            break;
        }
        case OBJECT_ARRAY: {
            array(object_t) *array = object_get_array(obj);
            array(object_t) *res_array = array_make(object_t);
            for (int i = 0; i < array_count(array); i++) {
                object_t *array_obj = array_get(array, i);
                array_add(res_array, array_obj);
            }
            copy = object_make_array_with_array(mem, res_array);
            break;
        }
        case OBJECT_MAP: {
            copy = object_make_map(mem);
            for (int i = 0; i < object_get_map_length(obj); i++) {
                object_t key = object_get_map_key_at(obj, i);
                object_t val = object_get_map_value_at(obj, i);
                object_set_map_value(copy, key, val);
            }
            break;
        }
        case OBJECT_EXTERNAL: {
            external_data_t *external = object_get_external_data(obj);
            void *data_copy = NULL;
            if (external->data_copy_fn) {
                data_copy = external->data_copy_fn(external->data);
            } else {
                data_copy = external->data;
            }
            copy = object_make_external(mem, data_copy);
            object_set_external_destroy_function(copy, external->data_destroy_fn);
            object_set_external_copy_function(copy, external->data_copy_fn);
            break;
        }
    }
    return copy;
}

double object_compare(object_t a, object_t b) {
    if (a.handle == b.handle) {
        return 0;
    }

    object_type_t a_type = object_get_type(a);
    object_type_t b_type = object_get_type(b);

    if ((a_type == OBJECT_NUMBER || a_type == OBJECT_BOOL || a_type == OBJECT_NULL)
        && (b_type == OBJECT_NUMBER || b_type == OBJECT_BOOL || b_type == OBJECT_NULL)) {
        double left_val = object_get_number(a);
        double right_val = object_get_number(b);
        return left_val - right_val;
    } else if (a_type == b_type && a_type == OBJECT_STRING) {
        const char *left_string = object_get_string(a);
        const char *right_string = object_get_string(b);
        return strcmp(left_string, right_string);
    } else {
        intptr_t a_data_val = (intptr_t)object_get_allocated_data(a);
        intptr_t b_data_val = (intptr_t)object_get_allocated_data(b);
        return (double)(a_data_val - b_data_val);
    }
}

bool object_equals(object_t a, object_t b) {
    object_type_t a_type = object_get_type(a);
    object_type_t b_type = object_get_type(b);

    if (a_type != b_type) {
        return false;
    }
    double res = object_compare(a, b);
    return APE_DBLEQ(res, 0);
}

external_data_t* object_get_external_data(object_t object) {
    APE_ASSERT(object_get_type(object) == OBJECT_EXTERNAL);
    object_data_t *data = object_get_allocated_data(object);
    return &data->external;
}

bool object_set_external_destroy_function(object_t object, external_data_destroy_fn destroy_fn) {
    APE_ASSERT(object_get_type(object) == OBJECT_EXTERNAL);
    external_data_t* data = object_get_external_data(object);
    if (!data) {
        return false;
    }
    data->data_destroy_fn = destroy_fn;
    return true;
}

object_data_t* object_get_allocated_data(object_t object) {
    APE_ASSERT(object_is_allocated(object) || object_get_type(object) == OBJECT_NULL);
    return (object_data_t*)(object.handle & ~OBJECT_HEADER_MASK);
}

bool object_get_bool(object_t obj) {
    if (object_is_number(obj)) {
        return obj.handle;
    }
    return obj.handle & (~OBJECT_HEADER_MASK);
}

double object_get_number(object_t obj) {
    if (object_is_number(obj)) { // todo: optimise? always return number?
        return obj.number;
    }
    return obj.handle & (~OBJECT_HEADER_MASK);
}

const char * object_get_string(object_t object) {
    APE_ASSERT(object_get_type(object) == OBJECT_STRING);
    object_data_t *data = object_get_allocated_data(object);
    if (data->string.is_allocated) {
        return data->string.value_allocated;
    } else {
        return data->string.value_buf;
    }
}

function_t* object_get_function(object_t object) {
    APE_ASSERT(object_get_type(object) == OBJECT_FUNCTION);
    object_data_t *data = object_get_allocated_data(object);
    return &data->function;
}

native_function_t* object_get_native_function(object_t obj) {
    object_data_t *data = object_get_allocated_data(obj);
    return &data->native_function;
}

object_type_t object_get_type(object_t obj) {
    if (object_is_number(obj)) {
        return OBJECT_NUMBER;
    }
    uint64_t tag = (obj.handle >> 48) & 0x7;
    switch (tag) {
        case 0: return OBJECT_NONE;
        case 1: return OBJECT_BOOL;
        case 2: return OBJECT_NULL;
        case 4: {
            object_data_t *data = object_get_allocated_data(obj);
            return data->type;
        }
        default: return OBJECT_NONE;
    }
}

bool object_is_numeric(object_t obj) {
    object_type_t type = object_get_type(obj);
    return type == OBJECT_NUMBER || type == OBJECT_BOOL;
}

bool object_is_null(object_t obj) {
    return object_get_type(obj) == OBJECT_NULL;
}

bool object_is_callable(object_t obj) {
    object_type_t type = object_get_type(obj);
    return type == OBJECT_NATIVE_FUNCTION || type == OBJECT_FUNCTION;
}

const char* object_get_function_name(object_t obj) {
    APE_ASSERT(object_get_type(obj) == OBJECT_FUNCTION);
    object_data_t *data = object_get_allocated_data(obj);
    APE_ASSERT(data);
    if (!data) {
        return NULL;
    }

    if (data->function.owns_data) {
        return data->function.name;
    } else {
        return data->function.const_name;
    }
}

object_t object_get_function_free_val(object_t obj, int ix) {
    APE_ASSERT(object_get_type(obj) == OBJECT_FUNCTION);
    object_data_t *data = object_get_allocated_data(obj);
    APE_ASSERT(data);
    if (!data) {
        return object_make_null();
    }
    function_t *fun = &data->function;
    APE_ASSERT(ix >= 0 && ix < fun->free_vals_count);
    if (ix < 0 || ix >= fun->free_vals_count) {
        return object_make_null();
    }
    if (freevals_are_allocated(fun)) {
        return fun->free_vals_allocated[ix];
    } else {
        return fun->free_vals_buf[ix];
    }
}

void object_set_function_free_val(object_t obj, int ix, object_t val) {
    APE_ASSERT(object_get_type(obj) == OBJECT_FUNCTION);
    object_data_t *data = object_get_allocated_data(obj);
    APE_ASSERT(data);
    if (!data) {
        return;
    }
    function_t *fun = &data->function;
    APE_ASSERT(ix >= 0 && ix < fun->free_vals_count);
    if (ix < 0 || ix >= fun->free_vals_count) {
        return;
    }
    if (freevals_are_allocated(fun)) {
        fun->free_vals_allocated[ix] = val;
    } else {
        fun->free_vals_buf[ix] = val;
    }
}

object_t* object_get_function_free_vals(object_t obj) {
    APE_ASSERT(object_get_type(obj) == OBJECT_FUNCTION);
    object_data_t *data = object_get_allocated_data(obj);
    APE_ASSERT(data);
    if (!data) {
        return NULL;
    }
    function_t *fun = &data->function;
    if (freevals_are_allocated(fun)) {
        return fun->free_vals_allocated;
    } else {
        return fun->free_vals_buf;
    }
}

const char* object_get_error_message(object_t object) {
    APE_ASSERT(object_get_type(object) == OBJECT_ERROR);
    object_data_t *data = object_get_allocated_data(object);
    return data->error.message;
}

void object_set_error_traceback(object_t object, traceback_t *traceback) {
    APE_ASSERT(object_get_type(object) == OBJECT_ERROR);
    object_data_t *data = object_get_allocated_data(object);
    APE_ASSERT(data->error.traceback == NULL);
    data->error.traceback = traceback;
}

traceback_t* object_get_error_traceback(object_t object) {
    APE_ASSERT(object_get_type(object) == OBJECT_ERROR);
    object_data_t *data = object_get_allocated_data(object);
    return data->error.traceback;
}

bool object_set_external_copy_function(object_t object, external_data_copy_fn copy_fn) {
    APE_ASSERT(object_get_type(object) == OBJECT_EXTERNAL);
    external_data_t* data = object_get_external_data(object);
    if (!data) {
        return false;
    }
    data->data_copy_fn = copy_fn;
    return true;
}

array(object_t)* object_get_array(object_t object) {
    APE_ASSERT(object_get_type(object) == OBJECT_ARRAY);
    object_data_t *data = object_get_allocated_data(object);
    return data->array;
}

object_t object_get_array_value_at(object_t object, int ix) {
    APE_ASSERT(object_get_type(object) == OBJECT_ARRAY);
    array(object_t)* array = object_get_array(object);
    if (ix < 0 || ix >= array_count(array)) {
        return object_make_null();
    }
    object_t *res = array_get(array, ix);
    if (!res) {
        return object_make_null();
    }
    return *res;
}

bool object_set_array_value_at(object_t object, int ix, object_t val) {
    APE_ASSERT(object_get_type(object) == OBJECT_ARRAY);
    array(object_t)* array = object_get_array(object);
    if (ix < 0 || ix >= array_count(array)) {
        return false;
    }
    return array_set(array, ix, &val);
}

bool object_add_array_value(object_t object, object_t val) {
    APE_ASSERT(object_get_type(object) == OBJECT_ARRAY);
    array(object_t)* array = object_get_array(object);
    return array_add(array, &val);
}

int object_get_array_length(object_t object) {
    APE_ASSERT(object_get_type(object) == OBJECT_ARRAY);
    array(object_t)* array = object_get_array(object);
    return array_count(array);
}

int object_get_map_length(object_t object) {
    APE_ASSERT(object_get_type(object) == OBJECT_MAP);
    object_data_t *data = object_get_allocated_data(object);
    return valdict_count(data->map);
}

object_t object_get_map_key_at(object_t object, int ix) {
    APE_ASSERT(object_get_type(object) == OBJECT_MAP);
    object_data_t *data = object_get_allocated_data(object);
    object_t *res = valdict_get_key_at(data->map, ix);
    if (!res) {
        return object_make_null();
    }
    return *res;
}

object_t object_get_map_value_at(object_t object, int ix) {
    APE_ASSERT(object_get_type(object) == OBJECT_MAP);
    object_data_t *data = object_get_allocated_data(object);
    object_t *res = valdict_get_value_at(data->map, ix);
    if (!res) {
        return object_make_null();
    }
    return *res;
}

bool object_set_map_value_at(object_t object, int ix, object_t val) {
    APE_ASSERT(object_get_type(object) == OBJECT_MAP);
    if (ix >= object_get_map_length(object)) {
        return false;
    }
    object_data_t *data = object_get_allocated_data(object);
    bool res = valdict_set_value_at(data->map, ix, &val);
    return res;
}

object_t object_get_kv_pair_at(gcmem_t *mem, object_t object, int ix) {
    APE_ASSERT(object_get_type(object) == OBJECT_MAP);
    object_data_t *data = object_get_allocated_data(object);
    if (ix >= valdict_count(data->map)) {
        return object_make_null();
    }
    object_t key = object_get_map_key_at(object, ix);
    object_t val = object_get_map_value_at(object, ix);
    object_t res = object_make_map(mem);
    object_set_map_value(res, object_make_string(mem, "key"), key);
    object_set_map_value(res, object_make_string(mem, "value"), val);
    return res;
}

bool object_set_map_value(object_t object, object_t key, object_t val) {
    APE_ASSERT(object_get_type(object) == OBJECT_MAP);
    object_data_t *data = object_get_allocated_data(object);
    return valdict_set(data->map, &key, &val);
}

object_t object_get_map_value(object_t object, object_t key) {
    APE_ASSERT(object_get_type(object) == OBJECT_MAP);
    object_data_t *data = object_get_allocated_data(object);
    object_t *res = valdict_get(data->map, &key);
    if (!res) {
        return object_make_null();
    }
    return *res;
}

bool object_map_has_key(object_t object, object_t key) {
    APE_ASSERT(object_get_type(object) == OBJECT_MAP);
    object_data_t *data = object_get_allocated_data(object);
    object_t *res = valdict_get(data->map, &key);
    return res != NULL;
}

// INTERNAL
static object_t object_make(object_type_t type, object_data_t *data) {
    object_t object;
    object.handle = OBJECT_PATTERN;
    uint64_t type_tag = get_type_tag(type) & 0x7;
    object.handle |= (type_tag << 48);
    object.handle |= (uintptr_t)data; // assumes no pointer exceeds 48 bits
    return object;
}

static object_t object_deep_copy_internal(gcmem_t *mem, object_t obj, valdict(object_t, object_t) *copies) {
    object_t *copy_ptr = valdict_get(copies, &obj);
    if (copy_ptr) {
        return *copy_ptr;
    }

    object_t copy = object_make_null()  ;

    object_type_t type = object_get_type(obj);
    switch (type) {
        case OBJECT_FREED:
        case OBJECT_ANY:
        case OBJECT_NONE: {
            APE_ASSERT(false);
            copy = object_make_null();
            break;
        }
        case OBJECT_NUMBER:
        case OBJECT_BOOL:
        case OBJECT_NULL:
        case OBJECT_NATIVE_FUNCTION: {
            copy = obj;
            break;
        }
        case OBJECT_STRING: {
            const char *str = object_get_string(obj);
            copy = object_make_string(mem, str);
            break;
        }
        case OBJECT_FUNCTION: {
            function_t *function = object_get_function(obj);
            uint8_t *bytecode_copy = ape_malloc(sizeof(uint8_t) * function->comp_result->count, ape_mallocArg);
            memcpy(bytecode_copy, function->comp_result->bytecode, sizeof(uint8_t) * function->comp_result->count);
            src_pos_t *src_positions_copy = ape_malloc(sizeof(src_pos_t) * function->comp_result->count, ape_mallocArg);
            memcpy(src_positions_copy, function->comp_result->src_positions, sizeof(src_pos_t) * function->comp_result->count);
            compilation_result_t *comp_res_copy = compilation_result_make(bytecode_copy, src_positions_copy, function->comp_result->count);
            copy = object_make_function(mem, object_get_function_name(obj), comp_res_copy, true,
                                        function->num_locals, function->num_args, 0);
            valdict_set(copies, &obj, &copy);
            function_t *function_copy = object_get_function(copy);
            if (freevals_are_allocated(function)) {
                function_copy->free_vals_allocated = ape_malloc(sizeof(object_t) * function->free_vals_count, ape_mallocArg);
            }
            function_copy->free_vals_count = function->free_vals_count;
            for (int i = 0; i < function->free_vals_count; i++) {
                object_t free_val = object_get_function_free_val(obj, i);
                object_t free_val_copy = object_deep_copy_internal(mem, free_val, copies);
                object_set_function_free_val(copy, i, free_val_copy);
            }
            break;
        }
        case OBJECT_ARRAY: {
            array(object_t) *res_array = array_make(object_t);
            for (int i = 0; i < object_get_array_length(obj); i++) {
                object_t array_obj = object_get_array_value_at(obj, i);
                object_t copy = object_deep_copy_internal(mem, array_obj, copies);
                array_add(res_array, &copy);
            }
            copy = object_make_array_with_array(mem, res_array);
            valdict_set(copies, &obj, &copy);
            break;
        }
        case OBJECT_MAP: {
            copy = object_make_map(mem);
            valdict_set(copies, &obj, &copy);
            for (int i = 0; i < object_get_map_length(obj); i++) {
                object_t key = object_get_map_key_at(obj, i);
                object_t val = object_get_map_value_at(obj, i);
                object_t key_copy = object_deep_copy_internal(mem, key, copies);
                object_t val_copy = object_deep_copy_internal(mem, val, copies);
                object_set_map_value(copy, key_copy, val_copy);
            }
            break;
        }
        case OBJECT_EXTERNAL: {
            copy = object_copy(mem, obj);
            break;
        }
        case OBJECT_ERROR: {
            copy = obj;
            break;
        }
    }
    return copy;
}

static bool object_equals_wrapped(const object_t *a_ptr, const object_t *b_ptr) {
    object_t a = *a_ptr;
    object_t b = *b_ptr;
    return object_equals(a, b);
}

static unsigned long object_hash(object_t *obj_ptr) {
    object_t obj = *obj_ptr;
    object_type_t type = object_get_type(obj);

    switch (type) {
        case OBJECT_NUMBER: {
            double val = object_get_number(obj);
            return object_hash_double(val);
        }
        case OBJECT_BOOL: {
            bool val = object_get_bool(obj);
            return val;
        }
        case OBJECT_STRING: {
            object_data_t *data = object_get_allocated_data(obj);
            return data->string.hash;
        }
        default: {
            return 0;
        }
    }
}

static unsigned long object_hash_string(const char *str) { /* djb2 */
    unsigned long hash = 5381;
    int c;
    while ((c = *str++)) {
        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
    }
    return hash;
}

static unsigned long object_hash_double(double val) { /* djb2 */
    uint32_t *val_ptr = (uint32_t*)&val;
    unsigned long hash = 5381;
    hash = ((hash << 5) + hash) + val_ptr[0];
    hash = ((hash << 5) + hash) + val_ptr[1];
    return hash;
}

static bool object_is_number(object_t o) {
    return (o.handle & OBJECT_PATTERN) != OBJECT_PATTERN;
}

static uint64_t get_type_tag(object_type_t type) {
    switch (type) {
        case OBJECT_NONE: return 0;
        case OBJECT_BOOL: return 1;
        case OBJECT_NULL: return 2;
        default:          return 4;
    }
}

static bool freevals_are_allocated(function_t *fun) {
    return fun->free_vals_count >= APE_ARRAY_LEN(fun->free_vals_buf);
}
//FILE_END
//FILE_START:gc.c
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#ifndef APE_AMALGAMATED
#include "gc.h"
#include "object.h"
#endif

#define GCMEM_POOL_SIZE 1024

typedef struct gcmem {
    ptrarray(object_data_t) *objects;
    ptrarray(object_data_t) *objects_back;

    array(object_t) *objects_not_gced;

    object_data_t *pool[GCMEM_POOL_SIZE];
    int pool_index;
} gcmem_t;

gcmem_t *gcmem_make() {
    gcmem_t *mem = ape_malloc(sizeof(gcmem_t), ape_mallocArg);
    memset(mem, 0, sizeof(gcmem_t));
    mem->objects = ptrarray_make();
    mem->objects_back = ptrarray_make();
    mem->objects_not_gced = array_make(object_t);
    mem->pool_index = -1;
    return mem;
}

void gcmem_destroy(gcmem_t *mem) {
    if (!mem) {
        return;
    }
    for (int i = 0; i < ptrarray_count(mem->objects); i++) {
        object_data_t *obj = ptrarray_get(mem->objects, i);
        object_data_deinit(obj);
        ape_free(obj, ape_freeArg);
    }
    ptrarray_destroy(mem->objects);
    ptrarray_destroy(mem->objects_back);
    array_destroy(mem->objects_not_gced);
    for (int i = 0; i <= mem->pool_index; i++) {
        ape_free(mem->pool[i], ape_freeArg);
    }
    memset(mem, 0, sizeof(gcmem_t));
    ape_free(mem, ape_freeArg);
}

object_data_t* gcmem_alloc_object_data(gcmem_t *mem, object_type_t type) {
    object_data_t *data = NULL;
    if (mem->pool_index >= 0) {
        data = mem->pool[mem->pool_index];
        mem->pool_index--;
    } else {
        data = ape_malloc(sizeof(object_data_t), ape_mallocArg);
    }
    memset(data, 0, sizeof(object_data_t));
    ptrarray_add(mem->objects, data);
    data->mem = mem;
    data->type = type;
    return data;
}

void gc_unmark_all(gcmem_t *mem) {
    for (int i = 0; i < ptrarray_count(mem->objects); i++) {
        object_data_t *data = ptrarray_get(mem->objects, i);
        data->gcmark = false;
    }
}

void gc_mark_objects(object_t *objects, int count) {
    for (int i = 0; i < count; i++) {
        object_t obj = objects[i];
        gc_mark_object(obj);
    }
}

void gc_mark_object(object_t obj) {
    if (!object_is_allocated(obj)) {
        return;
    }
    object_data_t *data = object_get_allocated_data(obj);
    if (data->gcmark) {
        return;
    }

    data->gcmark = true;
    switch (data->type) {
        case OBJECT_MAP: {
            int len = object_get_map_length(obj);
            for (int i = 0; i < len; i++) {
                object_t key = object_get_map_key_at(obj, i);
                object_t val = object_get_map_value_at(obj, i);
                gc_mark_object(key);
                gc_mark_object(val);
            }
            break;
        }
        case OBJECT_ARRAY: {
            int len = object_get_array_length(obj);
            for (int i = 0; i < len; i++) {
                object_t val = object_get_array_value_at(obj, i);
                gc_mark_object(val);
            }
            break;
        }
        case OBJECT_FUNCTION: {
            function_t *function = object_get_function(obj);
            for (int i = 0; i < function->free_vals_count; i++) {
                object_t free_val = object_get_function_free_val(obj, i);
                gc_mark_object(free_val);
            }
            break;
        }
        default: {
            break;
        }
    }
}

void gc_sweep(gcmem_t *mem) {
    gc_mark_objects(array_data(mem->objects_not_gced), array_count(mem->objects_not_gced));

    ptrarray_clear(mem->objects_back);
    for (int i = 0; i < ptrarray_count(mem->objects); i++) {
        object_data_t *data = ptrarray_get(mem->objects, i);
        if (data->gcmark) {
            ptrarray_add(mem->objects_back, data);
        } else {
            object_data_deinit(data);
            if (mem->pool_index < (GCMEM_POOL_SIZE - 1)) {
                mem->pool_index++;
                mem->pool[mem->pool_index] = data;
            } else {
                ape_free(data, ape_freeArg);
            }
        }
    }
    ptrarray(object_t) *objs_temp = mem->objects;
    mem->objects = mem->objects_back;
    mem->objects_back = objs_temp;
}

void gc_disable_on_object(object_t obj) {
    if (!object_is_allocated(obj)) {
        return;
    }
    object_data_t *data = object_get_allocated_data(obj);
    if (array_contains(data->mem->objects_not_gced, &obj)) {
        return;
    }
    array_add(data->mem->objects_not_gced, &obj);
}

void gc_enable_on_object(object_t obj) {
    if (!object_is_allocated(obj)) {
        return;
    }
    object_data_t *data = object_get_allocated_data(obj);
    array_remove_item(data->mem->objects_not_gced, &obj);
}
//FILE_END
//FILE_START:builtins.c
#include <stdlib.h>
#include <stdio.h>

#ifndef APE_AMALGAMATED
#include "builtins.h"

#include "common.h"
#include "object.h"
#include "vm.h"
#endif

static object_t len_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t first_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t last_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t rest_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t reverse_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t array_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t append_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t remove_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t remove_at_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t println_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t print_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t read_file_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t write_file_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t to_str_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t char_to_str_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t range_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t keys_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t values_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t copy_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t deep_copy_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t concat_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t error_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t crash_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t assert_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t random_fn(vm_t *vm, void *data, int argc, object_t *args);

// Type checks
static object_t is_string_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t is_array_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t is_map_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t is_number_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t is_bool_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t is_null_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t is_function_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t is_external_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t is_error_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t is_native_function_fn(vm_t *vm, void *data, int argc, object_t *args);

// Math
static object_t sqrt_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t pow_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t sin_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t cos_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t tan_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t log_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t ceil_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t floor_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t abs_fn(vm_t *vm, void *data, int argc, object_t *args);

static bool check_args(vm_t *vm, bool generate_error, int argc, object_t *args, int expected_argc, object_type_t *expected_types);
#define CHECK_ARGS(vm, generate_error, argc, args, ...) \
    check_args(\
        (vm),\
        (generate_error),\
        (argc),\
        (args),\
        sizeof((object_type_t[]){__VA_ARGS__}) / sizeof(object_type_t),\
        (object_type_t[]){__VA_ARGS__})

static struct {
    const char *name;
    native_fn fn;
} g_native_functions[] = {
    {"len",         len_fn},
    {"println",     println_fn},
    {"print",       print_fn},
    {"read_file",   read_file_fn},
    {"write_file",  write_file_fn},
    {"first",       first_fn},
    {"last",        last_fn},
    {"rest",        rest_fn},
    {"append",      append_fn},
    {"remove",      remove_fn},
    {"remove_at",   remove_at_fn},
    {"to_str",      to_str_fn},
    {"range",       range_fn},
    {"keys",        keys_fn},
    {"values",      values_fn},
    {"copy",        copy_fn},
    {"deep_copy",   deep_copy_fn},
    {"concat",      concat_fn},
    {"char_to_str", char_to_str_fn},
    {"reverse",     reverse_fn},
    {"array",       array_fn},
    {"error",       error_fn},
    {"crash",       crash_fn},
    {"assert",      assert_fn},
    {"random",      random_fn},

    // Type checks
    {"is_string",   is_string_fn},
    {"is_array",    is_array_fn},
    {"is_map",      is_map_fn},
    {"is_number",   is_number_fn},
    {"is_bool",     is_bool_fn},
    {"is_null",     is_null_fn},
    {"is_function", is_function_fn},
    {"is_external", is_external_fn},
    {"is_error",    is_error_fn},
    {"is_native_function", is_native_function_fn},

    // Math
    {"sqrt",  sqrt_fn},
    {"pow",   pow_fn},
    {"sin",   sin_fn},
    {"cos",   cos_fn},
    {"tan",   tan_fn},
    {"log",   log_fn},
    {"ceil",  ceil_fn},
    {"floor", floor_fn},
    {"abs",   abs_fn},
};

int builtins_count() {
    return APE_ARRAY_LEN(g_native_functions);
}

native_fn builtins_get_fn(int ix) {
    return g_native_functions[ix].fn;
}

const char* builtins_get_name(int ix) {
    return g_native_functions[ix].name;
}

// INTERNAL
static object_t len_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_STRING | OBJECT_ARRAY | OBJECT_MAP)) {
        return object_make_null();
    }

    object_t arg = args[0];
    object_type_t type = object_get_type(arg);
    if (type == OBJECT_STRING) {
        const char *str = object_get_string(arg);
        int len = (int)strlen(str);
        return object_make_number(len);
    } else if (type == OBJECT_ARRAY) {
        int len = object_get_array_length(arg);
        return object_make_number(len);
    } else if (type == OBJECT_MAP) {
        int len = object_get_map_length(arg);
        return object_make_number(len);
    }

    return object_make_null();
}

static object_t first_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ARRAY)) {
        return object_make_null();
    }
     object_t arg = args[0];
    return object_get_array_value_at(arg, 0);
}

static object_t last_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ARRAY)) {
        return object_make_null();
    }
    object_t arg = args[0];
    return object_get_array_value_at(arg, object_get_array_length(arg) - 1);
}

static object_t rest_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ARRAY)) {
        return object_make_null();
    }
    object_t arg = args[0];
    int len = object_get_array_length(arg);
    if (len == 0) {
        return object_make_null();
    }

    object_t res = object_make_array(vm->mem);
    for (int i = 1; i < len; i++) {
        object_t item = object_get_array_value_at(arg, i);
        object_add_array_value(res, item);
    }

    return res;
}

static object_t reverse_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ARRAY | OBJECT_STRING)) {
        return object_make_null();
    }
    object_t arg = args[0];
    object_type_t type = object_get_type(arg);
    if (type == OBJECT_ARRAY) {
        array(object_t) *array = object_get_array(arg);
        array_reverse(array);
        return object_make_array_with_array(vm->mem, array);
    } else if (type == OBJECT_STRING) {
        const char *str = object_get_string(arg);
        int len = (int)strlen(str);
        char *res_buf = ape_malloc(len + 1, ape_mallocArg);
        for (int i = 0; i < len; i++) {
            res_buf[len - i - 1] = str[i];
        }
        res_buf[len] = '\0';
        return object_make_string_no_copy(vm->mem, res_buf);
    }
    return object_make_null();
}

static object_t array_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (argc == 1) {
        if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER)) {
            return object_make_null();
        }
        int capacity = (int)object_get_number(args[0]);
        array(object_t) *res_arr = array_make_with_capacity(capacity, sizeof(object_t));
        object_t obj_null = object_make_null();
        for (int i = 0; i < capacity; i++) {
            array_add(res_arr, &obj_null);
        }
        return object_make_array_with_array(vm->mem, res_arr);
    } else if (argc == 2) {
        if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER, OBJECT_ANY)) {
            return object_make_null();
        }
        int capacity = (int)object_get_number(args[0]);
        array(object_t) *res_arr = array_make_with_capacity(capacity, sizeof(object_t));
        for (int i = 0; i < capacity; i++) {
            array_add(res_arr, &args[1]);
        }
        return object_make_array_with_array(vm->mem, res_arr);
    }
    CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER);
    return object_make_null();
}

static object_t append_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ARRAY, OBJECT_ANY)) {
        return object_make_null();
    }
    object_add_array_value(args[0], args[1]);
    int len = object_get_array_length(args[0]);
    return object_make_number(len);
}

static object_t println_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;

    const ape_config_t *config = vm->config;

    if (!config->stdio.write.write) {
        return object_make_null(); // todo: runtime error?
    }

    strbuf_t *buf = strbuf_make();
    for (int i = 0; i < argc; i++) {
        object_t arg = args[i];
        object_to_string(arg, buf, false);
    }
    strbuf_append(buf, "\n");
    config->stdio.write.write(config->stdio.write.context, strbuf_get_string(buf), strbuf_get_length(buf));
    strbuf_destroy(buf);
    return object_make_null();
}

static object_t print_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    const ape_config_t *config = vm->config;

    if (!config->stdio.write.write) {
        return object_make_null(); // todo: runtime error?
    }

    strbuf_t *buf = strbuf_make();
    for (int i = 0; i < argc; i++) {
        object_t arg = args[i];
        object_to_string(arg, buf, false);
    }
    config->stdio.write.write(config->stdio.write.context, strbuf_get_string(buf), strbuf_get_length(buf));
    strbuf_destroy(buf);
    return object_make_null();
}

static object_t write_file_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_STRING, OBJECT_STRING)) {
        return object_make_null();
    }

    const ape_config_t *config = vm->config;

    if (!config->fileio.write_file.write_file) {
        return object_make_null();
    }

    const char *path = object_get_string(args[0]);
    const char *string = object_get_string(args[1]);
    int string_size = (int)strlen(string) + 1;

    int written = (int)config->fileio.write_file.write_file(config->fileio.write_file.context, path, string, string_size);

    return object_make_number(written);
}

static object_t read_file_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_STRING)) {
        return object_make_null();
    }

    const ape_config_t *config = vm->config;

    if (!config->fileio.read_file.read_file) {
        return object_make_null();
    }

    const char *path = object_get_string(args[0]);

    const char *contents = config->fileio.read_file.read_file(config->fileio.read_file.context, path);
    if (!contents) {
        return object_make_null();
    }

    return object_make_string(vm->mem, contents);
}

static object_t to_str_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_STRING | OBJECT_NUMBER | OBJECT_BOOL | OBJECT_NULL | OBJECT_MAP | OBJECT_ARRAY)) {
        return object_make_null();
    }
    object_t arg = args[0];
    strbuf_t *buf = strbuf_make();
    object_to_string(arg, buf, false);
    object_t res = object_make_string(vm->mem, strbuf_get_string(buf));
    strbuf_destroy(buf);
    return res;
}

static object_t char_to_str_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER)) {
        return object_make_null();
    }

    double val = object_get_number(args[0]);

    char c = (char)val;
    char str[2] = {c, '\0'};
    return object_make_string(vm->mem, str);
}

static object_t range_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    for (int i = 0; i < argc; i++) {
        object_type_t type = object_get_type(args[i]);
        if (type != OBJECT_NUMBER) {
            const char *type_str = object_get_type_name(type);
            const char *expected_str = object_get_type_name(OBJECT_NUMBER);
            error_t *err = error_makef(ERROR_RUNTIME, src_pos_invalid,
                                       "Invalid argument %d passed to range, got %s instead of %s",
                                       i, type_str, expected_str);
            vm_set_runtime_error(vm, err);
            return object_make_null();
        }
    }

    int start = 0;
    int end = 0;
    int step = 1;

    if (argc == 1) {
        end = object_get_number(args[0]);
    } else if (argc == 2) {
        start = object_get_number(args[0]);
        end = object_get_number(args[1]);
    } else if (argc == 3) {
        start = object_get_number(args[0]);
        end = object_get_number(args[1]);
        step = object_get_number(args[2]);
    } else {
        error_t *err = error_makef(ERROR_RUNTIME, src_pos_invalid, "Invalid number of arguments passed to range, got %d", argc);
        vm_set_runtime_error(vm, err);
        return object_make_null();
    }

    if (step == 0) {
        error_t *err = error_make(ERROR_RUNTIME, src_pos_invalid, "range step cannot be 0");
        vm_set_runtime_error(vm, err);
        return object_make_null();
    }

    object_t res = object_make_array(vm->mem);
    for (int i = start; i < end; i += step) {
        object_t item = object_make_number(i);
        object_add_array_value(res, item);
    }
    return res;
}

static object_t keys_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_MAP)) {
        return object_make_null();
    }
    object_t arg = args[0];
    object_t res = object_make_array(vm->mem);
    int len = object_get_map_length(arg);
    for (int i = 0; i < len; i++) {
        object_t key = object_get_map_key_at(arg, i);
        object_add_array_value(res, key);
    }
    return res;
}

static object_t values_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_MAP)) {
        return object_make_null();
    }
    object_t arg = args[0];
    object_t res = object_make_array(vm->mem);
    int len = object_get_map_length(arg);
    for (int i = 0; i < len; i++) {
        object_t key = object_get_map_value_at(arg, i);
        object_add_array_value(res, key);
    }
    return res;
}

static object_t copy_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_copy(vm->mem, args[0]);
}

static object_t deep_copy_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_deep_copy(vm->mem, args[0]);
}

static object_t concat_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ARRAY | OBJECT_STRING, OBJECT_ANY)) {
        return object_make_null();
    }
    object_type_t type = object_get_type(args[0]);
    object_type_t item_type = object_get_type(args[1]);
    if (type == OBJECT_ARRAY) {
        if (item_type != OBJECT_ARRAY) {
            const char *item_type_str = object_get_type_name(item_type);
            error_t *err = error_makef(ERROR_RUNTIME, src_pos_invalid,
                                       "Invalid argument 2 passed to concat, got %s",
                                       item_type_str);
            vm_set_runtime_error(vm, err);
            return object_make_null();
        }
        array(object_t) *arr = object_get_array(args[0]);
        array(object_t) *item_arr = object_get_array(args[1]);
        array_add_array(arr, item_arr);
        return object_make_number(array_count(arr));
    } else if (type == OBJECT_STRING) {
        if (!CHECK_ARGS(vm, true, argc, args, OBJECT_STRING, OBJECT_STRING)) {
            return object_make_null();
        }
        const char *str = object_get_string(args[0]);
        int len = (int)strlen(str);
        const char *arg_str = object_get_string(args[1]);
        int arg_str_len = (int)strlen(arg_str);
        char *res_buf = ape_malloc(len + arg_str_len + 1, ape_mallocArg);
        for (int i = 0; i < len; i++) {
            res_buf[i] = str[i];
        }
        for (int i = 0; i < arg_str_len; i++) {
            res_buf[len + i] = arg_str[i];
        }
        res_buf[len + arg_str_len] = '\0';
        return object_make_string_no_copy(vm->mem, res_buf);
    }
    return object_make_null();
}

static object_t assert_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_BOOL)) {
        return object_make_null();
    }

    if (!object_get_bool(args[0])) {
        error_t *err = error_make(ERROR_RUNTIME, src_pos_invalid, "assertion failed");
        vm_set_runtime_error(vm, err);
        return object_make_null();
    }

    return object_make_bool(true);
}

static object_t remove_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ARRAY, OBJECT_ANY)) {
        return object_make_null();
    }

    int ix = -1;
    for (int i = 0; i < object_get_array_length(args[0]); i++) {
        object_t obj = object_get_array_value_at(args[0], i);
        if (object_equals(obj, args[1])) {
            ix = i;
            break;
        }
    }

    if (ix == -1) {
        return object_make_bool(false);
    }

    array(object_t) *arr = object_get_array(args[0]);
    bool res = array_remove_at(arr, ix);
    return object_make_bool(res);
}

static object_t remove_at_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ARRAY, OBJECT_NUMBER)) {
        return object_make_null();
    }

    object_type_t type = object_get_type(args[0]);
    int ix = object_get_number(args[1]);

    switch (type) {
        case OBJECT_ARRAY: {
            array(object_t) *arr = object_get_array(args[0]);
            bool res = array_remove_at(arr, ix);
            return object_make_bool(res);
        }
        default:
            break;
    }

    return object_make_bool(true);
}


static object_t error_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (argc == 1 && object_get_type(args[0]) == OBJECT_STRING) {
        return object_make_error(vm->mem, object_get_string(args[0]));
    } else {
        return object_make_error(vm->mem, "");
    }
}

static object_t crash_fn(vm_t *vm, void *data, int argc, object_t *args) {
    error_t *err = NULL;
    if (argc == 1 && object_get_type(args[0]) == OBJECT_STRING) {
        err = error_make(ERROR_RUNTIME, frame_src_position(vm->current_frame), object_get_string(args[0]));
    } else {
        err = error_make(ERROR_RUNTIME, frame_src_position(vm->current_frame), "");
    }
    vm_set_runtime_error(vm, err);
    return object_make_null();
}

static object_t random_fn(vm_t *vm, void *data, int argc, object_t *args) {
    double res = (double)rand() / RAND_MAX;
    if (argc == 0) {
        return object_make_number(res);
    } else if (argc == 2) {
        if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER, OBJECT_NUMBER)) {
            return object_make_null();
        }
        double min = object_get_number(args[0]);
        double max = object_get_number(args[1]);
        if (min >= max) {
            error_t *err = error_make(ERROR_RUNTIME, src_pos_invalid, "max is bigger than min");
            vm_set_runtime_error(vm, err);
            return object_make_null();
        }
        double range = max - min;
        res = min + (res * range);
        return object_make_number(res);
    } else {
        error_t *err = error_make(ERROR_RUNTIME, src_pos_invalid, "Invalid number or arguments");
        vm_set_runtime_error(vm, err);
        return object_make_null();
    }
}

//-----------------------------------------------------------------------------
// Type checks
//-----------------------------------------------------------------------------

static object_t is_string_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_make_bool(object_get_type(args[0]) == OBJECT_STRING);
}

static object_t is_array_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_make_bool(object_get_type(args[0]) == OBJECT_ARRAY);
}

static object_t is_map_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_make_bool(object_get_type(args[0]) == OBJECT_MAP);
}

static object_t is_number_fn(vm_t *vm, void *data, int argc, object_t *args){
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_make_bool(object_get_type(args[0]) == OBJECT_NUMBER);
}

static object_t is_bool_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_make_bool(object_get_type(args[0]) == OBJECT_BOOL);
}

static object_t is_null_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_make_bool(object_get_type(args[0]) == OBJECT_NULL);
}

static object_t is_function_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_make_bool(object_get_type(args[0]) == OBJECT_FUNCTION);
}

static object_t is_external_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_make_bool(object_get_type(args[0]) == OBJECT_EXTERNAL);
}

static object_t is_error_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_make_bool(object_get_type(args[0]) == OBJECT_ERROR);
}

static object_t is_native_function_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_make_bool(object_get_type(args[0]) == OBJECT_NATIVE_FUNCTION);
}

//-----------------------------------------------------------------------------
// Math
//-----------------------------------------------------------------------------

static object_t sqrt_fn(vm_t *vm, void *data, int argc, object_t *args) {
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER)) {
        return object_make_null();
    }
    double arg = object_get_number(args[0]);
    double res = sqrt(arg);
    return object_make_number(res);
}

static object_t pow_fn(vm_t *vm, void *data, int argc, object_t *args) {
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER, OBJECT_NUMBER)) {
        return object_make_null();
    }
    double arg1 = object_get_number(args[0]);
    double arg2 = object_get_number(args[1]);
    double res = pow(arg1, arg2);
    return object_make_number(res);
}

static object_t sin_fn(vm_t *vm, void *data, int argc, object_t *args) {
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER)) {
        return object_make_null();
    }
    double arg = object_get_number(args[0]);
    double res = sin(arg);
    return object_make_number(res);
}

static object_t cos_fn(vm_t *vm, void *data, int argc, object_t *args) {
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER)) {
        return object_make_null();
    }
    double arg = object_get_number(args[0]);
    double res = cos(arg);
    return object_make_number(res);
}

static object_t tan_fn(vm_t *vm, void *data, int argc, object_t *args) {
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER)) {
        return object_make_null();
    }
    double arg = object_get_number(args[0]);
    double res = tan(arg);
    return object_make_number(res);
}

static object_t log_fn(vm_t *vm, void *data, int argc, object_t *args) {
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER)) {
        return object_make_null();
    }
    double arg = object_get_number(args[0]);
    double res = log(arg);
    return object_make_number(res);
}

static object_t ceil_fn(vm_t *vm, void *data, int argc, object_t *args) {
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER)) {
        return object_make_null();
    }
    double arg = object_get_number(args[0]);
    double res = ceil(arg);
    return object_make_number(res);
}

static object_t floor_fn(vm_t *vm, void *data, int argc, object_t *args) {
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER)) {
        return object_make_null();
    }
    double arg = object_get_number(args[0]);
    double res = floor(arg);
    return object_make_number(res);
}

static object_t abs_fn(vm_t *vm, void *data, int argc, object_t *args) {
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER)) {
        return object_make_null();
    }
    double arg = object_get_number(args[0]);
    double res = fabs(arg);
    return object_make_number(res);
}


static bool check_args(vm_t *vm, bool generate_error, int argc, object_t *args, int expected_argc, object_type_t *expected_types) {
    if (argc != expected_argc) {
        if (generate_error) {
            error_t *err = error_makef(ERROR_RUNTIME, src_pos_invalid,
                                       "Invalid number or arguments, got %d instead of %d",
                                       argc, expected_argc);
            vm_set_runtime_error(vm, err);
        }
        return false;
    }

    for (int i = 0; i < argc; i++) {
       object_t arg = args[i];
        object_type_t type = object_get_type(arg);
        object_type_t expected_type = expected_types[i];
        if (!(type & expected_type)) {
            if (generate_error) {
                const char *type_str = object_get_type_name(type);
                const char *expected_type_str = object_get_type_name(expected_type);
                error_t *err = error_makef(ERROR_RUNTIME, src_pos_invalid,
                                           "Invalid argument %d type, got %s, expected %s",
                                           i, type_str, expected_type_str);
                vm_set_runtime_error(vm, err);
            }
            return false;
        }
    }
    return true;
}
//FILE_END
//FILE_START:traceback.c
#ifndef APE_AMALGAMATED
#include "traceback.h"
#include "vm.h"
#include "compiler.h"
#endif

traceback_t* traceback_make(void) {
    traceback_t *traceback = ape_malloc(sizeof(traceback_t), ape_mallocArg);
    traceback->items = array_make(traceback_item_t);
    return traceback;
}

void traceback_destroy(traceback_t *traceback) {
    if (!traceback) {
        return;
    }
    for (int i = 0; i < array_count(traceback->items); i++) {
        traceback_item_t *item = array_get(traceback->items, i);
        ape_free(item->function_name, ape_freeArg);
    }
    array_destroy(traceback->items);
    ape_free(traceback, ape_freeArg);
}

void traceback_append(traceback_t *traceback, const char *function_name, src_pos_t pos) {
    traceback_item_t item;
    item.function_name = ape_strdup(function_name);
    item.pos = pos;
    array_add(traceback->items, &item);
}

void traceback_append_from_vm(traceback_t *traceback, vm_t *vm) {
    for (int i = vm->frames_count - 1; i >= 0; i--) {
        frame_t *frame = &vm->frames[i];
        traceback_append(traceback, object_get_function_name(frame->function), frame_src_position(frame));
    }
}

void traceback_to_string(const traceback_t *traceback, strbuf_t *buf) {
    int depth  = array_count(traceback->items);
    for (int i = 0; i < depth; i++) {
        traceback_item_t *item = array_get(traceback->items, i);
        const char *filename = traceback_item_get_filepath(item);
        if (item->pos.line >= 0 && item->pos.column >= 0) {
            strbuf_appendf(buf, "%s in %s on %d:%d\n", item->function_name, filename, item->pos.line, item->pos.column);
        } else {
            strbuf_appendf(buf, "%s\n", item->function_name);
        }
    }
}

const char* traceback_item_get_line(traceback_item_t *item) {
    if (!item->pos.file) {
        return NULL;
    }
    ptrarray(char*) *lines = item->pos.file->lines;
    if (item->pos.line >= ptrarray_count(lines)) {
        return NULL;
    }
    const char *line = ptrarray_get(lines, item->pos.line);
    return line;
}

const char* traceback_item_get_filepath(traceback_item_t *item) {
    if (!item->pos.file) {
        return NULL;
    }
    return item->pos.file->path;
}
//FILE_END
//FILE_START:frame.c
#include <stdlib.h>

#ifndef APE_AMALGAMATED
#include "frame.h"
#include "compiler.h"
#endif

bool frame_init(frame_t* frame, object_t function_obj, int base_pointer) {
    if (object_get_type(function_obj) != OBJECT_FUNCTION) {
        return false;
    }
    function_t* function = object_get_function(function_obj);
    frame->function = function_obj;
    frame->ip = 0;
    frame->base_pointer = base_pointer;
    frame->src_ip = 0;
    frame->bytecode = function->comp_result->bytecode;
    frame->src_positions = function->comp_result->src_positions;
    frame->bytecode_size = function->comp_result->count;
    frame->recover_ip = -1;
    frame->is_recovering = false;
    return true;
}

opcode_val_t frame_read_opcode(frame_t* frame){
    frame->src_ip = frame->ip;
    return frame_read_uint8(frame);
}

uint64_t frame_read_uint64(frame_t* frame) {
    const uint8_t *data = frame->bytecode + frame->ip;
    frame->ip += 8;
    uint64_t res = 0;
    res |= (uint64_t)data[7];
    res |= (uint64_t)data[6] << 8;
    res |= (uint64_t)data[5] << 16;
    res |= (uint64_t)data[4] << 24;
    res |= (uint64_t)data[3] << 32;
    res |= (uint64_t)data[2] << 40;
    res |= (uint64_t)data[1] << 48;
    res |= (uint64_t)data[0] << 56;
    return res;
}

uint16_t frame_read_uint16(frame_t* frame) {
    const uint8_t *data = frame->bytecode + frame->ip;
    frame->ip += 2;
    return (data[0] << 8) | data[1];
}

uint8_t frame_read_uint8(frame_t* frame) {
    const uint8_t *data = frame->bytecode + frame->ip;
    frame->ip += 1;
    return data[0];
}

src_pos_t frame_src_position(const frame_t *frame) {
    if (frame->src_positions) {
        return frame->src_positions[frame->src_ip];
    }
    return src_pos_invalid;
}
//FILE_END
//FILE_START:vm.c
#include <stdlib.h>
#include <stdio.h>
#include <float.h>
#include <math.h>

#ifndef APE_AMALGAMATED
#include "vm.h"

#include "code.h"
#include "compiler.h"
#include "traceback.h"
#include "builtins.h"
#include "gc.h"
#endif

static void set_sp(vm_t *vm, int new_sp);
static void stack_push(vm_t *vm, object_t obj);
static object_t stack_pop(vm_t *vm);
static object_t stack_get(vm_t *vm, int nth_item);

static void this_stack_push(vm_t *vm, object_t obj);
static object_t this_stack_pop(vm_t *vm);
static object_t this_stack_get(vm_t *vm, int nth_item);

static bool push_frame(vm_t *vm, frame_t frame);
static bool pop_frame(vm_t *vm);
static void run_gc(vm_t *vm, array(object_t) *constants);
static bool call_object(vm_t *vm, object_t callee, int num_args);
static object_t call_native_function(vm_t *vm, object_t callee, src_pos_t src_pos, int argc, object_t *args);
static bool check_assign(vm_t *vm, object_t old_value, object_t new_value);
static bool try_overload_operator(vm_t *vm, object_t left, object_t right, opcode_t op, bool *out_overload_found);

vm_t *vm_make(const ape_config_t *config, gcmem_t *mem, ptrarray(error_t) *errors) {
    vm_t *vm = ape_malloc(sizeof(vm_t), ape_mallocArg);
    memset(vm, 0, sizeof(vm_t));
    vm->config = config;
    vm->mem = mem;
    vm->globals_count = 0;
    vm->sp = 0;
    vm->this_sp = 0;
    vm->frames_count = 0;
    vm->native_functions = array_make(object_t);
    vm->errors = errors;
    vm->runtime_error = NULL;
    vm->last_popped = object_make_null();
    vm->running = false;

    for (int i = 0; i < builtins_count(); i++) {
        object_t builtin = object_make_native_function(vm->mem, builtins_get_name(i), builtins_get_fn(i), vm);
        array_add(vm->native_functions, &builtin);
    }

    for (int i = 0; i < OPCODE_MAX; i++) {
        vm->operator_oveload_keys[i] = object_make_null();
    }
#define SET_OPERATOR_OVERLOAD_KEY(op, key) do {\
    object_t key_obj = object_make_string(vm->mem, key);\
    vm->operator_oveload_keys[op] = key_obj;\
} while (0)
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_ADD,     "__operator_add__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_SUB,     "__operator_sub__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_MUL,     "__operator_mul__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_DIV,     "__operator_div__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_MOD,     "__operator_mod__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_OR,      "__operator_or__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_XOR,     "__operator_xor__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_AND,     "__operator_and__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_LSHIFT,  "__operator_lshift__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_RSHIFT,  "__operator_rshift__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_MINUS,   "__operator_minus__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_BANG,    "__operator_bang__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_COMPARE, "__cmp__");
#undef SET_OPERATOR_OVERLOAD_KEY

    return vm;
}

void vm_destroy(vm_t *vm) {
    if (!vm) {
        return;
    }
    array_destroy(vm->native_functions);
    ape_free(vm, ape_freeArg);
}

void vm_reset(vm_t *vm) {
    vm->sp = 0;
    vm->this_sp = 0;
    while (vm->frames_count > 0) {
        pop_frame(vm);
    }
}

bool vm_run(vm_t *vm, compilation_result_t *comp_res, array(object_t) *constants) {
    int old_sp = vm->sp;
    int old_this_sp = vm->this_sp;
    int old_frames_count = vm->frames_count;
    object_t main_fn = object_make_function(vm->mem, "main", comp_res, false, 0, 0, 0);
    stack_push(vm, main_fn);
    bool res = vm_execute_function(vm, main_fn, constants);
    while (vm->frames_count > old_frames_count) {
        pop_frame(vm);
    }
    APE_ASSERT(vm->sp == old_sp);
    vm->this_sp = old_this_sp;
    return res;
}

object_t vm_call(vm_t *vm, array(object_t) *constants, object_t callee, int argc, object_t *args) {
    object_type_t type = object_get_type(callee);
    if (type == OBJECT_FUNCTION) {
        int old_sp = vm->sp;
        int old_this_sp = vm->this_sp;
        int old_frames_count = vm->frames_count;
        stack_push(vm, callee);
        for (int i = 0; i < argc; i++) {
            stack_push(vm, args[i]);
        }
        bool ok = vm_execute_function(vm, callee, constants);
        if (!ok) {
            return object_make_null();
        }
        while (vm->frames_count > old_frames_count) {
            pop_frame(vm);
        }
        APE_ASSERT(vm->sp == old_sp);
        vm->this_sp = old_this_sp;
        return vm_get_last_popped(vm);
    } else if (type == OBJECT_NATIVE_FUNCTION) {
        return call_native_function(vm, callee, src_pos_invalid, argc, args);
    } else {
        error_t *err = error_make(ERROR_USER, src_pos_invalid, "Object is not callable");
        ptrarray_add(vm->errors, err);
        return object_make_null();
    }
}

bool vm_execute_function(vm_t *vm, object_t function, array(object_t) *constants) {
    if (vm->running) {
        error_t *err = error_make(ERROR_USER, src_pos_invalid, "VM is already executing code");
        ptrarray_add(vm->errors, err);
        return false;
    }

    function_t *function_function = object_get_function(function); // naming is hard
    frame_t new_frame;
    frame_init(&new_frame, function, vm->sp - function_function->num_args);
    bool ok = push_frame(vm, new_frame);
    if (!ok) {
        error_t *err = error_make(ERROR_USER, src_pos_invalid, "Pushing frame failed");
        ptrarray_add(vm->errors, err);
        return false;
    }

    vm->running = true;
    vm->last_popped = object_make_null();

    int ticks_between_gc = 0;
    if (vm->config) {
        ticks_between_gc = vm->config->gc_interval;
    };

    int ticks_since_gc = 0;

    while (vm->current_frame->ip < vm->current_frame->bytecode_size) {
        opcode_val_t opcode = frame_read_opcode(vm->current_frame);
        switch (opcode) {
            case OPCODE_CONSTANT: {
                uint16_t constant_ix = frame_read_uint16(vm->current_frame);
                object_t *constant = array_get(constants, constant_ix);
                if (!constant) {
                    error_t *err = error_makef(ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                              "Constant at %d not found", constant_ix);
                    vm_set_runtime_error(vm, err);
                    goto err;
                }
                stack_push(vm, *constant);
                break;
            }
            case OPCODE_ADD:
            case OPCODE_SUB:
            case OPCODE_MUL:
            case OPCODE_DIV:
            case OPCODE_MOD:
            case OPCODE_OR:
            case OPCODE_XOR:
            case OPCODE_AND:
            case OPCODE_LSHIFT:
            case OPCODE_RSHIFT:
            {
                object_t right = stack_pop(vm);
                object_t left = stack_pop(vm);
                object_type_t left_type = object_get_type(left);
                object_type_t right_type = object_get_type(right);
                if (object_is_numeric(left) && object_is_numeric(right)) {
                    double right_val = object_get_number(right);
                    double left_val = object_get_number(left);

                    int64_t left_val_int = left_val;
                    int64_t right_val_int = right_val;

                    double res = 0;
                    switch (opcode) {
                        case OPCODE_ADD:    res = left_val + right_val; break;
                        case OPCODE_SUB:    res = left_val - right_val; break;
                        case OPCODE_MUL:    res = left_val * right_val; break;
                        case OPCODE_DIV:    res = left_val / right_val; break;
                        case OPCODE_MOD:    res = fmod(left_val, right_val); break;
                        case OPCODE_OR:     res = left_val_int | right_val_int; break;
                        case OPCODE_XOR:    res = left_val_int ^ right_val_int; break;
                        case OPCODE_AND:    res = left_val_int & right_val_int; break;
                        case OPCODE_LSHIFT: res = left_val_int << right_val_int; break;
                        case OPCODE_RSHIFT: res = left_val_int >> right_val_int; break;
                        default: APE_ASSERT(false); break;
                    }
                    stack_push(vm, object_make_number(res));
                } else if (left_type == OBJECT_STRING  && right_type == OBJECT_STRING && opcode == OPCODE_ADD) {
                    const char* right_val = object_get_string(right);
                    const char* left_val = object_get_string(left);
                    object_t res_obj = object_make_stringf(vm->mem, "%s%s", left_val, right_val);
                    stack_push(vm, res_obj);
                } else {
                    bool overload_found = false;
                    bool ok = try_overload_operator(vm, left, right, opcode, &overload_found);
                    if (!ok) {
                        goto err;
                    }
                    if (!overload_found) {
                        const char *opcode_name = opcode_get_name(opcode);
                        const char *left_type_name = object_get_type_name(left_type);
                        const char *right_type_name = object_get_type_name(right_type);
                        error_t *err = error_makef(ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                                   "Invalid operand types for %s, got %s and %s",
                                                   opcode_name, left_type_name, right_type_name);
                        vm_set_runtime_error(vm, err);
                        goto err;
                    }
                }
                break;
            }
            case OPCODE_POP: {
                stack_pop(vm);
                break;
            }
            case OPCODE_TRUE: {
                stack_push(vm, object_make_bool(true));
                break;
            }
            case OPCODE_FALSE: {
                stack_push(vm, object_make_bool(false));
                break;
            }
            case OPCODE_COMPARE: {
                object_t right = stack_pop(vm);
                object_t left = stack_pop(vm);
                bool is_overloaded = false;
                bool ok = try_overload_operator(vm, left, right, OPCODE_COMPARE, &is_overloaded);
                if (!ok) {
                    goto err;
                }
                if (!is_overloaded) {
                    double comparison_res = object_compare(left, right);
                    object_t res = object_make_number(comparison_res);
                    stack_push(vm, res);
                }
                break;
            }
            case OPCODE_EQUAL:
            case OPCODE_NOT_EQUAL:
            case OPCODE_GREATER_THAN:
            case OPCODE_GREATER_THAN_EQUAL:
            {
                object_t value = stack_pop(vm);
                double comparison_res = object_get_number(value);
                bool res_val = false;
                switch (opcode) {
                    case OPCODE_EQUAL: res_val = APE_DBLEQ(comparison_res, 0); break;
                    case OPCODE_NOT_EQUAL: res_val = !APE_DBLEQ(comparison_res, 0); break;
                    case OPCODE_GREATER_THAN: res_val = comparison_res > 0; break;
                    case OPCODE_GREATER_THAN_EQUAL: {
                        res_val = comparison_res > 0 || APE_DBLEQ(comparison_res, 0);
                        break;
                    }
                    default: APE_ASSERT(false); break;
                }
                object_t res = object_make_bool(res_val);
                stack_push(vm, res);
                break;
            }
            case OPCODE_MINUS:
            {
                object_t operand = stack_pop(vm);
                object_type_t operand_type = object_get_type(operand);
                if (operand_type == OBJECT_NUMBER) {
                    double val = object_get_number(operand);
                    object_t res = object_make_number(-val);
                    stack_push(vm, res);
                } else {
                    bool overload_found = false;
                    bool ok = try_overload_operator(vm, operand, object_make_null(), OPCODE_MINUS, &overload_found);
                    if (!ok) {
                        goto err;
                    }
                    if (!overload_found) {
                        const char *operand_type_string = object_get_type_name(operand_type);
                        error_t *err = error_makef(ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                                   "Invalid operand type for MINUS, got %s",
                                                   operand_type_string);
                        vm_set_runtime_error(vm, err);
                        goto err;
                    }
                }
                break;
            }
            case OPCODE_BANG: {
                object_t operand = stack_pop(vm);
                object_type_t type = object_get_type(operand);
                if (type == OBJECT_BOOL) {
                    object_t res = object_make_bool(!object_get_bool(operand));
                    stack_push(vm, res);
                } else if (type == OBJECT_NULL) {
                    object_t res = object_make_bool(true);
                    stack_push(vm, res);
                } else {
                    bool overload_found = false;
                    bool ok = try_overload_operator(vm, operand, object_make_null(), OPCODE_BANG, &overload_found);
                    if (!ok) {
                        goto err;
                    }
                    if (!overload_found) {
                        object_t res = object_make_bool(false);
                        stack_push(vm, res);
                    }
                }
                break;
            }
            case OPCODE_JUMP: {
                uint16_t pos = frame_read_uint16(vm->current_frame);
                vm->current_frame->ip = pos;
                break;
            }
            case OPCODE_JUMP_IF_FALSE: {
                uint16_t pos = frame_read_uint16(vm->current_frame);
                object_t test = stack_pop(vm);
                if (!object_get_bool(test)) {
                    vm->current_frame->ip = pos;
                }
                break;
            }
            case OPCODE_JUMP_IF_TRUE: {
                uint16_t pos = frame_read_uint16(vm->current_frame);
                object_t test = stack_pop(vm);
                if (object_get_bool(test)) {
                    vm->current_frame->ip = pos;
                }
                break;
            }
            case OPCODE_NULL: {
                stack_push(vm, object_make_null());
                break;
            }
            case OPCODE_DEFINE_GLOBAL: {
                uint16_t ix = frame_read_uint16(vm->current_frame);
                object_t value = stack_pop(vm);
                vm_set_global(vm, ix, value);
                break;
            }
            case OPCODE_SET_GLOBAL: {
                uint16_t ix = frame_read_uint16(vm->current_frame);
                object_t new_value = stack_pop(vm);
                object_t old_value = vm_get_global(vm, ix);
                if (!check_assign(vm, old_value, new_value)) {
                    goto err;
                }
                vm_set_global(vm, ix, new_value);
                break;
            }
            case OPCODE_GET_GLOBAL: {
                uint16_t ix = frame_read_uint16(vm->current_frame);
                object_t global = vm->globals[ix];
                stack_push(vm, global);
                break;
            }
            case OPCODE_ARRAY: {
                uint16_t count = frame_read_uint16(vm->current_frame);
                object_t array_obj = object_make_array_with_capacity(vm->mem, count);
                object_t *items = vm->stack + vm->sp - count;
                for (int i = 0; i < count; i++) {
                    object_t item = items[i];
                    object_add_array_value(array_obj, item);
                }
                set_sp(vm, vm->sp - count);
                stack_push(vm, array_obj);
                break;
            }
            case OPCODE_MAP_START: {
                uint16_t count = frame_read_uint16(vm->current_frame);
                object_t map_obj = object_make_map_with_capacity(vm->mem, count);
                this_stack_push(vm, map_obj);
                break;
            }
            case OPCODE_MAP_END: {
                uint16_t count = frame_read_uint16(vm->current_frame);
                object_t map_obj = this_stack_pop(vm);
                object_t *kvpairs = vm->stack + vm->sp - count;
                for (int i = 0; i < count; i += 2) {
                    object_t key = kvpairs[i];
                    if (!object_is_hashable(key)) {
                        object_type_t key_type = object_get_type(key);
                        const char *key_type_name = object_get_type_name(key_type);
                        error_t *err = error_makef(ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                                   "Key of type %s is not hashable", key_type_name);
                        vm_set_runtime_error(vm, err);
                        goto err;
                    }

                    object_t val = kvpairs[i + 1];
                    object_set_map_value(map_obj, key, val);
                }
                set_sp(vm, vm->sp - count);
                stack_push(vm, map_obj);
                break;
            }
            case OPCODE_GET_THIS: {
                object_t obj = this_stack_get(vm, 0);
                stack_push(vm, obj);
                break;
            }
            case OPCODE_GET_INDEX: {
                object_t index = stack_pop(vm);
                object_t left = stack_pop(vm);
                object_type_t left_type = object_get_type(left);
                object_type_t index_type = object_get_type(index);
                const char *left_type_name = object_get_type_name(left_type);
                const char *index_type_name = object_get_type_name(index_type);

                if (left_type != OBJECT_ARRAY && left_type != OBJECT_MAP && left_type != OBJECT_STRING) {
                    error_t *err = error_makef(ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                              "Type %s is not indexable", left_type_name);
                    vm_set_runtime_error(vm, err);
                    goto err;
                }

                object_t res = object_make_null();

                if (left_type == OBJECT_ARRAY) {
                    if (index_type != OBJECT_NUMBER) {
                        error_t *err = error_makef(ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                                  "Cannot index %s with %s", left_type_name, index_type_name);
                        vm_set_runtime_error(vm, err);
                        goto err;
                    }
                    int ix = (int)object_get_number(index);
                    if (ix < 0) {
                        ix = object_get_array_length(left) + ix;
                    }
                    if (ix >= 0 && ix < object_get_array_length(left)) {
                        res = object_get_array_value_at(left, ix);
                    }
                } else if (left_type == OBJECT_MAP) {
                    res = object_get_map_value(left, index);
                } else if (left_type == OBJECT_STRING) {
                    const char *str = object_get_string(left);
                    int ix = (int)object_get_number(index);
                    if (ix >= 0 && ix < (int)strlen(str)) {
                        char res_str[2] = {str[ix], '\0'};
                        res = object_make_string(vm->mem, res_str);
                    }
                }
                stack_push(vm, res);
                break;
            }
            case OPCODE_GET_VALUE_AT: {
                object_t index = stack_pop(vm);
                object_t left = stack_pop(vm);
                object_type_t left_type = object_get_type(left);
                object_type_t index_type = object_get_type(index);
                const char *left_type_name = object_get_type_name(left_type);
                const char *index_type_name = object_get_type_name(index_type);

                if (left_type != OBJECT_ARRAY && left_type != OBJECT_MAP && left_type != OBJECT_STRING) {
                    error_t *err = error_makef(ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                               "Type %s is not indexable", left_type_name);
                    vm_set_runtime_error(vm, err);
                    goto err;
                }

                object_t res = object_make_null();
                if (index_type != OBJECT_NUMBER) {
                    error_t *err = error_makef(ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                               "Cannot index %s with %s", left_type_name, index_type_name);
                    vm_set_runtime_error(vm, err);
                    goto err;
                }
                int ix = (int)object_get_number(index);

                if (left_type == OBJECT_ARRAY) {
                    res = object_get_array_value_at(left, ix);
                } else if (left_type == OBJECT_MAP) {
                    res = object_get_kv_pair_at(vm->mem, left, ix);
                } else if (left_type == OBJECT_STRING) {
                    const char *str = object_get_string(left);
                    int ix = (int)object_get_number(index);
                    if (ix >= 0 && ix < (int)strlen(str)) {
                        char res_str[2] = {str[ix], '\0'};
                        res = object_make_string(vm->mem, res_str);
                    }
                }
                stack_push(vm, res);
                break;
            }
            case OPCODE_CALL: {
                uint8_t num_args = frame_read_uint8(vm->current_frame);
                object_t callee = stack_get(vm, num_args);
                bool ok = call_object(vm, callee, num_args);
                if (!ok) {
                    goto err;
                }
                break;
            }
            case OPCODE_RETURN_VALUE: {
                object_t res = stack_pop(vm);
                bool ok = pop_frame(vm);
                if (!ok) {
                    goto end;
                }
                stack_push(vm, res);
                break;
            }
            case OPCODE_RETURN: {
                bool ok = pop_frame(vm);
                stack_push(vm, object_make_null());
                if (!ok) {
                    stack_pop(vm);
                    goto end;
                }
                break;
            }
            case OPCODE_DEFINE_LOCAL: {
                uint8_t pos = frame_read_uint8(vm->current_frame);
                vm->stack[vm->current_frame->base_pointer + pos] = stack_pop(vm);
                break;
            }
            case OPCODE_SET_LOCAL: {
                uint8_t pos = frame_read_uint8(vm->current_frame);
                object_t new_value = stack_pop(vm);
                object_t old_value = vm->stack[vm->current_frame->base_pointer + pos];
                if (!check_assign(vm, old_value, new_value)) {
                    goto err;
                }
                vm->stack[vm->current_frame->base_pointer + pos] = new_value;
                break;
            }
            case OPCODE_GET_LOCAL: {
                uint8_t pos = frame_read_uint8(vm->current_frame);
                object_t val = vm->stack[vm->current_frame->base_pointer + pos];
                stack_push(vm, val);
                break;
            }
            case OPCODE_GET_NATIVE_FUNCTION: {
                uint16_t ix = frame_read_uint16(vm->current_frame);
                object_t *val = array_get(vm->native_functions, ix);
                if (!val) {
                    error_t *err = error_makef(ERROR_RUNTIME, frame_src_position(vm->current_frame), "Native function %d not found", ix);
                    vm_set_runtime_error(vm, err);
                    goto err;
                }
                stack_push(vm, *val);
                break;
            }
            case OPCODE_FUNCTION: {
                uint16_t constant_ix = frame_read_uint16(vm->current_frame);
                uint8_t num_free = frame_read_uint8(vm->current_frame);
                object_t *constant = array_get(constants, constant_ix);
                if (!constant) {
                    error_t *err = error_makef(ERROR_RUNTIME, frame_src_position(vm->current_frame), "Constant %d not found", constant_ix);
                    vm_set_runtime_error(vm, err);
                    goto err;
                }
                object_type_t constant_type = object_get_type(*constant);
                if (constant_type != OBJECT_FUNCTION) {
                    const char *type_name = object_get_type_name(constant_type);
                    error_t *err = error_makef(ERROR_RUNTIME, frame_src_position(vm->current_frame), "%s is not a function", type_name);
                    vm_set_runtime_error(vm, err);
                    goto err;
                }

                const function_t *constant_function = object_get_function(*constant);
                object_t function_obj = object_make_function(vm->mem, object_get_function_name(*constant),
                                                            constant_function->comp_result, false,
                                                            constant_function->num_locals, constant_function->num_args,
                                                            num_free);
                for (int i = 0; i < num_free; i++) {
                    object_t free_val = vm->stack[vm->sp - num_free + i];
                    object_set_function_free_val(function_obj, i, free_val);
                }
                set_sp(vm, vm->sp - num_free);
                stack_push(vm, function_obj);
                break;
            }
            case OPCODE_GET_FREE: {
                uint8_t free_ix = frame_read_uint8(vm->current_frame);
                object_t val = object_get_function_free_val(vm->current_frame->function, free_ix);
                stack_push(vm, val);
                break;
            }
            case OPCODE_SET_FREE: {
                uint8_t free_ix = frame_read_uint8(vm->current_frame);
                object_t val = stack_pop(vm);
                object_set_function_free_val(vm->current_frame->function, free_ix, val);
                break;
            }
            case OPCODE_CURRENT_FUNCTION: {
                object_t current_function = vm->current_frame->function;
                stack_push(vm, current_function);
                break;
            }
            case OPCODE_SET_INDEX: {
                object_t index = stack_pop(vm);
                object_t left = stack_pop(vm);
                object_t new_value = stack_pop(vm);
                object_type_t left_type = object_get_type(left);
                object_type_t index_type = object_get_type(index);
                const char *left_type_name = object_get_type_name(left_type);
                const char *index_type_name = object_get_type_name(index_type);

                if (left_type != OBJECT_ARRAY && left_type != OBJECT_MAP) {
                    error_t *err = error_makef(ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                              "Type %s is not indexable", left_type_name);
                    vm_set_runtime_error(vm, err);
                    goto err;
                }

                if (left_type == OBJECT_ARRAY) {
                    if (index_type != OBJECT_NUMBER) {
                        error_t *err = error_makef(ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                                  "Cannot index %s with %s", left_type_name, index_type_name);
                        vm_set_runtime_error(vm, err);
                        goto err;
                    }
                    int ix = (int)object_get_number(index);
                    bool ok = object_set_array_value_at(left, ix, new_value);
                    if (!ok) {
                        error_t *err = error_make(ERROR_RUNTIME, frame_src_position(vm->current_frame), "Setting array item failed (out of bounds?)");
                        vm_set_runtime_error(vm, err);
                        goto err;
                    }
                } else if (left_type == OBJECT_MAP) {
                    object_t old_value = object_get_map_value(left, index);
                    if (!check_assign(vm, old_value, new_value)) {
                        goto err;
                    }
                    object_set_map_value(left, index, new_value);
                }
                break;
            }
            case OPCODE_DUP: {
                object_t val = stack_get(vm, 0);
                stack_push(vm, val);
                break;
            }
            case OPCODE_LEN: {
                object_t val = stack_pop(vm);
                int len = 0;
                object_type_t type = object_get_type(val);
                if (type == OBJECT_ARRAY) {
                    len = object_get_array_length(val);
                } else if (type == OBJECT_MAP) {
                    len = object_get_map_length(val);
                } else if (type == OBJECT_STRING) {
                    const char *str = object_get_string(val);
                    len = (int)strlen(str);
                } else {
                    const char *type_name = object_get_type_name(type);
                    error_t *err = error_makef(ERROR_RUNTIME, frame_src_position(vm->current_frame), "Cannot get length of %s", type_name);
                    vm_set_runtime_error(vm, err);
                    goto err;
                }
                stack_push(vm, object_make_number(len));
                break;
            }
            case OPCODE_NUMBER: {
                uint64_t val = frame_read_uint64(vm->current_frame);
                double val_double = ape_uint64_to_double(val);
                object_t obj = object_make_number(val_double);
                stack_push(vm, obj);
                break;
            }
            case OPCODE_SET_RECOVER: {
                uint16_t recover_ip = frame_read_uint16(vm->current_frame);
                vm->current_frame->recover_ip = recover_ip;
                break;
            }
            default: {
                APE_ASSERT(false);
                error_t *err = error_makef(ERROR_RUNTIME, frame_src_position(vm->current_frame), "Unknown opcode: 0x%x", opcode);
                vm_set_runtime_error(vm, err);
                goto err;
            }
        }
    err:
        if (vm->runtime_error != NULL) {
            int recover_frame_ix = -1;
            for (int i = vm->frames_count - 1; i >= 0; i--) {
                frame_t *frame = &vm->frames[i];
                if (frame->recover_ip >= 0 && !frame->is_recovering) {
                    recover_frame_ix = i;
                    break;
                }
            }
            if (recover_frame_ix < 0) {
                goto end;
            } else {
                error_t *err = vm->runtime_error;
                if (!err->traceback) {
                    err->traceback = traceback_make();
                }
                traceback_append_from_vm(err->traceback, vm);
                while (vm->frames_count > (recover_frame_ix + 1)) {
                    pop_frame(vm);
                }
                object_t err_obj = object_make_error(vm->mem, err->message);
                object_set_error_traceback(err_obj, err->traceback);
                err->traceback = NULL;
                stack_push(vm, err_obj);
                vm->current_frame->ip = vm->current_frame->recover_ip;
                vm->current_frame->is_recovering = true;
                error_destroy(vm->runtime_error);
                vm->runtime_error = NULL;
            }
        }
        if (ticks_between_gc >= 0 && ticks_since_gc >= ticks_between_gc) {
            run_gc(vm, constants);
            ticks_since_gc = 0;
        } else {
            ticks_since_gc++;
        }
    }

end:
    if (vm->runtime_error) {
        error_t *err = vm->runtime_error;
        if (!err->traceback) {
            err->traceback = traceback_make();
        }
        traceback_append_from_vm(err->traceback, vm);
        ptrarray_add(vm->errors, vm->runtime_error);
        vm->runtime_error = NULL;
    }

    run_gc(vm, constants);

    vm->running = false;
    return ptrarray_count(vm->errors) == 0;
}

object_t vm_get_last_popped(vm_t *vm) {
    return vm->last_popped;
}

bool vm_has_errors(vm_t *vm) {
    return vm->runtime_error != NULL || ptrarray_count(vm->errors) > 0;
}

void vm_set_global(vm_t *vm, int ix, object_t val) {
#ifdef APE_DEBUG
    if (ix >= VM_MAX_GLOBALS) {
        APE_ASSERT(false);
        error_t *err = error_make(ERROR_RUNTIME, frame_src_position(vm->current_frame), "Global write out of range");
        vm_set_runtime_error(vm, err);
        return;
    }
#endif
    vm->globals[ix] = val;
    if (ix >= vm->globals_count) {
        vm->globals_count = ix + 1;
    }
}

object_t vm_get_global(vm_t *vm, int ix) {
#ifdef APE_DEBUG
    if (ix >= VM_MAX_GLOBALS) {
        APE_ASSERT(false);
        error_t *err = error_make(ERROR_RUNTIME, frame_src_position(vm->current_frame), "Global read out of range");
        vm_set_runtime_error(vm, err);
        return object_make_null();
    }
#endif
    return vm->globals[ix];
}

void vm_set_runtime_error(vm_t *vm, error_t *error) {
    APE_ASSERT(vm->running);
    if (error) {
        APE_ASSERT(vm->runtime_error == NULL);
    }
    vm->runtime_error = error;
}

// INTERNAL
static void set_sp(vm_t *vm, int new_sp) {
    if (new_sp > vm->sp) { // to avoid gcing freed objects
        int count = new_sp - vm->sp;
        size_t bytes_count = count * sizeof(object_t);
        memset(vm->stack + vm->sp, 0, bytes_count);
    }
    vm->sp = new_sp;
}

static void stack_push(vm_t *vm, object_t obj) {
#ifdef APE_DEBUG
    if (vm->sp >= VM_STACK_SIZE) {
        APE_ASSERT(false);
        error_t *err = error_make(ERROR_RUNTIME, frame_src_position(vm->current_frame), "Stack overflow");
        vm_set_runtime_error(vm, err);
        return;
    }
    if (vm->current_frame) {
        frame_t *frame = vm->current_frame;
        function_t *current_function = object_get_function(frame->function);
        int num_locals = current_function->num_locals;
        APE_ASSERT(vm->sp >= (frame->base_pointer + num_locals));
    }
#endif
    vm->stack[vm->sp] = obj;
    vm->sp++;
}

static object_t stack_pop(vm_t *vm) {
#ifdef APE_DEBUG
    if (vm->sp == 0) {
        error_t *err = error_make(ERROR_RUNTIME, frame_src_position(vm->current_frame), "Stack underflow");
        vm_set_runtime_error(vm, err);
        APE_ASSERT(false);
        return object_make_null();
    }
    if (vm->current_frame) {
        frame_t *frame = vm->current_frame;
        function_t *current_function = object_get_function(frame->function);
        int num_locals = current_function->num_locals;
        APE_ASSERT((vm->sp - 1) >= (frame->base_pointer + num_locals));
    }
#endif
    vm->sp--;
    object_t res = vm->stack[vm->sp];
    vm->last_popped = res;
    return res;
}

static object_t stack_get(vm_t *vm, int nth_item) {
    int ix = vm->sp - 1 - nth_item;
#ifdef APE_DEBUG
    if (ix < 0 || ix >= VM_STACK_SIZE) {
        error_t *err = error_makef(ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                  "Invalid stack index: %d", nth_item);
        vm_set_runtime_error(vm, err);
        APE_ASSERT(false);
        return object_make_null();
    }
#endif
    return vm->stack[ix];
}

static void this_stack_push(vm_t *vm, object_t obj) {
#ifdef APE_DEBUG
    if (vm->this_sp >= VM_THIS_STACK_SIZE) {
        APE_ASSERT(false);
        error_t *err = error_make(ERROR_RUNTIME, frame_src_position(vm->current_frame), "this stack overflow");
        vm_set_runtime_error(vm, err);
        return;
    }
#endif
    vm->this_stack[vm->this_sp] = obj;
    vm->this_sp++;
}

static object_t this_stack_pop(vm_t *vm) {
#ifdef APE_DEBUG
    if (vm->this_sp == 0) {
        error_t *err = error_make(ERROR_RUNTIME, frame_src_position(vm->current_frame), "this stack underflow");
        vm_set_runtime_error(vm, err);
        APE_ASSERT(false);
        return object_make_null();
    }
#endif
    vm->this_sp--;
    return vm->this_stack[vm->this_sp];
}

static object_t this_stack_get(vm_t *vm, int nth_item) {
    int ix = vm->this_sp - 1 - nth_item;
#ifdef APE_DEBUG
    if (ix < 0 || ix >= VM_THIS_STACK_SIZE) {
        error_t *err = error_makef(ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                   "Invalid this stack index: %d", nth_item);
        vm_set_runtime_error(vm, err);
        APE_ASSERT(false);
        return object_make_null();
    }
#endif
    return vm->this_stack[ix];
}

static bool push_frame(vm_t *vm, frame_t frame) {
    if (vm->frames_count >= VM_MAX_FRAMES) {
        APE_ASSERT(false);
        return false;
    }
    vm->frames[vm->frames_count] = frame;
    vm->current_frame = &vm->frames[vm->frames_count];
    vm->frames_count++;
    function_t *frame_function = object_get_function(frame.function);
    set_sp(vm, frame.base_pointer + frame_function->num_locals);
    return true;
}

static bool pop_frame(vm_t *vm) {
    set_sp(vm, vm->current_frame->base_pointer - 1);
    if (vm->frames_count <= 0) {
        APE_ASSERT(false);
        vm->current_frame = NULL;
        return false;
    }
    vm->frames_count--;
    if (vm->frames_count == 0) {
        vm->current_frame = NULL;
        return false;
    }
    vm->current_frame = &vm->frames[vm->frames_count - 1];
    return true;
}

static void run_gc(vm_t *vm, array(object_t) *constants) {
    gc_unmark_all(vm->mem);
    gc_mark_objects(array_data(vm->native_functions), array_count(vm->native_functions));
    gc_mark_objects(array_data(constants), array_count(constants));
    gc_mark_objects(vm->globals, vm->globals_count);
    for (int i = 0; i < vm->frames_count; i++) {
        frame_t *frame = &vm->frames[i];
        gc_mark_object(frame->function);
    }
    gc_mark_objects(vm->stack, vm->sp);
    gc_mark_objects(vm->this_stack, vm->this_sp);
    gc_mark_object(vm->last_popped);
    gc_mark_objects(vm->operator_oveload_keys, OPCODE_MAX);
    gc_sweep(vm->mem);
}

static bool call_object(vm_t *vm, object_t callee, int num_args) {
    object_type_t callee_type = object_get_type(callee);
    if (callee_type == OBJECT_FUNCTION) {
        function_t *callee_function = object_get_function(callee);
        if (num_args != callee_function->num_args) {
            error_t *err = error_makef(ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                       "Invalid number of arguments to \"%s\", expected %d, got %d",
                                       object_get_function_name(callee), callee_function->num_args, num_args);
            vm_set_runtime_error(vm, err);
            return false;
        }
        frame_t callee_frame;
        frame_init(&callee_frame, callee, vm->sp - num_args);
        bool ok = push_frame(vm, callee_frame);
        if (!ok) {
            error_t *err = error_make(ERROR_RUNTIME, src_pos_invalid, "Pushing frame failed in call_object");
            vm_set_runtime_error(vm, err);
            return false;
        }
    } else if (callee_type == OBJECT_NATIVE_FUNCTION) {
        object_t *stack_pos = vm->stack + vm->sp - num_args;
        object_t res = call_native_function(vm, callee, frame_src_position(vm->current_frame), num_args, stack_pos);
        if (vm_has_errors(vm)) {
            return false;
        }
        set_sp(vm, vm->sp - num_args - 1);
        stack_push(vm, res);
    } else {
        const char *callee_type_name = object_get_type_name(callee_type);
        error_t *err = error_makef(ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                   "%s object is not callable", callee_type_name);
        vm_set_runtime_error(vm, err);
        return false;
    }
    return true;
}

static object_t call_native_function(vm_t *vm, object_t callee, src_pos_t src_pos, int argc, object_t *args) {
    native_function_t *bn = object_get_native_function(callee);
    object_t res = bn->fn(vm, bn->data, argc, args);
    if (vm->runtime_error != NULL && !APE_STREQ(bn->name, "crash")) {
        error_t *err = vm->runtime_error;
        err->pos = src_pos;
        err->traceback = traceback_make();
        traceback_append(err->traceback, bn->name, src_pos_invalid);
        return object_make_null();
    }
    object_type_t res_type = object_get_type(res);
    if (res_type == OBJECT_ERROR) {
        traceback_t *traceback = traceback_make();
         // error builtin is treated in a special way
        if (!APE_STREQ(bn->name, "error")) {
            traceback_append(traceback, bn->name, src_pos_invalid);
        }
        traceback_append_from_vm(traceback, vm);
        object_set_error_traceback(res, traceback);
    }
    return res;
}

static bool check_assign(vm_t *vm, object_t old_value, object_t new_value) {
    object_type_t old_value_type = object_get_type(old_value);
    object_type_t new_value_type = object_get_type(new_value);
    if (old_value_type == OBJECT_NULL || new_value_type == OBJECT_NULL) {
        return true;
    }
    if (old_value_type != new_value_type) {
        error_t *err = error_makef(ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                   "Trying to assign variable of type %s to %s",
                                   object_get_type_name(new_value_type),
                                   object_get_type_name(old_value_type)
                                   );
        vm_set_runtime_error(vm, err);
        return false;
    }
    return true;
}

static bool try_overload_operator(vm_t *vm, object_t left, object_t right, opcode_t op, bool *out_overload_found) {
    *out_overload_found = false;
    object_type_t left_type = object_get_type(left);
    object_type_t right_type = object_get_type(right);
    if (left_type != OBJECT_MAP && right_type != OBJECT_MAP) {
        *out_overload_found = false;
        return true;
    }

    int num_operands = 2;
    if (op == OPCODE_MINUS || op == OPCODE_BANG) {
        num_operands = 1;
    }

    object_t key = vm->operator_oveload_keys[op];
    object_t callee = object_make_null();
    if (left_type == OBJECT_MAP) {
        callee = object_get_map_value(left, key);
    }
    if (!object_is_callable(callee)) {
        if (right_type == OBJECT_MAP) {
            callee = object_get_map_value(right, key);
        }

        if (!object_is_callable(callee)) {
            *out_overload_found = false;
            return true;
        }
    }

    *out_overload_found = true;

    stack_push(vm, callee);
    stack_push(vm, left);
    if (num_operands == 2) {
        stack_push(vm, right);
    }
    bool ok = call_object(vm, callee, num_operands);
    return ok;
}

//FILE_END
//FILE_START:ape.c
#include "ape.h"

#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>

#define APE_IMPL_VERSION_MAJOR 0
#define APE_IMPL_VERSION_MINOR 5
#define APE_IMPL_VERSION_PATCH 0

#if (APE_VERSION_MAJOR != APE_IMPL_VERSION_MAJOR)\
 || (APE_VERSION_MINOR != APE_IMPL_VERSION_MINOR)\
 || (APE_VERSION_PATCH != APE_IMPL_VERSION_PATCH)
    #error "Version mismatch"
#endif

#ifndef APE_AMALGAMATED
#include "ape.h"
#include "gc.h"
#include "compiler.h"
#include "lexer.h"
#include "parser.h"
#include "vm.h"
#include "error.h"
#include "symbol_table.h"
#include "traceback.h"
#endif

typedef struct native_fn_wrapper {
    ape_native_fn fn;
    ape_t *ape;
    void *data;
} native_fn_wrapper_t;

typedef struct ape_program {
    ape_t *ape;
    compilation_result_t *comp_res;
} ape_program_t;

typedef struct ape {
    gcmem_t *mem;
    compiler_t *compiler;
    vm_t *vm;
    ptrarray(ape_error_t) *errors;
    ptrarray(native_fn_wrapper_t) *native_fn_wrappers;
    ape_config_t config;
} ape_t;

static object_t ape_native_fn_wrapper(vm_t *vm, void *data, int argc, object_t *args);
static object_t ape_object_to_object(ape_object_t obj);
static ape_object_t object_to_ape_object(object_t obj);

static void reset_state(ape_t *ape);
static void set_default_config(ape_t *ape);
static char* read_file_default(void *ctx, const char *filename);
static size_t write_file_default(void* context, const char *path, const char *string, size_t string_size);
static size_t stdout_write_default(void* context, const void *data, size_t size);

#undef malloc
#undef free


void* ape_mallocArg = NULL;
void* ape_freeArg = NULL;
ape_malloc_fn ape_malloc = apeMalloc;
ape_free_fn ape_free = apeFree;

//-----------------------------------------------------------------------------
// Ape
//-----------------------------------------------------------------------------

void ape_set_memory_functions(void* mallocArg, ape_malloc_fn malloc_fn, void* freeArg, ape_free_fn free_fn) {
    ape_mallocArg = mallocArg;
    ape_malloc = malloc_fn;
    ape_freeArg = freeArg;
    ape_free = free_fn;
    collections_set_memory_functions(malloc_fn, free_fn);
}

ape_t *ape_make(void) {
    ape_t *ape = ape_malloc(sizeof(ape_t), ape_mallocArg);
    memset(ape, 0, sizeof(ape_t));

    set_default_config(ape);

    ape->mem = gcmem_make();
    ape->errors = ptrarray_make();
    if (!ape->errors) {
        goto err;
    }
    if (!ape->mem) {
        goto err;
    }
    ape->compiler = compiler_make(&ape->config, ape->mem, ape->errors);
    if (!ape->compiler) {
        goto err;
    }
    ape->vm = vm_make(&ape->config, ape->mem, ape->errors);
    if (!ape->vm) {
        goto err;
    }
    ape->native_fn_wrappers = ptrarray_make();
    if (!ape->native_fn_wrappers) {
        goto err;
    }
    return ape;
err:
    gcmem_destroy(ape->mem);
    compiler_destroy(ape->compiler);
    vm_destroy(ape->vm);
    ptrarray_destroy(ape->errors);
    return NULL;
}

void ape_destroy(ape_t *ape) {
    if (!ape) {
        return;
    }
    ptrarray_destroy_with_items(ape->native_fn_wrappers, ape_free);
    ptrarray_destroy_with_items(ape->errors, error_destroy);
    vm_destroy(ape->vm);
    compiler_destroy(ape->compiler);
    gcmem_destroy(ape->mem);
    ape_free(ape, ape_freeArg);
}

void ape_set_repl_mode(ape_t *ape, bool enabled) {
    ape->config.repl_mode = enabled;
}

void ape_set_gc_interval(ape_t *ape, int interval) {
    ape->config.gc_interval = interval;
}

void ape_set_stdout_write_function(ape_t *ape, ape_stdout_write_fn stdout_write, void *context) {
    ape->config.stdio.write.write = stdout_write;
    ape->config.stdio.write.context = context;
}

void ape_set_file_write_function(ape_t *ape, ape_write_file_fn file_write, void *context) {
    ape->config.fileio.write_file.write_file = file_write;
    ape->config.fileio.write_file.context = context;
}

void ape_set_file_read_function(ape_t *ape, ape_read_file_fn file_read, void *context) {
    ape->config.fileio.read_file.read_file = file_read;
    ape->config.fileio.read_file.context = context;
}

ape_program_t* ape_compile(ape_t *ape, const char *code) {
    ptrarray_clear_and_destroy_items(ape->errors, error_destroy);

    compilation_result_t *comp_res = NULL;

    comp_res = compiler_compile(ape->compiler, code);
    if (!comp_res || ptrarray_count(ape->errors) > 0) {
        goto err;
    }

    ape_program_t *program = ape_malloc(sizeof(ape_program_t), ape_mallocArg);
    program->ape = ape;
    program->comp_res = comp_res;
    return program;

err:
    compilation_result_destroy(comp_res);
    return NULL;
}

ape_program_t* ape_compile_file(ape_t *ape, const char *path) {
    ptrarray_clear_and_destroy_items(ape->errors, error_destroy);

    compilation_result_t *comp_res = NULL;

    comp_res = compiler_compile_file(ape->compiler, path);
    if (!comp_res || ptrarray_count(ape->errors) > 0) {
        goto err;
    }

    ape_program_t *program = ape_malloc(sizeof(ape_program_t), ape_mallocArg);
    program->ape = ape;
    program->comp_res = comp_res;
    return program;

err:
    compilation_result_destroy(comp_res);
    return NULL;
}

ape_object_t ape_execute_program(ape_t *ape, const ape_program_t *program) {
    reset_state(ape);

    if (ape != program->ape) {
        error_t *err = error_make(ERROR_USER, src_pos_invalid, "ape program was compiled with a different ape instance");
        ptrarray_add(ape->errors, err);
        return ape_object_make_null();
    }

    bool ok = vm_run(ape->vm, program->comp_res, ape->compiler->constants);
    if (!ok || ptrarray_count(ape->errors)) {
        return ape_object_make_null();
    }

    APE_ASSERT(ape->vm->sp == 0);

    object_t res = vm_get_last_popped(ape->vm);
    if (object_get_type(res) == OBJECT_NONE) {
        return ape_object_make_null();
    }

    return object_to_ape_object(res);
}

void ape_program_destroy(ape_program_t *program) {
    if (!program) {
        return;
    }
    compilation_result_destroy(program->comp_res);
    ape_free(program, ape_freeArg);
}

ape_object_t ape_execute(ape_t *ape, const char *code) {
    reset_state(ape);

    compilation_result_t *comp_res = NULL;

    comp_res = compiler_compile(ape->compiler, code);
    if (!comp_res || ptrarray_count(ape->errors) > 0) {
        goto err;
    }

    bool ok = vm_run(ape->vm, comp_res, ape->compiler->constants);
    if (!ok || ptrarray_count(ape->errors)) {
        goto err;
    }

    APE_ASSERT(ape->vm->sp == 0);

    object_t res = vm_get_last_popped(ape->vm);
    if (object_get_type(res) == OBJECT_NONE) {
        goto err;
    }

    compilation_result_destroy(comp_res);

    return object_to_ape_object(res);

err:
    compilation_result_destroy(comp_res);
    return ape_object_make_null();
}

ape_object_t ape_execute_file(ape_t *ape, const char *path) {
    reset_state(ape);

    compilation_result_t *comp_res = NULL;

    comp_res = compiler_compile_file(ape->compiler, path);
    if (!comp_res || ptrarray_count(ape->errors) > 0) {
        goto err;
    }

    bool ok = vm_run(ape->vm, comp_res, ape->compiler->constants);
    if (!ok || ptrarray_count(ape->errors)) {
        goto err;
    }

    APE_ASSERT(ape->vm->sp == 0);

    object_t res = vm_get_last_popped(ape->vm);
    if (object_get_type(res) == OBJECT_NONE) {
        goto err;
    }

    compilation_result_destroy(comp_res);

    return object_to_ape_object(res);

err:
    compilation_result_destroy(comp_res);
    return ape_object_make_null();
}

ape_object_t ape_call(ape_t *ape, const char *function_name, int argc, ape_object_t *args) {
    reset_state(ape);

    object_t callee = ape_object_to_object(ape_get_object(ape, function_name));
    if (object_get_type(callee) == OBJECT_NULL) {
        return ape_object_make_null();
    }
    object_t res = vm_call(ape->vm, ape->compiler->constants, callee, argc, (object_t*)args);
    if (ptrarray_count(ape->errors) > 0) {
        return ape_object_make_null();
    }
    return object_to_ape_object(res);
}

bool ape_has_errors(const ape_t *ape) {
    return ptrarray_count(ape->errors) > 0;
}

int ape_errors_count(const ape_t *ape) {
    return ptrarray_count(ape->errors);
}

const ape_error_t* ape_get_error(const ape_t *ape, int index) {
    return ptrarray_get(ape->errors, index);
}

bool ape_set_native_function(ape_t *ape, const char *name, ape_native_fn fn, void *data) {
    native_fn_wrapper_t *wrapper = ape_malloc(sizeof(native_fn_wrapper_t), ape_mallocArg);
    memset(wrapper, 0, sizeof(native_fn_wrapper_t));
    wrapper->fn = fn;
    wrapper->ape = ape;
    wrapper->data = data;
    object_t wrapper_native_function = object_make_native_function(ape->mem, name, ape_native_fn_wrapper, wrapper);
    int ix = array_count(ape->vm->native_functions);
    array_add(ape->vm->native_functions, &wrapper_native_function);
    symbol_table_t *symbol_table = compiler_get_symbol_table(ape->compiler);
    symbol_table_define_native_function(symbol_table, name, ix);
    ptrarray_add(ape->native_fn_wrappers, wrapper);
    return true;
}

bool ape_set_global_constant(ape_t *ape, const char *name, ape_object_t obj) {
    symbol_table_t *symbol_table = compiler_get_symbol_table(ape->compiler);
    symbol_t *symbol = NULL;
    if (symbol_table_symbol_is_defined(symbol_table, name)) {
        symbol = symbol_table_resolve(symbol_table, name);
        if (symbol->type != SYMBOL_GLOBAL) {
            error_t *err = error_makef(ERROR_USER, src_pos_invalid,
                                       "Symbol \"%s\" already defined outside global scope", name);
            ptrarray_add(ape->errors, err);
            return false;
        }
    } else {
        symbol = symbol_table_define(symbol_table, name, false);
    }
    vm_set_global(ape->vm, symbol->index, ape_object_to_object(obj));
    return true;
}

ape_object_t ape_get_object(ape_t *ape, const char *name) {
    symbol_table_t *st = compiler_get_symbol_table(ape->compiler);
    symbol_t *symbol = symbol_table_resolve(st, name);
    if (!symbol) {
        error_t *err = error_makef(ERROR_USER, src_pos_invalid,
                                   "Symbol \"%s\" is not defined", name);
        ptrarray_add(ape->errors, err);
        return ape_object_make_null();
    }
    object_t res = object_make_null();
    if (symbol->type == SYMBOL_GLOBAL) {
        res = vm_get_global(ape->vm, symbol->index);
    } else if (symbol->type == SYMBOL_NATIVE_FUNCTION) {
        object_t *res_ptr = array_get(ape->vm->native_functions, symbol->index);
        res = *res_ptr;
    } else {
        error_t *err = error_makef(ERROR_USER, src_pos_invalid,
                                   "Value associated with symbol \"%s\" could not be loaded", name);
        ptrarray_add(ape->errors, err);
        return ape_object_make_null();
    }
    return object_to_ape_object(res);
}

bool ape_check_args(ape_t *ape, bool generate_error, int argc, ape_object_t *args, int expected_argc, int *expected_types) {
    if (argc != expected_argc) {
        if (generate_error) {
            ape_set_runtime_errorf(ape, "Invalid number or arguments, got %d instead of %d", argc, expected_argc);
        }
        return false;
    }

    for(int i = 0; i < argc; i++) {
        ape_object_t arg = args[i];
        ape_object_type_t type = ape_object_get_type(arg);
        ape_object_type_t expected_type = expected_types[i];
        if (!(type & expected_type)) {
            if (generate_error) {
                const char *type_str = ape_object_get_type_name(type);
                const char *expected_type_str = ape_object_get_type_name(expected_type);
                ape_set_runtime_errorf(ape, "Invalid argument type, got %s, expected %s", type_str, expected_type_str);
            }
            return false;
        }
    }
    return true;
}

//-----------------------------------------------------------------------------
// Ape object
//-----------------------------------------------------------------------------

ape_object_t ape_object_make_number(double val) {
    return object_to_ape_object(object_make_number(val));
}

ape_object_t ape_object_make_bool(bool val) {
    return object_to_ape_object(object_make_bool(val));
}

ape_object_t ape_object_make_string(ape_t *ape, const char *str) {
    return object_to_ape_object(object_make_string(ape->mem, str));
}

ape_object_t ape_object_make_stringf(ape_t *ape, const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    int to_write = vsnprintf(NULL, 0, fmt, args);
    va_end(args);
    va_start(args, fmt);
    char *res = (char*)ape_malloc(to_write + 1, ape_mallocArg);
    int written = vsprintf(res, fmt, args);
    (void)written;
    APE_ASSERT(written == to_write);
    va_end(args);
    return object_to_ape_object(object_make_string_no_copy(ape->mem, res));
}

ape_object_t ape_object_make_null() {
    return object_to_ape_object(object_make_null());
}

ape_object_t ape_object_make_array(ape_t *ape) {
    return object_to_ape_object(object_make_array(ape->mem));
}

ape_object_t ape_object_make_map(ape_t *ape) {
    return object_to_ape_object(object_make_map(ape->mem));
}

ape_object_t ape_object_make_native_function(ape_t *ape, ape_native_fn fn, void *data) {
    native_fn_wrapper_t *wrapper = ape_malloc(sizeof(native_fn_wrapper_t), ape_mallocArg);
    memset(wrapper, 0, sizeof(native_fn_wrapper_t));
    wrapper->fn = fn;
    wrapper->ape = ape;
    wrapper->data = data;
    object_t wrapper_native_function = object_make_native_function(ape->mem, "", ape_native_fn_wrapper, wrapper);
    ptrarray_add(ape->native_fn_wrappers, wrapper);
    return object_to_ape_object(wrapper_native_function);
}

ape_object_t ape_object_make_error(ape_t *ape, const char *msg) {
    return object_to_ape_object(object_make_error(ape->mem, msg));
}

ape_object_t ape_object_make_errorf(ape_t *ape, const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    int to_write = vsnprintf(NULL, 0, fmt, args);
    va_end(args);
    va_start(args, fmt);
    char *res = (char*)ape_malloc(to_write + 1, ape_mallocArg);
    int written = vsprintf(res, fmt, args);
    (void)written;
    APE_ASSERT(written == to_write);
    va_end(args);
    return object_to_ape_object(object_make_error_no_copy(ape->mem, res));
}

ape_object_t ape_object_make_external(ape_t *ape, void *data) {
    object_t res = object_make_external(ape->mem, data);
    return object_to_ape_object(res);
}

char *ape_object_serialize(ape_object_t obj) {
    return object_serialize(ape_object_to_object(obj));
}

void ape_object_disable_gc(ape_object_t ape_obj) {
    object_t obj = ape_object_to_object(ape_obj);
    gc_disable_on_object(obj);
}

void ape_object_enable_gc(ape_object_t ape_obj) {
    object_t obj = ape_object_to_object(ape_obj);
    gc_enable_on_object(obj);
}

bool ape_object_equals(ape_object_t ape_a, ape_object_t ape_b){
    object_t a = ape_object_to_object(ape_a);
    object_t b = ape_object_to_object(ape_b);
    return object_equals(a, b);
}

ape_object_t ape_object_copy(ape_object_t ape_obj) {
    object_t obj = ape_object_to_object(ape_obj);
    gcmem_t *mem = object_get_mem(obj);
    object_t res = object_copy(mem, obj);
    return object_to_ape_object(res);
}

ape_object_t ape_object_deep_copy(ape_object_t ape_obj) {
    object_t obj = ape_object_to_object(ape_obj);
    gcmem_t *mem = object_get_mem(obj);
    object_t res = object_deep_copy(mem, obj);
    return object_to_ape_object(res);
}

void ape_set_runtime_error(ape_t *ape, const char *message) {
    error_t *err = error_make(ERROR_RUNTIME, src_pos_invalid, message);
    ptrarray_add(ape->errors, err);
}

void ape_set_runtime_errorf(ape_t *ape, const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    int to_write = vsnprintf(NULL, 0, fmt, args);
    va_end(args);
    va_start(args, fmt);
    char *message = (char*)ape_malloc(to_write + 1, ape_mallocArg);
    vsprintf(message, fmt, args);
    va_end(args);

    error_t *err = error_make_no_copy(ERROR_RUNTIME, src_pos_invalid, message);

    ptrarray_add(ape->errors, err);
}

ape_object_type_t ape_object_get_type(ape_object_t ape_obj) {
    object_t obj = ape_object_to_object(ape_obj);
    switch (object_get_type(obj)) {
        case OBJECT_NONE:            return APE_OBJECT_NONE;
        case OBJECT_ERROR:           return APE_OBJECT_ERROR;
        case OBJECT_NUMBER:          return APE_OBJECT_NUMBER;
        case OBJECT_BOOL:            return APE_OBJECT_BOOL;
        case OBJECT_STRING:          return APE_OBJECT_STRING;
        case OBJECT_NULL:            return APE_OBJECT_NULL;
        case OBJECT_NATIVE_FUNCTION: return APE_OBJECT_NATIVE_FUNCTION;
        case OBJECT_ARRAY:           return APE_OBJECT_ARRAY;
        case OBJECT_MAP:             return APE_OBJECT_MAP;
        case OBJECT_FUNCTION:        return APE_OBJECT_FUNCTION;
        case OBJECT_EXTERNAL:        return APE_OBJECT_EXTERNAL;
        case OBJECT_FREED:           return APE_OBJECT_FREED;
        case OBJECT_ANY:             return APE_OBJECT_ANY;
        default:                     return APE_OBJECT_NONE;
    }
}

const char* ape_object_get_type_string(ape_object_t obj) {
    return ape_object_get_type_name(ape_object_get_type(obj));
}

const char* ape_object_get_type_name(ape_object_type_t type) {
    switch (type) {
        case APE_OBJECT_NONE:            return "NONE";
        case APE_OBJECT_ERROR:           return "ERROR";
        case APE_OBJECT_NUMBER:          return "NUMBER";
        case APE_OBJECT_BOOL:            return "BOOL";
        case APE_OBJECT_STRING:          return "STRING";
        case APE_OBJECT_NULL:            return "NULL";
        case APE_OBJECT_NATIVE_FUNCTION: return "NATIVE_FUNCTION";
        case APE_OBJECT_ARRAY:           return "ARRAY";
        case APE_OBJECT_MAP:             return "MAP";
        case APE_OBJECT_FUNCTION:        return "FUNCTION";
        case APE_OBJECT_EXTERNAL:        return "EXTERNAL";
        case APE_OBJECT_FREED:           return "FREED";
        case APE_OBJECT_ANY:             return "ANY";
        default:                         return "NONE";
    }
}

double ape_object_get_number(ape_object_t obj) {
    return object_get_number(ape_object_to_object(obj));
}

bool ape_object_get_bool(ape_object_t obj) {
    return object_get_bool(ape_object_to_object(obj));
}

const char *ape_object_get_string(ape_object_t obj) {
    return object_get_string(ape_object_to_object(obj));
}

void *ape_object_get_external(ape_object_t obj) {
    external_data_t* data = object_get_external_data(ape_object_to_object(obj));
    if(!data) return NULL;
    return data->data;
}

const char *ape_object_get_error_message(ape_object_t obj) {
    return object_get_error_message(ape_object_to_object(obj));
}

const ape_traceback_t* ape_object_get_error_traceback(ape_object_t ape_obj) {
    object_t obj = ape_object_to_object(ape_obj);
    return (const ape_traceback_t*)object_get_error_traceback(obj);
}

bool ape_object_set_external_destroy_function(ape_object_t object, ape_data_destroy_fn destroy_fn) {
    return object_set_external_destroy_function(ape_object_to_object(object), (external_data_destroy_fn)destroy_fn);
}

bool ape_object_set_external_copy_function(ape_object_t object, ape_data_copy_fn copy_fn) {
    return object_set_external_copy_function(ape_object_to_object(object), (external_data_copy_fn)copy_fn);
}

//-----------------------------------------------------------------------------
// Ape object array
//-----------------------------------------------------------------------------

int ape_object_get_array_length(ape_object_t obj) {
    return object_get_array_length(ape_object_to_object(obj));
}

ape_object_t ape_object_get_array_value(ape_object_t obj, int ix) {
    object_t res = object_get_array_value_at(ape_object_to_object(obj), ix);
    return object_to_ape_object(res);
}

const char* ape_object_get_array_string(ape_object_t obj, int ix) {
    ape_object_t object = ape_object_get_array_value(obj, ix);
    if (ape_object_get_type(object) != APE_OBJECT_STRING) {
        return NULL;
    }
    return ape_object_get_string(object);
}

double ape_object_get_array_number(ape_object_t obj, int ix) {
    ape_object_t object = ape_object_get_array_value(obj, ix);
    if (ape_object_get_type(object) != APE_OBJECT_NUMBER) {
        return 0;
    }
    return ape_object_get_number(object);
}

bool ape_object_get_array_bool(ape_object_t obj, int ix) {
    ape_object_t object = ape_object_get_array_value(obj, ix);
    if (ape_object_get_type(object) != APE_OBJECT_BOOL) {
        return 0;
    }
    return ape_object_get_bool(object);
}

bool ape_object_set_array_value(ape_object_t ape_obj, int ix, ape_object_t ape_value) {
    object_t obj = ape_object_to_object(ape_obj);
    object_t value = ape_object_to_object(ape_value);
    return object_set_array_value_at(obj, ix, value);
}

bool ape_object_set_array_string(ape_object_t obj, int ix, const char *string) {
    gcmem_t *mem = object_get_mem(ape_object_to_object(obj));
    if (!mem) {
        return false;
    }
    object_t new_value = object_make_string(mem, string);
    return ape_object_set_array_value(obj, ix, object_to_ape_object(new_value));
}

bool ape_object_set_array_number(ape_object_t obj, int ix, double number) {
    object_t new_value = object_make_number(number);
    return ape_object_set_array_value(obj, ix, object_to_ape_object(new_value));
}

bool ape_object_set_array_bool(ape_object_t obj, int ix, bool value) {
    object_t new_value = object_make_bool(value);
    return ape_object_set_array_value(obj, ix, object_to_ape_object(new_value));
}

bool ape_object_add_array_value(ape_object_t ape_obj, ape_object_t ape_value) {
    object_t obj = ape_object_to_object(ape_obj);
    object_t value = ape_object_to_object(ape_value);
    return object_add_array_value(obj, value);
}

bool ape_object_add_array_string(ape_object_t obj, const char *string) {
    gcmem_t *mem = object_get_mem(ape_object_to_object(obj));
    if (!mem) {
        return false;
    }
    object_t new_value = object_make_string(mem, string);
    return ape_object_add_array_value(obj, object_to_ape_object(new_value));
}

bool ape_object_add_array_number(ape_object_t obj, double number) {
    object_t new_value = object_make_number(number);
    return ape_object_add_array_value(obj, object_to_ape_object(new_value));
}

bool ape_object_add_array_bool(ape_object_t obj, bool value) {
    object_t new_value = object_make_bool(value);
    return ape_object_add_array_value(obj, object_to_ape_object(new_value));
}

//-----------------------------------------------------------------------------
// Ape object map
//-----------------------------------------------------------------------------

int ape_object_get_map_length(ape_object_t obj) {
    return object_get_map_length(ape_object_to_object(obj));
}

ape_object_t ape_object_get_map_key_at(ape_object_t ape_obj, int ix) {
    object_t obj = ape_object_to_object(ape_obj);
    return object_to_ape_object(object_get_map_key_at(obj, ix));
}

ape_object_t ape_object_get_map_value_at(ape_object_t ape_obj, int ix) {
    object_t obj = ape_object_to_object(ape_obj);
    object_t res = object_get_map_value_at(obj, ix);
    return object_to_ape_object(res);
}

bool ape_object_set_map_value_at(ape_object_t ape_obj, int ix, ape_object_t ape_val) {
    object_t obj = ape_object_to_object(ape_obj);
    object_t val = ape_object_to_object(ape_val);
    return object_set_map_value_at(obj, ix, val);
}

bool ape_object_set_map_value_with_value_key(ape_object_t obj, ape_object_t key, ape_object_t val) {
    return object_set_map_value(ape_object_to_object(obj), ape_object_to_object(key), ape_object_to_object(val));
}

bool ape_object_set_map_value(ape_object_t obj, const char *key, ape_object_t value) {
    gcmem_t *mem = object_get_mem(ape_object_to_object(obj));
    object_t key_object = object_make_string(mem, key);
    return ape_object_set_map_value_with_value_key(obj, object_to_ape_object(key_object), value);
}

bool ape_object_set_map_string(ape_object_t obj, const char *key, const char *string) {
    gcmem_t *mem = object_get_mem(ape_object_to_object(obj));
    object_t string_object = object_make_string(mem, string);
    return ape_object_set_map_value(obj, key, object_to_ape_object(string_object));
}

bool ape_object_set_map_number(ape_object_t obj, const char *key, double number) {
    object_t number_object = object_make_number(number);
    return ape_object_set_map_value(obj, key, object_to_ape_object(number_object));
}

bool ape_object_set_map_bool(ape_object_t obj, const char *key, bool value) {
    object_t bool_object = object_make_bool(value);
    return ape_object_set_map_value(obj, key, object_to_ape_object(bool_object));
}

ape_object_t ape_object_get_map_value_with_value_key(ape_object_t obj, ape_object_t key) {
    return object_to_ape_object(object_get_map_value(ape_object_to_object(obj), ape_object_to_object(key)));
}

ape_object_t ape_object_get_map_value(ape_object_t object, const char *key) {
    gcmem_t *mem = object_get_mem(ape_object_to_object(object));
    if (!mem) {
        return ape_object_make_null();
    }
    object_t key_object = object_make_string(mem, key);
    ape_object_t res = ape_object_get_map_value_with_value_key(object, object_to_ape_object(key_object));
    return res;
}

const char* ape_object_get_map_string(ape_object_t object, const char *key) {
    ape_object_t res = ape_object_get_map_value(object, key);
    return ape_object_get_string(res);
}

double ape_object_get_map_number(ape_object_t object, const char *key) {
    ape_object_t res = ape_object_get_map_value(object, key);
    return ape_object_get_number(res);
}

bool ape_object_get_map_bool(ape_object_t object, const char *key) {
    ape_object_t res = ape_object_get_map_value(object, key);
    return ape_object_get_bool(res);
}

bool ape_object_map_has_key(ape_object_t ape_object, const char *key) {
    object_t object = ape_object_to_object(ape_object);
    gcmem_t *mem = object_get_mem(object);
    if (!mem) {
        return false;
    }
    object_t key_object = object_make_string(mem, key);
    return object_map_has_key(object, key_object);
}

//-----------------------------------------------------------------------------
// Ape error
//-----------------------------------------------------------------------------

const char* ape_error_get_message(const ape_error_t *ape_error) {
    const error_t *error = (const error_t*)ape_error;
    return error->message;
}

const char* ape_error_get_filepath(const ape_error_t *ape_error) {
    const error_t *error = (const error_t*)ape_error;
    if (!error->pos.file) {
        return NULL;
    }
    return error->pos.file->path;
}

const char* ape_error_get_line(const ape_error_t *ape_error) {
    const error_t *error = (const error_t*)ape_error;
    if (!error->pos.file) {
        return NULL;
    }
    ptrarray(char*) *lines = error->pos.file->lines;
    if (error->pos.line >= ptrarray_count(lines)) {
        return NULL;
    }
    const char *line = ptrarray_get(lines, error->pos.line);
    return line;
}

int ape_error_get_line_number(const ape_error_t *ape_error) {
    const error_t *error = (const error_t*)ape_error;
    return error->pos.line + 1;
}

int ape_error_get_column_number(const ape_error_t *ape_error) {
    const error_t *error = (const error_t*)ape_error;
    return error->pos.column + 1;
}

ape_error_type_t ape_error_get_type(const ape_error_t *ape_error) {
    const error_t *error = (const error_t*)ape_error;
    switch (error->type) {
        case ERROR_NONE: return APE_ERROR_NONE;
        case ERROR_PARSING: return APE_ERROR_PARSING;
        case ERROR_COMPILATION: return APE_ERROR_COMPILATION;
        case ERROR_RUNTIME: return APE_ERROR_RUNTIME;
        case ERROR_USER: return APE_ERROR_USER;
        default: return APE_ERROR_NONE;
    }
}

const char* ape_error_get_type_string(const ape_error_t *error) {
    return ape_error_type_to_string(ape_error_get_type(error));
}

const char* ape_error_type_to_string(ape_error_type_t type) {
    switch (type) {
        case APE_ERROR_PARSING: return "PARSING";
        case APE_ERROR_COMPILATION: return "COMPILATION";
        case APE_ERROR_RUNTIME: return "RUNTIME";
        case APE_ERROR_USER: return "USER";
        default: return "NONE";
    }
}

char* ape_error_serialize(const ape_error_t *err) {
    const char *type_str = ape_error_get_type_string(err);
    const char *filename = ape_error_get_filepath(err);
    const char *line = ape_error_get_line(err);
    int line_num = ape_error_get_line_number(err);
    int col_num = ape_error_get_column_number(err);
    strbuf_t *buf = strbuf_make();
    if (line) {
        strbuf_append(buf, line);
        strbuf_append(buf, "\n");
        if (col_num >= 0) {
            for (int j = 0; j < (col_num - 1); j++) {
                strbuf_append(buf, " ");
            }
            strbuf_append(buf, "^\n");
        }
    }
    strbuf_appendf(buf, "%s ERROR in \"%s\" on %d:%d: %s\n", type_str,
           filename, line_num, col_num, ape_error_get_message(err));
    const ape_traceback_t *traceback = ape_error_get_traceback(err);
    if (traceback) {
        strbuf_appendf(buf, "Traceback:\n");
        traceback_to_string((const traceback_t*)ape_error_get_traceback(err), buf);
    }
    return strbuf_get_string_and_destroy(buf);
}

const ape_traceback_t* ape_error_get_traceback(const ape_error_t *ape_error) {
    const error_t *error = (const error_t*)ape_error;
    return (const ape_traceback_t*)error->traceback;
}

//-----------------------------------------------------------------------------
// Ape traceback
//-----------------------------------------------------------------------------

int ape_traceback_get_depth(const ape_traceback_t *ape_traceback) {
    const traceback_t *traceback = (const traceback_t*)ape_traceback;
    return array_count(traceback->items);
}

const char* ape_traceback_get_filepath(const ape_traceback_t *ape_traceback, int depth) {
    const traceback_t *traceback = (const traceback_t*)ape_traceback;
    traceback_item_t *item = array_get(traceback->items, depth);
    if (!item) {
        return NULL;
    }
    return traceback_item_get_filepath(item);
}

const char* ape_traceback_get_line(const ape_traceback_t *ape_traceback, int depth) {
    const traceback_t *traceback = (const traceback_t*)ape_traceback;
    traceback_item_t *item = array_get(traceback->items, depth);
    if (!item) {
        return NULL;
    }
    return traceback_item_get_line(item);
}

int ape_traceback_get_line_number(const ape_traceback_t *ape_traceback, int depth) {
    const traceback_t *traceback = (const traceback_t*)ape_traceback;
    traceback_item_t *item = array_get(traceback->items, depth);
    if (!item) {
        return -1;
    }
    return item->pos.line;
}

int ape_traceback_get_column_number(const ape_traceback_t *ape_traceback, int depth) {
    const traceback_t *traceback = (const traceback_t*)ape_traceback;
    traceback_item_t *item = array_get(traceback->items, depth);
    if (!item) {
        return -1;
    }
    return item->pos.column;
}

const char* ape_traceback_get_function_name(const ape_traceback_t *ape_traceback, int depth) {
    const traceback_t *traceback = (const traceback_t*)ape_traceback;
    traceback_item_t *item = array_get(traceback->items, depth);
    if (!item) {
        return "";
    }
    return item->function_name;
}

//-----------------------------------------------------------------------------
// Ape internal
//-----------------------------------------------------------------------------

static object_t ape_native_fn_wrapper(vm_t *vm, void *data, int argc, object_t *args) {
    native_fn_wrapper_t *wrapper = (native_fn_wrapper_t*)data;
    APE_ASSERT(vm == wrapper->ape->vm);
    ape_object_t res = wrapper->fn(wrapper->ape, wrapper->data, argc, (ape_object_t*)args);
    if (ape_has_errors(wrapper->ape)) {
        return object_make_null();
    }
    return ape_object_to_object(res);
}

static object_t ape_object_to_object(ape_object_t obj) {
    return (object_t){ .handle = obj._internal };
}

static ape_object_t object_to_ape_object(object_t obj) {
    return (ape_object_t){ ._internal = obj.handle };
}

static void reset_state(ape_t *ape) {
    ptrarray_clear_and_destroy_items(ape->errors, error_destroy);
    vm_reset(ape->vm);
}

static void set_default_config(ape_t *ape) {
    memset(&ape->config, 0, sizeof(ape_config_t));
    ape_set_repl_mode(ape, false);
    ape_set_file_read_function(ape, read_file_default, NULL);
    ape_set_file_write_function(ape, write_file_default, NULL);
    ape_set_stdout_write_function(ape, stdout_write_default, NULL);
    ape_set_gc_interval(ape, 10000);
}

static char* read_file_default(void *ctx, const char *filename){
    FILE *fp = fopen(filename, "r");
    size_t size_to_read = 0;
    size_t size_read = 0;
    long pos;
    char *file_contents;
    if (!fp) {
        return NULL;
    }
    fseek(fp, 0L, SEEK_END);
    pos = ftell(fp);
    if (pos < 0) {
        fclose(fp);
        return NULL;
    }
    size_to_read = pos;
    rewind(fp);
    file_contents = (char*)ape_malloc(sizeof(char) * (size_to_read + 1), ape_mallocArg);
    if (!file_contents) {
        fclose(fp);
        return NULL;
    }
    size_read = fread(file_contents, 1, size_to_read, fp);
    if (size_read == 0 || ferror(fp)) {
        fclose(fp);
        free(file_contents);
        return NULL;
    }
    fclose(fp);
    file_contents[size_read] = '\0';
    return file_contents;
}

static size_t write_file_default(void* context, const char *path, const char *string, size_t string_size) {
    FILE *fp = fopen(path, "w");
    if (!fp) {
        return 0;
    }
    size_t written = fwrite(string, 1, string_size, fp);
    fclose(fp);
    return written;
}

static size_t stdout_write_default(void* context, const void *data, size_t size) {
    return fwrite(data, 1, size, stdout);
}
//FILE_END
#include "assert.h"


#include <stdlib.h>

#if defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) || defined(__MINGW32__) || defined(__BORLANDC__)
#define OS_WIN
#endif

#if defined(OS_WIN) && !defined(__TINYC__)
#include <windows.h>
#include <libloaderapi.h>
#endif

#if defined(__TINYC__)
#include <winapi/windows.h>
#endif

#include <sys/types.h>
#include <sys/stat.h>

typedef struct _stat FileStat;

//#if defined(__TINYC__)
//#include <sys/unistd.h>
//size_t __cdecl strnlen(const char *_Str,size_t _MaxCount);
//#endif

#include <errno.h>



#if _MSC_VER
#define LITAC_THREADLOCAL __declspec(thread)
#define LITAC_INLINE static inline __forceinline
#define LITAC_NOINLINE __declspec(noinline)
#define LITAC_PACKED __pragma(pack(push, 1))
#define LITAC_PACKED_POP __pragma(pack(pop))
#define LITAC_EXPORT __declspec(dllexport)
#endif

#if __GNUC__
#define LITAC_THREADLOCAL __thread
#define LITAC_INLINE static inline __attribute__((always_inline))
#define LITAC_NOINLINE __attribute__((noinline))
#define LITAC_PACKED __attribute__((packed))
#define LITAC_PACKED_POP
#define LITAC_EXPORT __attribute__((visibility("default")))
#endif


#if __TINYC__
#define LITAC_THREADLOCAL
#define LITAC_INLINE
#define LITAC_NOINLINE
#define LITAC_PACKED __attribute__((packed))
#define LITAC_PACKED_POP
#define LITAC_EXPORT __attribute__((dllexport))
#endif

#include <libtcc.h>


#include <stdarg.h>

#include <stdio.h>

#include <stdlib.h>

#include <math.h>

#include <ctype.h>

#include <limits.h>

#include <string.h>


#define MIN(x, y) ((x) <= (y) ? (x) : (y))
#define MAX(x, y) ((x) >= (y) ? (x) : (y))
#define ABS(x)    ((x < 0) ? (x) * -1 : (x))


#if defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) || defined(__MINGW32__) || defined(__BORLANDC__)
#define OS_WIN
#endif

#if !defined(OS_WIN) || defined(__TINYC__)
size_t strnlen(const char * s, size_t len) {
    size_t i = 0;
    for ( ; i < len && s[i] != '\0'; ++i);
    return i;
}
#endif



#define LITAC_DEFAULT_ALIGNMENT (2*sizeof(void*))

/*
 *
 * Mini regex-module inspired by Rob Pike's regex code described in:
 *
 * http://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html
 *
 *
 *
 * Supports:
 * ---------
 *   '.'        Dot, matches any character
 *   '^'        Start anchor, matches beginning of string
 *   '$'        End anchor, matches end of string
 *   '*'        Asterisk, match zero or more (greedy)
 *   '+'        Plus, match one or more (greedy)
 *   '?'        Question, match zero or one (non-greedy)
 *   '[abc]'    Character class, match if one of {'a', 'b', 'c'}
 *   '[^abc]'   Inverted class, match if NOT one of {'a', 'b', 'c'} -- NOTE: feature is currently broken!
 *   '[a-zA-Z]' Character ranges, the character set of the ranges { a-z | A-Z }
 *   '\s'       Whitespace, \t \f \r \n \v and spaces
 *   '\S'       Non-whitespace
 *   '\w'       Alphanumeric, [a-zA-Z0-9_]
 *   '\W'       Non-alphanumeric
 *   '\d'       Digits, [0-9]
 *   '\D'       Non-digits
 *
 *
 */



/*
 *
 * Mini regex-module inspired by Rob Pike's regex code described in:
 *
 * http://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html
 *
 *
 *
 * Supports:
 * ---------
 *   '.'        Dot, matches any character
 *   '^'        Start anchor, matches beginning of string
 *   '$'        End anchor, matches end of string
 *   '*'        Asterisk, match zero or more (greedy)
 *   '+'        Plus, match one or more (greedy)
 *   '?'        Question, match zero or one (non-greedy)
 *   '[abc]'    Character class, match if one of {'a', 'b', 'c'}
 *   '[^abc]'   Inverted class, match if NOT one of {'a', 'b', 'c'} -- NOTE: feature is currently broken!
 *   '[a-zA-Z]' Character ranges, the character set of the ranges { a-z | A-Z }
 *   '\s'       Whitespace, \t \f \r \n \v and spaces
 *   '\S'       Non-whitespace
 *   '\w'       Alphanumeric, [a-zA-Z0-9_]
 *   '\W'       Non-alphanumeric
 *   '\d'       Digits, [0-9]
 *   '\D'       Non-digits
 *
 *
 */

#ifndef _TINY_REGEX_C
#define _TINY_REGEX_C


#ifndef RE_DOT_MATCHES_NEWLINE
/* Define to 0 if you DON'T want '.' to match '\r' + '\n' */
#define RE_DOT_MATCHES_NEWLINE 1
#endif

#ifdef __cplusplus
extern "C"{
#endif



/* Typedef'd pointer to get abstract datatype. */
typedef struct regex_t* re_t;


/* Compile regex string pattern to a regex_t-array. */
re_t re_compile(const char* pattern);


/* Find matches of the compiled pattern inside text. */
int  re_matchp(re_t pattern, const char* text, int* matchlength);


/* Find matches of the txt pattern inside text (will compile automatically first). */
int  re_match(const char* pattern, const char* text, int* matchlength);


#ifdef __cplusplus
}
#endif

#endif /* ifndef _TINY_REGEX_C */

#include <stdio.h>

/* Definitions: */

#define MAX_REGEXP_OBJECTS      30    /* Max number of regex symbols in expression. */
#define MAX_CHAR_CLASS_LEN      40    /* Max length of character-class buffer in.   */


enum { UNUSED, DOT, BEGIN, END, QUESTIONMARK, STAR, PLUS, RE_CHAR, CHAR_CLASS, INV_CHAR_CLASS, DIGIT, NOT_DIGIT, ALPHA, NOT_ALPHA, WHITESPACE, NOT_WHITESPACE, /* BRANCH */ };

typedef struct regex_t
{
  unsigned char  type;   /* CHAR, STAR, etc.                      */
  union
  {
    unsigned char  ch;   /*      the character itself             */
    unsigned char* ccl;  /*  OR  a pointer to characters in class */
  };
} regex_t;



/* Private function declarations: */
static int matchpattern(regex_t* pattern, const char* text, int* matchlength);
static int matchcharclass(char c, const char* str);
static int matchstar(regex_t p, regex_t* pattern, const char* text, int* matchlength);
static int matchplus(regex_t p, regex_t* pattern, const char* text, int* matchlength);
static int matchone(regex_t p, char c);
static int matchdigit(char c);
static int matchalpha(char c);
static int matchwhitespace(char c);
static int matchmetachar(char c, const char* str);
static int matchrange(char c, const char* str);
static int matchdot(char c);
static int ismetachar(char c);



/* Public functions: */
int re_match(const char* pattern, const char* text, int* matchlength)
{
  return re_matchp(re_compile(pattern), text, matchlength);
}

int re_matchp(re_t pattern, const char* text, int* matchlength)
{
  *matchlength = 0;
  if (pattern != 0)
  {
    if (pattern[0].type == BEGIN)
    {
      return ((matchpattern(&pattern[1], text, matchlength)) ? 0 : -1);
    }
    else
    {
      int idx = -1;

      do
      {
        idx += 1;

        if (matchpattern(pattern, text, matchlength))
        {
          if (text[0] == '\0')
            return -1;

          return idx;
        }
      }
      while (*text++ != '\0');
    }
  }
  return -1;
}

re_t re_compile(const char* pattern)
{
  /* The sizes of the two static arrays below substantiates the static RAM usage of this module.
     MAX_REGEXP_OBJECTS is the max number of symbols in the expression.
     MAX_CHAR_CLASS_LEN determines the size of buffer for chars in all char-classes in the expression. */
  static regex_t re_compiled[MAX_REGEXP_OBJECTS];
  static unsigned char ccl_buf[MAX_CHAR_CLASS_LEN];
  int ccl_bufidx = 1;

  char c;     /* current char in pattern   */
  int i = 0;  /* index into pattern        */
  int j = 0;  /* index into re_compiled    */

  while (pattern[i] != '\0' && (j+1 < MAX_REGEXP_OBJECTS))
  {
    c = pattern[i];

    switch (c)
    {
      /* Meta-characters: */
      case '^': {    re_compiled[j].type = BEGIN;           } break;
      case '$': {    re_compiled[j].type = END;             } break;
      case '.': {    re_compiled[j].type = DOT;             } break;
      case '*': {    re_compiled[j].type = STAR;            } break;
      case '+': {    re_compiled[j].type = PLUS;            } break;
      case '?': {    re_compiled[j].type = QUESTIONMARK;    } break;
/*    case '|': {    re_compiled[j].type = BRANCH;          } break; <-- not working properly */

      /* Escaped character-classes (\s \w ...): */
      case '\\':
      {
        if (pattern[i+1] != '\0')
        {
          /* Skip the escape-char '\\' */
          i += 1;
          /* ... and check the next */
          switch (pattern[i])
          {
            /* Meta-character: */
            case 'd': {    re_compiled[j].type = DIGIT;            } break;
            case 'D': {    re_compiled[j].type = NOT_DIGIT;        } break;
            case 'w': {    re_compiled[j].type = ALPHA;            } break;
            case 'W': {    re_compiled[j].type = NOT_ALPHA;        } break;
            case 's': {    re_compiled[j].type = WHITESPACE;       } break;
            case 'S': {    re_compiled[j].type = NOT_WHITESPACE;   } break;

            /* Escaped character, e.g. '.' or '$' */
            default:
            {
              re_compiled[j].type = RE_CHAR;
              re_compiled[j].ch = pattern[i];
            } break;
          }
        }
        /* '\\' as last char in pattern -> invalid regular expression. */
/*
        else
        {
          re_compiled[j].type = CHAR;
          re_compiled[j].ch = pattern[i];
        }
*/
      } break;

      /* Character class: */
      case '[':
      {
        /* Remember where the char-buffer starts. */
        int buf_begin = ccl_bufidx;

        /* Look-ahead to determine if negated */
        if (pattern[i+1] == '^')
        {
          re_compiled[j].type = INV_CHAR_CLASS;
          i += 1; /* Increment i to avoid including '^' in the char-buffer */
          if (pattern[i+1] == 0) /* incomplete pattern, missing non-zero char after '^' */
          {
            return 0;
          }
        }
        else
        {
          re_compiled[j].type = CHAR_CLASS;
        }

        /* Copy characters inside [..] to buffer */
        while (    (pattern[++i] != ']')
                && (pattern[i]   != '\0')) /* Missing ] */
        {
          if (pattern[i] == '\\')
          {
            if (ccl_bufidx >= MAX_CHAR_CLASS_LEN - 1)
            {
              //fputs("exceeded internal buffer!\n", stderr);
              return 0;
            }
            if (pattern[i+1] == 0) /* incomplete pattern, missing non-zero char after '\\' */
            {
              return 0;
            }
            ccl_buf[ccl_bufidx++] = pattern[i++];
          }
          else if (ccl_bufidx >= MAX_CHAR_CLASS_LEN)
          {
              //fputs("exceeded internal buffer!\n", stderr);
              return 0;
          }
          ccl_buf[ccl_bufidx++] = pattern[i];
        }
        if (ccl_bufidx >= MAX_CHAR_CLASS_LEN)
        {
            /* Catches cases such as [00000000000000000000000000000000000000][ */
            //fputs("exceeded internal buffer!\n", stderr);
            return 0;
        }
        /* Null-terminate string end */
        ccl_buf[ccl_bufidx++] = 0;
        re_compiled[j].ccl = &ccl_buf[buf_begin];
      } break;

      /* Other characters: */
      default:
      {
        re_compiled[j].type = RE_CHAR;
        re_compiled[j].ch = c;
      } break;
    }
    /* no buffer-out-of-bounds access on invalid patterns - see https://github.com/kokke/tiny-regex-c/commit/1a279e04014b70b0695fba559a7c05d55e6ee90b */
    if (pattern[i] == 0)
    {
      return 0;
    }

    i += 1;
    j += 1;
  }
  /* 'UNUSED' is a sentinel used to indicate end-of-pattern */
  re_compiled[j].type = UNUSED;

  return (re_t) re_compiled;
}

void re_print(regex_t* pattern)
{
  const char* types[] = { "UNUSED", "DOT", "BEGIN", "END", "QUESTIONMARK", "STAR", "PLUS", "CHAR", "CHAR_CLASS", "INV_CHAR_CLASS", "DIGIT", "NOT_DIGIT", "ALPHA", "NOT_ALPHA", "WHITESPACE", "NOT_WHITESPACE", "BRANCH" };

  int i;
  int j;
  char c;
  for (i = 0; i < MAX_REGEXP_OBJECTS; ++i)
  {
    if (pattern[i].type == UNUSED)
    {
      break;
    }

    printf("type: %s", types[pattern[i].type]);
    if (pattern[i].type == CHAR_CLASS || pattern[i].type == INV_CHAR_CLASS)
    {
      printf(" [");
      for (j = 0; j < MAX_CHAR_CLASS_LEN; ++j)
      {
        c = pattern[i].ccl[j];
        if ((c == '\0') || (c == ']'))
        {
          break;
        }
        printf("%c", c);
      }
      printf("]");
    }
    else if (pattern[i].type == RE_CHAR)
    {
      printf(" '%c'", pattern[i].ch);
    }
    printf("\n");
  }
}



/* Private functions: */
static int matchdigit(char c)
{
  return ((c >= '0') && (c <= '9'));
}
static int matchalpha(char c)
{
  return ((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'));
}
static int matchwhitespace(char c)
{
  return ((c == ' ') || (c == '\t') || (c == '\n') || (c == '\r') || (c == '\f') || (c == '\v'));
}
static int matchalphanum(char c)
{
  return ((c == '_') || matchalpha(c) || matchdigit(c));
}
static int matchrange(char c, const char* str)
{
  return (    (c != '-')
           && (str[0] != '\0')
           && (str[0] != '-')
           && (str[1] == '-')
           && (str[2] != '\0')
           && (    (c >= str[0])
                && (c <= str[2])));
}
static int matchdot(char c)
{
#if defined(RE_DOT_MATCHES_NEWLINE) && (RE_DOT_MATCHES_NEWLINE == 1)
  (void)c;
  return 1;
#else
  return c != '\n' && c != '\r';
#endif
}
static int ismetachar(char c)
{
  return ((c == 's') || (c == 'S') || (c == 'w') || (c == 'W') || (c == 'd') || (c == 'D'));
}

static int matchmetachar(char c, const char* str)
{
  switch (str[0])
  {
    case 'd': return  matchdigit(c);
    case 'D': return !matchdigit(c);
    case 'w': return  matchalphanum(c);
    case 'W': return !matchalphanum(c);
    case 's': return  matchwhitespace(c);
    case 'S': return !matchwhitespace(c);
    default:  return (c == str[0]);
  }
}

static int matchcharclass(char c, const char* str)
{
  do
  {
    if (matchrange(c, str))
    {
      return 1;
    }
    else if (str[0] == '\\')
    {
      /* Escape-char: increment str-ptr and match on next char */
      str += 1;
      if (matchmetachar(c, str))
      {
        return 1;
      }
      else if ((c == str[0]) && !ismetachar(c))
      {
        return 1;
      }
    }
    else if (c == str[0])
    {
      if (c == '-')
      {
        return ((str[-1] == '\0') || (str[1] == '\0'));
      }
      else
      {
        return 1;
      }
    }
  }
  while (*str++ != '\0');

  return 0;
}

static int matchone(regex_t p, char c)
{
  switch (p.type)
  {
    case DOT:            return matchdot(c);
    case CHAR_CLASS:     return  matchcharclass(c, (const char*)p.ccl);
    case INV_CHAR_CLASS: return !matchcharclass(c, (const char*)p.ccl);
    case DIGIT:          return  matchdigit(c);
    case NOT_DIGIT:      return !matchdigit(c);
    case ALPHA:          return  matchalphanum(c);
    case NOT_ALPHA:      return !matchalphanum(c);
    case WHITESPACE:     return  matchwhitespace(c);
    case NOT_WHITESPACE: return !matchwhitespace(c);
    default:             return  (p.ch == c);
  }
}

static int matchstar(regex_t p, regex_t* pattern, const char* text, int* matchlength)
{
  int prelen = *matchlength;
  const char* prepoint = text;
  while ((text[0] != '\0') && matchone(p, *text))
  {
    text++;
    (*matchlength)++;
  }
  while (text >= prepoint)
  {
    if (matchpattern(pattern, text--, matchlength))
      return 1;
    (*matchlength)--;
  }

  *matchlength = prelen;
  return 0;
}

static int matchplus(regex_t p, regex_t* pattern, const char* text, int* matchlength)
{
  const char* prepoint = text;
  while ((text[0] != '\0') && matchone(p, *text))
  {
    text++;
    (*matchlength)++;
  }
  while (text > prepoint)
  {
    if (matchpattern(pattern, text--, matchlength))
      return 1;
    (*matchlength)--;
  }

  return 0;
}

static int matchquestion(regex_t p, regex_t* pattern, const char* text, int* matchlength)
{
  if (p.type == UNUSED)
    return 1;
  if (matchpattern(pattern, text, matchlength))
      return 1;
  if (*text && matchone(p, *text++))
  {
    if (matchpattern(pattern, text, matchlength))
    {
      (*matchlength)++;
      return 1;
    }
  }
  return 0;
}


#if 0

/* Recursive matching */
static int matchpattern(regex_t* pattern, const char* text, int *matchlength)
{
  int pre = *matchlength;
  if ((pattern[0].type == UNUSED) || (pattern[1].type == QUESTIONMARK))
  {
    return matchquestion(pattern[1], &pattern[2], text, matchlength);
  }
  else if (pattern[1].type == STAR)
  {
    return matchstar(pattern[0], &pattern[2], text, matchlength);
  }
  else if (pattern[1].type == PLUS)
  {
    return matchplus(pattern[0], &pattern[2], text, matchlength);
  }
  else if ((pattern[0].type == END) && pattern[1].type == UNUSED)
  {
    return text[0] == '\0';
  }
  else if ((text[0] != '\0') && matchone(pattern[0], text[0]))
  {
    (*matchlength)++;
    return matchpattern(&pattern[1], text+1);
  }
  else
  {
    *matchlength = pre;
    return 0;
  }
}

#else

/* Iterative matching */
static int matchpattern(regex_t* pattern, const char* text, int* matchlength)
{
  int pre = *matchlength;
  do
  {
    if ((pattern[0].type == UNUSED) || (pattern[1].type == QUESTIONMARK))
    {
      return matchquestion(pattern[0], &pattern[2], text, matchlength);
    }
    else if (pattern[1].type == STAR)
    {
      return matchstar(pattern[0], &pattern[2], text, matchlength);
    }
    else if (pattern[1].type == PLUS)
    {
      return matchplus(pattern[0], &pattern[2], text, matchlength);
    }
    else if ((pattern[0].type == END) && pattern[1].type == UNUSED)
    {
      return (text[0] == '\0');
    }
/*  Branching is not working properly
    else if (pattern[1].type == BRANCH)
    {
      return (matchpattern(pattern, text) || matchpattern(&pattern[2], text));
    }
*/
  (*matchlength)++;
  }
  while ((text[0] != '\0') && matchone(*pattern++, *text++));

  *matchlength = pre;
  return 0;
}

#endif
typedef enum litaC_main__ParseStatus {
    litaC_main__ParseStatus_OK,
    litaC_main__ParseStatus_ERROR,
    litaC_main__ParseStatus_TERMINATE
} litaC_main__ParseStatus;
typedef struct litaC_mem__Allocator litaC_mem__Allocator;
typedef struct litaC_mem__Arena litaC_mem__Arena;
typedef struct litaC_mem__LinearAllocator litaC_mem__LinearAllocator;
typedef struct litaC_mem__Allocation litaC_mem__Allocation;
typedef struct litaC_mem__DebugAllocator litaC_mem__DebugAllocator;

typedef enum litaC_io__FileStatus {
    litaC_io__FileStatus_Ok = 0,
    litaC_io__FileStatus_FileNotFoundError,
    litaC_io__FileStatus_IOError
} litaC_io__FileStatus;
typedef enum litaC_cmdline__CmdParserStatus {
    litaC_cmdline__CmdParserStatus_OK,
    litaC_cmdline__CmdParserStatus_MISSING_ARGUMENT,
    litaC_cmdline__CmdParserStatus_MISSING_REQUIRED
} litaC_cmdline__CmdParserStatus;
typedef enum litaC_cmdline__OptionFlag {
    litaC_cmdline__OptionFlag_HAS_ARGUMENT = (1 << 0),
    litaC_cmdline__OptionFlag_IS_REQUIRED = (1 << 1),
    litaC_cmdline__OptionFlag_IS_USED = (1 << 2)
} litaC_cmdline__OptionFlag;
typedef struct litaC_cmdline__Option litaC_cmdline__Option;
typedef struct litaC_cmdline__CmdParser litaC_cmdline__CmdParser;
typedef struct litaC_string_buffer__StringBuffer litaC_string_buffer__StringBuffer;
typedef struct litaC_string_view__StringView litaC_string_view__StringView;
typedef struct litaC_system__Process litaC_system__Process;
typedef struct litaC_string__String litaC_string__String;

typedef enum litaC_profile__ProfileTag {
    litaC_profile__ProfileTag_MAX_PROFILE_TAGS
} litaC_profile__ProfileTag;
typedef struct litaC_profile__ProfileEntry litaC_profile__ProfileEntry;

typedef enum litaC_lex__TokenType {
    litaC_lex__TokenType_IMPORT,
    litaC_lex__TokenType_STRUCT,
    litaC_lex__TokenType_UNION,
    litaC_lex__TokenType_TRAIT,
    litaC_lex__TokenType_ENUM,
    litaC_lex__TokenType_FUNC,
    litaC_lex__TokenType_TYPEDEF,
    litaC_lex__TokenType_VAR,
    litaC_lex__TokenType_CONST,
    litaC_lex__TokenType_NULL,
    litaC_lex__TokenType_VOID,
    litaC_lex__TokenType_TRUE,
    litaC_lex__TokenType_FALSE,
    litaC_lex__TokenType_BOOL,
    litaC_lex__TokenType_CHAR,
    litaC_lex__TokenType_I8,
    litaC_lex__TokenType_U8,
    litaC_lex__TokenType_I16,
    litaC_lex__TokenType_U16,
    litaC_lex__TokenType_I32,
    litaC_lex__TokenType_U32,
    litaC_lex__TokenType_I64,
    litaC_lex__TokenType_U64,
    litaC_lex__TokenType_F32,
    litaC_lex__TokenType_F64,
    litaC_lex__TokenType_USIZE,
    litaC_lex__TokenType_FOR,
    litaC_lex__TokenType_WHILE,
    litaC_lex__TokenType_DO,
    litaC_lex__TokenType_IF,
    litaC_lex__TokenType_ELSE,
    litaC_lex__TokenType_SWITCH,
    litaC_lex__TokenType_CASE,
    litaC_lex__TokenType_DEFAULT,
    litaC_lex__TokenType_DEFER,
    litaC_lex__TokenType_BREAK,
    litaC_lex__TokenType_CONTINUE,
    litaC_lex__TokenType_RETURN,
    litaC_lex__TokenType_GOTO,
    litaC_lex__TokenType_SIZEOF,
    litaC_lex__TokenType_TYPEOF,
    litaC_lex__TokenType_OFFSETOF,
    litaC_lex__TokenType_AS,
    litaC_lex__TokenType_PUBLIC,
    litaC_lex__TokenType_USING,
    litaC_lex__TokenType_PLUS,
    litaC_lex__TokenType_MINUS,
    litaC_lex__TokenType_STAR,
    litaC_lex__TokenType_MOD,
    litaC_lex__TokenType_SLASH,
    litaC_lex__TokenType_DOLLAR,
    litaC_lex__TokenType_HASH,
    litaC_lex__TokenType_DOT,
    litaC_lex__TokenType_VAR_ARGS,
    litaC_lex__TokenType_AT,
    litaC_lex__TokenType_QUESTION_MARK,
    litaC_lex__TokenType_COMMA,
    litaC_lex__TokenType_SEMICOLON,
    litaC_lex__TokenType_COLON,
    litaC_lex__TokenType_COLON_COLON,
    litaC_lex__TokenType_DOUBLE_QUOTE,
    litaC_lex__TokenType_LESS_THAN,
    litaC_lex__TokenType_LESS_EQUALS,
    litaC_lex__TokenType_GREATER_THAN,
    litaC_lex__TokenType_GREATER_EQUALS,
    litaC_lex__TokenType_EQUALS_EQUALS,
    litaC_lex__TokenType_EQUALS,
    litaC_lex__TokenType_NOT_EQUALS,
    litaC_lex__TokenType_PLUS_EQ,
    litaC_lex__TokenType_MINUS_EQ,
    litaC_lex__TokenType_DIV_EQ,
    litaC_lex__TokenType_MUL_EQ,
    litaC_lex__TokenType_MOD_EQ,
    litaC_lex__TokenType_LSHIFT_EQ,
    litaC_lex__TokenType_RSHIFT_EQ,
    litaC_lex__TokenType_BNOT_EQ,
    litaC_lex__TokenType_XOR_EQ,
    litaC_lex__TokenType_BAND_EQ,
    litaC_lex__TokenType_BOR_EQ,
    litaC_lex__TokenType_LSHIFT,
    litaC_lex__TokenType_RSHIFT,
    litaC_lex__TokenType_BNOT,
    litaC_lex__TokenType_XOR,
    litaC_lex__TokenType_BAND,
    litaC_lex__TokenType_BOR,
    litaC_lex__TokenType_LEFT_PAREN,
    litaC_lex__TokenType_RIGHT_PAREN,
    litaC_lex__TokenType_LEFT_BRACKET,
    litaC_lex__TokenType_RIGHT_BRACKET,
    litaC_lex__TokenType_LEFT_BRACE,
    litaC_lex__TokenType_RIGHT_BRACE,
    litaC_lex__TokenType_NOT,
    litaC_lex__TokenType_OR,
    litaC_lex__TokenType_AND,
    litaC_lex__TokenType_STRING,
    litaC_lex__TokenType_IDENTIFIER,
    litaC_lex__TokenType_INT_NUMBER,
    litaC_lex__TokenType_FLOAT_NUMBER,
    litaC_lex__TokenType_ERROR,
    litaC_lex__TokenType_END_OF_FILE,
    litaC_lex__TokenType_MAX_TOKEN_TYPES
} litaC_lex__TokenType;
typedef struct litaC_lex__SrcPos litaC_lex__SrcPos;
typedef union litaC_lex__Value litaC_lex__Value;
typedef enum litaC_lex__Mod {
    litaC_lex__Mod_NONE = 0,
    litaC_lex__Mod_MULTISTR
} litaC_lex__Mod;
typedef struct litaC_lex__Token litaC_lex__Token;
typedef struct litaC_lex__Lexer litaC_lex__Lexer;

typedef enum litaC_types__TypeKind {
    litaC_types__TypeKind_BOOL = 1,
    litaC_types__TypeKind_CHAR,
    litaC_types__TypeKind_I8,
    litaC_types__TypeKind_U8,
    litaC_types__TypeKind_I16,
    litaC_types__TypeKind_U16,
    litaC_types__TypeKind_I32,
    litaC_types__TypeKind_U32,
    litaC_types__TypeKind_I64,
    litaC_types__TypeKind_U64,
    litaC_types__TypeKind_F32,
    litaC_types__TypeKind_F64,
    litaC_types__TypeKind_USIZE,
    litaC_types__TypeKind_NULL,
    litaC_types__TypeKind_VOID,
    litaC_types__TypeKind_STR,
    litaC_types__TypeKind_ARRAY,
    litaC_types__TypeKind_PTR,
    litaC_types__TypeKind_FUNC_PTR,
    litaC_types__TypeKind_STRUCT,
    litaC_types__TypeKind_UNION,
    litaC_types__TypeKind_TRAIT,
    litaC_types__TypeKind_ENUM,
    litaC_types__TypeKind_FUNC,
    litaC_types__TypeKind_CONST,
    litaC_types__TypeKind_GENERIC_PARAM,
    litaC_types__TypeKind_POISON,
    litaC_types__TypeKind_MAX_TYPE_KINDS
} litaC_types__TypeKind;
typedef struct litaC_types__FieldPositionResult litaC_types__FieldPositionResult;
typedef struct litaC_types__FieldPath litaC_types__FieldPath;
typedef struct litaC_types__TypeInfo litaC_types__TypeInfo;
typedef struct litaC_types__GenericTypeInfo litaC_types__GenericTypeInfo;
typedef struct litaC_types__FuncTypeInfo litaC_types__FuncTypeInfo;
typedef struct litaC_types__ConstTypeInfo litaC_types__ConstTypeInfo;
typedef struct litaC_types__PtrTypeInfo litaC_types__PtrTypeInfo;
typedef struct litaC_types__ArrayTypeInfo litaC_types__ArrayTypeInfo;
typedef struct litaC_types__FuncPtrTypeInfo litaC_types__FuncPtrTypeInfo;
typedef struct litaC_types__EnumTypeInfo litaC_types__EnumTypeInfo;
typedef struct litaC_types__AggregateTypeInfo litaC_types__AggregateTypeInfo;

typedef enum litaC_ast__StmtKind {
    litaC_ast__StmtKind_IMPORT_DECL,
    litaC_ast__StmtKind_CONST_DECL,
    litaC_ast__StmtKind_VAR_DECL,
    litaC_ast__StmtKind_STRUCT_DECL,
    litaC_ast__StmtKind_UNION_DECL,
    litaC_ast__StmtKind_TRAIT_DECL,
    litaC_ast__StmtKind_ENUM_DECL,
    litaC_ast__StmtKind_FUNC_DECL,
    litaC_ast__StmtKind_TYPEDEF_DECL,
    litaC_ast__StmtKind_PARAM_DECL,
    litaC_ast__StmtKind_NATIVE_DECL,
    litaC_ast__StmtKind_NOTES_DECL,
    litaC_ast__StmtKind_VAR_FIELD_DECL,
    litaC_ast__StmtKind_ENUM_FIELD_ENTRY_DECL,
    litaC_ast__StmtKind_ENUM_FIELD_DECL,
    litaC_ast__StmtKind_STRUCT_FIELD_DECL,
    litaC_ast__StmtKind_UNION_FIELD_DECL,
    litaC_ast__StmtKind_TRAIT_FIELD_DECL,
    litaC_ast__StmtKind_POISON_DECL,
    litaC_ast__StmtKind_BLOCK_STMT,
    litaC_ast__StmtKind_BREAK_STMT,
    litaC_ast__StmtKind_COMP_STMT,
    litaC_ast__StmtKind_CONTINUE_STMT,
    litaC_ast__StmtKind_DEFER_STMT,
    litaC_ast__StmtKind_DO_WHILE_STMT,
    litaC_ast__StmtKind_EMPTY_STMT,
    litaC_ast__StmtKind_FOR_STMT,
    litaC_ast__StmtKind_FUNC_BODY_STMT,
    litaC_ast__StmtKind_GOTO_STMT,
    litaC_ast__StmtKind_IF_STMT,
    litaC_ast__StmtKind_LABEL_STMT,
    litaC_ast__StmtKind_MODULE_STMT,
    litaC_ast__StmtKind_NOTE_STMT,
    litaC_ast__StmtKind_PARAMETERS_STMT,
    litaC_ast__StmtKind_RETURN_STMT,
    litaC_ast__StmtKind_SWITCH_CASE_STMT,
    litaC_ast__StmtKind_SWITCH_STMT,
    litaC_ast__StmtKind_WHILE_STMT,
    litaC_ast__StmtKind_ARRAY_DESIGNATION_EXPR,
    litaC_ast__StmtKind_ARRAY_INIT_EXPR,
    litaC_ast__StmtKind_BINARY_EXPR,
    litaC_ast__StmtKind_BOOLEAN_EXPR,
    litaC_ast__StmtKind_CAST_EXPR,
    litaC_ast__StmtKind_CHAR_EXPR,
    litaC_ast__StmtKind_FUNC_CALL_EXPR,
    litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR,
    litaC_ast__StmtKind_GET_EXPR,
    litaC_ast__StmtKind_GROUP_EXPR,
    litaC_ast__StmtKind_IDENTIFIER_EXPR,
    litaC_ast__StmtKind_INIT_EXPR,
    litaC_ast__StmtKind_INIT_ARG_EXPR,
    litaC_ast__StmtKind_NULL_EXPR,
    litaC_ast__StmtKind_NUMBER_EXPR,
    litaC_ast__StmtKind_OFFSET_OF_EXPR,
    litaC_ast__StmtKind_SET_EXPR,
    litaC_ast__StmtKind_SIZE_OF_EXPR,
    litaC_ast__StmtKind_STRING_EXPR,
    litaC_ast__StmtKind_SUBSCRIPT_GET_EXPR,
    litaC_ast__StmtKind_SUBSCRIPT_SET_EXPR,
    litaC_ast__StmtKind_TERNARY_EXPR,
    litaC_ast__StmtKind_TYPE_IDENTIFIER_EXPR,
    litaC_ast__StmtKind_TYPE_OF_EXPR,
    litaC_ast__StmtKind_UNARY_EXPR,
    litaC_ast__StmtKind_POISON_EXPR,
    litaC_ast__StmtKind_MAX_STMT_KINDS
} litaC_ast__StmtKind;

typedef enum litaC_ast__TypeSpecKind {
    litaC_ast__TypeSpecKind_NONE,
    litaC_ast__TypeSpecKind_ARRAY,
    litaC_ast__TypeSpecKind_PTR,
    litaC_ast__TypeSpecKind_CONST,
    litaC_ast__TypeSpecKind_NAME,
    litaC_ast__TypeSpecKind_FUNC_PTR,
    litaC_ast__TypeSpecKind_MAX_TYPESPEC_KINDS
} litaC_ast__TypeSpecKind;
typedef enum litaC_ast__FuncFlags {
    litaC_ast__FuncFlags_HAS_VARARGS = (1 << 0),
    litaC_ast__FuncFlags_IS_METHOD = (1 << 1)
} litaC_ast__FuncFlags;
typedef enum litaC_ast__AggregateFlags {
    litaC_ast__AggregateFlags_IS_EMBEDDED = (1 << 0),
    litaC_ast__AggregateFlags_IS_ANONYMOUS = (1 << 1)
} litaC_ast__AggregateFlags;
typedef struct litaC_ast__TypeSpec litaC_ast__TypeSpec;
typedef struct litaC_ast__NameTypeSpec litaC_ast__NameTypeSpec;
typedef struct litaC_ast__ArrayTypeSpec litaC_ast__ArrayTypeSpec;
typedef struct litaC_ast__PtrTypeSpec litaC_ast__PtrTypeSpec;
typedef struct litaC_ast__ConstTypeSpec litaC_ast__ConstTypeSpec;
typedef struct litaC_ast__FuncPtrTypeSpec litaC_ast__FuncPtrTypeSpec;
typedef struct litaC_ast__GenericParam litaC_ast__GenericParam;
typedef struct litaC_ast__Attributes litaC_ast__Attributes;
typedef struct litaC_ast__Node litaC_ast__Node;
typedef struct litaC_ast__Decl litaC_ast__Decl;
typedef struct litaC_ast__GenericDecl litaC_ast__GenericDecl;
typedef struct litaC_ast__ImportDecl litaC_ast__ImportDecl;
typedef struct litaC_ast__VarDecl litaC_ast__VarDecl;
typedef struct litaC_ast__ParameterDecl litaC_ast__ParameterDecl;
typedef struct litaC_ast__FuncDecl litaC_ast__FuncDecl;
typedef struct litaC_ast__AggregateDecl litaC_ast__AggregateDecl;
typedef struct litaC_ast__EnumDecl litaC_ast__EnumDecl;
typedef struct litaC_ast__TypedefDecl litaC_ast__TypedefDecl;
typedef struct litaC_ast__NativeDecl litaC_ast__NativeDecl;
typedef struct litaC_ast__NotesDecl litaC_ast__NotesDecl;
typedef struct litaC_ast__PoisonDecl litaC_ast__PoisonDecl;
typedef struct litaC_ast__BlockStmt litaC_ast__BlockStmt;
typedef struct litaC_ast__BreakStmt litaC_ast__BreakStmt;
typedef struct litaC_ast__CompStmt litaC_ast__CompStmt;
typedef struct litaC_ast__ContinueStmt litaC_ast__ContinueStmt;
typedef struct litaC_ast__DeferStmt litaC_ast__DeferStmt;
typedef struct litaC_ast__DoWhileStmt litaC_ast__DoWhileStmt;
typedef struct litaC_ast__EmptyStmt litaC_ast__EmptyStmt;
typedef struct litaC_ast__EnumFieldEntryDecl litaC_ast__EnumFieldEntryDecl;
typedef struct litaC_ast__ForStmt litaC_ast__ForStmt;
typedef struct litaC_ast__FuncBodyStmt litaC_ast__FuncBodyStmt;
typedef struct litaC_ast__GotoStmt litaC_ast__GotoStmt;
typedef struct litaC_ast__IfStmt litaC_ast__IfStmt;
typedef struct litaC_ast__LabelStmt litaC_ast__LabelStmt;
typedef struct litaC_ast__ModuleStmt litaC_ast__ModuleStmt;
typedef struct litaC_ast__NoteStmt litaC_ast__NoteStmt;
typedef struct litaC_ast__ParametersStmt litaC_ast__ParametersStmt;
typedef struct litaC_ast__ReturnStmt litaC_ast__ReturnStmt;
typedef struct litaC_ast__SwitchCaseStmt litaC_ast__SwitchCaseStmt;
typedef struct litaC_ast__SwitchStmt litaC_ast__SwitchStmt;
typedef struct litaC_ast__VarFieldDecl litaC_ast__VarFieldDecl;
typedef struct litaC_ast__TraitFieldDecl litaC_ast__TraitFieldDecl;
typedef union litaC_ast__anon_0 litaC_ast__anon_0;
typedef struct litaC_ast__FieldStmt litaC_ast__FieldStmt;
typedef struct litaC_ast__WhileStmt litaC_ast__WhileStmt;
typedef struct litaC_ast__Stmt litaC_ast__Stmt;
typedef struct litaC_ast__ArrayDesignationExpr litaC_ast__ArrayDesignationExpr;
typedef struct litaC_ast__ArrayInitExpr litaC_ast__ArrayInitExpr;
typedef struct litaC_ast__BinaryExpr litaC_ast__BinaryExpr;
typedef struct litaC_ast__BooleanExpr litaC_ast__BooleanExpr;
typedef struct litaC_ast__CastExpr litaC_ast__CastExpr;
typedef struct litaC_ast__CharExpr litaC_ast__CharExpr;
typedef struct litaC_ast__CallArg litaC_ast__CallArg;
typedef struct litaC_ast__FuncCallExpr litaC_ast__FuncCallExpr;
typedef enum litaC_ast__GetExprFlags {
    litaC_ast__GetExprFlags_IS_NORMAL = 0,
    litaC_ast__GetExprFlags_IS_METHOD_CALL = (1 << 0),
    litaC_ast__GetExprFlags_IS_ENUM = (1 << 1),
    litaC_ast__GetExprFlags_IS_USING = (1 << 2),
    litaC_ast__GetExprFlags_IS_METHOD_ARG = (1 << 3)
} litaC_ast__GetExprFlags;
typedef struct litaC_ast__GetExpr litaC_ast__GetExpr;
typedef struct litaC_ast__GroupExpr litaC_ast__GroupExpr;
typedef struct litaC_ast__IdentifierExpr litaC_ast__IdentifierExpr;
typedef struct litaC_ast__InitArgExpr litaC_ast__InitArgExpr;
typedef struct litaC_ast__InitExpr litaC_ast__InitExpr;
typedef struct litaC_ast__NullExpr litaC_ast__NullExpr;
typedef struct litaC_ast__NumberExpr litaC_ast__NumberExpr;
typedef struct litaC_ast__OffsetOfExpr litaC_ast__OffsetOfExpr;
typedef struct litaC_ast__SetExpr litaC_ast__SetExpr;
typedef struct litaC_ast__SizeOfExpr litaC_ast__SizeOfExpr;
typedef struct litaC_ast__StringExpr litaC_ast__StringExpr;
typedef struct litaC_ast__SubscriptGetExpr litaC_ast__SubscriptGetExpr;
typedef struct litaC_ast__SubscriptSetExpr litaC_ast__SubscriptSetExpr;
typedef struct litaC_ast__TernaryExpr litaC_ast__TernaryExpr;
typedef struct litaC_ast__TypeIdentifierExpr litaC_ast__TypeIdentifierExpr;
typedef struct litaC_ast__TypeOfExpr litaC_ast__TypeOfExpr;
typedef struct litaC_ast__UnaryExpr litaC_ast__UnaryExpr;
typedef struct litaC_ast__PoisonExpr litaC_ast__PoisonExpr;
typedef struct litaC_ast__Expr litaC_ast__Expr;
typedef struct litaC_ast__Operand litaC_ast__Operand;

typedef enum litaC_symbols__SymbolKind {
    litaC_symbols__SymbolKind_TYPE,
    litaC_symbols__SymbolKind_VAR,
    litaC_symbols__SymbolKind_CONST,
    litaC_symbols__SymbolKind_FUNC
} litaC_symbols__SymbolKind;

typedef enum litaC_symbols__SymbolState {
    litaC_symbols__SymbolState_UNRESOLVED = 0,
    litaC_symbols__SymbolState_RESOLVING,
    litaC_symbols__SymbolState_RESOLVED,
    litaC_symbols__SymbolState_ERROR
} litaC_symbols__SymbolState;
typedef enum litaC_symbols__SymbolFlags {
    litaC_symbols__SymbolFlags_IS_LOCAL = (1 << 1),
    litaC_symbols__SymbolFlags_IS_FOREIGN = (1 << 2),
    litaC_symbols__SymbolFlags_IS_CONSTANT = (1 << 3),
    litaC_symbols__SymbolFlags_IS_USING = (1 << 4),
    litaC_symbols__SymbolFlags_IS_TYPE = (1 << 5),
    litaC_symbols__SymbolFlags_IS_INCOMPLETE = (1 << 6),
    litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE = (1 << 7),
    litaC_symbols__SymbolFlags_IS_BUILTIN = (1 << 8),
    litaC_symbols__SymbolFlags_IS_FROM_GENERIC_TEMPLATE = (1 << 9),
    litaC_symbols__SymbolFlags_IS_IMPORTED = (1 << 10),
    litaC_symbols__SymbolFlags_IS_PUBLIC = (1 << 11),
    litaC_symbols__SymbolFlags_IS_EMITTED = (1 << 12),
    litaC_symbols__SymbolFlags_IS_TEST = (1 << 13),
    litaC_symbols__SymbolFlags_IS_ALIAS = (1 << 14),
    litaC_symbols__SymbolFlags_IS_MAIN = (1 << 15),
    litaC_symbols__SymbolFlags_IS_METHOD = (1 << 16),
    litaC_symbols__SymbolFlags_IS_TRAIT = (1 << 17),
    litaC_symbols__SymbolFlags_IS_TRAIT_METHOD = (1 << 18),
    litaC_symbols__SymbolFlags_IS_TRAIT_GENERATED = (1 << 19)
} litaC_symbols__SymbolFlags;
typedef struct litaC_symbols__Symbol litaC_symbols__Symbol;
typedef enum litaC_symbols__ScopeKind {
    litaC_symbols__ScopeKind_MODULE,
    litaC_symbols__ScopeKind_FUNC
} litaC_symbols__ScopeKind;
typedef struct litaC_symbols__ProgramSymbols litaC_symbols__ProgramSymbols;
typedef struct litaC_symbols__Scope litaC_symbols__Scope;
typedef enum litaC_module__ModuleFlags {
    litaC_module__ModuleFlags_TYPE_CHECKED = (1 << 0),
    litaC_module__ModuleFlags_TYPE_RESOLVED = (1 << 1),
    litaC_module__ModuleFlags_TYPE_IMPORTED = (1 << 2)
} litaC_module__ModuleFlags;
typedef struct litaC_module__ModuleId litaC_module__ModuleId;
typedef struct litaC_module__ModuleImport litaC_module__ModuleImport;
typedef struct litaC_module__Module litaC_module__Module;
typedef enum litaC_phase_result__ErrorType {
    litaC_phase_result__ErrorType_WARN,
    litaC_phase_result__ErrorType_ERROR
} litaC_phase_result__ErrorType;
typedef struct litaC_phase_result__PhaseError litaC_phase_result__PhaseError;
typedef struct litaC_phase_result__PhaseResult litaC_phase_result__PhaseResult;
typedef enum litaC_common__LogLevel {
    litaC_common__LogLevel_TRACE,
    litaC_common__LogLevel_INFO,
    litaC_common__LogLevel_DEBUG,
    litaC_common__LogLevel_ERROR,
    litaC_common__LogLevel_FATAL
} litaC_common__LogLevel;
typedef struct litaC_lita__Lita litaC_lita__Lita;

typedef enum litaC_lita__MetricType {
    litaC_lita__MetricType_PARSING,
    litaC_lita__MetricType_TYPE_CHECKING,
    litaC_lita__MetricType_CGEN,
    litaC_lita__MetricType_CCOMPILE,
    litaC_lita__MetricType_MAX_METRIC_TYPES
} litaC_lita__MetricType;
typedef struct litaC_lita__Metric litaC_lita__Metric;

typedef enum litaC_lita__TypeInfoOption {
    litaC_lita__TypeInfoOption_NONE,
    litaC_lita__TypeInfoOption_TAGGED,
    litaC_lita__TypeInfoOption_ALL
} litaC_lita__TypeInfoOption;
typedef struct litaC_lita__LitaOptions litaC_lita__LitaOptions;
typedef struct litaC_preprocessor__Preprocessor litaC_preprocessor__Preprocessor;
typedef struct litaC_preprocessor__CallContext litaC_preprocessor__CallContext;
typedef struct litaC_regex__Regex litaC_regex__Regex;
typedef struct litaC_checker__LabelInfo litaC_checker__LabelInfo;
typedef struct litaC_checker__GenericContext litaC_checker__GenericContext;
typedef struct litaC_checker__TypeChecker litaC_checker__TypeChecker;
typedef struct litaC_types_new__TypeCache litaC_types_new__TypeCache;
typedef struct litaC_types_new__ArrayEntry litaC_types_new__ArrayEntry;
typedef struct litaC_generics__Template litaC_generics__Template;
typedef struct litaC_introspection__Introspect litaC_introspection__Introspect;
typedef enum litaC_error_codes__ErrorCode {
    litaC_error_codes__ErrorCode_INVALID_ASSIGNMENT,
    litaC_error_codes__ErrorCode_INVALID_CONST_EXPR,
    litaC_error_codes__ErrorCode_INVALID_ARRAY_DIMENSION_EXPR,
    litaC_error_codes__ErrorCode_INVALID_CHARACTER,
    litaC_error_codes__ErrorCode_INVALID_NUMBER,
    litaC_error_codes__ErrorCode_INVALID_FIELD,
    litaC_error_codes__ErrorCode_INVALID_IMPORT_ACCESS,
    litaC_error_codes__ErrorCode_INVALID_CONTINUE,
    litaC_error_codes__ErrorCode_INVALID_BREAK,
    litaC_error_codes__ErrorCode_INVALID_OBJECT_INIT,
    litaC_error_codes__ErrorCode_INVALID_MODULE_ACCESS,
    litaC_error_codes__ErrorCode_INVALID_VARARG_POSITION,
    litaC_error_codes__ErrorCode_INVALID_NOTE_DECL,
    litaC_error_codes__ErrorCode_INVALID_LABEL_STMT,
    litaC_error_codes__ErrorCode_INVALID_COMP_STMT,
    litaC_error_codes__ErrorCode_INVALID_DEFAULT_ASSIGNMENT,
    litaC_error_codes__ErrorCode_INVALID_TRAIT_MEMBER,
    litaC_error_codes__ErrorCode_MISSING_COMMA,
    litaC_error_codes__ErrorCode_MISSING_SEMICOLON,
    litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACE,
    litaC_error_codes__ErrorCode_MISSING_EQUALS,
    litaC_error_codes__ErrorCode_MISSING_IDENTIFIER,
    litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACKET,
    litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN,
    litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN,
    litaC_error_codes__ErrorCode_MISSING_LEFT_BRACE,
    litaC_error_codes__ErrorCode_MISSING_ARRAY_BRACKETS,
    litaC_error_codes__ErrorCode_MISSING_COLON,
    litaC_error_codes__ErrorCode_MISSING_WHILE,
    litaC_error_codes__ErrorCode_MISSING_AS,
    litaC_error_codes__ErrorCode_MISSING_GENERIC_END,
    litaC_error_codes__ErrorCode_MISSING_COMP_STMT_END,
    litaC_error_codes__ErrorCode_RANGE_INTEGER,
    litaC_error_codes__ErrorCode_RANGE_LONG,
    litaC_error_codes__ErrorCode_RANGE_REAL,
    litaC_error_codes__ErrorCode_UNEXPECTED_EOF,
    litaC_error_codes__ErrorCode_UNEXPECTED_TOKEN,
    litaC_error_codes__ErrorCode_UNIMPLEMENTED,
    litaC_error_codes__ErrorCode_UNKNOWN_ERROR,
    litaC_error_codes__ErrorCode_TOO_MANY_ERRORS,
    litaC_error_codes__ErrorCode_MAX_NUM_ERROR_CODES
} litaC_error_codes__ErrorCode;
typedef struct litaC_parser__Parser litaC_parser__Parser;
typedef struct litaC_cgen__CGen litaC_cgen__CGen;
typedef struct litaC_cgen__CGenScope litaC_cgen__CGenScope;
typedef struct litaC_cgen__CompilationUnit litaC_cgen__CompilationUnit;
typedef struct litaC_dependency_graph__DependencyGraph litaC_dependency_graph__DependencyGraph;
typedef enum litaC_dependency_graph__State {
    litaC_dependency_graph__State_EMPTY = 0,
    litaC_dependency_graph__State_PENDING = 1,
    litaC_dependency_graph__State_RESOLVED = 2
} litaC_dependency_graph__State;
typedef struct litaC_dependency_graph__Dependency litaC_dependency_graph__Dependency;
typedef struct litaC_references__Reference litaC_references__Reference;
typedef struct litaC_references__FieldReference litaC_references__FieldReference;
typedef struct litaC_references__ReferenceDatabase litaC_references__ReferenceDatabase;

typedef enum litaC_json__JsonType {
    litaC_json__JsonType_NULL,
    litaC_json__JsonType_BOOLEAN,
    litaC_json__JsonType_INT_NUMBER,
    litaC_json__JsonType_FLOAT_NUMBER,
    litaC_json__JsonType_STRING,
    litaC_json__JsonType_OBJECT,
    litaC_json__JsonType_ARRAY
} litaC_json__JsonType;
typedef struct litaC_json__Entry litaC_json__Entry;
typedef struct litaC_json__JsonObject litaC_json__JsonObject;
typedef union litaC_json__JsonValue litaC_json__JsonValue;
typedef struct litaC_json__JsonNode litaC_json__JsonNode;
typedef enum litaC_json__TokenKind {
    litaC_json__TokenKind_EOF,
    litaC_json__TokenKind_ERROR,
    litaC_json__TokenKind_COMMA,
    litaC_json__TokenKind_COLON,
    litaC_json__TokenKind_LEFT_BRACE,
    litaC_json__TokenKind_RIGHT_BRACE,
    litaC_json__TokenKind_LEFT_BRACKET,
    litaC_json__TokenKind_RIGHT_BRACKET,
    litaC_json__TokenKind_NULL,
    litaC_json__TokenKind_INT_NUMBER,
    litaC_json__TokenKind_REAL_NUMBER,
    litaC_json__TokenKind_TRUE,
    litaC_json__TokenKind_FALSE,
    litaC_json__TokenKind_STRING
} litaC_json__TokenKind;
typedef struct litaC_json__SrcPos litaC_json__SrcPos;
typedef union litaC_json__anon_1 litaC_json__anon_1;
typedef struct litaC_json__Token litaC_json__Token;
typedef enum litaC_json__JsonParserStatus {
    litaC_json__JsonParserStatus_OK = 0,
    litaC_json__JsonParserStatus_WARNING,
    litaC_json__JsonParserStatus_ERROR
} litaC_json__JsonParserStatus;
typedef struct litaC_json__JsonParser litaC_json__JsonParser;
typedef struct litaC_workspace__Workspace litaC_workspace__Workspace;
typedef struct litaC_workspace__TextDocument litaC_workspace__TextDocument;
typedef struct litaC_lsp__LspServer litaC_lsp__LspServer;
typedef struct litaC_protocol__Position litaC_protocol__Position;
typedef struct litaC_protocol__Range litaC_protocol__Range;
typedef struct litaC_protocol__Location litaC_protocol__Location;
typedef struct litaC_protocol__TextDocumentChangeEvent litaC_protocol__TextDocumentChangeEvent;
typedef enum litaC_protocol__ErrorCodes {
    litaC_protocol__ErrorCodes_ParseError = -(32700),
    litaC_protocol__ErrorCodes_InvalidRequest = -(32600),
    litaC_protocol__ErrorCodes_MethodNotFound = -(32601),
    litaC_protocol__ErrorCodes_InvalidParams = -(32602),
    litaC_protocol__ErrorCodes_InternalError = -(32603),
    litaC_protocol__ErrorCodes_jsonrpcReservedErrorRangeStart = -(32099),
    litaC_protocol__ErrorCodes_serverErrorStart = litaC_protocol__ErrorCodes_jsonrpcReservedErrorRangeStart,
    litaC_protocol__ErrorCodes_ServerNotInitialized = -(32002),
    litaC_protocol__ErrorCodes_UnknownErrorCode = -(32001),
    litaC_protocol__ErrorCodes_jsonrpcReservedErrorRangeEnd = -(32000),
    litaC_protocol__ErrorCodes_serverErrorEnd = litaC_protocol__ErrorCodes_jsonrpcReservedErrorRangeEnd,
    litaC_protocol__ErrorCodes_lspReservedErrorRangeStart = -(32899),
    litaC_protocol__ErrorCodes_ContentModified = -(32801),
    litaC_protocol__ErrorCodes_RequestCancelled = -(32800),
    litaC_protocol__ErrorCodes_lspReservedErrorRangeEnd = -(32800)
} litaC_protocol__ErrorCodes;

typedef enum litaC_protocol__SymbolInfoKind {
    litaC_protocol__SymbolInfoKind_File = 1,
    litaC_protocol__SymbolInfoKind_Module = 2,
    litaC_protocol__SymbolInfoKind_Namespace = 3,
    litaC_protocol__SymbolInfoKind_Package = 4,
    litaC_protocol__SymbolInfoKind_Class = 5,
    litaC_protocol__SymbolInfoKind_Method = 6,
    litaC_protocol__SymbolInfoKind_Property = 7,
    litaC_protocol__SymbolInfoKind_Field = 8,
    litaC_protocol__SymbolInfoKind_Constructor = 9,
    litaC_protocol__SymbolInfoKind_Enum = 10,
    litaC_protocol__SymbolInfoKind_Interface = 11,
    litaC_protocol__SymbolInfoKind_Function = 12,
    litaC_protocol__SymbolInfoKind_Variable = 13,
    litaC_protocol__SymbolInfoKind_Constant = 14,
    litaC_protocol__SymbolInfoKind_String = 15,
    litaC_protocol__SymbolInfoKind_Number = 16,
    litaC_protocol__SymbolInfoKind_Boolean = 17,
    litaC_protocol__SymbolInfoKind_Array = 18,
    litaC_protocol__SymbolInfoKind_Object = 19,
    litaC_protocol__SymbolInfoKind_Key = 20,
    litaC_protocol__SymbolInfoKind_Null = 21,
    litaC_protocol__SymbolInfoKind_EnumMember = 22,
    litaC_protocol__SymbolInfoKind_Struct = 23,
    litaC_protocol__SymbolInfoKind_Event = 24,
    litaC_protocol__SymbolInfoKind_Operator = 25,
    litaC_protocol__SymbolInfoKind_TypeParameter = 26
} litaC_protocol__SymbolInfoKind;
typedef enum litaC_util__SourceLocationKind {
    litaC_util__SourceLocationKind_NONE,
    litaC_util__SourceLocationKind_AST,
    litaC_util__SourceLocationKind_TYPE
} litaC_util__SourceLocationKind;
typedef union litaC_util__anon_2 litaC_util__anon_2;
typedef struct litaC_util__SourceLocation litaC_util__SourceLocation;
typedef struct litaC_util__SourceLookup litaC_util__SourceLookup;
typedef struct litaC_builtins__any litaC_builtins__any;
typedef struct litaC_array__Array_cb__ptr_JsonNode_ce_ litaC_array__Array_cb__ptr_JsonNode_ce_;
typedef struct litaC_array__Array_cb__ptr_Allocation_ce_ litaC_array__Array_cb__ptr_Allocation_ce_;
typedef struct litaC_array__Array_cb_Option_ce_ litaC_array__Array_cb_Option_ce_;
typedef struct litaC_array__Array_cb__ptr_const_char_ce_ litaC_array__Array_cb__ptr_const_char_ce_;
typedef struct litaC_array__Array_cb_GenericParam_ce_ litaC_array__Array_cb_GenericParam_ce_;
typedef struct litaC_array__Array_cb__ptr_TypeInfo_ce_ litaC_array__Array_cb__ptr_TypeInfo_ce_;
typedef struct litaC_array__Array_cb__ptr_TypeSpec_ce_ litaC_array__Array_cb__ptr_TypeSpec_ce_;
typedef struct litaC_array__Array_cb__ptr_NoteStmt_ce_ litaC_array__Array_cb__ptr_NoteStmt_ce_;
typedef struct litaC_array__Array_cb_FieldStmt_ce_ litaC_array__Array_cb_FieldStmt_ce_;
typedef struct litaC_array__Array_cb__ptr_EnumFieldEntryDecl_ce_ litaC_array__Array_cb__ptr_EnumFieldEntryDecl_ce_;
typedef struct litaC_array__Array_cb__ptr_Stmt_ce_ litaC_array__Array_cb__ptr_Stmt_ce_;
typedef struct litaC_array__Array_cb__ptr_ImportDecl_ce_ litaC_array__Array_cb__ptr_ImportDecl_ce_;
typedef struct litaC_array__Array_cb__ptr_Decl_ce_ litaC_array__Array_cb__ptr_Decl_ce_;
typedef struct litaC_array__Array_cb_Token_ce_ litaC_array__Array_cb_Token_ce_;
typedef struct litaC_array__Array_cb__ptr_ParameterDecl_ce_ litaC_array__Array_cb__ptr_ParameterDecl_ce_;
typedef struct litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_ litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_;
typedef struct litaC_array__Array_cb__ptr_Expr_ce_ litaC_array__Array_cb__ptr_Expr_ce_;
typedef struct litaC_array__Array_cb_CallArg_ce_ litaC_array__Array_cb_CallArg_ce_;
typedef struct litaC_array__Array_cb__ptr_InitArgExpr_ce_ litaC_array__Array_cb__ptr_InitArgExpr_ce_;
typedef struct litaC_array__Array_cb__ptr_Symbol_ce_ litaC_array__Array_cb__ptr_Symbol_ce_;
typedef struct litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_ litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_;
typedef struct litaC_array__Array_cb_i64_ce_ litaC_array__Array_cb_i64_ce_;
typedef struct litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_ litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_;
typedef struct litaC_array__Array_cb_ModuleImport_ce_ litaC_array__Array_cb_ModuleImport_ce_;
typedef struct litaC_array__Array_cb_PhaseError_ce_ litaC_array__Array_cb_PhaseError_ce_;
typedef struct litaC_map__Map_cb__ptr_const_char_c__ptr_Module_ce_ litaC_map__Map_cb__ptr_const_char_c__ptr_Module_ce_;
typedef struct litaC_array__Array_cb__ptr_CompStmt_ce_ litaC_array__Array_cb__ptr_CompStmt_ce_;
typedef struct litaC_array__Array_cb__ptr_Module_ce_ litaC_array__Array_cb__ptr_Module_ce_;
typedef struct litaC_array__Array_cb__ptr_FuncTypeInfo_ce_ litaC_array__Array_cb__ptr_FuncTypeInfo_ce_;
typedef struct litaC_array__Array_cb_Array_cb_GenericParam_ce__ce_ litaC_array__Array_cb_Array_cb_GenericParam_ce__ce_;
typedef struct litaC_map__Map_cb_i64_c__ptr_ConstTypeInfo_ce_ litaC_map__Map_cb_i64_c__ptr_ConstTypeInfo_ce_;
typedef struct litaC_map__Map_cb_i64_c__ptr_PtrTypeInfo_ce_ litaC_map__Map_cb_i64_c__ptr_PtrTypeInfo_ce_;
typedef struct litaC_map__Map_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_ litaC_map__Map_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_;
typedef struct litaC_map__Map_cb__ptr_const_char_c__ptr_TypeInfo_ce_ litaC_map__Map_cb__ptr_const_char_c__ptr_TypeInfo_ce_;
typedef struct litaC_map__Map_cb__ptr_Symbol_c_Dependency_ce_ litaC_map__Map_cb__ptr_Symbol_c_Dependency_ce_;
typedef struct litaC_array__Array_cb__ptr_Dependency_ce_ litaC_array__Array_cb__ptr_Dependency_ce_;
typedef struct litaC_array__Array_cb_Reference_ce_ litaC_array__Array_cb_Reference_ce_;
typedef struct litaC_array__Array_cb_FieldReference_ce_ litaC_array__Array_cb_FieldReference_ce_;
typedef struct litaC_map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_ litaC_map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_;
typedef struct litaC_array__Array_cb_SrcPos_ce_ litaC_array__Array_cb_SrcPos_ce_;
typedef struct litaC_map__Map_cb__ptr_const_char_c_i32_ce_ litaC_map__Map_cb__ptr_const_char_c_i32_ce_;
typedef struct litaC_array__Array_cb_Entry_ce_ litaC_array__Array_cb_Entry_ce_;
typedef struct litaC_map__Map_cb__ptr_const_char_c__ptr_TextDocument_ce_ litaC_map__Map_cb__ptr_const_char_c__ptr_TextDocument_ce_;
typedef struct litaC_map__MapIterator_cb__ptr_const_char_c__ptr_Symbol_ce_ litaC_map__MapIterator_cb__ptr_const_char_c__ptr_Symbol_ce_;
typedef struct litaC_map__MapEntry_cb__ptr_const_char_c__ptr_Symbol_ce_ litaC_map__MapEntry_cb__ptr_const_char_c__ptr_Symbol_ce_;
typedef struct litaC_map__MapIterator_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_ litaC_map__MapIterator_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_;
typedef struct litaC_map__MapEntry_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_ litaC_map__MapEntry_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_;
typedef struct litaC_map__MapIterator_cb_i64_c__ptr_PtrTypeInfo_ce_ litaC_map__MapIterator_cb_i64_c__ptr_PtrTypeInfo_ce_;
typedef struct litaC_map__MapEntry_cb_i64_c__ptr_PtrTypeInfo_ce_ litaC_map__MapEntry_cb_i64_c__ptr_PtrTypeInfo_ce_;
typedef struct litaC_map__MapIterator_cb_i64_c__ptr_ConstTypeInfo_ce_ litaC_map__MapIterator_cb_i64_c__ptr_ConstTypeInfo_ce_;
typedef struct litaC_map__MapEntry_cb_i64_c__ptr_ConstTypeInfo_ce_ litaC_map__MapEntry_cb_i64_c__ptr_ConstTypeInfo_ce_;
typedef struct litaC_map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_ litaC_map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_;
typedef struct litaC_map__MapEntry_cb_i64_c_Array_cb_i64_ce__ce_ litaC_map__MapEntry_cb_i64_c_Array_cb_i64_ce__ce_;
typedef struct litaC_map__MapIterator_cb__ptr_const_char_c__ptr_Module_ce_ litaC_map__MapIterator_cb__ptr_const_char_c__ptr_Module_ce_;
typedef struct litaC_map__MapEntry_cb__ptr_const_char_c__ptr_Module_ce_ litaC_map__MapEntry_cb__ptr_const_char_c__ptr_Module_ce_;
typedef struct litaC_map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_ litaC_map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_;
typedef struct litaC_map__MapEntry_cb__ptr_Symbol_c_Dependency_ce_ litaC_map__MapEntry_cb__ptr_Symbol_c_Dependency_ce_;
litaC_i32 litaC_main__main(litaC_i32 litaC_len,litaC_char** litaC_args);
litaC_main__ParseStatus litaC_main__ParseArgs(litaC_i32 litaC_n,litaC_char** litaC_args,litaC_lita__LitaOptions* litaC_options);
litaC_void* litaC_mem__memduplicate(const litaC_void* litaC_p,litaC_usize litaC_len,const litaC_mem__Allocator* litaC_a);
litaC_bool litaC_mem__isPowerOfTwo(litaC_usize litaC_x);
litaC_usize litaC_mem__alignForward(litaC_usize litaC_ptr,litaC_usize litaC_align);
LITAC_INLINE 
litaC_void* litaC_mem__Allocator_alloc(const litaC_mem__Allocator* litaC_a,litaC_usize litaC_size);
LITAC_INLINE 
litaC_void* litaC_mem__Allocator_calloc(const litaC_mem__Allocator* litaC_a,litaC_usize litaC_num,litaC_usize litaC_size);
LITAC_INLINE 
litaC_void* litaC_mem__Allocator_realloc(const litaC_mem__Allocator* litaC_a,litaC_void* litaC_ptr,litaC_usize litaC_oldsize,litaC_usize litaC_newsize);
LITAC_INLINE 
litaC_void litaC_mem__Allocator_free(const litaC_mem__Allocator* litaC_a,litaC_void* litaC_ptr);
litaC_void* litaC_mem__cMalloc(const litaC_mem__Allocator* litaC_a,litaC_usize litaC_size);
litaC_void* litaC_mem__cCalloc(const litaC_mem__Allocator* litaC_a,litaC_usize litaC_num,litaC_usize litaC_size);
litaC_void* litaC_mem__cRealloc(const litaC_mem__Allocator* litaC_a,litaC_void* litaC_ptr,litaC_usize litaC_oldSize,litaC_usize litaC_size);
litaC_void litaC_mem__cFree(const litaC_mem__Allocator* litaC_a,litaC_void* litaC_ptr);
litaC_void litaC_mem__Arena_init(litaC_mem__Arena* litaC_arena,litaC_usize litaC_size,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_mem__Arena_free(litaC_mem__Arena* litaC_arena);
litaC_void* litaC_mem__Arena_malloc(litaC_mem__Arena* litaC_arena,litaC_usize litaC_size);
litaC_void* litaC_mem__ArenaMalloc(const litaC_mem__Allocator* litaC_alloc,litaC_usize litaC_size);
litaC_void* litaC_mem__ArenaCalloc(const litaC_mem__Allocator* litaC_alloc,litaC_usize litaC_num,litaC_usize litaC_size);
litaC_void* litaC_mem__ArenaRealloc(const litaC_mem__Allocator* litaC_alloc,litaC_void* litaC_ptr,litaC_usize litaC_oldSize,litaC_usize litaC_size);
litaC_void litaC_mem__ArenaFree(const litaC_mem__Allocator* litaC_alloc,litaC_void* litaC_ptr);
litaC_void litaC_mem__LinearAllocator_init(litaC_mem__LinearAllocator* litaC_this,litaC_void* litaC_mem,litaC_usize litaC_size);

litaC_void litaC_mem__LinearAllocator_clear(litaC_mem__LinearAllocator* litaC_this);
litaC_void* litaC_mem__LinearAllocator_malloc(litaC_mem__LinearAllocator* litaC_this,litaC_usize litaC_size);
litaC_void* litaC_mem__LinearMalloc(const litaC_mem__Allocator* litaC_alloc,litaC_usize litaC_size);
litaC_void* litaC_mem__LinearCalloc(const litaC_mem__Allocator* litaC_alloc,litaC_usize litaC_num,litaC_usize litaC_size);
litaC_void* litaC_mem__LinearRealloc(const litaC_mem__Allocator* litaC_alloc,litaC_void* litaC_ptr,litaC_usize litaC_oldSize,litaC_usize litaC_size);
litaC_void litaC_mem__LinearFree(const litaC_mem__Allocator* litaC_alloc,litaC_void* litaC_ptr);
litaC_void litaC_mem__DebugAllocator_init(litaC_mem__DebugAllocator* litaC_d,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_mem__DebugAllocator_free(litaC_mem__DebugAllocator* litaC_d);
litaC_void litaC_mem__DebugAllocator_report(litaC_mem__DebugAllocator* litaC_d);
litaC_void* litaC_mem__DebugAllocator_malloc(litaC_mem__DebugAllocator* litaC_d,litaC_usize litaC_size,const litaC_char* litaC_file,litaC_u64 litaC_line);
litaC_void* litaC_mem__DebugMalloc(const litaC_mem__Allocator* litaC_alloc,litaC_usize litaC_size);
litaC_void* litaC_mem__DebugCalloc(const litaC_mem__Allocator* litaC_alloc,litaC_usize litaC_num,litaC_usize litaC_size);
litaC_void* litaC_mem__DebugRealloc(const litaC_mem__Allocator* litaC_alloc,litaC_void* litaC_ptr,litaC_usize litaC_oldSize,litaC_usize litaC_size);
litaC_void litaC_mem__DebugFree(const litaC_mem__Allocator* litaC_alloc,litaC_void* litaC_ptr);
litaC_i64 litaC_io__FileLength(const litaC_char* litaC_fileName);
litaC_io__FileStatus litaC_io__ReadFile(const litaC_char* litaC_fileName,litaC_char** litaC_data,const litaC_mem__Allocator* litaC_alloc);
litaC_io__FileStatus litaC_io__WriteFile(const litaC_char* litaC_fileName,const litaC_char* litaC_buffer,litaC_usize litaC_len);
litaC_io__FileStatus litaC_io__WriteBytes(FILE* litaC_fp,const litaC_char* litaC_buffer,litaC_usize litaC_len);
litaC_cmdline__CmdParser litaC_cmdline__CmdParserInit(const litaC_mem__Allocator* litaC_allocator);
litaC_void litaC_cmdline__CmdParser_init(litaC_cmdline__CmdParser* litaC_p,const litaC_mem__Allocator* litaC_allocator);
litaC_void litaC_cmdline__CmdParser_free(litaC_cmdline__CmdParser* litaC_p);
litaC_void litaC_cmdline__CmdParser_addOption(litaC_cmdline__CmdParser* litaC_p,const litaC_char* litaC_longName,litaC_char litaC_shortName,const litaC_char* litaC_description,litaC_i32 litaC_flags,const litaC_char* litaC_defaultValue);
litaC_cmdline__Option* litaC_cmdline__CmdParser_getOption(litaC_cmdline__CmdParser* litaC_p,const litaC_char* litaC_longName);
litaC_cmdline__Option* litaC_cmdline__CmdParser_getOptionShort(litaC_cmdline__CmdParser* litaC_p,litaC_char litaC_shortName);
litaC_bool litaC_cmdline__CmdParser_hasOption(litaC_cmdline__CmdParser* litaC_p,const litaC_char* litaC_longName);
litaC_bool litaC_cmdline__CmdParser_hasOptionShort(litaC_cmdline__CmdParser* litaC_p,litaC_char litaC_shortName);
litaC_cmdline__CmdParserStatus litaC_cmdline__CmdParser_parse(litaC_cmdline__CmdParser* litaC_p,litaC_i32 litaC_argc,litaC_char** litaC_argv);
litaC_void litaC_cmdline__CmdParser_printHelp(litaC_cmdline__CmdParser* litaC_p,litaC_string_buffer__StringBuffer* litaC_sb);
litaC_string_buffer__StringBuffer litaC_string_buffer__StringBufferInit(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_string_buffer__StringBuffer_init(litaC_string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_string_buffer__StringBuffer_free(litaC_string_buffer__StringBuffer* litaC_b);
litaC_void litaC_string_buffer__StringBuffer_appendStr(litaC_string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_str);
litaC_void litaC_string_buffer__StringBuffer_appendStrn(litaC_string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_i32 litaC_string_buffer__StringBuffer_appendFloat(litaC_string_buffer__StringBuffer* litaC_b,litaC_f64 litaC_f);
litaC_i32 litaC_string_buffer__StringBuffer_appendI32(litaC_string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_i);
litaC_i32 litaC_string_buffer__StringBuffer_appendI64(litaC_string_buffer__StringBuffer* litaC_b,litaC_i64 litaC_i);
litaC_i32 litaC_string_buffer__StringBuffer_appendU32(litaC_string_buffer__StringBuffer* litaC_b,litaC_u32 litaC_i);
litaC_i32 litaC_string_buffer__StringBuffer_appendU64(litaC_string_buffer__StringBuffer* litaC_b,litaC_u64 litaC_i);
litaC_i32 litaC_string_buffer__StringBuffer_appendChar(litaC_string_buffer__StringBuffer* litaC_b,litaC_char litaC_c);
litaC_i32 litaC_string_buffer__StringBuffer_append(litaC_string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_format,...);
litaC_i32 litaC_string_buffer__StringBuffer_appendArgs(litaC_string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_format,va_list litaC_args);
litaC_void litaC_string_buffer__StringBuffer_delete(litaC_string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_start,litaC_i32 litaC_end);
litaC_bool litaC_string_buffer__StringBuffer_contains(litaC_string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_i32 litaC_string_buffer__StringBuffer_indexOf(litaC_string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_i32 litaC_string_buffer__StringBuffer_indexOfAt(litaC_string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len,litaC_i32 litaC_fromIndex);
litaC_i32 litaC_string_buffer__StringBuffer_replace(litaC_string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_start,litaC_i32 litaC_end,const litaC_char* litaC_str);
litaC_i32 litaC_string_buffer__StringBuffer_insert(litaC_string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_index,const litaC_char* litaC_format,...);
litaC_i32 litaC_string_buffer__StringBuffer_copyTo(litaC_string_buffer__StringBuffer* litaC_b,litaC_char* litaC_buf,litaC_i32 litaC_len,litaC_bool litaC_addZero);
litaC_void litaC_string_buffer__StringBuffer_forEach(litaC_string_buffer__StringBuffer* litaC_b,litaC_bool (*litaC_fn)(litaC_char));
LITAC_INLINE 
litaC_bool litaC_string_buffer__StringBuffer_empty(litaC_string_buffer__StringBuffer* litaC_b);
LITAC_INLINE 
litaC_i32 litaC_string_buffer__StringBuffer_size(litaC_string_buffer__StringBuffer* litaC_b);
LITAC_INLINE 
litaC_void litaC_string_buffer__StringBuffer_clear(litaC_string_buffer__StringBuffer* litaC_b);
const litaC_char* litaC_string_buffer__StringBuffer_cStrConst(litaC_string_buffer__StringBuffer* litaC_b);
litaC_char* litaC_string_buffer__StringBuffer_cStr(litaC_string_buffer__StringBuffer* litaC_b);
LITAC_INLINE 
litaC_string_view__StringView litaC_string_buffer__StringBuffer_asStringView(litaC_string_buffer__StringBuffer* litaC_b);
litaC_char litaC_string_buffer__StringBuffer_get(litaC_string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_index);
litaC_void litaC_string_buffer__StringBuffer_reserve(litaC_string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_length);
litaC_void litaC_string_buffer__BufferGrow(litaC_string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_increment);
litaC_string_view__StringView litaC_string_view__StringViewInit(const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_u32 litaC_string_view__StringView_hash(litaC_string_view__StringView litaC_b);
litaC_string_view__StringView litaC_string_view__StringView_substring(litaC_string_view__StringView litaC_b,litaC_i32 litaC_start,litaC_i32 litaC_end);
litaC_bool litaC_string_view__StringView_startsWith(litaC_string_view__StringView litaC_b,const litaC_char* litaC_prefix,litaC_i32 litaC_len,litaC_i32 litaC_fromIndex);
litaC_bool litaC_string_view__StringView_endsWith(litaC_string_view__StringView litaC_b,const litaC_char* litaC_suffix,litaC_i32 litaC_len);
litaC_bool litaC_string_view__StringView_equals(litaC_string_view__StringView litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_bool litaC_string_view__StringView_equalsStringView(litaC_string_view__StringView litaC_b,litaC_string_view__StringView litaC_other);
litaC_bool litaC_string_view__StringView_contains(litaC_string_view__StringView litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_i32 litaC_string_view__StringView_indexOf(litaC_string_view__StringView litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_i32 litaC_string_view__StringView_indexOfAt(litaC_string_view__StringView litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len,litaC_i32 litaC_fromIndex);
litaC_i32 litaC_string_view__StringView_copyTo(litaC_string_view__StringView litaC_b,litaC_char* litaC_buf,litaC_i32 litaC_len,litaC_bool litaC_addZero);
litaC_string_view__StringView litaC_string_view__StringView_copy(litaC_string_view__StringView litaC_s,const litaC_mem__Allocator* litaC_allocator);
litaC_void litaC_string_view__StringView_forEach(litaC_string_view__StringView litaC_b,litaC_bool (*litaC_fn)(litaC_char));
litaC_bool litaC_string_view__StringView_empty(litaC_string_view__StringView litaC_b);
litaC_i32 litaC_string_view__StringView_size(litaC_string_view__StringView litaC_b);
litaC_void litaC_string_view__StringView_clear(litaC_string_view__StringView litaC_b);
litaC_char litaC_string_view__StringView_get(litaC_string_view__StringView litaC_b,litaC_i32 litaC_index);
const litaC_char* litaC_system__OSAsStr(Lita_OSType litaC_type);


litaC_bool litaC_system__SystemInit();
Lita_OSType litaC_system__GetOS();
litaC_char* litaC_system__GetEnv(const litaC_char* litaC_varName);
const litaC_char* litaC_system__CurrentWorkingPath();
litaC_bool litaC_system__FileExists(const litaC_char* litaC_filename);
litaC_bool litaC_system__Mkdir(const litaC_char* litaC_dir);
litaC_char* litaC_system__FilePath(const litaC_char* litaC_filename,litaC_char* litaC_out);
litaC_i32 litaC_system__strcicmp(const litaC_char* litaC_a,const litaC_char* litaC_b);
litaC_char* litaC_system__GetAbsolutePath(const litaC_char* litaC_pwd,const litaC_char* litaC_path,litaC_char* litaC_output);
litaC_bool litaC_system__PathEquals(const litaC_char* litaC_a,const litaC_char* litaC_b);
litaC_char* litaC_system__FilePathToUri(const litaC_char* litaC_path,litaC_char* litaC_output);
litaC_char* litaC_system__UriToFilePath(const litaC_char* litaC_uri,litaC_char* litaC_output);

litaC_f64 litaC_system__SystemTimeMSec();
const litaC_char* litaC_system__CurrentDateTime();
litaC_system__Process litaC_system__SystemExec(const litaC_char* litaC_command);
litaC_i64 litaC_system__Process_readOutput(litaC_system__Process* litaC_this,litaC_char* litaC_buffer,litaC_usize litaC_length);
litaC_u64 litaC_system__Process_writeInput(litaC_system__Process* litaC_this,litaC_char* litaC_buffer,litaC_usize litaC_length);
litaC_void litaC_system__Process_close(litaC_system__Process* litaC_this);
litaC_string__String litaC_string__StringInit(litaC_char* litaC_str,litaC_i32 litaC_capacity,litaC_i32 litaC_len);
litaC_i32 litaC_string__String_format(litaC_string__String* litaC_s,const litaC_char* litaC_format,...);
litaC_i32 litaC_string__String_append(litaC_string__String* litaC_s,const litaC_char* litaC_format,...);
litaC_void litaC_string__String_setStrn(litaC_string__String* litaC_s,const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_void litaC_string__String_appendChar(litaC_string__String* litaC_s,litaC_char litaC_c);
litaC_string_view__StringView litaC_string__String_substring(litaC_string__String litaC_s,litaC_i32 litaC_start,litaC_i32 litaC_end);
litaC_string_view__StringView litaC_string__String_asView(litaC_string__String litaC_s);
litaC_void litaC_string__String_memset(litaC_string__String litaC_s,litaC_i32 litaC_value);
litaC_void litaC_string__String_toLower(litaC_string__String litaC_s);
litaC_void litaC_string__String_toUpper(litaC_string__String litaC_s);
litaC_string__String litaC_string__String_copy(litaC_string__String litaC_s,const litaC_mem__Allocator* litaC_allocator);
litaC_void litaC_string__String_adjust(litaC_string__String* litaC_s);
litaC_void litaC_string__String_clear(litaC_string__String* litaC_s);
litaC_bool litaC_string__String_empty(litaC_string__String litaC_s);
litaC_i32 litaC_string__String_size(litaC_string__String litaC_s);
litaC_char* litaC_string__String_cStr(litaC_string__String litaC_s);
const litaC_char* litaC_string__String_cStrConst(litaC_string__String litaC_s);
litaC_char* litaC_string__StringCopy(const litaC_char* litaC_original,litaC_i32 litaC_len,const litaC_mem__Allocator* litaC_allocator);

LITAC_INLINE 
litaC_bool litaC_system_win___SystemInit();
LITAC_INLINE 
const litaC_char* litaC_system_win___CurrentWorkingPath();
LITAC_INLINE 
litaC_bool litaC_system_win___Mkdir(const litaC_char* litaC_dir);
LITAC_INLINE 

litaC_f64 litaC_system_win___SystemTimeMSec();
litaC_u32 litaC_map__StrHashFn(const litaC_char* litaC_str);
litaC_bool litaC_map__StrEqualFn(const litaC_char* litaC_a,const litaC_char* litaC_b);
litaC_u32 litaC_map__nextPowerOf2(litaC_u32 litaC_n);

litaC_void litaC_profile__StartWatch(litaC_profile__ProfileTag litaC_tag);

litaC_void litaC_profile__StopWatch(litaC_profile__ProfileTag litaC_tag);

litaC_void litaC_profile__ExportTimings(const litaC_char* litaC_filename);
litaC_bool litaC_lex__Token_nameEquals(litaC_lex__Token* litaC_token,const litaC_char* litaC_str);
litaC_i32 litaC_lex__SrcPos_getLineLength(litaC_lex__SrcPos* litaC_p);

const litaC_char* litaC_lex__Token_asString(litaC_lex__Token* litaC_t);
litaC_void litaC_lex__Token_print(litaC_lex__Token* litaC_token);
litaC_lex__Lexer litaC_lex__LexerInit(const litaC_char* litaC_filename,const litaC_char* litaC_text,const litaC_mem__Allocator* litaC_allocator);
litaC_bool litaC_lex__Lexer_hasError(litaC_lex__Lexer* litaC_l);
litaC_void litaC_lex__Lexer_error(litaC_lex__Lexer* litaC_l,const litaC_char* litaC_format,...);
litaC_char litaC_lex__Lexer_nextChar(litaC_lex__Lexer* litaC_l);
litaC_lex__Token litaC_lex__Lexer_eofToken(litaC_lex__Lexer* litaC_l);
litaC_lex__Token litaC_lex__Lexer_errorToken(litaC_lex__Lexer* litaC_l);
litaC_void litaC_lex__Lexer_skipWhitespace(litaC_lex__Lexer* litaC_l);
litaC_void litaC_lex__Lexer_skipComments(litaC_lex__Lexer* litaC_l);
litaC_bool litaC_lex__Lexer_isValidIdentifierStart(litaC_lex__Lexer* litaC_l,litaC_char litaC_c);
litaC_bool litaC_lex__Lexer_isValidIdentifierChar(litaC_lex__Lexer* litaC_l,litaC_char litaC_c);
litaC_bool litaC_lex__Lexer_isSymbolStart(litaC_lex__Lexer* litaC_l,litaC_char litaC_c);
litaC_bool litaC_lex__Lexer_checkKeyword(litaC_lex__Lexer* litaC_l);
litaC_lex__Token litaC_lex__Lexer_scanWord(litaC_lex__Lexer* litaC_l);
litaC_void litaC_lex__Lexer_scanInt(litaC_lex__Lexer* litaC_l,litaC_char* litaC_stream);
litaC_void litaC_lex__Lexer_scanFloat(litaC_lex__Lexer* litaC_l,litaC_char* litaC_stream);
litaC_void litaC_lex__Lexer_scanTypeInfo(litaC_lex__Lexer* litaC_l);
litaC_bool litaC_lex__IsHexChar(litaC_char litaC_c);
litaC_lex__Token litaC_lex__Lexer_scanNumber(litaC_lex__Lexer* litaC_l);
litaC_lex__Token litaC_lex__Lexer_scanChar(litaC_lex__Lexer* litaC_l);
litaC_lex__Token litaC_lex__Lexer_scanString(litaC_lex__Lexer* litaC_l);
litaC_lex__Token litaC_lex__Lexer_scanSymbol(litaC_lex__Lexer* litaC_l);
litaC_bool litaC_lex__Lexer_eof(litaC_lex__Lexer* litaC_l);
litaC_lex__Token litaC_lex__Lexer_nextToken(litaC_lex__Lexer* litaC_l);
litaC_types__TypeKind litaC_types__TypeKindFromString(const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_bool litaC_types__IsPtr(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsPtrLike(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsPtrOf(litaC_types__TypeInfo* litaC_type,litaC_types__TypeKind litaC_kind);
litaC_bool litaC_types__IsFuncLike(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsPrimitive(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsNumberLike(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsInteger(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsBooleanable(litaC_types__TypeInfo* litaC_type);
litaC_types__FuncPtrTypeInfo* litaC_types__AsTraitFuncPtr(litaC_types__TypeInfo* litaC_type,const litaC_char* litaC_name,litaC_types_new__TypeCache* litaC_typeCache);
litaC_types__AggregateTypeInfo* litaC_types__AsAggregate(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsAggregateLike(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsAggregate(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsPtrAggregate(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsTrait(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsPtrTrait(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsTraitLike(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsFieldAccessible(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsGenericCapable(litaC_types__TypeInfo* litaC_type);
litaC_types__TypeInfo* litaC_types__TypeInfo_getBaseType(litaC_types__TypeInfo* litaC_this);
litaC_types__TypeInfo* litaC_types__TypeInfo_getTypeOf(litaC_types__TypeInfo* litaC_this);
const litaC_char* litaC_types__TypeInfo_toStringDebug(litaC_types__TypeInfo* litaC_this);
litaC_void litaC_types__TypeInfo_toString(litaC_types__TypeInfo* litaC_this,litaC_string_buffer__StringBuffer* litaC_sb);
litaC_bool litaC_types__TypeInfo_strictEquals(litaC_types__TypeInfo* litaC_this,litaC_types__TypeInfo* litaC_other);
litaC_bool litaC_types__TypeInfo_isAssignable(litaC_types__TypeInfo* litaC_this,litaC_types__TypeInfo* litaC_other,litaC_checker__TypeChecker* litaC_checker);
litaC_bool litaC_types__TypeInfo_isDeclarable(litaC_types__TypeInfo* litaC_this,litaC_types__TypeInfo* litaC_other,litaC_checker__TypeChecker* litaC_checker);
litaC_bool litaC_types__TypeInfo_canCastTo(litaC_types__TypeInfo* litaC_this,litaC_types__TypeInfo* litaC_castTo,litaC_checker__TypeChecker* litaC_checker);
litaC_bool litaC_types__IsFuncImpl(litaC_types__FuncPtrTypeInfo* litaC_traitFn,litaC_types__TypeInfo* litaC_fn,litaC_checker__TypeChecker* litaC_checker);
litaC_ast__TypeSpec* litaC_types__TypeInfo_asTypeSpec(litaC_types__TypeInfo* litaC_this,const litaC_mem__Allocator* litaC_allocator);
litaC_types__FuncPtrTypeInfo* litaC_types__FuncTypeInfo_asPtr(litaC_types__FuncTypeInfo* litaC_this,litaC_types_new__TypeCache* litaC_typeCache);
litaC_ast__EnumFieldEntryDecl* litaC_types__EnumTypeInfo_getField(litaC_types__EnumTypeInfo* litaC_this,const litaC_char* litaC_name);
litaC_i32 litaC_types__EnumTypeInfo_getFieldIndex(litaC_types__EnumTypeInfo* litaC_this,const litaC_char* litaC_name);
const litaC_char* litaC_types__AggregateTypeInfo_getBaseName(litaC_types__AggregateTypeInfo* litaC_this,litaC_char* litaC_name);
litaC_ast__FieldStmt litaC_types__AggregateTypeInfo_getFieldByPosition(litaC_types__AggregateTypeInfo* litaC_this,litaC_i32 litaC_position);
litaC_ast__FieldStmt litaC_types__AggregateTypeInfo_getField(litaC_types__AggregateTypeInfo* litaC_this,const litaC_char* litaC_name);

litaC_i32 litaC_types__AggregateTypeInfo_getFieldIndex(litaC_types__AggregateTypeInfo* litaC_this,const litaC_char* litaC_name);

litaC_types__FieldPositionResult litaC_types__AggregateTypeInfo_getFieldPosition(litaC_types__AggregateTypeInfo* litaC_this,const litaC_char* litaC_name);

litaC_ast__FieldStmt litaC_types__AggregateTypeInfo_getFieldByType(litaC_types__AggregateTypeInfo* litaC_this,litaC_types__AggregateTypeInfo* litaC_type,litaC_bool litaC_isParent);
litaC_ast__FieldStmt litaC_types__AggregateTypeInfo_getFieldWithUsing(litaC_types__AggregateTypeInfo* litaC_this,const litaC_char* litaC_name);
litaC_void litaC_types__FieldPath_add(litaC_types__FieldPath* litaC_this,litaC_ast__FieldStmt litaC_field);
litaC_void litaC_types__FieldPath_pop(litaC_types__FieldPath* litaC_this);
litaC_bool litaC_types__AggregateTypeInfo_getFieldPath(litaC_types__AggregateTypeInfo* litaC_this,const litaC_char* litaC_name,litaC_types__FieldPath* litaC_path);
litaC_bool litaC_types__AggregateTypeInfo_getFieldPathByType(litaC_types__AggregateTypeInfo* litaC_this,litaC_types__AggregateTypeInfo* litaC_type,litaC_types__FieldPath* litaC_path);

const litaC_char* litaC_types__AggregateTypeInfo_getFunctionName(litaC_types__AggregateTypeInfo* litaC_this,litaC_char* litaC_result,const litaC_char* litaC_methodName);
litaC_symbols__Symbol* litaC_types__AggregateTypeInfo_getMethod(litaC_types__AggregateTypeInfo* litaC_this,litaC_module__Module* litaC_module,const litaC_char* litaC_methodName);
litaC_bool litaC_types__AggregateTypeInfo_implementsTrait(litaC_types__AggregateTypeInfo* litaC_this,litaC_types__TypeInfo* litaC_iface,litaC_checker__TypeChecker* litaC_checker);
litaC_i64 litaC_types__NextTypeId();
litaC_ast__TypeSpec* litaC_ast_new__NewVoidTypeSpec(litaC_lex__SrcPos litaC_pos,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__NameTypeSpec* litaC_ast_new__NewNameTypeSpec(litaC_lex__SrcPos litaC_pos,const litaC_char* litaC_name,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__TypeSpec* litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind litaC_kind,litaC_lex__SrcPos litaC_pos,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewImportDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_name,litaC_lex__Token litaC_alias,litaC_bool litaC_isUsing,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewVarDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_name,litaC_ast__TypeSpec* litaC_type,litaC_ast__Expr* litaC_expr,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewFuncDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_name,litaC_array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_ast__ParametersStmt* litaC_params,litaC_ast__Stmt* litaC_body,litaC_ast__TypeSpec* litaC_returnType,litaC_i32 litaC_flags,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewAggregateDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__StmtKind litaC_kind,litaC_lex__Token litaC_name,litaC_array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_array__Array_cb_FieldStmt_ce_ litaC_fields,litaC_i32 litaC_flags,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewStructDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_name,litaC_array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_array__Array_cb_FieldStmt_ce_ litaC_fields,litaC_i32 litaC_flags,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewUnionDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_name,litaC_array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_array__Array_cb_FieldStmt_ce_ litaC_fields,litaC_i32 litaC_flags,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewTraitDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_name,litaC_array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_array__Array_cb_FieldStmt_ce_ litaC_fields,litaC_i32 litaC_flags,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewEnumDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_name,litaC_array__Array_cb__ptr_EnumFieldEntryDecl_ce_ litaC_fields,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewTypedefDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_name,litaC_array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_ast__TypeSpec* litaC_type,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewParameterDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_name,litaC_ast__TypeSpec* litaC_type,litaC_ast__Expr* litaC_defaultExpr,litaC_bool litaC_isUsing,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewNotesDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_array__Array_cb__ptr_NoteStmt_ce_ litaC_notes,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewBuiltinDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_types__TypeInfo* litaC_type,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewPoisonDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewTernaryExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_ast__Expr* litaC_then,litaC_ast__Expr* litaC_other,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewBinaryExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_left,litaC_lex__TokenType litaC_operator,litaC_ast__Expr* litaC_right,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewUnaryExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__TokenType litaC_operator,litaC_ast__Expr* litaC_expr,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewInitExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__NameTypeSpec* litaC_type,litaC_array__Array_cb__ptr_InitArgExpr_ce_ litaC_arguments,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewFuncCallExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_object,litaC_array__Array_cb_CallArg_ce_ litaC_arguments,litaC_array__Array_cb__ptr_TypeSpec_ce_ litaC_genericArgs,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewSubscriptGetExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_object,litaC_ast__Expr* litaC_index,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewSubscriptSetExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_object,litaC_ast__Expr* litaC_index,litaC_lex__TokenType litaC_operator,litaC_ast__Expr* litaC_value,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewGetExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_object,litaC_ast__IdentifierExpr* litaC_field,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewSetExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_object,litaC_ast__IdentifierExpr* litaC_field,litaC_lex__TokenType litaC_operator,litaC_ast__Expr* litaC_value,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewIdentifierExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__NameTypeSpec* litaC_type,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewTypeIdentifierExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__TypeSpec* litaC_type,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewCastExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_castExpr,litaC_ast__TypeSpec* litaC_castTo,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewArrayDesignationExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_index,litaC_ast__Expr* litaC_value,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewInitArgExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_fieldName,litaC_i32 litaC_position,litaC_ast__Expr* litaC_value,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewBooleanExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_bool litaC_boolean,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewNullExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewNumberExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_number,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewStringExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_string,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewCharExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_character,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewGroupExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_groupedExpr,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewArrayInitExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__TypeSpec* litaC_type,litaC_array__Array_cb__ptr_Expr_ce_ litaC_values,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewSizeOfExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_sizeOfExpr,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewTypeOfExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_typeOfExpr,litaC_ast__TypeSpec* litaC_type,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewOffsetOfExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__TypeSpec* litaC_type,litaC_lex__Token litaC_field,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewPoisonExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewModuleStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_array__Array_cb__ptr_ImportDecl_ce_ litaC_imports,litaC_array__Array_cb__ptr_NoteStmt_ce_ litaC_notes,litaC_array__Array_cb__ptr_Decl_ce_ litaC_declarations,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewCompStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_char* litaC_type,const litaC_char* litaC_expr,litaC_array__Array_cb__ptr_Stmt_ce_ litaC_body,litaC_ast__CompStmt* litaC_end,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewFuncBodyStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_array__Array_cb__ptr_Stmt_ce_ litaC_stmts,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewBlockStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_array__Array_cb__ptr_Stmt_ce_ litaC_stmts,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewIfStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_ast__Stmt* litaC_then,litaC_ast__Stmt* litaC_other,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewWhileStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_ast__Stmt* litaC_body,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewDoWhileStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_ast__Stmt* litaC_body,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewForStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Stmt* litaC_init,litaC_ast__Expr* litaC_cond,litaC_ast__Stmt* litaC_post,litaC_ast__Stmt* litaC_body,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewSwitchCaseStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_ast__Stmt* litaC_body,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewSwitchStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_ litaC_cases,litaC_ast__Stmt* litaC_defaultStmt,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewBreakStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewContinueStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewReturnStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_expr,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewDeferStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Stmt* litaC_defered,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewGotoStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_label,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewLabelStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_label,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewNoteStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_name,litaC_array__Array_cb_Token_ce_ litaC_attributes,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewEmptyStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewParametersStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_array__Array_cb__ptr_ParameterDecl_ce_ litaC_params,litaC_bool litaC_isVararg,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewVarFieldDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_fieldName,litaC_ast__TypeSpec* litaC_type,litaC_ast__Attributes litaC_attributes,litaC_ast__Expr* litaC_defaultExpr,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewTraitFieldDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_fieldName,litaC_ast__TypeSpec* litaC_type,litaC_ast__Attributes litaC_attributes,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewEnumFieldEntryDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_fieldName,litaC_ast__Expr* litaC_value,litaC_ast__Attributes litaC_attributes,const litaC_mem__Allocator* litaC_allocator);
litaC_void litaC_ast__Node_setSrcPos(litaC_ast__Node* litaC_n,litaC_lex__SrcPos litaC_start,litaC_lex__SrcPos litaC_end);
litaC_array__Array_cb_CallArg_ce_* litaC_ast__Node_becomeParentOfChildrenCallArgs(litaC_ast__Node* litaC_n,litaC_array__Array_cb_CallArg_ce_* litaC_children);
litaC_bool litaC_ast__IsExpr(litaC_ast__Node* litaC_node);
litaC_bool litaC_ast__IsDecl(litaC_ast__Node* litaC_node);
litaC_bool litaC_ast__Decl_hasNote(litaC_ast__Decl* litaC_d,const litaC_char* litaC_name);
litaC_ast__NoteStmt* litaC_ast__Decl_getNote(litaC_ast__Decl* litaC_d,const litaC_char* litaC_name);
litaC_ast__TypeSpec* litaC_ast__TypeSpec_getBaseType(litaC_ast__TypeSpec* litaC_this);
litaC_bool litaC_ast__FuncDecl_getName(litaC_ast__FuncDecl* litaC_f,litaC_char* litaC_name);
litaC_bool litaC_ast__Expr_isIdentifier(litaC_ast__Expr* litaC_expr);
litaC_bool litaC_ast__Expr_isConstNumberExpr(litaC_ast__Expr* litaC_expr);
litaC_bool litaC_ast__Expr_isConstExpr(litaC_ast__Expr* litaC_expr);
litaC_i32 litaC_ast__CallArgSort(litaC_ast__CallArg litaC_a,litaC_ast__CallArg litaC_b);
litaC_bool litaC_symbols__Symbol_isGenericCapable(litaC_symbols__Symbol* litaC_this);
litaC_symbols__Scope* litaC_symbols__NewScope(litaC_symbols__ScopeKind litaC_kind,litaC_symbols__Scope* litaC_parent,litaC_phase_result__PhaseResult* litaC_result,const litaC_mem__Allocator* litaC_allocator);
litaC_void litaC_symbols__Scope_init(litaC_symbols__Scope* litaC_scope,litaC_symbols__ScopeKind litaC_kind,litaC_symbols__Scope* litaC_parent,litaC_phase_result__PhaseResult* litaC_result,const litaC_mem__Allocator* litaC_allocator);
litaC_symbols__Symbol* litaC_symbols__Scope_lookup(litaC_symbols__Scope* litaC_s,const litaC_char* litaC_name);
litaC_symbols__Symbol* litaC_symbols__Scope_lookupByToken(litaC_symbols__Scope* litaC_s,litaC_lex__Token litaC_name);
litaC_void litaC_symbols__Scope_importSymbol(litaC_symbols__Scope* litaC_this,const litaC_char* litaC_name,litaC_symbols__Symbol* litaC_symbol);
litaC_symbols__Symbol* litaC_symbols__Scope_addSymbol(litaC_symbols__Scope* litaC_this,const litaC_char* litaC_name,litaC_module__Module* litaC_module,litaC_ast__Decl* litaC_decl,litaC_i32 litaC_flags);
litaC_void litaC_symbols__Scope_print(litaC_symbols__Scope* litaC_this,const litaC_char* litaC_header);
litaC_module__Module* litaC_module__BuiltinsInit(litaC_lita__Lita* litaC_lita);
litaC_void litaC_module__AddBuiltin(litaC_lita__Lita* litaC_lita,litaC_types__TypeInfo* litaC_type);
litaC_module__Module* litaC_module__NewModule(litaC_lita__Lita* litaC_lita,const litaC_char* litaC_filename);
litaC_void litaC_module__Module_init(litaC_module__Module* litaC_this,litaC_phase_result__PhaseResult* litaC_result,litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_* litaC_genericSymbols,const litaC_mem__Allocator* litaC_allocator);
litaC_symbols__Symbol* litaC_module__Module_getType(litaC_module__Module* litaC_this,const litaC_char* litaC_type);
litaC_bool litaC_module__Module_isMethodForType(litaC_module__Module* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_symbols__Symbol* litaC_sym);
litaC_i32 litaC_module__Module_getMethodsForType(litaC_module__Module* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_symbols__Symbol** litaC_result);
litaC_void litaC_module__Module_importModule(litaC_module__Module* litaC_this,litaC_ast__ImportDecl* litaC_importDecl,litaC_module__Module* litaC_moduleToImport);
litaC_void litaC_module__Module_importModuleSymbols(litaC_module__Module* litaC_this,litaC_module__Module* litaC_moduleToImport,litaC_string_view__StringView* litaC_moduleName,litaC_bool litaC_isUsing);
litaC_void litaC_module__Module_importModuleSymbol(litaC_module__Module* litaC_this,litaC_module__Module* litaC_moduleToImport,litaC_string_view__StringView* litaC_moduleName,litaC_symbols__Symbol* litaC_symbol,const litaC_char* litaC_symName,litaC_bool litaC_isUsing);
LITAC_INLINE 
litaC_bool litaC_module__Module_equals(litaC_module__Module* litaC_this,litaC_module__Module* litaC_other);
litaC_void litaC_module__Module_print(litaC_module__Module* litaC_this,const litaC_char* litaC_header);
litaC_void litaC_module__ModuleId_fromFile(litaC_module__ModuleId* litaC_moduleId,litaC_lita__Lita* litaC_lita,const litaC_char* litaC_filename);
litaC_string_view__StringView litaC_module__GetModuleName(litaC_string_view__StringView litaC_pathStr);
litaC_phase_result__PhaseResult litaC_phase_result__PhaseResultInit(const litaC_mem__Allocator* litaC_allocator);
litaC_void litaC_phase_result__PhaseResult_addError(litaC_phase_result__PhaseResult* litaC_r,litaC_lex__SrcPos litaC_pos,const litaC_char* litaC_format,...);
litaC_void litaC_phase_result__PhaseResult_addErrorStr(litaC_phase_result__PhaseResult* litaC_r,litaC_lex__SrcPos litaC_pos,litaC_string_buffer__StringBuffer* litaC_sb);
litaC_bool litaC_phase_result__PhaseResult_hasErrors(litaC_phase_result__PhaseResult* litaC_r);
litaC_void litaC_common__Log(litaC_common__LogLevel litaC_level,const litaC_char* litaC_format,...);
litaC_void litaC_common__Logv(litaC_common__LogLevel litaC_level,const litaC_char* litaC_format,va_list litaC_args);
litaC_void litaC_common__Info(const litaC_char* litaC_format,...);
litaC_void litaC_common__Debug(const litaC_char* litaC_format,...);
litaC_void litaC_common__Error(const litaC_char* litaC_format,...);
litaC_void litaC_common__Panic(const litaC_char* litaC_format,...);
litaC_char* litaC_common__EscapeName(const litaC_char* litaC_name,litaC_string_buffer__StringBuffer* litaC_sb);
litaC_void litaC_lita__Lita_init(litaC_lita__Lita* litaC_this,litaC_lita__LitaOptions* litaC_options);

litaC_void litaC_lita__Lita_reset(litaC_lita__Lita* litaC_this);
litaC_void litaC_lita__Lita_free(litaC_lita__Lita* litaC_lita);
litaC_void litaC_lita__Lita_addModule(litaC_lita__Lita* litaC_lita,litaC_module__Module* litaC_module);
litaC_void litaC_lita__Lita_startCapture(litaC_lita__Lita* litaC_lita,litaC_lita__MetricType litaC_type);
litaC_void litaC_lita__Lita_endCapture(litaC_lita__Lita* litaC_lita,litaC_lita__MetricType litaC_type);
litaC_module__Module* litaC_lita__Lita_parse(litaC_lita__Lita* litaC_this);
litaC_bool litaC_lita__Lita_typeCheck(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module);
litaC_bool litaC_lita__Lita_transpile(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module);
litaC_void litaC_lita__LibtccErrorFunc(litaC_void* litaC_data,const litaC_char* litaC_msg);
litaC_bool litaC_lita__Lita_compileWithLibtcc(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module,const litaC_char* litaC_binaryFilename);
litaC_bool litaC_lita__Lita_emitC(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module,const litaC_char* litaC_cFilename);
litaC_bool litaC_lita__Lita_compileC(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module,const litaC_char* litaC_sourceFilename,const litaC_char* litaC_binaryFilename);
litaC_void litaC_lita__Lita_run(litaC_lita__Lita* litaC_this);
litaC_bool litaC_lita__FindModulePath(litaC_lita__Lita* litaC_lita,litaC_string_view__StringView litaC_moduleName,litaC_char* litaC_filename);
litaC_bool litaC_lita__ParseModule(litaC_lita__Lita* litaC_lita,litaC_module__Module* litaC_module,litaC_lex__SrcPos litaC_pos);
litaC_void litaC_preprocessor__noOpFree(litaC_void* litaC_mem,litaC_void* litaC_freeArg);
litaC_void* litaC_preprocessor__litaMalloc(litaC_u64 litaC_len,litaC_void* litaC_arg);
litaC_preprocessor__Preprocessor litaC_preprocessor__PreprocessorInit(litaC_lita__Lita* litaC_lita);
litaC_void litaC_preprocessor__Preprocessor_init(litaC_preprocessor__Preprocessor* litaC_this,litaC_lita__Lita* litaC_lita);

litaC_bool litaC_preprocessor__Preprocessor_eval(litaC_preprocessor__Preprocessor* litaC_this,litaC_ast__CompStmt* litaC_comp);

litaC_void litaC_preprocessor__Preprocessor_evaluateForModule(litaC_preprocessor__Preprocessor* litaC_this,litaC_ast__ModuleStmt* litaC_moduleStmt,litaC_ast__CompStmt* litaC_comp);

litaC_ast__Stmt* litaC_preprocessor__Preprocessor_evaluateForFunction(litaC_preprocessor__Preprocessor* litaC_this,litaC_checker__TypeChecker* litaC_checker,litaC_ast__CompStmt* litaC_comp);
ape_object_t litaC_preprocessor__ApeGetTypeKind(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
litaC_bool litaC_preprocessor__CallContext_logErrors(litaC_preprocessor__CallContext* litaC_this);
litaC_void litaC_preprocessor__Preprocessor_preResolveSymbols(litaC_preprocessor__Preprocessor* litaC_this,litaC_checker__TypeChecker* litaC_checker);
litaC_void litaC_preprocessor__Preprocessor_addNotes(litaC_preprocessor__Preprocessor* litaC_this,ape_object_t litaC_obj,litaC_ast__Attributes* litaC_attributes);
ape_object_t litaC_preprocessor__Preprocessor_declToApe(litaC_preprocessor__Preprocessor* litaC_this,litaC_symbols__Symbol* litaC_sym);

litaC_void litaC_preprocessor__CallContext_preprocessCall(litaC_preprocessor__CallContext* litaC_this,litaC_ast__ModuleStmt* litaC_moduleStmt,litaC_ast__CompStmt* litaC_comp);
ape_object_t litaC_preprocessor__ApeEmit(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__ApeEmitClear(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__ApeEmitStr(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__ApeGetSymbolsWithNote(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__ApeAddDeclaration(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__ApeReplaceDeclaration(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__ApeGetInputModuleFilename(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__ApeGetCurrentModuleFilename(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__ApeGetMainSymbol(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__ApeAstInsert(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__ApeAddImport(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__ApeSetMainSymbol(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__ApeGetSymbolsToTest(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
litaC_regex__Regex litaC_regex__RegexCompile(const litaC_char* litaC_pattern);
litaC_i32 litaC_regex__Regex_match(litaC_regex__Regex* litaC_this,const litaC_char* litaC_text,litaC_i32* litaC_matchlength);
litaC_i32 litaC_regex__RegexMatch(const litaC_char* litaC_pattern,const litaC_char* litaC_text,litaC_i32* litaC_matchlength);
const litaC_char* litaC_ast_copy__NewTokenName(litaC_lex__Token litaC_token,const litaC_mem__Allocator* litaC_allocator);
litaC_array__Array_cb__ptr_TypeSpec_ce_ litaC_ast_copy__CopyTypeSpecs(litaC_array__Array_cb__ptr_TypeSpec_ce_ litaC_specs,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__TypeSpec* litaC_ast_copy__CopyTypeSpec(litaC_ast__TypeSpec* litaC_spec,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_copy__CopyDecl(litaC_ast__Decl* litaC_decl,const litaC_mem__Allocator* litaC_allocator);
litaC_array__Array_cb_CallArg_ce_ litaC_ast_copy__CopyCallArgs(litaC_array__Array_cb_CallArg_ce_* litaC_args,const litaC_mem__Allocator* litaC_allocator);
litaC_array__Array_cb__ptr_Expr_ce_ litaC_ast_copy__CopyExprs(litaC_array__Array_cb__ptr_Expr_ce_* litaC_exprs,const litaC_mem__Allocator* litaC_allocator);
litaC_array__Array_cb__ptr_Stmt_ce_ litaC_ast_copy__CopyStmts(litaC_array__Array_cb__ptr_Stmt_ce_* litaC_stmts,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_copy__CopyExpr(litaC_ast__Expr* litaC_expr,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_copy__CopyStmt(litaC_ast__Stmt* litaC_stmt,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__AggregateDecl* litaC_ast_copy__CopyAggregateDecl(litaC_ast__AggregateDecl* litaC_decl,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__FuncDecl* litaC_ast_copy__CopyFuncDecl(litaC_ast__FuncDecl* litaC_decl,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__ParametersStmt* litaC_ast_copy__CopyParameters(litaC_ast__ParametersStmt litaC_params,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__TypedefDecl* litaC_ast_copy__CopyTypedefDecl(litaC_ast__TypedefDecl* litaC_decl,const litaC_mem__Allocator* litaC_allocator);
litaC_void litaC_ast_copy__AstInsertText(litaC_ast__Node* litaC_node,const litaC_char* litaC_text,litaC_i32 litaC_index,litaC_lita__Lita* litaC_lita);

litaC_void litaC_ast_copy__AstInsert(litaC_ast__Node* litaC_node,litaC_ast__Stmt* litaC_stmt,litaC_i32 litaC_index,const litaC_mem__Allocator* litaC_allocator);
const litaC_char* litaC_ast_copy__AstAddImport(litaC_lita__Lita* litaC_lita,litaC_checker__TypeChecker* litaC_checker,litaC_module__Module* litaC_module,litaC_module__Module* litaC_importModule);
litaC_void litaC_checker__TypeChecker_init(litaC_checker__TypeChecker* litaC_this,litaC_lita__Lita* litaC_lita);

litaC_symbols__ProgramSymbols litaC_checker__TypeChecker_typeCheck(litaC_checker__TypeChecker* litaC_this,litaC_module__Module* litaC_root);
litaC_bool litaC_checker__TypeChecker_checkTrait(litaC_checker__TypeChecker* litaC_this,litaC_string_buffer__StringBuffer* litaC_sb,litaC_types__TypeInfo* litaC_a,litaC_types__TypeInfo* litaC_b,const litaC_char* litaC_description);
litaC_bool litaC_checker__TypeChecker_checkCastability(litaC_checker__TypeChecker* litaC_this,litaC_lex__SrcPos litaC_src,litaC_types__TypeInfo* litaC_a,litaC_types__TypeInfo* litaC_b);
litaC_bool litaC_checker__TypeChecker_checkAssignability(litaC_checker__TypeChecker* litaC_this,litaC_lex__SrcPos litaC_src,litaC_types__TypeInfo* litaC_a,litaC_types__TypeInfo* litaC_b);
litaC_bool litaC_checker__TypeChecker_checkDeclarability(litaC_checker__TypeChecker* litaC_this,litaC_lex__SrcPos litaC_src,litaC_types__TypeInfo* litaC_a,litaC_types__TypeInfo* litaC_b);
litaC_bool litaC_checker__TypeChecker_checkTypeCompatibility(litaC_checker__TypeChecker* litaC_this,litaC_lex__SrcPos litaC_src,litaC_types__TypeInfo* litaC_a,litaC_types__TypeInfo* litaC_b);
litaC_void litaC_checker__TypeChecker_createModuleSymbols(litaC_checker__TypeChecker* litaC_this,litaC_module__Module* litaC_module);
litaC_void litaC_checker__TypeChecker_enterModule(litaC_checker__TypeChecker* litaC_this,litaC_module__Module* litaC_module);
litaC_void litaC_checker__TypeChecker_leaveModule(litaC_checker__TypeChecker* litaC_this);
litaC_symbols__Scope* litaC_checker__TypeChecker_currentScope(litaC_checker__TypeChecker* litaC_this);
litaC_void litaC_checker__TypeChecker_pushScope(litaC_checker__TypeChecker* litaC_this,litaC_symbols__Scope* litaC_scope);
litaC_void litaC_checker__TypeChecker_popScope(litaC_checker__TypeChecker* litaC_this);
litaC_bool litaC_checker__TypeChecker_isGenericParamType(litaC_checker__TypeChecker* litaC_this,litaC_ast__NameTypeSpec* litaC_name);
litaC_symbols__Symbol* litaC_checker__TypeChecker_createDeclSymbol(litaC_checker__TypeChecker* litaC_this,litaC_ast__Decl* litaC_decl);
litaC_void litaC_checker__TypeChecker_createImportSymbols(litaC_checker__TypeChecker* litaC_this,litaC_ast__ImportDecl* litaC_imp);
litaC_void litaC_checker__TypeChecker_resolveSymbols(litaC_checker__TypeChecker* litaC_this);
litaC_void litaC_checker__TypeChecker_resolveSymbol(litaC_checker__TypeChecker* litaC_this,litaC_symbols__Symbol* litaC_sym);
litaC_void litaC_checker__TypeChecker_finishResolveSymbol(litaC_checker__TypeChecker* litaC_this,litaC_symbols__Symbol* litaC_sym);
litaC_symbols__Symbol* litaC_checker__TypeChecker_getType(litaC_checker__TypeChecker* litaC_this,litaC_ast__NameTypeSpec* litaC_spec);
litaC_symbols__Symbol* litaC_checker__TypeChecker_getTypeByName(litaC_checker__TypeChecker* litaC_this,const litaC_char* litaC_typeName);
litaC_bool litaC_checker__TypeChecker_implementsTrait(litaC_checker__TypeChecker* litaC_this,litaC_types__AggregateTypeInfo* litaC_agg,litaC_types__AggregateTypeInfo* litaC_iface);
litaC_types__TypeInfo* litaC_checker__TypeChecker_resolveTypeSpec(litaC_checker__TypeChecker* litaC_this,litaC_ast__TypeSpec* litaC_spec);
litaC_symbols__Symbol* litaC_checker__TypeChecker_addSymbol(litaC_checker__TypeChecker* litaC_this,litaC_ast__Decl* litaC_decl,litaC_types__TypeInfo* litaC_typeInfo);
litaC_void litaC_checker__TypeChecker_addTypeToScope(litaC_checker__TypeChecker* litaC_this,litaC_ast__Decl* litaC_decl,litaC_symbols__Scope* litaC_scope,litaC_types__TypeInfo* litaC_baseType,litaC_types__AggregateTypeInfo* litaC_currentType);
litaC_bool litaC_checker__TypeChecker_resolveStmt(litaC_checker__TypeChecker* litaC_this,litaC_ast__Stmt* litaC_stmt);
litaC_u32 litaC_types_new__Hash(litaC_types_new__ArrayEntry litaC_a);
litaC_bool litaC_types_new__Equals(litaC_types_new__ArrayEntry litaC_a,litaC_types_new__ArrayEntry litaC_b);
litaC_void litaC_types_new__TypeCache_init(litaC_types_new__TypeCache* litaC_this,const litaC_mem__Allocator* litaC_allocator);
litaC_types__TypeInfo* litaC_types_new__TypeCache_newGenericParamTypeInfo(litaC_types_new__TypeCache* litaC_this,const litaC_char* litaC_name);
litaC_types__FuncTypeInfo* litaC_types_new__TypeCache_newFuncTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_symbols__Symbol* litaC_sym,litaC_ast__FuncDecl* litaC_funcDecl);
litaC_types__ArrayTypeInfo* litaC_types_new__TypeCache_newArrayTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_types__TypeInfo* litaC_arrayOf,litaC_usize litaC_length,litaC_ast__Expr* litaC_numOfElements,litaC_bool litaC_isLengthDefined);
litaC_types__FuncPtrTypeInfo* litaC_types_new__TypeCache_newFuncPtrTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_types__TypeInfo* litaC_returnType,litaC_array__Array_cb__ptr_TypeInfo_ce_ litaC_paramDecls,litaC_bool litaC_hasVarargs);
litaC_types__AggregateTypeInfo* litaC_types_new__TypeCache_newAggregateTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_symbols__Symbol* litaC_sym,litaC_ast__AggregateDecl* litaC_aggregateDecl);
litaC_types__EnumTypeInfo* litaC_types_new__TypeCache_newEnumTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_symbols__Symbol* litaC_sym,litaC_ast__EnumDecl* litaC_enumDecl);
litaC_types__TypeInfo* litaC_types_new__TypeCache_newForeignTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_symbols__Symbol* litaC_sym);
litaC_types__ConstTypeInfo* litaC_types_new__TypeCache_newConstTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_types__TypeInfo* litaC_base);
litaC_types__PtrTypeInfo* litaC_types_new__TypeCache_newPtrTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_types__TypeInfo* litaC_base);
litaC_types__TypeInfo* litaC_types_new__TypeCache_typeDecay(litaC_types_new__TypeCache* litaC_this,litaC_types__TypeInfo* litaC_type);
litaC_void litaC_ast_print__PrintTypeSpec(litaC_ast__TypeSpec* litaC_spec);
litaC_void litaC_ast_print__PrintName(litaC_lex__Token litaC_tok);
litaC_void litaC_ast_print__Printf(litaC_i32 litaC_indent,const litaC_char* litaC_format,...);
litaC_void litaC_ast_print__PrintStmt(litaC_ast__Stmt* litaC_s,litaC_i32 litaC_indent);
litaC_void litaC_generics__GetGenericName(litaC_checker__TypeChecker* litaC_checker,litaC_ast__TypeSpec* litaC_type,litaC_string__String* litaC_str);
litaC_symbols__Symbol* litaC_generics__CreateTypeFromGenericTemplate(litaC_checker__TypeChecker* litaC_checker,litaC_symbols__Symbol* litaC_sym,litaC_ast__NameTypeSpec* litaC_name);
litaC_ast__GenericDecl* litaC_generics__CreateAggregateDecl(litaC_ast__AggregateDecl* litaC_aggDecl,litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_genericArgs,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__GenericDecl* litaC_generics__CreateFuncDecl(litaC_ast__FuncDecl* litaC_funcDecl,litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_genericArgs,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__GenericDecl* litaC_generics__CreateTypedefDecl(litaC_ast__TypedefDecl* litaC_typedefDecl,litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_genericArgs,const litaC_mem__Allocator* litaC_allocator);
litaC_ast__TypeSpec* litaC_generics__Template_replaceTypeSpec(litaC_generics__Template* litaC_this,litaC_ast__TypeSpec* litaC_type);
litaC_bool litaC_generics__ReplaceTypes(litaC_generics__Template* litaC_template,litaC_ast__Node* litaC_ast);
litaC_bool litaC_generics__HasGenericParam(litaC_checker__TypeChecker* litaC_checker,litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_genericArgs);
litaC_void litaC_introspection__Introspect_generate(litaC_introspection__Introspect* litaC_this,litaC_checker__TypeChecker* litaC_checker);
litaC_void litaC_introspection__Introspect_emitFunc(litaC_introspection__Introspect* litaC_this,litaC_string_buffer__StringBuffer* litaC_sb,litaC_string_buffer__StringBuffer* litaC_scratch,litaC_symbols__Symbol* litaC_sym);
litaC_void litaC_introspection__Introspect_emitType(litaC_introspection__Introspect* litaC_this,litaC_string_buffer__StringBuffer* litaC_sb,litaC_string_buffer__StringBuffer* litaC_scratch,litaC_symbols__Symbol* litaC_sym);
litaC_void litaC_introspection__Introspect_emitPrimitiveType(litaC_introspection__Introspect* litaC_this,litaC_string_buffer__StringBuffer* litaC_sb,litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_checker_decl__TypeChecker_resolveDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__Decl* litaC_decl);
litaC_types__TypeInfo* litaC_checker_decl__TypeChecker_resolveValueDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__VarDecl* litaC_decl);
litaC_bool litaC_checker_decl__TypeChecker_checkAnonAggregateFieldDuplicate(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl,litaC_ast__FieldStmt litaC_field,litaC_i32 litaC_index);
litaC_void litaC_checker_decl__TypeChecker_errorInvalidMemberForTrait(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl,litaC_string_view__StringView litaC_fieldName,litaC_lex__SrcPos litaC_pos);
litaC_void litaC_checker_decl__TypeChecker_errorUsingMember(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl,litaC_string_view__StringView litaC_fieldName,litaC_lex__SrcPos litaC_pos);
litaC_void litaC_checker_decl__TypeChecker_errorUsingParameter(litaC_checker__TypeChecker* litaC_this,litaC_ast__ParameterDecl* litaC_paramDecl);
litaC_void litaC_checker_decl__TypeChecker_errorDuplicateMember(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl,litaC_string_view__StringView litaC_fieldName,litaC_lex__SrcPos litaC_pos);
litaC_bool litaC_checker_decl__TypeChecker_checkAggregateFieldDuplicate(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl,litaC_string_view__StringView litaC_fieldName,litaC_i32 litaC_index);
litaC_bool litaC_checker_decl__TypeChecker_resolveAggregateDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl);
litaC_i32 litaC_checker_decl__TypeChecker_addFieldReferences(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl,litaC_types__TypeInfo* litaC_parentTypeInfo,litaC_i32 litaC_position);
litaC_bool litaC_checker_decl__TypeChecker_checkEnumFieldDuplicate(litaC_checker__TypeChecker* litaC_this,litaC_ast__EnumDecl* litaC_enumDecl,litaC_ast__EnumFieldEntryDecl* litaC_field,litaC_i32 litaC_index);
litaC_bool litaC_checker_decl__TypeChecker_resolveEnumDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__EnumDecl* litaC_enumDecl);
litaC_void litaC_checker_decl__TypeChecker_checkLabels(litaC_checker__TypeChecker* litaC_this);
litaC_bool litaC_checker_decl__TypeChecker_resolveFuncDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncDecl* litaC_funcDecl);
litaC_bool litaC_checker_decl__TypeChecker_resolveParamDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__ParameterDecl* litaC_paramDecl);
litaC_bool litaC_checker_decl__TypeChecker_resolveTypedefDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__TypedefDecl* litaC_typedefDecl);
litaC_bool litaC_checker_expr__TypeChecker_resolveConstExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveFuncIdentifierExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__IdentifierExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_isMethodSyntax(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,litaC_array__Array_cb_CallArg_ce_* litaC_suppliedArgs);
litaC_ast__Expr* litaC_checker_expr__TypeChecker_coerceTypeWithUsing(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_sourceType,litaC_types__TypeInfo* litaC_targetType);
litaC_bool litaC_checker_expr__TypeChecker_coerceFuncArgs(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,litaC_types__TypeInfo* litaC_funcType,litaC_array__Array_cb_CallArg_ce_* litaC_suppliedArgs);
litaC_bool litaC_checker_expr__TypeChecker_coerceFuncArg(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,litaC_i32 litaC_index,litaC_ast__Expr* litaC_argExpr,litaC_types__TypeInfo* litaC_paramInfo,litaC_array__Array_cb_CallArg_ce_* litaC_suppliedArgs);
litaC_bool litaC_checker_expr__TypeChecker_checkNumberOfArgs(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,const litaC_char* litaC_funcName,litaC_i32 litaC_maxNumOfArgs,litaC_bool litaC_hasVarargs,litaC_i32 litaC_numberOfSuppliedArgs,litaC_i32 litaC_numberOfDefaultArgs);
litaC_types__TypeInfo* litaC_checker_expr__TypeChecker_inferredType(litaC_checker__TypeChecker* litaC_this,litaC_lex__Token litaC_name,litaC_types__TypeInfo* litaC_paramType,litaC_types__TypeInfo* litaC_expectedType);
litaC_types__TypeInfo* litaC_checker_expr__TypeChecker_inferFuncCallExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,litaC_types__TypeInfo* litaC_funcType,litaC_array__Array_cb_CallArg_ce_* litaC_suppliedArgs,litaC_bool litaC_isMethodCall);
litaC_bool litaC_checker_expr__TypeChecker_checkFuncCallArgs(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,litaC_types__TypeInfo* litaC_funcType,litaC_array__Array_cb_CallArg_ce_* litaC_suppliedArgs);
litaC_bool litaC_checker_expr__TypeChecker_resolveFuncCallExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveBooleanExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__BooleanExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveCharExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__CharExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveNullExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__NullExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveNumberExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__NumberExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveStringExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__StringExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveSubscriptSetExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__SubscriptSetExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveSubscriptGetExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__SubscriptGetExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveInitArgExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__InitArgExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_addDefaultArguments(litaC_checker__TypeChecker* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_ast__InitExpr* litaC_expr);
litaC_void litaC_checker_expr__TypeChecker_addInitArgumentsReferences(litaC_checker__TypeChecker* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_ast__InitExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_checkInitArguments(litaC_checker__TypeChecker* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_ast__InitExpr* litaC_expr);
litaC_types__TypeInfo* litaC_checker_expr__TypeChecker_inferInitExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__InitExpr* litaC_expr,litaC_types__AggregateTypeInfo* litaC_aggInfo);
litaC_bool litaC_checker_expr__TypeChecker_resolveInitExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__InitExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveSetExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__SetExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveTernaryExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__TernaryExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveTypeIdentifierExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__TypeIdentifierExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveTypeOfExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__TypeOfExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveOffsetOfExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__OffsetOfExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveSizeOfExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__SizeOfExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_checkMethodExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__GetExpr* litaC_expr,litaC_types__AggregateTypeInfo* litaC_aggInfo);
litaC_bool litaC_checker_expr__TypeChecker_resolveGetExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__GetExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveGroupExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__GroupExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveUnaryExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__UnaryExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveCastExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__CastExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveArrayDesignationExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__ArrayDesignationExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveArrayInitExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__ArrayInitExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveBinaryExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__BinaryExpr* litaC_expr);
litaC_void litaC_checker_expr__TypeChecker_errorNonIndexableType(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type);
litaC_void litaC_checker_expr__TypeChecker_errorSetIndexingConstType(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type);
litaC_void litaC_checker_expr__TypeChecker_errorIndexType(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type);
litaC_void litaC_checker_expr__TypeChecker_errorNonAggregateType(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type);
litaC_void litaC_checker_expr__TypeChecker_errorNonFuncType(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type);
litaC_void litaC_checker_expr__TypeChecker_errorOperand(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type,const litaC_char* litaC_side);
litaC_void litaC_checker_expr__TypeChecker_errorEnumFieldSet(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type,const litaC_char* litaC_field);
litaC_void litaC_checker_expr__TypeChecker_errorNoField(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type,const litaC_char* litaC_field);
litaC_void litaC_checker_expr__TypeChecker_errorNoFieldAt(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type,litaC_i32 litaC_position);
litaC_void litaC_checker_expr__TypeChecker_errorNoFieldAccess(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type,const litaC_char* litaC_field);
litaC_void litaC_checker_expr__TypeChecker_errorInferGenericParameter(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_ast__GenericParam* litaC_param);
litaC_void litaC_checker_expr__TypeChecker_errorInferGenericParameters(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_array__Array_cb_GenericParam_ce_* litaC_params);
litaC_void litaC_checker_expr__TypeChecker_errorMissingGenericArguments(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,const litaC_char* litaC_typeName,litaC_array__Array_cb_GenericParam_ce_* litaC_genericParams);
litaC_void litaC_checker_expr__TypeChecker_errorFixedArgumentAfterNamed(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_arg);
litaC_void litaC_checker_expr__TypeChecker_errorNamedArgumentsForFuncPtr(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr);
litaC_void litaC_checker_expr__TypeChecker_errorInvalidNamedArgument(litaC_checker__TypeChecker* litaC_this,litaC_lex__SrcPos litaC_pos,litaC_string_view__StringView* litaC_name,litaC_types__FuncTypeInfo* litaC_funcInfo);
litaC_bool litaC_checker_expr__TypeChecker_checkConstant(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_checkTruthyness(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_checker_expr__TypeChecker_checkRightValue(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveIdentiferExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__IdentifierExpr* litaC_expr);
litaC_void litaC_error_codes__PrintError(litaC_string_buffer__StringBuffer* litaC_sb,litaC_phase_result__PhaseError litaC_error);
litaC_parser__Parser litaC_parser__ParserInit(const litaC_char* litaC_filename,const litaC_char* litaC_text,litaC_lita__Lita* litaC_lita);
litaC_ast__ModuleStmt* litaC_parser__Parser_parseModule(litaC_parser__Parser* litaC_p);
litaC_void litaC_parser__Parser_parseModuleDeclaration(litaC_parser__Parser* litaC_p,litaC_ast__ModuleStmt* litaC_moduleStmt);
litaC_ast__Stmt* litaC_parser__Parser_parseCompileTimeBody(litaC_parser__Parser* litaC_p);
litaC_ast__ImportDecl* litaC_parser__Parser_importDeclaration(litaC_parser__Parser* litaC_p);
litaC_bool litaC_parser__Parser_notes(litaC_parser__Parser* litaC_p,litaC_array__Array_cb__ptr_NoteStmt_ce_* litaC_notes);
litaC_ast__Decl* litaC_parser__Parser_varDeclaration(litaC_parser__Parser* litaC_p);
litaC_ast__Decl* litaC_parser__Parser_constDeclaration(litaC_parser__Parser* litaC_p);
litaC_ast__Decl* litaC_parser__Parser_funcDeclaration(litaC_parser__Parser* litaC_p);
litaC_ast__Decl* litaC_parser__Parser_structDeclaration(litaC_parser__Parser* litaC_p);
litaC_ast__Decl* litaC_parser__Parser_unionDeclaration(litaC_parser__Parser* litaC_p);
litaC_ast__Decl* litaC_parser__Parser_traitDeclaration(litaC_parser__Parser* litaC_p);
litaC_ast__Decl* litaC_parser__Parser_aggregateDeclaration(litaC_parser__Parser* litaC_p,litaC_ast__StmtKind litaC_kind);
litaC_ast__Decl* litaC_parser__Parser_enumDeclaration(litaC_parser__Parser* litaC_p);
litaC_ast__Decl* litaC_parser__Parser_typedefDeclaration(litaC_parser__Parser* litaC_p);
litaC_ast__ParameterDecl* litaC_parser__Parser_paramDeclaration(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_expression(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_constExpression(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_group(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_arrayInit(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_aggregateInit(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_sizeOf(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_typeOf(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_offsetOf(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_assignment(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_ternary(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_or(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_and(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_bitOr(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_bitXor(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_bitAnd(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_equality(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_comparison(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_bitShift(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_term(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_factor(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_unary(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_functionCall(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_primary(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_finishFunctionCall(litaC_parser__Parser* litaC_p,litaC_ast__Expr* litaC_expr);
litaC_ast__Expr* litaC_parser__Parser_cast(litaC_parser__Parser* litaC_p,litaC_ast__Expr* litaC_expr);
litaC_ast__Stmt* litaC_parser__Parser_statement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_tryStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_compStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_blockStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_ifStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_whileStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_doWhileStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_forStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_switchCaseStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_switchDefaultStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_switchStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_breakStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_continueStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_returnStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_deferStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_gotoStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_tryLabelStatement(litaC_parser__Parser* litaC_p);
litaC_ast__TypeSpec* litaC_parser__Parser_type(litaC_parser__Parser* litaC_p,litaC_bool litaC_disambiguate);
litaC_ast__NameTypeSpec* litaC_parser__Parser_identifierType(litaC_parser__Parser* litaC_p,litaC_bool litaC_disambiguate);
litaC_ast__ArrayTypeSpec* litaC_parser__Parser_arrayType(litaC_parser__Parser* litaC_p);
litaC_ast__FuncPtrTypeSpec* litaC_parser__Parser_funcPtrType(litaC_parser__Parser* litaC_p);
litaC_ast__ParametersStmt* litaC_parser__Parser_parametersStatement(litaC_parser__Parser* litaC_p);
litaC_bool litaC_parser__Parser_structArguments(litaC_parser__Parser* litaC_p,litaC_array__Array_cb__ptr_InitArgExpr_ce_* litaC_arguments);
litaC_bool litaC_parser__Parser_arguments(litaC_parser__Parser* litaC_p,litaC_array__Array_cb_CallArg_ce_* litaC_arguments);
litaC_bool litaC_parser__Parser_genericParameters(litaC_parser__Parser* litaC_p,litaC_array__Array_cb_GenericParam_ce_* litaC_arguments);
litaC_array__Array_cb__ptr_TypeSpec_ce_ litaC_parser__Parser_genericArguments(litaC_parser__Parser* litaC_p);
litaC_array__Array_cb__ptr_TypeSpec_ce_ litaC_parser__Parser_tryGenericArguments(litaC_parser__Parser* litaC_p,litaC_bool litaC_disambiguate);
litaC_bool litaC_parser__Parser_arrayArguments(litaC_parser__Parser* litaC_p,litaC_array__Array_cb__ptr_Expr_ce_* litaC_arguments);
litaC_ast__Expr* litaC_parser__Parser_tryArrayDesignationExpr(litaC_parser__Parser* litaC_p);
litaC_ast__FieldStmt litaC_parser__Parser_fieldStatement(litaC_parser__Parser* litaC_p,litaC_ast__StmtKind litaC_aggKind);
litaC_ast__EnumFieldEntryDecl* litaC_parser__Parser_enumFieldEntryDecl(litaC_parser__Parser* litaC_p);
litaC_void litaC_parser__Parser_rewindTo(litaC_parser__Parser* litaC_p,litaC_i32 litaC_backtrack,litaC_u64 litaC_numOfErrors);
litaC_ast__Expr* litaC_parser__Parser_tryBitShiftRight(litaC_parser__Parser* litaC_p,litaC_ast__Expr* litaC_expr);
litaC_void litaC_parser__Parser_eatSemicolon(litaC_parser__Parser* litaC_p);
litaC_lex__Token litaC_parser__Parser_identifier(litaC_parser__Parser* litaC_p);
litaC_bool litaC_parser__Parser_checkConstExpr(litaC_parser__Parser* litaC_p,litaC_ast__Expr* litaC_expr);
litaC_ast__Stmt* litaC_parser__Parser_poisonStatement(litaC_parser__Parser* litaC_p,litaC_lex__SrcPos litaC_pos);
litaC_ast__Expr* litaC_parser__Parser_poisonExpr(litaC_parser__Parser* litaC_p,litaC_lex__SrcPos litaC_pos);
litaC_ast__Decl* litaC_parser__Parser_poisonDecl(litaC_parser__Parser* litaC_p,litaC_lex__SrcPos litaC_pos);
litaC_lex__SrcPos litaC_parser__Parser_pos(litaC_parser__Parser* litaC_p);
litaC_lex__SrcPos litaC_parser__Parser_prevPos(litaC_parser__Parser* litaC_p);
litaC_lex__Token* litaC_parser__Parser_peek(litaC_parser__Parser* litaC_p);
litaC_void litaC_parser__Parser_rewind(litaC_parser__Parser* litaC_p);
litaC_lex__Token* litaC_parser__Parser_previous(litaC_parser__Parser* litaC_p);
litaC_bool litaC_parser__Parser_atEnd(litaC_parser__Parser* litaC_p);
litaC_lex__Token* litaC_parser__Parser_advance(litaC_parser__Parser* litaC_p);
LITAC_INLINE 
litaC_bool litaC_parser__Parser_check(litaC_parser__Parser* litaC_p,litaC_lex__TokenType litaC_type);
litaC_bool litaC_parser__Parser_match(litaC_parser__Parser* litaC_p,litaC_lex__TokenType litaC_type);
litaC_bool litaC_parser__Parser_matches(litaC_parser__Parser* litaC_p,litaC_lex__TokenType* litaC_types,litaC_i32 litaC_len);
litaC_lex__Token* litaC_parser__Parser_consume(litaC_parser__Parser* litaC_p,litaC_lex__TokenType litaC_type,litaC_error_codes__ErrorCode litaC_errorCode);
litaC_void litaC_parser__Parser_adjust(litaC_parser__Parser* litaC_p,litaC_lex__TokenType* litaC_types,litaC_i32 litaC_len);
litaC_void litaC_parser__Parser_errorAtToken(litaC_parser__Parser* litaC_p,litaC_lex__Token* litaC_token,litaC_error_codes__ErrorCode litaC_errorCode);
litaC_void litaC_parser__Parser_errorAtPos(litaC_parser__Parser* litaC_p,litaC_lex__SrcPos litaC_pos,litaC_error_codes__ErrorCode litaC_errorCode);
litaC_void litaC_parser__Parser_errorUnexpectedToken(litaC_parser__Parser* litaC_p,litaC_lex__Token* litaC_token,litaC_error_codes__ErrorCode litaC_errorCode);
litaC_i32 litaC_parser__Parser_numOfErrors(litaC_parser__Parser* litaC_p);
litaC_void litaC_instrument__Instrument(litaC_lita__Lita* litaC_lita,litaC_checker__TypeChecker* litaC_checker);
litaC_array__Array_cb__ptr_Decl_ce_ litaC_traits__CreateTraitWrappers(litaC_checker__TypeChecker* litaC_checker);
litaC_void litaC_traits__PrintGenerics(litaC_array__Array_cb_GenericParam_ce_* litaC_genericParams,litaC_string_buffer__StringBuffer* litaC_sb);
litaC_void litaC_traits__PrintGenericArgs(litaC_array__Array_cb__ptr_TypeInfo_ce_* litaC_genericArgs,litaC_string_buffer__StringBuffer* litaC_sb);
litaC_symbols__Symbol* litaC_traits__FindSymbolByTypeid(litaC_array__Array_cb__ptr_Symbol_ce_ litaC_symbols,litaC_i64 litaC_id);
const litaC_char* litaC_traits__GetTraitName(litaC_symbols__Symbol* litaC_traitSym,litaC_string_buffer__StringBuffer* litaC_sb);
litaC_void litaC_traits__Parse(litaC_string_buffer__StringBuffer* litaC_sb,litaC_checker__TypeChecker* litaC_checker,litaC_array__Array_cb__ptr_Decl_ce_* litaC_decls);
litaC_void litaC_cgen__CGen_init(litaC_cgen__CGen* litaC_this,litaC_lita__Lita* litaC_lita,FILE* litaC_output);
litaC_void litaC_cgen__CGen_emitProgram(litaC_cgen__CGen* litaC_this,litaC_module__Module* litaC_module);
litaC_void litaC_cgen__CGen_emitMain(litaC_cgen__CGen* litaC_this,litaC_symbols__Symbol* litaC_sym);
litaC_void litaC_cgen__CGen_emitForward(litaC_cgen__CGen* litaC_this);
litaC_void litaC_cgen__CGen_emitPrimitiveConstDecls(litaC_cgen__CGen* litaC_this);
litaC_void litaC_cgen__CGen_emitModuleNotes(litaC_cgen__CGen* litaC_this);
litaC_symbols__Symbol* litaC_cgen__CGen_findSymbolByTypeid(litaC_cgen__CGen* litaC_this,litaC_i64 litaC_id);
litaC_void litaC_cgen__CGen_emitTraitForwardDecls(litaC_cgen__CGen* litaC_this);
litaC_void litaC_cgen__CGen_emitTraitDecls(litaC_cgen__CGen* litaC_this);
litaC_bool litaC_cgen__CGen_emitTraitCast(litaC_cgen__CGen* litaC_this,litaC_ast__Expr* litaC_expr);
litaC_void litaC_cgen__CGen_emitForwardDecls(litaC_cgen__CGen* litaC_this);
litaC_void litaC_cgen__CGen_emitTypeForwardDecl(litaC_cgen__CGen* litaC_this,litaC_symbols__Symbol* litaC_sym);
const litaC_char* litaC_cgen__CGen_allocTemp(litaC_cgen__CGen* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_char* litaC_buffer);
litaC_char* litaC_cgen__CGen_escapeNameStr(litaC_cgen__CGen* litaC_this,const litaC_char* litaC_name);
const litaC_char* litaC_cgen__CGen_escapeName(litaC_cgen__CGen* litaC_this,litaC_types__TypeInfo* litaC_type);
litaC_string_view__StringView litaC_cgen__CGen_baseTypeName(litaC_cgen__CGen* litaC_this,litaC_string_view__StringView litaC_name);
litaC_void litaC_cgen__CGen_pushScope(litaC_cgen__CGen* litaC_this,litaC_cgen__CGenScope* litaC_scope);
litaC_cgen__CGenScope* litaC_cgen__CGen_popScope(litaC_cgen__CGen* litaC_this);
litaC_void litaC_cgen__CGen_popLoopScope(litaC_cgen__CGen* litaC_this,litaC_bool litaC_checkSwitch);
litaC_void litaC_cgen__CGen_leaveScope(litaC_cgen__CGen* litaC_this,litaC_cgen__CGenScope* litaC_scope);
litaC_bool litaC_cgen__CGen_hasPendingDefers(litaC_cgen__CGen* litaC_this);
litaC_void litaC_cgen__CGen_emitDefers(litaC_cgen__CGen* litaC_this);
litaC_void litaC_cgen__CGen_emitLineInfo(litaC_cgen__CGen* litaC_this,litaC_ast__Stmt* litaC_stmt);
const litaC_char* litaC_cgen__CGen_cType(litaC_cgen__CGen* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_bool litaC_isCast,litaC_bool litaC_decay);
const litaC_char* litaC_cgen__CGen_cTypeDecl(litaC_cgen__CGen* litaC_this,litaC_types__TypeInfo* litaC_type,const litaC_char* litaC_name,litaC_bool litaC_decay);
litaC_string_view__StringView litaC_cgen__CGen_foreignName(litaC_cgen__CGen* litaC_this,litaC_ast__Decl* litaC_decl,litaC_string_view__StringView litaC_defaultName);
const litaC_char* litaC_cgen__CGen_cName(litaC_cgen__CGen* litaC_this,litaC_symbols__Symbol* litaC_sym);
const litaC_char* litaC_cgen__CGen_cTypeName(litaC_cgen__CGen* litaC_this,litaC_types__TypeInfo* litaC_type);
const litaC_char* litaC_cgen__CGen_prefix(litaC_cgen__CGen* litaC_this,const litaC_char* litaC_name,litaC_string_buffer__StringBuffer* litaC_sb);
litaC_void litaC_cgen__CGen_emitTypeSpec(litaC_cgen__CGen* litaC_this,litaC_ast__TypeSpec* litaC_spec);
litaC_void litaC_cgen__CGen_flush(litaC_cgen__CGen* litaC_this);
litaC_void litaC_cgen__CGen_emitName(litaC_cgen__CGen* litaC_this,litaC_lex__Token litaC_tok);
litaC_void litaC_cgen__CGen_emitln(litaC_cgen__CGen* litaC_this);
litaC_void litaC_cgen__CGen_emit(litaC_cgen__CGen* litaC_this,const litaC_char* litaC_strFormat,...);
litaC_void litaC_cgen__CGen_emitStr(litaC_cgen__CGen* litaC_this,const litaC_char* litaC_str);
litaC_void litaC_cgen__CGen_emitStrn(litaC_cgen__CGen* litaC_this,const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_void litaC_cgen__CGen_emitNotes(litaC_cgen__CGen* litaC_this,litaC_ast__Attributes* litaC_attributes,litaC_bool litaC_isPrelude);
litaC_void litaC_cgen__CGen_emitPreludeNote(litaC_cgen__CGen* litaC_this,litaC_ast__NoteStmt* litaC_note);
litaC_void litaC_cgen__CGen_emitPostludeNote(litaC_cgen__CGen* litaC_this,litaC_ast__NoteStmt* litaC_note);
litaC_void litaC_cgen__CGen_emitFieldName(litaC_cgen__CGen* litaC_this,litaC_ast__FieldStmt litaC_field);
litaC_void litaC_cgen__CGen_emitSymbol(litaC_cgen__CGen* litaC_this,litaC_symbols__Symbol* litaC_sym);
litaC_void litaC_cgen__CGen_emitTraitFuncCall(litaC_cgen__CGen* litaC_this,litaC_ast__FuncCallExpr* litaC_expr);
litaC_void litaC_cgen__CGen_emitStmt(litaC_cgen__CGen* litaC_this,litaC_ast__Stmt* litaC_s);
litaC_void litaC_dependency_graph__DependencyGraph_init(litaC_dependency_graph__DependencyGraph* litaC_this,litaC_lita__Lita* litaC_lita);
litaC_void litaC_dependency_graph__DependencyGraph_markDependencies(litaC_dependency_graph__DependencyGraph* litaC_this,litaC_dependency_graph__Dependency* litaC_dependency);
litaC_void litaC_dependency_graph__DependencyGraph_buildGraph(litaC_dependency_graph__DependencyGraph* litaC_this,litaC_symbols__ProgramSymbols* litaC_program);
litaC_dependency_graph__Dependency* litaC_dependency_graph__DependencyGraph_resolveDependency(litaC_dependency_graph__DependencyGraph* litaC_this,litaC_dependency_graph__Dependency* litaC_dependency);
litaC_void litaC_dependency_graph__DependencyGraph_sortAggregates(litaC_dependency_graph__DependencyGraph* litaC_this);
litaC_array__Array_cb__ptr_Dependency_ce_ litaC_dependency_graph__DependencyGraph_sortAggregatesDependencies(litaC_dependency_graph__DependencyGraph* litaC_this,litaC_array__Array_cb__ptr_Dependency_ce_* litaC_deps);
litaC_array__Array_cb__ptr_Symbol_ce_ litaC_dependency_graph__DependencyGraph_sort(litaC_dependency_graph__DependencyGraph* litaC_this);
litaC_void litaC_cgen_decl__CGen_emitVarDecl(litaC_cgen__CGen* litaC_this,litaC_ast__VarDecl* litaC_decl);
litaC_void litaC_cgen_decl__CGen_emitFuncDeclSignature(litaC_cgen__CGen* litaC_this,litaC_ast__FuncDecl* litaC_decl,const litaC_char* litaC_name);
litaC_void litaC_cgen_decl__CGen_emitFuncDecl(litaC_cgen__CGen* litaC_this,litaC_ast__FuncDecl* litaC_decl);
litaC_void litaC_cgen_decl__CGen_emitAggregateDecl(litaC_cgen__CGen* litaC_this,litaC_ast__AggregateDecl* litaC_decl);
litaC_void litaC_cgen_decl__CGen_emitEnumDecl(litaC_cgen__CGen* litaC_this,litaC_ast__EnumDecl* litaC_decl);
litaC_lex__Token litaC_references__FindTokenByPosition(litaC_lsp__LspServer* litaC_lsp,const litaC_mem__Allocator* litaC_alloc,litaC_workspace__TextDocument* litaC_doc,litaC_protocol__Position litaC_pos);
litaC_void litaC_references__ReferenceDatabase_init(litaC_references__ReferenceDatabase* litaC_this,const litaC_mem__Allocator* litaC_allocator);
litaC_void litaC_references__ReferenceDatabase_addSymbolReference(litaC_references__ReferenceDatabase* litaC_this,litaC_symbols__Symbol* litaC_symbol,litaC_lex__SrcPos litaC_pos);
litaC_void litaC_references__ReferenceDatabase_addTypeReference(litaC_references__ReferenceDatabase* litaC_this,litaC_ast__TypeSpec* litaC_type);
litaC_void litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(litaC_references__ReferenceDatabase* litaC_this,litaC_lex__SrcPos litaC_srcPos,litaC_symbols__Symbol* litaC_sym);
litaC_void litaC_references__ReferenceDatabase_addTypeReferenceByTypeInfo(litaC_references__ReferenceDatabase* litaC_this,litaC_lex__SrcPos litaC_srcPos,litaC_types__TypeInfo* litaC_typeInfo);
litaC_void litaC_references__ReferenceDatabase_addFieldReference(litaC_references__ReferenceDatabase* litaC_this,litaC_lex__SrcPos litaC_srcPos,litaC_types__TypeInfo* litaC_parent,litaC_i32 litaC_offset);
litaC_array__Array_cb_SrcPos_ce_ litaC_references__ReferenceDatabase_getSymbolReferences(litaC_references__ReferenceDatabase* litaC_this,litaC_symbols__Symbol* litaC_symbol);
litaC_void litaC_references__ReferenceDatabase_getTypeReferences(litaC_references__ReferenceDatabase* litaC_this,litaC_i64 litaC_typeid,litaC_array__Array_cb_SrcPos_ce_* litaC_results);
litaC_void litaC_references__ReferenceDatabase_getFieldReferences(litaC_references__ReferenceDatabase* litaC_this,litaC_i64 litaC_typeid,litaC_i32 litaC_offset,litaC_array__Array_cb_SrcPos_ce_* litaC_results);
LITAC_INLINE 
litaC_bool litaC_json__JsonNode_isNull(litaC_json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_bool litaC_json__JsonNode_isBool(litaC_json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_bool litaC_json__JsonNode_isTrue(litaC_json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_bool litaC_json__JsonNode_isFalse(litaC_json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_bool litaC_json__JsonNode_isNumber(litaC_json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_bool litaC_json__JsonNode_isString(litaC_json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_bool litaC_json__JsonNode_isArray(litaC_json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_bool litaC_json__JsonNode_isObject(litaC_json__JsonNode* litaC_node);
LITAC_INLINE 
const litaC_char* litaC_json__JsonNode_asString(litaC_json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_bool litaC_json__JsonNode_asBool(litaC_json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_f64 litaC_json__JsonNode_asNumber(litaC_json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_f64 litaC_json__JsonNode_asFloat(litaC_json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_i32 litaC_json__JsonNode_asInt(litaC_json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_i64 litaC_json__JsonNode_asLong(litaC_json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_array__Array_cb__ptr_JsonNode_ce_* litaC_json__JsonNode_asArray(litaC_json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_json__JsonObject* litaC_json__JsonNode_asObject(litaC_json__JsonNode* litaC_node);
litaC_json__JsonNode* litaC_json__CreateJsonNumber(litaC_f64 litaC_value,const litaC_mem__Allocator* litaC_alloc);
litaC_json__JsonNode* litaC_json__CreateJsonIntNumber(litaC_i64 litaC_value,const litaC_mem__Allocator* litaC_alloc);
litaC_json__JsonNode* litaC_json__CreateJsonFloatNumber(litaC_f64 litaC_value,const litaC_mem__Allocator* litaC_alloc);
litaC_json__JsonNode* litaC_json__CreateJsonString(const litaC_char* litaC_str,litaC_i32 litaC_len,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_json__EscapeString(litaC_string_buffer__StringBuffer* litaC_buf,const litaC_char* litaC_string,litaC_i32 litaC_length);
litaC_json__JsonNode* litaC_json__CreateJsonStringNoDup(const litaC_char* litaC_str,const litaC_mem__Allocator* litaC_alloc);
litaC_json__JsonNode* litaC_json__CreateJsonArray(const litaC_mem__Allocator* litaC_alloc);
litaC_json__JsonNode* litaC_json__CreateJsonObject(const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_json__JsonNode_put(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_json__JsonNode* litaC_n,litaC_i32 litaC_len);
litaC_void litaC_json__JsonNode_putNoDup(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_json__JsonNode* litaC_n,litaC_i32 litaC_len);
litaC_void litaC_json__JsonNode_putStr(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_void litaC_json__JsonNode_putNumber(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_f64 litaC_number,litaC_i32 litaC_len);
litaC_void litaC_json__JsonNode_putIntNumber(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_i64 litaC_number,litaC_i32 litaC_len);
litaC_void litaC_json__JsonNode_putFloatNumber(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_f64 litaC_number,litaC_i32 litaC_len);
litaC_void litaC_json__JsonNode_putBool(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_bool litaC_b,litaC_i32 litaC_len);
litaC_bool litaC_json__JsonNode_contains(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key);
litaC_json__JsonNode* litaC_json__JsonNode_get(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key);
litaC_bool litaC_json__JsonNode_getBool(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_bool litaC_defaultValue);
litaC_i32 litaC_json__JsonNode_getInt(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_i32 litaC_defaultValue);
litaC_i64 litaC_json__JsonNode_getLong(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_i64 litaC_defaultValue);
litaC_f64 litaC_json__JsonNode_getFloat(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_f64 litaC_defaultValue);
const litaC_char* litaC_json__JsonNode_getStr(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,const litaC_char* litaC_defaultValue);
litaC_char* litaC_json__JsonNode_getStrCopy(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_json__JsonNode* litaC_json__JsonNode_getArray(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key);
litaC_json__JsonNode* litaC_json__JsonNode_getObject(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key);
litaC_void litaC_json__JsonNode_add(litaC_json__JsonNode* litaC_node,litaC_json__JsonNode* litaC_n);
litaC_json__JsonNode* litaC_json__JsonNode_at(litaC_json__JsonNode* litaC_node,litaC_i32 litaC_index);
litaC_i32 litaC_json__JsonNode_size(litaC_json__JsonNode* litaC_node);
litaC_bool litaC_json__JsonNode_equals(litaC_json__JsonNode* litaC_node,litaC_json__JsonNode* litaC_other);
const litaC_char* litaC_json__JsonNode_print(litaC_json__JsonNode* litaC_node,litaC_string_buffer__StringBuffer* litaC_buf);
litaC_void litaC_json__JsonNode_free(litaC_json__JsonNode* litaC_node);
litaC_json__JsonParser litaC_json__JsonParserInit(const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_json__JsonParser_init(litaC_json__JsonParser* litaC_p,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_json__JsonParser_free(litaC_json__JsonParser* litaC_p);
litaC_json__JsonNode* litaC_json__JsonParser_parseJson(litaC_json__JsonParser* litaC_p,const litaC_char* litaC_buffer);
litaC_bool litaC_json__JsonParser_hasError(litaC_json__JsonParser* litaC_p);
litaC_void litaC_json__PrintJson(litaC_json__JsonNode* litaC_node,litaC_string_buffer__StringBuffer* litaC_buf);
litaC_json__JsonNode* litaC_json__JsonParser_parseJsonNode(litaC_json__JsonParser* litaC_p);
litaC_json__JsonNode* litaC_json__JsonParser_parseJsonIntNumber(litaC_json__JsonParser* litaC_p);
litaC_json__JsonNode* litaC_json__JsonParser_parseJsonRealNumber(litaC_json__JsonParser* litaC_p);
litaC_json__JsonNode* litaC_json__JsonParser_parseJsonStr(litaC_json__JsonParser* litaC_p);
litaC_json__JsonNode* litaC_json__JsonParser_parseJsonArray(litaC_json__JsonParser* litaC_p);
litaC_json__JsonNode* litaC_json__JsonParser_parseJsonObject(litaC_json__JsonParser* litaC_p);
const litaC_char* litaC_json__TokenName(litaC_json__TokenKind litaC_t);
litaC_void litaC_json__JsonParser_error(litaC_json__JsonParser* litaC_p,const litaC_char* litaC_format,...);
litaC_void litaC_json__JsonParser_scanInt(litaC_json__JsonParser* litaC_p);
litaC_void litaC_json__JsonParser_scanFloat(litaC_json__JsonParser* litaC_p);
litaC_void litaC_json__JsonParser_scanStr(litaC_json__JsonParser* litaC_p);
litaC_void litaC_json__JsonParser_scanMultiStr(litaC_json__JsonParser* litaC_p);
litaC_void litaC_json__JsonParser_skipComments(litaC_json__JsonParser* litaC_l);
litaC_void litaC_json__JsonParser_nextToken(litaC_json__JsonParser* litaC_p);
litaC_bool litaC_json__JsonParser_check(litaC_json__JsonParser* litaC_p,litaC_json__TokenKind litaC_kind);
litaC_bool litaC_json__JsonParser_match(litaC_json__JsonParser* litaC_p,litaC_json__TokenKind litaC_kind);
litaC_bool litaC_json__JsonParser_expect(litaC_json__JsonParser* litaC_p,litaC_json__TokenKind litaC_kind);
litaC_void litaC_workspace__Workspace_init(litaC_workspace__Workspace* litaC_this,litaC_lsp__LspServer* litaC_lsp,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_workspace__Workspace_setup(litaC_workspace__Workspace* litaC_this,const litaC_char* litaC_rootPath,const litaC_char* litaC_rootUri);
litaC_bool litaC_workspace__Workspace_isDocumentOpen(litaC_workspace__Workspace* litaC_this,const litaC_char* litaC_uri);
litaC_void litaC_workspace__Workspace_openDocument(litaC_workspace__Workspace* litaC_this,const litaC_char* litaC_uri,const litaC_char* litaC_text);
litaC_void litaC_workspace__Workspace_closeDocument(litaC_workspace__Workspace* litaC_this,const litaC_char* litaC_uri);
litaC_void litaC_workspace__Workspace_saveDocument(litaC_workspace__Workspace* litaC_this,const litaC_char* litaC_uri);
litaC_void litaC_workspace__Workspace_changeDocument(litaC_workspace__Workspace* litaC_this,const litaC_char* litaC_uri,litaC_protocol__TextDocumentChangeEvent* litaC_change);
litaC_json__JsonNode* litaC_workspace__Workspace_documentSymbols(litaC_workspace__Workspace* litaC_this,const litaC_char* litaC_uri,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_workspace__Workspace_addDocumentSymbol(litaC_workspace__Workspace* litaC_this,litaC_json__JsonNode* litaC_results,litaC_symbols__Symbol* litaC_sym,const litaC_char* litaC_docFilename,const litaC_mem__Allocator* litaC_alloc);
litaC_json__JsonNode* litaC_workspace__Workspace_references(litaC_workspace__Workspace* litaC_this,const litaC_char* litaC_uri,litaC_json__JsonNode* litaC_position,const litaC_mem__Allocator* litaC_alloc);
litaC_json__JsonNode* litaC_workspace__Workspace_findTypeReferences(litaC_workspace__Workspace* litaC_this,litaC_i64 litaC_typeid,const litaC_mem__Allocator* litaC_alloc);
litaC_json__JsonNode* litaC_workspace__Workspace_findFieldReferences(litaC_workspace__Workspace* litaC_this,litaC_i64 litaC_typeid,litaC_i32 litaC_offset,const litaC_mem__Allocator* litaC_alloc);
litaC_util__SourceLocation litaC_workspace__Workspace_getNodeAtSourcePos(litaC_workspace__Workspace* litaC_this,const litaC_char* litaC_uri,litaC_json__JsonNode* litaC_position);
litaC_json__JsonNode* litaC_workspace__Workspace_goToDefinition(litaC_workspace__Workspace* litaC_this,const litaC_char* litaC_uri,litaC_json__JsonNode* litaC_position,const litaC_mem__Allocator* litaC_alloc);
litaC_phase_result__PhaseResult* litaC_workspace__Workspace_runDiagnostics(litaC_workspace__Workspace* litaC_this,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_lsp__LspServer_init(litaC_lsp__LspServer* litaC_this,litaC_lita__Lita* litaC_lita);
const litaC_mem__Allocator* litaC_lsp__LspServer_requestAlloc(litaC_lsp__LspServer* litaC_this);
const litaC_mem__Allocator* litaC_lsp__LspServer_appAlloc(litaC_lsp__LspServer* litaC_this);
litaC_void litaC_lsp__LspServer_free(litaC_lsp__LspServer* litaC_this);
litaC_void litaC_lsp__LspServer_start(litaC_lsp__LspServer* litaC_this);
litaC_void litaC_lsp__LspServer_log(litaC_lsp__LspServer* litaC_this,const litaC_char* litaC_format,...);
litaC_void litaC_lsp__LspServer_readMessage(litaC_lsp__LspServer* litaC_this);
litaC_i32 litaC_lsp__LspServer_readHeader(litaC_lsp__LspServer* litaC_this);
litaC_void litaC_lsp__LspServer_handleMessage(litaC_lsp__LspServer* litaC_this,litaC_json__JsonNode* litaC_msg);
litaC_void litaC_lsp__LspServer_handleInitializeMessage(litaC_lsp__LspServer* litaC_this,litaC_json__JsonNode* litaC_msg,litaC_json__JsonNode* litaC_params);
litaC_void litaC_lsp__LspServer_handleTextDocumentOpenMessage(litaC_lsp__LspServer* litaC_this,litaC_json__JsonNode* litaC_msg,litaC_json__JsonNode* litaC_params);
litaC_void litaC_lsp__LspServer_handleTextDocumentCloseMessage(litaC_lsp__LspServer* litaC_this,litaC_json__JsonNode* litaC_msg,litaC_json__JsonNode* litaC_params);
litaC_void litaC_lsp__LspServer_handleTextDocumentSymbolMessage(litaC_lsp__LspServer* litaC_this,litaC_json__JsonNode* litaC_msg,litaC_json__JsonNode* litaC_params);
litaC_void litaC_lsp__LspServer_handleTextDocumentSaveMessage(litaC_lsp__LspServer* litaC_this,litaC_json__JsonNode* litaC_msg,litaC_json__JsonNode* litaC_params);
litaC_void litaC_lsp__LspServer_handleTextDocumentChangeMessage(litaC_lsp__LspServer* litaC_this,litaC_json__JsonNode* litaC_msg,litaC_json__JsonNode* litaC_params);
litaC_void litaC_lsp__LspServer_handleTextDocumentReferencesMessage(litaC_lsp__LspServer* litaC_this,litaC_json__JsonNode* litaC_msg,litaC_json__JsonNode* litaC_params);
litaC_void litaC_lsp__LspServer_handleTextDocumentDefinitionMessage(litaC_lsp__LspServer* litaC_this,litaC_json__JsonNode* litaC_msg,litaC_json__JsonNode* litaC_params);
litaC_void litaC_lsp__LspServer_writeDiagnostic(litaC_lsp__LspServer* litaC_this,const litaC_char* litaC_docUri);
litaC_void litaC_lsp__LspServer_writeErrorResponse(litaC_lsp__LspServer* litaC_this,litaC_i64 litaC_id,litaC_i32 litaC_code,const litaC_char* litaC_format,...);
litaC_void litaC_lsp__LspServer_writeResponse(litaC_lsp__LspServer* litaC_this,litaC_json__JsonNode* litaC_msg);
litaC_json__JsonNode* litaC_lsp__LspServer_createResponse(litaC_lsp__LspServer* litaC_this,litaC_i64 litaC_id);
litaC_protocol__SymbolInfoKind litaC_protocol__SymbolKindFromSymbol(litaC_symbols__Symbol* litaC_sym);
litaC_json__JsonNode* litaC_protocol__SymbolToSymbolInformation(litaC_symbols__Symbol* litaC_sym,const litaC_char* litaC_rootPath,const litaC_mem__Allocator* litaC_alloc);
litaC_json__JsonNode* litaC_protocol__SrcPosToLocation(litaC_lex__SrcPos litaC_pos,const litaC_char* litaC_rootPath,const litaC_mem__Allocator* litaC_alloc);
litaC_json__JsonNode* litaC_protocol__SrcPosWithEndToLocation(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_char* litaC_rootPath,const litaC_mem__Allocator* litaC_alloc);
litaC_json__JsonNode* litaC_protocol__SrcPosToRange(litaC_lex__SrcPos litaC_pos,const litaC_mem__Allocator* litaC_alloc);
litaC_json__JsonNode* litaC_protocol__SrcPosWithEndToRange(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_mem__Allocator* litaC_alloc);
litaC_json__JsonNode* litaC_protocol__SrcPosToLocations(const litaC_char* litaC_rootPath,litaC_array__Array_cb_SrcPos_ce_* litaC_results,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_util__PosToRange(litaC_lex__SrcPos litaC_srcPos,litaC_protocol__Range* litaC_range);
litaC_bool litaC_util__IsSrcPosAtPosition(litaC_lex__SrcPos* litaC_srcPos,litaC_protocol__Position litaC_pos);
litaC_util__SourceLocation litaC_util__SourceLookup_findAstNodeByPosition(litaC_util__SourceLookup* litaC_this,litaC_ast__ModuleStmt* litaC_moduleAst,litaC_protocol__Position litaC_pos);
litaC_bool litaC_util__SourceLookup_isNodeAtPos(litaC_util__SourceLookup* litaC_this,litaC_ast__Node* litaC_node);
litaC_bool litaC_util__SourceLookup_isSrcAtPos(litaC_util__SourceLookup* litaC_this,litaC_lex__SrcPos* litaC_srcPos);
litaC_bool litaC_util__SourceLookup_isTokenAtPos(litaC_util__SourceLookup* litaC_this,litaC_lex__Token litaC_token);
litaC_bool litaC_util__SourceLookup_isTypeAtPos(litaC_util__SourceLookup* litaC_this,litaC_ast__TypeSpec* litaC_type);
litaC_bool litaC_util__SourceLookup_isDeclAtPos(litaC_util__SourceLookup* litaC_this,litaC_ast__Decl* litaC_decl);
litaC_bool litaC_util__SourceLookup_visitDecl(litaC_util__SourceLookup* litaC_this,litaC_ast__Decl* litaC_node);
litaC_bool litaC_util__SourceLookup_visitStmt(litaC_util__SourceLookup* litaC_this,litaC_ast__Stmt* litaC_node);
litaC_bool litaC_util__SourceLookup_visitExpr(litaC_util__SourceLookup* litaC_this,litaC_ast__Expr* litaC_node);
const litaC_char* litaC_io__FileStatusAsStr(litaC_io__FileStatus litaC_enumType);
const litaC_char* litaC_lex__TokenTypeAsStr(litaC_lex__TokenType litaC_enumType);
const litaC_char* litaC_types__TypeKindAsStr(litaC_types__TypeKind litaC_enumType);
const litaC_char* litaC_ast__StmtKindAsStr(litaC_ast__StmtKind litaC_enumType);
const litaC_char* litaC_ast__TypeSpecKindAsStr(litaC_ast__TypeSpecKind litaC_enumType);
const litaC_char* litaC_symbols__SymbolKindAsStr(litaC_symbols__SymbolKind litaC_enumType);
const litaC_char* litaC_symbols__SymbolStateAsStr(litaC_symbols__SymbolState litaC_enumType);
const litaC_char* litaC_lita__MetricTypeAsStr(litaC_lita__MetricType litaC_enumType);
const litaC_char* litaC_lita__TypeInfoOptionAsStr(litaC_lita__TypeInfoOption litaC_enumType);
const litaC_char* litaC_json__JsonTypeAsStr(litaC_json__JsonType litaC_enumType);
const litaC_char* litaC_protocol__SymbolInfoKindAsStr(litaC_protocol__SymbolInfoKind litaC_enumType);
LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb_PhaseError_ce_(litaC_array__Array_cb_PhaseError_ce_* litaC_a);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_PhaseError_ce_(litaC_array__Array_cb_PhaseError_ce_* litaC_a);
litaC_phase_result__PhaseError litaC_array__Array_get_cb_PhaseError_ce_(litaC_array__Array_cb_PhaseError_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_const_char_ce_(litaC_array__Array_cb__ptr_const_char_ce_* litaC_a);
const litaC_char* litaC_array__Array_get_cb__ptr_const_char_ce_(litaC_array__Array_cb__ptr_const_char_ce_* litaC_a,litaC_i32 litaC_index);
litaC_mem__Arena* litaC_mem__new_cb_Arena_ce_(const litaC_mem__Allocator* litaC_a);
litaC_void litaC_array__Array_init_cb__ptr_Allocation_ce_(litaC_array__Array_cb__ptr_Allocation_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_free_cb__ptr_Allocation_ce_(litaC_array__Array_cb__ptr_Allocation_ce_* litaC_a);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_Allocation_ce_(litaC_array__Array_cb__ptr_Allocation_ce_* litaC_a);
litaC_mem__Allocation* litaC_array__Array_get_cb__ptr_Allocation_ce_(litaC_array__Array_cb__ptr_Allocation_ce_* litaC_a,litaC_i32 litaC_index);
litaC_mem__Allocation* litaC_mem__new_cb_Allocation_ce_(const litaC_mem__Allocator* litaC_a);
litaC_void litaC_array__Array_add_cb__ptr_Allocation_ce_(litaC_array__Array_cb__ptr_Allocation_ce_* litaC_a,litaC_mem__Allocation* litaC_element);
litaC_void litaC_array__ArrayGrow_cb__ptr_Allocation_ce_(litaC_array__Array_cb__ptr_Allocation_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_mem__Allocation* litaC_array__Array_removeAt_cb__ptr_Allocation_ce_(litaC_array__Array_cb__ptr_Allocation_ce_* litaC_a,litaC_i32 litaC_index);
litaC_array__Array_cb_Option_ce_ litaC_array__ArrayInit_cb_Option_ce_(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_init_cb_Option_ce_(litaC_array__Array_cb_Option_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_array__Array_cb__ptr_const_char_ce_ litaC_array__ArrayInit_cb__ptr_const_char_ce_(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_init_cb__ptr_const_char_ce_(litaC_array__Array_cb__ptr_const_char_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_free_cb_Option_ce_(litaC_array__Array_cb_Option_ce_* litaC_a);
litaC_void litaC_array__Array_free_cb__ptr_const_char_ce_(litaC_array__Array_cb__ptr_const_char_ce_* litaC_a);
litaC_void litaC_array__Array_add_cb_Option_ce_(litaC_array__Array_cb_Option_ce_* litaC_a,litaC_cmdline__Option litaC_element);
litaC_void litaC_array__ArrayGrow_cb_Option_ce_(litaC_array__Array_cb_Option_ce_* litaC_a,litaC_i32 litaC_increment);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_Option_ce_(litaC_array__Array_cb_Option_ce_* litaC_a);
litaC_void litaC_array__Array_add_cb__ptr_const_char_ce_(litaC_array__Array_cb__ptr_const_char_ce_* litaC_a,const litaC_char* litaC_element);
litaC_void litaC_array__ArrayGrow_cb__ptr_const_char_ce_(litaC_array__Array_cb__ptr_const_char_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_array__Array_cb__ptr_TypeInfo_ce_ litaC_array__ArrayInit_cb__ptr_TypeInfo_ce_(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_init_cb__ptr_TypeInfo_ce_(litaC_array__Array_cb__ptr_TypeInfo_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_TypeInfo_ce_(litaC_array__Array_cb__ptr_TypeInfo_ce_* litaC_a);
litaC_void litaC_array__Array_add_cb__ptr_TypeInfo_ce_(litaC_array__Array_cb__ptr_TypeInfo_ce_* litaC_a,litaC_types__TypeInfo* litaC_element);
litaC_void litaC_array__ArrayGrow_cb__ptr_TypeInfo_ce_(litaC_array__Array_cb__ptr_TypeInfo_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_types__TypeInfo* litaC_array__Array_get_cb__ptr_TypeInfo_ce_(litaC_array__Array_cb__ptr_TypeInfo_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb_GenericParam_ce_(litaC_array__Array_cb_GenericParam_ce_* litaC_a);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_GenericParam_ce_(litaC_array__Array_cb_GenericParam_ce_* litaC_a);
litaC_ast__GenericParam litaC_array__Array_get_cb_GenericParam_ce_(litaC_array__Array_cb_GenericParam_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(litaC_array__Array_cb__ptr_ParameterDecl_ce_* litaC_a);
litaC_ast__ParameterDecl* litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(litaC_array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb_FieldStmt_ce_(litaC_array__Array_cb_FieldStmt_ce_* litaC_a);
litaC_void litaC_array__Array_init_cb__ptr_TypeSpec_ce_(litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_add_cb__ptr_TypeSpec_ce_(litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_a,litaC_ast__TypeSpec* litaC_element);
litaC_void litaC_array__ArrayGrow_cb__ptr_TypeSpec_ce_(litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_array__Array_cb_GenericParam_ce_ litaC_array__ArrayInit_cb_GenericParam_ce_(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_init_cb_GenericParam_ce_(litaC_array__Array_cb_GenericParam_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_addAll_cb_GenericParam_ce_(litaC_array__Array_cb_GenericParam_ce_* litaC_a,litaC_array__Array_cb_GenericParam_ce_* litaC_other);
litaC_void litaC_array__ArrayGrow_cb_GenericParam_ce_(litaC_array__Array_cb_GenericParam_ce_* litaC_a,litaC_i32 litaC_increment);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(litaC_array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_a);
litaC_ast__EnumFieldEntryDecl* litaC_array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(litaC_array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_FieldStmt_ce_(litaC_array__Array_cb_FieldStmt_ce_* litaC_a);
litaC_ast__FieldStmt litaC_array__Array_get_cb_FieldStmt_ce_(litaC_array__Array_cb_FieldStmt_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb__ptr_ParameterDecl_ce_(litaC_array__Array_cb__ptr_ParameterDecl_ce_* litaC_a);
litaC_ast__ParameterDecl* litaC_array__Array_first_cb__ptr_ParameterDecl_ce_(litaC_array__Array_cb__ptr_ParameterDecl_ce_* litaC_a);
litaC_ast__NameTypeSpec* litaC_mem__new_cb_NameTypeSpec_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__TypeSpec* litaC_mem__new_cb_TypeSpec_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__ArrayTypeSpec* litaC_mem__new_cb_ArrayTypeSpec_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__PtrTypeSpec* litaC_mem__new_cb_PtrTypeSpec_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__ConstTypeSpec* litaC_mem__new_cb_ConstTypeSpec_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__FuncPtrTypeSpec* litaC_mem__new_cb_FuncPtrTypeSpec_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__ImportDecl* litaC_mem__new_cb_ImportDecl_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__VarDecl* litaC_mem__new_cb_VarDecl_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__FuncDecl* litaC_mem__new_cb_FuncDecl_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__ParametersStmt* litaC_ast__Node_becomeParentOf_cb_ParametersStmt_ce_(litaC_ast__Node* litaC_n,litaC_ast__ParametersStmt* litaC_child);
litaC_ast__Stmt* litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(litaC_ast__Node* litaC_n,litaC_ast__Stmt* litaC_child);
litaC_ast__AggregateDecl* litaC_mem__new_cb_AggregateDecl_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__EnumDecl* litaC_ast__Node_becomeParentOf_cb_EnumDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__EnumDecl* litaC_child);
litaC_ast__AggregateDecl* litaC_ast__Node_becomeParentOf_cb_AggregateDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__AggregateDecl* litaC_child);
litaC_ast__TraitFieldDecl* litaC_ast__Node_becomeParentOf_cb_TraitFieldDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__TraitFieldDecl* litaC_child);
litaC_ast__VarFieldDecl* litaC_ast__Node_becomeParentOf_cb_VarFieldDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__VarFieldDecl* litaC_child);
litaC_ast__Expr* litaC_ast__Node_becomeParentOf_cb_Expr_ce_(litaC_ast__Node* litaC_n,litaC_ast__Expr* litaC_child);
litaC_ast__EnumDecl* litaC_mem__new_cb_EnumDecl_ce_(const litaC_mem__Allocator* litaC_a);
litaC_array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_EnumFieldEntryDecl_ce_(litaC_ast__Node* litaC_n,litaC_array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_children);
litaC_ast__EnumFieldEntryDecl* litaC_ast__Node_becomeParentOf_cb_EnumFieldEntryDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__EnumFieldEntryDecl* litaC_child);
litaC_ast__TypedefDecl* litaC_mem__new_cb_TypedefDecl_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__ParameterDecl* litaC_mem__new_cb_ParameterDecl_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__NotesDecl* litaC_mem__new_cb_NotesDecl_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__NativeDecl* litaC_mem__new_cb_NativeDecl_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__PoisonDecl* litaC_mem__new_cb_PoisonDecl_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__TernaryExpr* litaC_mem__new_cb_TernaryExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__BinaryExpr* litaC_mem__new_cb_BinaryExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__UnaryExpr* litaC_mem__new_cb_UnaryExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__InitExpr* litaC_mem__new_cb_InitExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_array__Array_cb__ptr_InitArgExpr_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_InitArgExpr_ce_(litaC_ast__Node* litaC_n,litaC_array__Array_cb__ptr_InitArgExpr_ce_* litaC_children);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_InitArgExpr_ce_(litaC_array__Array_cb__ptr_InitArgExpr_ce_* litaC_a);
litaC_ast__InitArgExpr* litaC_array__Array_get_cb__ptr_InitArgExpr_ce_(litaC_array__Array_cb__ptr_InitArgExpr_ce_* litaC_a,litaC_i32 litaC_index);
litaC_ast__InitArgExpr* litaC_ast__Node_becomeParentOf_cb_InitArgExpr_ce_(litaC_ast__Node* litaC_n,litaC_ast__InitArgExpr* litaC_child);
litaC_ast__FuncCallExpr* litaC_mem__new_cb_FuncCallExpr_ce_(const litaC_mem__Allocator* litaC_a);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_a);
litaC_ast__CallArg litaC_array__Array_get_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_index);
litaC_ast__SubscriptGetExpr* litaC_mem__new_cb_SubscriptGetExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__SubscriptSetExpr* litaC_mem__new_cb_SubscriptSetExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__GetExpr* litaC_mem__new_cb_GetExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__IdentifierExpr* litaC_ast__Node_becomeParentOf_cb_IdentifierExpr_ce_(litaC_ast__Node* litaC_n,litaC_ast__IdentifierExpr* litaC_child);
litaC_ast__SetExpr* litaC_mem__new_cb_SetExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__IdentifierExpr* litaC_mem__new_cb_IdentifierExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__TypeIdentifierExpr* litaC_mem__new_cb_TypeIdentifierExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__CastExpr* litaC_mem__new_cb_CastExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__ArrayDesignationExpr* litaC_mem__new_cb_ArrayDesignationExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__InitArgExpr* litaC_mem__new_cb_InitArgExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__BooleanExpr* litaC_mem__new_cb_BooleanExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__NullExpr* litaC_mem__new_cb_NullExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__NumberExpr* litaC_mem__new_cb_NumberExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__StringExpr* litaC_mem__new_cb_StringExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__CharExpr* litaC_mem__new_cb_CharExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__GroupExpr* litaC_mem__new_cb_GroupExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__ArrayInitExpr* litaC_mem__new_cb_ArrayInitExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_array__Array_cb__ptr_Expr_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_Expr_ce_(litaC_ast__Node* litaC_n,litaC_array__Array_cb__ptr_Expr_ce_* litaC_children);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_Expr_ce_(litaC_array__Array_cb__ptr_Expr_ce_* litaC_a);
litaC_ast__Expr* litaC_array__Array_get_cb__ptr_Expr_ce_(litaC_array__Array_cb__ptr_Expr_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb__ptr_Expr_ce_(litaC_array__Array_cb__ptr_Expr_ce_* litaC_a);
litaC_ast__SizeOfExpr* litaC_mem__new_cb_SizeOfExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__TypeOfExpr* litaC_mem__new_cb_TypeOfExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__OffsetOfExpr* litaC_mem__new_cb_OffsetOfExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__PoisonExpr* litaC_mem__new_cb_PoisonExpr_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__ModuleStmt* litaC_mem__new_cb_ModuleStmt_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__CompStmt* litaC_mem__new_cb_CompStmt_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__BlockStmt* litaC_mem__new_cb_BlockStmt_ce_(const litaC_mem__Allocator* litaC_a);
litaC_array__Array_cb__ptr_Stmt_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_Stmt_ce_(litaC_ast__Node* litaC_n,litaC_array__Array_cb__ptr_Stmt_ce_* litaC_children);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_Stmt_ce_(litaC_array__Array_cb__ptr_Stmt_ce_* litaC_a);
litaC_ast__Stmt* litaC_array__Array_get_cb__ptr_Stmt_ce_(litaC_array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_i32 litaC_index);
litaC_ast__IfStmt* litaC_mem__new_cb_IfStmt_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__WhileStmt* litaC_mem__new_cb_WhileStmt_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__DoWhileStmt* litaC_mem__new_cb_DoWhileStmt_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__ForStmt* litaC_mem__new_cb_ForStmt_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__SwitchCaseStmt* litaC_mem__new_cb_SwitchCaseStmt_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__SwitchStmt* litaC_mem__new_cb_SwitchStmt_ce_(const litaC_mem__Allocator* litaC_a);
litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_SwitchCaseStmt_ce_(litaC_ast__Node* litaC_n,litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_children);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_SwitchCaseStmt_ce_(litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a);
litaC_ast__SwitchCaseStmt* litaC_array__Array_get_cb__ptr_SwitchCaseStmt_ce_(litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a,litaC_i32 litaC_index);
litaC_ast__SwitchCaseStmt* litaC_ast__Node_becomeParentOf_cb_SwitchCaseStmt_ce_(litaC_ast__Node* litaC_n,litaC_ast__SwitchCaseStmt* litaC_child);
litaC_ast__BreakStmt* litaC_mem__new_cb_BreakStmt_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__ContinueStmt* litaC_mem__new_cb_ContinueStmt_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__ReturnStmt* litaC_mem__new_cb_ReturnStmt_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__DeferStmt* litaC_mem__new_cb_DeferStmt_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__GotoStmt* litaC_mem__new_cb_GotoStmt_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__LabelStmt* litaC_mem__new_cb_LabelStmt_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__NoteStmt* litaC_mem__new_cb_NoteStmt_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__EmptyStmt* litaC_mem__new_cb_EmptyStmt_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__ParametersStmt* litaC_mem__new_cb_ParametersStmt_ce_(const litaC_mem__Allocator* litaC_a);
litaC_array__Array_cb__ptr_ParameterDecl_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_ParameterDecl_ce_(litaC_ast__Node* litaC_n,litaC_array__Array_cb__ptr_ParameterDecl_ce_* litaC_children);
litaC_ast__ParameterDecl* litaC_ast__Node_becomeParentOf_cb_ParameterDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__ParameterDecl* litaC_child);
litaC_ast__VarFieldDecl* litaC_mem__new_cb_VarFieldDecl_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__TraitFieldDecl* litaC_mem__new_cb_TraitFieldDecl_ce_(const litaC_mem__Allocator* litaC_a);
litaC_ast__EnumFieldEntryDecl* litaC_mem__new_cb_EnumFieldEntryDecl_ce_(const litaC_mem__Allocator* litaC_a);
LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb__ptr_NoteStmt_ce_(litaC_array__Array_cb__ptr_NoteStmt_ce_* litaC_a);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_NoteStmt_ce_(litaC_array__Array_cb__ptr_NoteStmt_ce_* litaC_a);
litaC_ast__NoteStmt* litaC_array__Array_get_cb__ptr_NoteStmt_ce_(litaC_array__Array_cb__ptr_NoteStmt_ce_* litaC_a,litaC_i32 litaC_index);
litaC_symbols__Scope* litaC_mem__new_cb_Scope_ce_(const litaC_mem__Allocator* litaC_a);
litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_ litaC_map__StrMap_cb__ptr_Symbol_ce_(litaC_symbols__Symbol* litaC_emptyValue,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_map__Map_init_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_* litaC_m,litaC_symbols__Symbol* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(const litaC_char*),litaC_bool (*litaC_equalFn)(const litaC_char*,const litaC_char*),const litaC_mem__Allocator* litaC_alloc,const litaC_char* litaC_emptyKey);
litaC_void litaC_map__MapGrow_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_* litaC_m,litaC_i32 litaC_newlength);
litaC_void litaC_map__Map_put_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_* litaC_m,const litaC_char* litaC_key,litaC_symbols__Symbol* litaC_value);
litaC_void litaC_map__Map_free_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_* litaC_m);
litaC_symbols__Symbol* litaC_map__Map_get_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_* litaC_m,const litaC_char* litaC_key);
litaC_bool litaC_map__Map_contains_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_* litaC_m,const litaC_char* litaC_key);
litaC_symbols__Symbol* litaC_mem__new_cb_Symbol_ce_(const litaC_mem__Allocator* litaC_a);
litaC_void litaC_array__Array_init_cb_ModuleImport_ce_(litaC_array__Array_cb_ModuleImport_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_module__Module* litaC_mem__new_cb_Module_ce_(const litaC_mem__Allocator* litaC_a);
litaC_map__MapIterator_cb__ptr_const_char_c__ptr_Symbol_ce_ litaC_map__Map_iter_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_* litaC_m);
litaC_bool litaC_map__MapIterator_hasNext_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_map__MapIterator_cb__ptr_const_char_c__ptr_Symbol_ce_* litaC_iter);
litaC_map__MapEntry_cb__ptr_const_char_c__ptr_Symbol_ce_ litaC_map__MapIterator_next_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_map__MapIterator_cb__ptr_const_char_c__ptr_Symbol_ce_* litaC_iter);
litaC_void litaC_array__Array_add_cb_ModuleImport_ce_(litaC_array__Array_cb_ModuleImport_ce_* litaC_a,litaC_module__ModuleImport litaC_element);
litaC_void litaC_array__ArrayGrow_cb_ModuleImport_ce_(litaC_array__Array_cb_ModuleImport_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_void litaC_array__Array_init_cb_PhaseError_ce_(litaC_array__Array_cb_PhaseError_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_add_cb_PhaseError_ce_(litaC_array__Array_cb_PhaseError_ce_* litaC_a,litaC_phase_result__PhaseError litaC_element);
litaC_void litaC_array__ArrayGrow_cb_PhaseError_ce_(litaC_array__Array_cb_PhaseError_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_map__Map_cb__ptr_const_char_c__ptr_Module_ce_ litaC_map__StrMap_cb__ptr_Module_ce_(litaC_module__Module* litaC_emptyValue,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_map__Map_init_cb__ptr_const_char_c__ptr_Module_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m,litaC_module__Module* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(const litaC_char*),litaC_bool (*litaC_equalFn)(const litaC_char*,const litaC_char*),const litaC_mem__Allocator* litaC_alloc,const litaC_char* litaC_emptyKey);
litaC_void litaC_map__MapGrow_cb__ptr_const_char_c__ptr_Module_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m,litaC_i32 litaC_newlength);
litaC_void litaC_map__Map_put_cb__ptr_const_char_c__ptr_Module_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m,const litaC_char* litaC_key,litaC_module__Module* litaC_value);
litaC_void litaC_map__Map_free_cb__ptr_const_char_c__ptr_Module_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m);
litaC_void litaC_array__Array_add_cb__ptr_ImportDecl_ce_(litaC_array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_ast__ImportDecl* litaC_element);
litaC_void litaC_array__ArrayGrow_cb__ptr_ImportDecl_ce_(litaC_array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_i32 litaC_increment);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_ImportDecl_ce_(litaC_array__Array_cb__ptr_ImportDecl_ce_* litaC_a);
litaC_ast__ImportDecl* litaC_array__Array_get_cb__ptr_ImportDecl_ce_(litaC_array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_i32 litaC_index);
litaC_module__Module* litaC_map__Map_get_cb__ptr_const_char_c__ptr_Module_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m,const litaC_char* litaC_key);
litaC_void litaC_array__Array_init_cb__ptr_CompStmt_ce_(litaC_array__Array_cb__ptr_CompStmt_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_add_cb__ptr_CompStmt_ce_(litaC_array__Array_cb__ptr_CompStmt_ce_* litaC_a,litaC_ast__CompStmt* litaC_element);
litaC_void litaC_array__ArrayGrow_cb__ptr_CompStmt_ce_(litaC_array__Array_cb__ptr_CompStmt_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_void litaC_array__Array_add_cb__ptr_NoteStmt_ce_(litaC_array__Array_cb__ptr_NoteStmt_ce_* litaC_a,litaC_ast__NoteStmt* litaC_element);
litaC_void litaC_array__ArrayGrow_cb__ptr_NoteStmt_ce_(litaC_array__Array_cb__ptr_NoteStmt_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_void litaC_array__Array_addAll_cb__ptr_NoteStmt_ce_(litaC_array__Array_cb__ptr_NoteStmt_ce_* litaC_a,litaC_array__Array_cb__ptr_NoteStmt_ce_* litaC_other);
litaC_void litaC_array__Array_add_cb__ptr_Decl_ce_(litaC_array__Array_cb__ptr_Decl_ce_* litaC_a,litaC_ast__Decl* litaC_element);
litaC_void litaC_array__ArrayGrow_cb__ptr_Decl_ce_(litaC_array__Array_cb__ptr_Decl_ce_* litaC_a,litaC_i32 litaC_increment);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_CompStmt_ce_(litaC_array__Array_cb__ptr_CompStmt_ce_* litaC_a);
litaC_ast__CompStmt* litaC_array__Array_get_cb__ptr_CompStmt_ce_(litaC_array__Array_cb__ptr_CompStmt_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_Token_ce_(litaC_array__Array_cb_Token_ce_* litaC_a);
litaC_lex__Token litaC_array__Array_get_cb_Token_ce_(litaC_array__Array_cb_Token_ce_* litaC_a,litaC_i32 litaC_index);
litaC_void litaC_array__Array_addAll_cb__ptr_ImportDecl_ce_(litaC_array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_array__Array_cb__ptr_ImportDecl_ce_* litaC_other);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_Decl_ce_(litaC_array__Array_cb__ptr_Decl_ce_* litaC_a);
litaC_void litaC_array__Array_addAll_cb__ptr_Decl_ce_(litaC_array__Array_cb__ptr_Decl_ce_* litaC_a,litaC_array__Array_cb__ptr_Decl_ce_* litaC_other);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_Symbol_ce_(litaC_array__Array_cb__ptr_Symbol_ce_* litaC_a);
litaC_symbols__Symbol* litaC_array__Array_get_cb__ptr_Symbol_ce_(litaC_array__Array_cb__ptr_Symbol_ce_* litaC_a,litaC_i32 litaC_index);
litaC_ast__Decl* litaC_array__Array_get_cb__ptr_Decl_ce_(litaC_array__Array_cb__ptr_Decl_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_ModuleImport_ce_(litaC_array__Array_cb_ModuleImport_ce_* litaC_a);
litaC_module__ModuleImport litaC_array__Array_get_cb_ModuleImport_ce_(litaC_array__Array_cb_ModuleImport_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb__ptr_TypeSpec_ce_(litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_a);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_TypeSpec_ce_(litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_a);
litaC_ast__TypeSpec* litaC_array__Array_get_cb__ptr_TypeSpec_ce_(litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_a,litaC_i32 litaC_index);
litaC_void litaC_array__Array_add_cb_GenericParam_ce_(litaC_array__Array_cb_GenericParam_ce_* litaC_a,litaC_ast__GenericParam litaC_element);
LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_a);
litaC_array__Array_cb_CallArg_ce_ litaC_array__ArrayInit_cb_CallArg_ce_(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_init_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_add_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_a,litaC_ast__CallArg litaC_element);
litaC_void litaC_array__ArrayGrow_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_array__Array_cb__ptr_Expr_ce_ litaC_array__ArrayInit_cb__ptr_Expr_ce_(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_init_cb__ptr_Expr_ce_(litaC_array__Array_cb__ptr_Expr_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_add_cb__ptr_Expr_ce_(litaC_array__Array_cb__ptr_Expr_ce_* litaC_a,litaC_ast__Expr* litaC_element);
litaC_void litaC_array__ArrayGrow_cb__ptr_Expr_ce_(litaC_array__Array_cb__ptr_Expr_ce_* litaC_a,litaC_i32 litaC_increment);
LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb__ptr_Stmt_ce_(litaC_array__Array_cb__ptr_Stmt_ce_* litaC_a);
litaC_array__Array_cb__ptr_Stmt_ce_ litaC_array__ArrayInit_cb__ptr_Stmt_ce_(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_init_cb__ptr_Stmt_ce_(litaC_array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_add_cb__ptr_Stmt_ce_(litaC_array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_ast__Stmt* litaC_element);
litaC_void litaC_array__ArrayGrow_cb__ptr_Stmt_ce_(litaC_array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_i32 litaC_increment);
LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb__ptr_InitArgExpr_ce_(litaC_array__Array_cb__ptr_InitArgExpr_ce_* litaC_a);
litaC_void litaC_array__Array_init_cb__ptr_InitArgExpr_ce_(litaC_array__Array_cb__ptr_InitArgExpr_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_add_cb__ptr_InitArgExpr_ce_(litaC_array__Array_cb__ptr_InitArgExpr_ce_* litaC_a,litaC_ast__InitArgExpr* litaC_element);
litaC_void litaC_array__ArrayGrow_cb__ptr_InitArgExpr_ce_(litaC_array__Array_cb__ptr_InitArgExpr_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_void litaC_array__Array_init_cb__ptr_ParameterDecl_ce_(litaC_array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_add_cb__ptr_ParameterDecl_ce_(litaC_array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_ast__ParameterDecl* litaC_element);
litaC_void litaC_array__ArrayGrow_cb__ptr_ParameterDecl_ce_(litaC_array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_i32 litaC_increment);
LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb__ptr_SwitchCaseStmt_ce_(litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a);
litaC_void litaC_array__Array_init_cb__ptr_SwitchCaseStmt_ce_(litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_add_cb__ptr_SwitchCaseStmt_ce_(litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a,litaC_ast__SwitchCaseStmt* litaC_element);
litaC_void litaC_array__ArrayGrow_cb__ptr_SwitchCaseStmt_ce_(litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_array__Array_cb_GenericParam_ce_ litaC_array__Array_copy_cb_GenericParam_ce_(litaC_array__Array_cb_GenericParam_ce_* litaC_a,const litaC_mem__Allocator* litaC_allocator);
litaC_array__Array_cb_FieldStmt_ce_ litaC_array__ArrayInit_cb_FieldStmt_ce_(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_init_cb_FieldStmt_ce_(litaC_array__Array_cb_FieldStmt_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_add_cb_FieldStmt_ce_(litaC_array__Array_cb_FieldStmt_ce_* litaC_a,litaC_ast__FieldStmt litaC_element);
litaC_void litaC_array__ArrayGrow_cb_FieldStmt_ce_(litaC_array__Array_cb_FieldStmt_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_void litaC_array__Array_insertAt_cb__ptr_Stmt_ce_(litaC_array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__Stmt* litaC_element);
litaC_void litaC_array__Array_set_cb__ptr_Stmt_ce_(litaC_array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__Stmt* litaC_element);
litaC_void litaC_array__Array_init_cb__ptr_Module_ce_(litaC_array__Array_cb__ptr_Module_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_init_cb__ptr_FuncTypeInfo_ce_(litaC_array__Array_cb__ptr_FuncTypeInfo_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_init_cb__ptr_Symbol_ce_(litaC_array__Array_cb__ptr_Symbol_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_init_cb_Array_cb_GenericParam_ce__ce_(litaC_array__Array_cb_Array_cb_GenericParam_ce__ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_u32 litaC_map__PtrHashFn_cb_i64_ce_(litaC_i64 litaC_a);
litaC_bool litaC_map__PtrEqualFn_cb_i64_ce_(litaC_i64 litaC_a,litaC_i64 litaC_b);
litaC_void litaC_map__Map_init_cb_i64_c_Array_cb_i64_ce__ce_(litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m,litaC_array__Array_cb_i64_ce_ litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_i64),litaC_bool (*litaC_equalFn)(litaC_i64,litaC_i64),const litaC_mem__Allocator* litaC_alloc,litaC_i64 litaC_emptyKey);
litaC_void litaC_map__MapGrow_cb_i64_c_Array_cb_i64_ce__ce_(litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m,litaC_i32 litaC_newlength);
litaC_void litaC_map__Map_put_cb_i64_c_Array_cb_i64_ce__ce_(litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m,litaC_i64 litaC_key,litaC_array__Array_cb_i64_ce_ litaC_value);
litaC_void litaC_map__Map_free_cb_i64_c_Array_cb_i64_ce__ce_(litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m);
litaC_void litaC_array__Array_push_cb__ptr_Module_ce_(litaC_array__Array_cb__ptr_Module_ce_* litaC_a,litaC_module__Module* litaC_element);
litaC_void litaC_array__Array_add_cb__ptr_Module_ce_(litaC_array__Array_cb__ptr_Module_ce_* litaC_a,litaC_module__Module* litaC_element);
litaC_void litaC_array__ArrayGrow_cb__ptr_Module_ce_(litaC_array__Array_cb__ptr_Module_ce_* litaC_a,litaC_i32 litaC_increment);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_Module_ce_(litaC_array__Array_cb__ptr_Module_ce_* litaC_a);
litaC_module__Module* litaC_array__Array_pop_cb__ptr_Module_ce_(litaC_array__Array_cb__ptr_Module_ce_* litaC_a);
litaC_module__Module* litaC_array__Array_last_cb__ptr_Module_ce_(litaC_array__Array_cb__ptr_Module_ce_* litaC_a);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_Array_cb_GenericParam_ce__ce_(litaC_array__Array_cb_Array_cb_GenericParam_ce__ce_* litaC_a);
litaC_void litaC_array__Array_add_cb__ptr_Symbol_ce_(litaC_array__Array_cb__ptr_Symbol_ce_* litaC_a,litaC_symbols__Symbol* litaC_element);
litaC_void litaC_array__ArrayGrow_cb__ptr_Symbol_ce_(litaC_array__Array_cb__ptr_Symbol_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_void litaC_array__Array_add_cb_Array_cb_GenericParam_ce__ce_(litaC_array__Array_cb_Array_cb_GenericParam_ce__ce_* litaC_a,litaC_array__Array_cb_GenericParam_ce_ litaC_element);
litaC_void litaC_array__ArrayGrow_cb_Array_cb_GenericParam_ce__ce_(litaC_array__Array_cb_Array_cb_GenericParam_ce__ce_* litaC_a,litaC_i32 litaC_increment);
litaC_array__Array_cb_GenericParam_ce_ litaC_array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(litaC_array__Array_cb_Array_cb_GenericParam_ce__ce_* litaC_a);
litaC_bool litaC_map__Map_contains_cb_i64_c_Array_cb_i64_ce__ce_(litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m,litaC_i64 litaC_key);
litaC_array__Array_cb_i64_ce_* litaC_map__Map_getPtr_cb_i64_c_Array_cb_i64_ce__ce_(litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m,litaC_i64 litaC_key);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_i64_ce_(litaC_array__Array_cb_i64_ce_* litaC_a);
litaC_i64 litaC_array__Array_get_cb_i64_ce_(litaC_array__Array_cb_i64_ce_* litaC_a,litaC_i32 litaC_index);
litaC_array__Array_cb_i64_ce_ litaC_array__ArrayInit_cb_i64_ce_(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_init_cb_i64_ce_(litaC_array__Array_cb_i64_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_add_cb_i64_ce_(litaC_array__Array_cb_i64_ce_* litaC_a,litaC_i64 litaC_element);
litaC_void litaC_array__ArrayGrow_cb_i64_ce_(litaC_array__Array_cb_i64_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_types__FuncTypeInfo* litaC_array__Array_last_cb__ptr_FuncTypeInfo_ce_(litaC_array__Array_cb__ptr_FuncTypeInfo_ce_* litaC_a);
litaC_void litaC_map__Map_init_cb_i64_c__ptr_ConstTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_ConstTypeInfo_ce_* litaC_m,litaC_types__ConstTypeInfo* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_i64),litaC_bool (*litaC_equalFn)(litaC_i64,litaC_i64),const litaC_mem__Allocator* litaC_alloc,litaC_i64 litaC_emptyKey);
litaC_void litaC_map__MapGrow_cb_i64_c__ptr_ConstTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_ConstTypeInfo_ce_* litaC_m,litaC_i32 litaC_newlength);
litaC_void litaC_map__Map_put_cb_i64_c__ptr_ConstTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_ConstTypeInfo_ce_* litaC_m,litaC_i64 litaC_key,litaC_types__ConstTypeInfo* litaC_value);
litaC_void litaC_map__Map_free_cb_i64_c__ptr_ConstTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_ConstTypeInfo_ce_* litaC_m);
litaC_void litaC_map__Map_init_cb_i64_c__ptr_PtrTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_PtrTypeInfo_ce_* litaC_m,litaC_types__PtrTypeInfo* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_i64),litaC_bool (*litaC_equalFn)(litaC_i64,litaC_i64),const litaC_mem__Allocator* litaC_alloc,litaC_i64 litaC_emptyKey);
litaC_void litaC_map__MapGrow_cb_i64_c__ptr_PtrTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_PtrTypeInfo_ce_* litaC_m,litaC_i32 litaC_newlength);
litaC_void litaC_map__Map_put_cb_i64_c__ptr_PtrTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_PtrTypeInfo_ce_* litaC_m,litaC_i64 litaC_key,litaC_types__PtrTypeInfo* litaC_value);
litaC_void litaC_map__Map_free_cb_i64_c__ptr_PtrTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_PtrTypeInfo_ce_* litaC_m);
litaC_void litaC_map__Map_init_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(litaC_map__Map_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_* litaC_m,litaC_types__ArrayTypeInfo* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_types_new__ArrayEntry),litaC_bool (*litaC_equalFn)(litaC_types_new__ArrayEntry,litaC_types_new__ArrayEntry),const litaC_mem__Allocator* litaC_alloc,litaC_types_new__ArrayEntry litaC_emptyKey);
litaC_void litaC_map__MapGrow_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(litaC_map__Map_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_* litaC_m,litaC_i32 litaC_newlength);
litaC_void litaC_map__Map_put_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(litaC_map__Map_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_* litaC_m,litaC_types_new__ArrayEntry litaC_key,litaC_types__ArrayTypeInfo* litaC_value);
litaC_void litaC_map__Map_free_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(litaC_map__Map_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_* litaC_m);
litaC_void litaC_map__Map_init_cb__ptr_const_char_c__ptr_TypeInfo_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TypeInfo_ce_* litaC_m,litaC_types__TypeInfo* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(const litaC_char*),litaC_bool (*litaC_equalFn)(const litaC_char*,const litaC_char*),const litaC_mem__Allocator* litaC_alloc,const litaC_char* litaC_emptyKey);
litaC_void litaC_map__MapGrow_cb__ptr_const_char_c__ptr_TypeInfo_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TypeInfo_ce_* litaC_m,litaC_i32 litaC_newlength);
litaC_void litaC_map__Map_put_cb__ptr_const_char_c__ptr_TypeInfo_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TypeInfo_ce_* litaC_m,const litaC_char* litaC_key,litaC_types__TypeInfo* litaC_value);
litaC_void litaC_map__Map_free_cb__ptr_const_char_c__ptr_TypeInfo_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TypeInfo_ce_* litaC_m);
litaC_types__TypeInfo* litaC_map__Map_get_cb__ptr_const_char_c__ptr_TypeInfo_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TypeInfo_ce_* litaC_m,const litaC_char* litaC_key);
litaC_types__TypeInfo* litaC_mem__new_cb_TypeInfo_ce_(const litaC_mem__Allocator* litaC_a);
litaC_types__FuncTypeInfo* litaC_mem__new_cb_FuncTypeInfo_ce_(const litaC_mem__Allocator* litaC_a);
litaC_types__ArrayTypeInfo* litaC_map__Map_get_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(litaC_map__Map_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_* litaC_m,litaC_types_new__ArrayEntry litaC_key);
litaC_types__ArrayTypeInfo* litaC_mem__new_cb_ArrayTypeInfo_ce_(const litaC_mem__Allocator* litaC_a);
litaC_types__FuncPtrTypeInfo* litaC_mem__new_cb_FuncPtrTypeInfo_ce_(const litaC_mem__Allocator* litaC_a);
litaC_types__AggregateTypeInfo* litaC_mem__new_cb_AggregateTypeInfo_ce_(const litaC_mem__Allocator* litaC_a);
litaC_types__EnumTypeInfo* litaC_mem__new_cb_EnumTypeInfo_ce_(const litaC_mem__Allocator* litaC_a);
litaC_types__ConstTypeInfo* litaC_map__Map_get_cb_i64_c__ptr_ConstTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_ConstTypeInfo_ce_* litaC_m,litaC_i64 litaC_key);
litaC_types__ConstTypeInfo* litaC_mem__new_cb_ConstTypeInfo_ce_(const litaC_mem__Allocator* litaC_a);
litaC_types__PtrTypeInfo* litaC_map__Map_get_cb_i64_c__ptr_PtrTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_PtrTypeInfo_ce_* litaC_m,litaC_i64 litaC_key);
litaC_types__PtrTypeInfo* litaC_mem__new_cb_PtrTypeInfo_ce_(const litaC_mem__Allocator* litaC_a);
LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb_Token_ce_(litaC_array__Array_cb_Token_ce_* litaC_a);
litaC_ast__GenericParam litaC_array__Array_removeAt_cb_GenericParam_ce_(litaC_array__Array_cb_GenericParam_ce_* litaC_a,litaC_i32 litaC_index);
litaC_void litaC_array__Array_set_cb__ptr_TypeSpec_ce_(litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__TypeSpec* litaC_element);
litaC_map__MapIterator_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_ litaC_map__Map_iter_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(litaC_map__Map_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_* litaC_m);
litaC_bool litaC_map__MapIterator_hasNext_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(litaC_map__MapIterator_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_* litaC_iter);
litaC_map__MapEntry_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_ litaC_map__MapIterator_next_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(litaC_map__MapIterator_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_* litaC_iter);
litaC_map__MapIterator_cb_i64_c__ptr_PtrTypeInfo_ce_ litaC_map__Map_iter_cb_i64_c__ptr_PtrTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_PtrTypeInfo_ce_* litaC_m);
litaC_bool litaC_map__MapIterator_hasNext_cb_i64_c__ptr_PtrTypeInfo_ce_(litaC_map__MapIterator_cb_i64_c__ptr_PtrTypeInfo_ce_* litaC_iter);
litaC_map__MapEntry_cb_i64_c__ptr_PtrTypeInfo_ce_ litaC_map__MapIterator_next_cb_i64_c__ptr_PtrTypeInfo_ce_(litaC_map__MapIterator_cb_i64_c__ptr_PtrTypeInfo_ce_* litaC_iter);
litaC_map__MapIterator_cb_i64_c__ptr_ConstTypeInfo_ce_ litaC_map__Map_iter_cb_i64_c__ptr_ConstTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_ConstTypeInfo_ce_* litaC_m);
litaC_bool litaC_map__MapIterator_hasNext_cb_i64_c__ptr_ConstTypeInfo_ce_(litaC_map__MapIterator_cb_i64_c__ptr_ConstTypeInfo_ce_* litaC_iter);
litaC_map__MapEntry_cb_i64_c__ptr_ConstTypeInfo_ce_ litaC_map__MapIterator_next_cb_i64_c__ptr_ConstTypeInfo_ce_(litaC_map__MapIterator_cb_i64_c__ptr_ConstTypeInfo_ce_* litaC_iter);
litaC_void litaC_array__Array_add_cb__ptr_FuncTypeInfo_ce_(litaC_array__Array_cb__ptr_FuncTypeInfo_ce_* litaC_a,litaC_types__FuncTypeInfo* litaC_element);
litaC_void litaC_array__ArrayGrow_cb__ptr_FuncTypeInfo_ce_(litaC_array__Array_cb__ptr_FuncTypeInfo_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_types__FuncTypeInfo* litaC_array__Array_pop_cb__ptr_FuncTypeInfo_ce_(litaC_array__Array_cb__ptr_FuncTypeInfo_ce_* litaC_a);
litaC_void litaC_array__Array_insertAt_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__CallArg litaC_element);
litaC_void litaC_array__Array_set_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__CallArg litaC_element);
litaC_ast__CallArg* litaC_array__Array_getPtr_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_index);
litaC_void litaC_array__Array_addAll_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_a,litaC_array__Array_cb_CallArg_ce_* litaC_other);
litaC_void litaC_array__Array_sort_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 (*litaC_sorter)(litaC_ast__CallArg,litaC_ast__CallArg));
litaC_void litaC_array__QuickSort_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_array,litaC_i32 (*litaC_comp)(litaC_ast__CallArg,litaC_ast__CallArg));
litaC_void litaC_array__Array_init_cb_Token_ce_(litaC_array__Array_cb_Token_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_add_cb_Token_ce_(litaC_array__Array_cb_Token_ce_* litaC_a,litaC_lex__Token litaC_element);
litaC_void litaC_array__ArrayGrow_cb_Token_ce_(litaC_array__Array_cb_Token_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_void litaC_array__Array_init_cb__ptr_ImportDecl_ce_(litaC_array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_init_cb__ptr_NoteStmt_ce_(litaC_array__Array_cb__ptr_NoteStmt_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_init_cb__ptr_Decl_ce_(litaC_array__Array_cb__ptr_Decl_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_ast__Decl* litaC_array__Array_last_cb__ptr_Decl_ce_(litaC_array__Array_cb__ptr_Decl_ce_* litaC_a);
litaC_void litaC_array__Array_insertAt_cb__ptr_ParameterDecl_ce_(litaC_array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__ParameterDecl* litaC_element);
litaC_void litaC_array__Array_set_cb__ptr_ParameterDecl_ce_(litaC_array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__ParameterDecl* litaC_element);
litaC_void litaC_array__Array_init_cb__ptr_EnumFieldEntryDecl_ce_(litaC_array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_add_cb__ptr_EnumFieldEntryDecl_ce_(litaC_array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_a,litaC_ast__EnumFieldEntryDecl* litaC_element);
litaC_void litaC_array__ArrayGrow_cb__ptr_EnumFieldEntryDecl_ce_(litaC_array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_void litaC_array__Array_free_cb__ptr_TypeSpec_ce_(litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_a);
LITAC_INLINE 
litaC_void litaC_array__Array_clear_cb__ptr_TypeSpec_ce_(litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_a);
litaC_lex__Token litaC_array__Array_last_cb_Token_ce_(litaC_array__Array_cb_Token_ce_* litaC_a);
litaC_array__Array_cb__ptr_Decl_ce_ litaC_array__ArrayInit_cb__ptr_Decl_ce_(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
LITAC_INLINE 
litaC_i32 litaC_map__Map_size_cb_i64_c_Array_cb_i64_ce__ce_(litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m);
litaC_map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_ litaC_map__Map_iter_cb_i64_c_Array_cb_i64_ce__ce_(litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m);
litaC_bool litaC_map__MapIterator_hasNext_cb_i64_c_Array_cb_i64_ce__ce_(litaC_map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_* litaC_iter);
litaC_map__MapEntry_cb_i64_c_Array_cb_i64_ce__ce_ litaC_map__MapIterator_next_cb_i64_c_Array_cb_i64_ce__ce_(litaC_map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_* litaC_iter);
litaC_map__MapIterator_cb__ptr_const_char_c__ptr_Module_ce_ litaC_map__Map_iter_cb__ptr_const_char_c__ptr_Module_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m);
litaC_bool litaC_map__MapIterator_hasNext_cb__ptr_const_char_c__ptr_Module_ce_(litaC_map__MapIterator_cb__ptr_const_char_c__ptr_Module_ce_* litaC_iter);
litaC_map__MapEntry_cb__ptr_const_char_c__ptr_Module_ce_ litaC_map__MapIterator_next_cb__ptr_const_char_c__ptr_Module_ce_(litaC_map__MapIterator_cb__ptr_const_char_c__ptr_Module_ce_* litaC_iter);
litaC_u32 litaC_map__PtrHashFn_cb__ptr_Symbol_ce_(litaC_symbols__Symbol* litaC_a);
litaC_bool litaC_map__PtrEqualFn_cb__ptr_Symbol_ce_(litaC_symbols__Symbol* litaC_a,litaC_symbols__Symbol* litaC_b);
litaC_void litaC_map__Map_init_cb__ptr_Symbol_c_Dependency_ce_(litaC_map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m,litaC_dependency_graph__Dependency litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_symbols__Symbol*),litaC_bool (*litaC_equalFn)(litaC_symbols__Symbol*,litaC_symbols__Symbol*),const litaC_mem__Allocator* litaC_alloc,litaC_symbols__Symbol* litaC_emptyKey);
litaC_void litaC_map__MapGrow_cb__ptr_Symbol_c_Dependency_ce_(litaC_map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m,litaC_i32 litaC_newlength);
litaC_void litaC_map__Map_put_cb__ptr_Symbol_c_Dependency_ce_(litaC_map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m,litaC_symbols__Symbol* litaC_key,litaC_dependency_graph__Dependency litaC_value);
litaC_void litaC_map__Map_free_cb__ptr_Symbol_c_Dependency_ce_(litaC_map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m);
litaC_dependency_graph__Dependency* litaC_map__Map_getPtr_cb__ptr_Symbol_c_Dependency_ce_(litaC_map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m,litaC_symbols__Symbol* litaC_key);
litaC_void litaC_array__Array_add_cb__ptr_Dependency_ce_(litaC_array__Array_cb__ptr_Dependency_ce_* litaC_a,litaC_dependency_graph__Dependency* litaC_element);
litaC_void litaC_array__ArrayGrow_cb__ptr_Dependency_ce_(litaC_array__Array_cb__ptr_Dependency_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_void litaC_array__Array_init_cb__ptr_Dependency_ce_(litaC_array__Array_cb__ptr_Dependency_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_ litaC_map__Map_iter_cb__ptr_Symbol_c_Dependency_ce_(litaC_map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m);
litaC_bool litaC_map__MapIterator_hasNext_cb__ptr_Symbol_c_Dependency_ce_(litaC_map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_* litaC_iter);
litaC_map__MapEntry_cb__ptr_Symbol_c_Dependency_ce_ litaC_map__MapIterator_next_cb__ptr_Symbol_c_Dependency_ce_(litaC_map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_* litaC_iter);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_Dependency_ce_(litaC_array__Array_cb__ptr_Dependency_ce_* litaC_a);
litaC_dependency_graph__Dependency* litaC_array__Array_get_cb__ptr_Dependency_ce_(litaC_array__Array_cb__ptr_Dependency_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_i32 litaC_map__Map_size_cb__ptr_Symbol_c_Dependency_ce_(litaC_map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m);
LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb__ptr_Dependency_ce_(litaC_array__Array_cb__ptr_Dependency_ce_* litaC_a);
litaC_void litaC_array__Array_addAll_cb__ptr_Dependency_ce_(litaC_array__Array_cb__ptr_Dependency_ce_* litaC_a,litaC_array__Array_cb__ptr_Dependency_ce_* litaC_other);
LITAC_INLINE 
litaC_void litaC_array__Array_clear_cb__ptr_Symbol_ce_(litaC_array__Array_cb__ptr_Symbol_ce_* litaC_a);
litaC_void litaC_array__Array_addAll_cb__ptr_Symbol_ce_(litaC_array__Array_cb__ptr_Symbol_ce_* litaC_a,litaC_array__Array_cb__ptr_Symbol_ce_* litaC_other);
LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb__ptr_const_char_ce_(litaC_array__Array_cb__ptr_const_char_ce_* litaC_a);
litaC_void litaC_array__Array_init_cb_Reference_ce_(litaC_array__Array_cb_Reference_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_init_cb_FieldReference_ce_(litaC_array__Array_cb_FieldReference_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_u32 litaC_map__PtrHashFn_cb_usize_ce_(litaC_usize litaC_a);
litaC_bool litaC_map__PtrEqualFn_cb_usize_ce_(litaC_usize litaC_a,litaC_usize litaC_b);
litaC_void litaC_map__Map_init_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_array__Array_cb_SrcPos_ce_ litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_usize),litaC_bool (*litaC_equalFn)(litaC_usize,litaC_usize),const litaC_mem__Allocator* litaC_alloc,litaC_usize litaC_emptyKey);
litaC_void litaC_map__MapGrow_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_i32 litaC_newlength);
litaC_void litaC_map__Map_put_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_usize litaC_key,litaC_array__Array_cb_SrcPos_ce_ litaC_value);
litaC_void litaC_map__Map_free_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m);
litaC_bool litaC_map__Map_contains_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_usize litaC_key);
litaC_array__Array_cb_SrcPos_ce_ litaC_array__ArrayInit_cb_SrcPos_ce_(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_init_cb_SrcPos_ce_(litaC_array__Array_cb_SrcPos_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_array__Array_cb_SrcPos_ce_* litaC_map__Map_getPtr_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_usize litaC_key);
litaC_void litaC_array__Array_add_cb_SrcPos_ce_(litaC_array__Array_cb_SrcPos_ce_* litaC_a,litaC_lex__SrcPos litaC_element);
litaC_void litaC_array__ArrayGrow_cb_SrcPos_ce_(litaC_array__Array_cb_SrcPos_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_void litaC_array__Array_add_cb_Reference_ce_(litaC_array__Array_cb_Reference_ce_* litaC_a,litaC_references__Reference litaC_element);
litaC_void litaC_array__ArrayGrow_cb_Reference_ce_(litaC_array__Array_cb_Reference_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_void litaC_array__Array_add_cb_FieldReference_ce_(litaC_array__Array_cb_FieldReference_ce_* litaC_a,litaC_references__FieldReference litaC_element);
litaC_void litaC_array__ArrayGrow_cb_FieldReference_ce_(litaC_array__Array_cb_FieldReference_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_array__Array_cb_SrcPos_ce_ litaC_map__Map_get_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_usize litaC_key);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_Reference_ce_(litaC_array__Array_cb_Reference_ce_* litaC_a);
litaC_references__Reference* litaC_array__Array_getPtr_cb_Reference_ce_(litaC_array__Array_cb_Reference_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_FieldReference_ce_(litaC_array__Array_cb_FieldReference_ce_* litaC_a);
litaC_references__FieldReference* litaC_array__Array_getPtr_cb_FieldReference_ce_(litaC_array__Array_cb_FieldReference_ce_* litaC_a,litaC_i32 litaC_index);
litaC_json__JsonNode* litaC_mem__new_cb_JsonNode_ce_(const litaC_mem__Allocator* litaC_a);
litaC_array__Array_cb__ptr_JsonNode_ce_* litaC_mem__new_cb_Array_cb__ptr_JsonNode_ce__ce_(const litaC_mem__Allocator* litaC_a);
litaC_void litaC_array__Array_init_cb__ptr_JsonNode_ce_(litaC_array__Array_cb__ptr_JsonNode_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_json__JsonObject* litaC_mem__new_cb_JsonObject_ce_(const litaC_mem__Allocator* litaC_a);
litaC_void litaC_map__Map_init_cb__ptr_const_char_c_i32_ce_(litaC_map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m,litaC_i32 litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(const litaC_char*),litaC_bool (*litaC_equalFn)(const litaC_char*,const litaC_char*),const litaC_mem__Allocator* litaC_alloc,const litaC_char* litaC_emptyKey);
litaC_void litaC_map__MapGrow_cb__ptr_const_char_c_i32_ce_(litaC_map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m,litaC_i32 litaC_newlength);
litaC_void litaC_map__Map_put_cb__ptr_const_char_c_i32_ce_(litaC_map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m,const litaC_char* litaC_key,litaC_i32 litaC_value);
litaC_void litaC_map__Map_free_cb__ptr_const_char_c_i32_ce_(litaC_map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m);
litaC_void litaC_array__Array_init_cb_Entry_ce_(litaC_array__Array_cb_Entry_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_array__Array_add_cb_Entry_ce_(litaC_array__Array_cb_Entry_ce_* litaC_a,litaC_json__Entry litaC_element);
litaC_void litaC_array__ArrayGrow_cb_Entry_ce_(litaC_array__Array_cb_Entry_ce_* litaC_a,litaC_i32 litaC_increment);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_Entry_ce_(litaC_array__Array_cb_Entry_ce_* litaC_a);
litaC_bool litaC_map__Map_contains_cb__ptr_const_char_c_i32_ce_(litaC_map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m,const litaC_char* litaC_key);
litaC_i32 litaC_map__Map_get_cb__ptr_const_char_c_i32_ce_(litaC_map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m,const litaC_char* litaC_key);
litaC_json__Entry litaC_array__Array_get_cb_Entry_ce_(litaC_array__Array_cb_Entry_ce_* litaC_a,litaC_i32 litaC_index);
litaC_void litaC_array__Array_add_cb__ptr_JsonNode_ce_(litaC_array__Array_cb__ptr_JsonNode_ce_* litaC_a,litaC_json__JsonNode* litaC_element);
litaC_void litaC_array__ArrayGrow_cb__ptr_JsonNode_ce_(litaC_array__Array_cb__ptr_JsonNode_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_json__JsonNode* litaC_array__Array_get_cb__ptr_JsonNode_ce_(litaC_array__Array_cb__ptr_JsonNode_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_JsonNode_ce_(litaC_array__Array_cb__ptr_JsonNode_ce_* litaC_a);
LITAC_INLINE 
litaC_i32 litaC_map__Map_size_cb__ptr_const_char_c_i32_ce_(litaC_map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m);
litaC_void litaC_array__Array_free_cb__ptr_JsonNode_ce_(litaC_array__Array_cb__ptr_JsonNode_ce_* litaC_a);
litaC_void litaC_array__Array_free_cb_Entry_ce_(litaC_array__Array_cb_Entry_ce_* litaC_a);
litaC_map__Map_cb__ptr_const_char_c__ptr_TextDocument_ce_ litaC_map__StrMap_cb__ptr_TextDocument_ce_(litaC_workspace__TextDocument* litaC_emptyValue,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc);
litaC_void litaC_map__Map_init_cb__ptr_const_char_c__ptr_TextDocument_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TextDocument_ce_* litaC_m,litaC_workspace__TextDocument* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(const litaC_char*),litaC_bool (*litaC_equalFn)(const litaC_char*,const litaC_char*),const litaC_mem__Allocator* litaC_alloc,const litaC_char* litaC_emptyKey);
litaC_void litaC_map__MapGrow_cb__ptr_const_char_c__ptr_TextDocument_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TextDocument_ce_* litaC_m,litaC_i32 litaC_newlength);
litaC_void litaC_map__Map_put_cb__ptr_const_char_c__ptr_TextDocument_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TextDocument_ce_* litaC_m,const litaC_char* litaC_key,litaC_workspace__TextDocument* litaC_value);
litaC_void litaC_map__Map_free_cb__ptr_const_char_c__ptr_TextDocument_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TextDocument_ce_* litaC_m);
litaC_bool litaC_map__Map_contains_cb__ptr_const_char_c__ptr_TextDocument_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TextDocument_ce_* litaC_m,const litaC_char* litaC_key);
litaC_workspace__TextDocument* litaC_mem__new_cb_TextDocument_ce_(const litaC_mem__Allocator* litaC_a);
litaC_workspace__TextDocument* litaC_map__Map_remove_cb__ptr_const_char_c__ptr_TextDocument_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TextDocument_ce_* litaC_m,const litaC_char* litaC_key);
litaC_workspace__TextDocument* litaC_map__Map_get_cb__ptr_const_char_c__ptr_TextDocument_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TextDocument_ce_* litaC_m,const litaC_char* litaC_key);
LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb_SrcPos_ce_(litaC_array__Array_cb_SrcPos_ce_* litaC_a);
LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_SrcPos_ce_(litaC_array__Array_cb_SrcPos_ce_* litaC_a);
litaC_lex__SrcPos* litaC_array__Array_getPtr_cb_SrcPos_ce_(litaC_array__Array_cb_SrcPos_ce_* litaC_a,litaC_i32 litaC_index);
litaC_ast__GenericParam* litaC_array__Array_getPtr_cb_GenericParam_ce_(litaC_array__Array_cb_GenericParam_ce_* litaC_a,litaC_i32 litaC_index);
litaC_ast__FieldStmt* litaC_array__Array_getPtr_cb_FieldStmt_ce_(litaC_array__Array_cb_FieldStmt_ce_* litaC_a,litaC_i32 litaC_index);


// Generated code for interfaces

#endif /* _LITAC_HEADER_H */


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// translated code begins
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


struct litaC_array__Array_cb__ptr_Expr_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__Expr** elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_map__MapEntry_cb_i64_c__ptr_ConstTypeInfo_ce_ {
    litaC_i64 key;
    litaC_types__ConstTypeInfo* value;
    litaC_types__ConstTypeInfo** valuePtr;
    
};

struct litaC_array__Array_cb__ptr_InitArgExpr_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__InitArgExpr** elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_array__Array_cb_FieldReference_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_references__FieldReference* elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_json__SrcPos {
    const litaC_char* name;
    litaC_i32 line;
    
};

struct litaC_map__MapIterator_cb__ptr_const_char_c__ptr_Symbol_ce_ {
    litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_* m;
    litaC_i32 it;
    litaC_i32 count;
    
};

struct litaC_array__Array_cb__ptr_Dependency_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_dependency_graph__Dependency** elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_map__MapIterator_cb_i64_c__ptr_PtrTypeInfo_ce_ {
    litaC_map__Map_cb_i64_c__ptr_PtrTypeInfo_ce_* m;
    litaC_i32 it;
    litaC_i32 count;
    
};


struct litaC_json__Entry {
    const litaC_char* key;
    litaC_json__JsonNode* value;
    
};

struct litaC_array__Array_cb__ptr_FuncTypeInfo_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_types__FuncTypeInfo** elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_array__Array_cb__ptr_TypeInfo_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_types__TypeInfo** elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_checker__GenericContext {
    litaC_module__Module* callsite;
    
};

struct litaC_types_new__ArrayEntry {
    litaC_types__TypeInfo* arrayOf;
    litaC_ast__Expr* expr;
    litaC_usize length;
    
};

struct litaC_cgen__CompilationUnit {
    litaC_module__Module* module;
    litaC_char filename[_MAX_PATH];
    FILE* file;
    
};

struct litaC_array__Array_cb_i64_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_i64* elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_array__Array_cb_PhaseError_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_phase_result__PhaseError* elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_array__Array_cb__ptr_CompStmt_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__CompStmt** elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_map__Map_cb__ptr_const_char_c__ptr_TextDocument_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(const litaC_char*);
    litaC_bool (*equalFn)(const litaC_char*,const litaC_char*);
    const litaC_mem__Allocator* alloc;
    const litaC_char** keys;
    litaC_workspace__TextDocument** values;
    litaC_workspace__TextDocument* emptyValue;
    const litaC_char* emptyKey;
    
};

struct litaC_module__ModuleImport {
    litaC_module__Module* module;
    litaC_string_view__StringView* alias;
    litaC_bool isUsing;
    
};

struct litaC_protocol__Position {
    litaC_i32 line;
    litaC_i32 character;
    
};

struct litaC_array__Array_cb__ptr_NoteStmt_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__NoteStmt** elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_array__Array_cb__ptr_Symbol_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_symbols__Symbol** elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_map__MapEntry_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_ {
    litaC_types_new__ArrayEntry key;
    litaC_types__ArrayTypeInfo* value;
    litaC_types__ArrayTypeInfo** valuePtr;
    
};

struct litaC_map__Map_cb__ptr_const_char_c_i32_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(const litaC_char*);
    litaC_bool (*equalFn)(const litaC_char*,const litaC_char*);
    const litaC_mem__Allocator* alloc;
    const litaC_char** keys;
    litaC_i32* values;
    litaC_i32 emptyValue;
    const litaC_char* emptyKey;
    
};

struct litaC_dependency_graph__Dependency {
    litaC_dependency_graph__State state;
    litaC_symbols__Symbol* sym;
    litaC_array__Array_cb__ptr_Dependency_ce_ dependsOn;
    
};

struct litaC_protocol__TextDocumentChangeEvent {
    litaC_protocol__Range* range;
    const litaC_char* text;
    
};

struct litaC_cmdline__Option {
    const litaC_char* name;
    litaC_char shortName;
    const litaC_char* description;
    const litaC_char* value;
    const litaC_char* defaultValue;
    litaC_i32 flags;
    
};

struct litaC_string_buffer__StringBuffer {
    litaC_char* buffer;
    litaC_i32 length;
    litaC_i32 capacity;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_ {
    litaC_map__Map_cb__ptr_Symbol_c_Dependency_ce_* m;
    litaC_i32 it;
    litaC_i32 count;
    
};

struct litaC_builtins__any {
    litaC_void* value;
    litaC_u64 id;
    
};

struct litaC_array__Array_cb__ptr_EnumFieldEntryDecl_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__EnumFieldEntryDecl** elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__SwitchCaseStmt** elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_types__TypeInfo {
    litaC_types__TypeKind kind;
    litaC_i64 typeid;
    const litaC_char* name;
    litaC_symbols__Symbol* sym;
    
};

struct litaC_array__Array_cb_Option_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_cmdline__Option* elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_array__Array_cb__ptr_ImportDecl_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__ImportDecl** elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_array__Array_cb_Token_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_lex__Token* elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_map__MapIterator_cb_i64_c__ptr_ConstTypeInfo_ce_ {
    litaC_map__Map_cb_i64_c__ptr_ConstTypeInfo_ce_* m;
    litaC_i32 it;
    litaC_i32 count;
    
};

struct litaC_map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_ {
    litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_* m;
    litaC_i32 it;
    litaC_i32 count;
    
};

struct litaC_array__Array_cb_CallArg_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__CallArg* elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_map__Map_cb_i64_c__ptr_PtrTypeInfo_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(litaC_i64);
    litaC_bool (*equalFn)(litaC_i64,litaC_i64);
    const litaC_mem__Allocator* alloc;
    litaC_i64* keys;
    litaC_types__PtrTypeInfo** values;
    litaC_types__PtrTypeInfo* emptyValue;
    litaC_i64 emptyKey;
    
};

struct litaC_phase_result__PhaseResult {
    const litaC_mem__Allocator* allocator;
    litaC_array__Array_cb_PhaseError_ce_ errors;
    litaC_bool enabled;
    
};

struct litaC_map__Map_cb__ptr_const_char_c__ptr_TypeInfo_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(const litaC_char*);
    litaC_bool (*equalFn)(const litaC_char*,const litaC_char*);
    const litaC_mem__Allocator* alloc;
    const litaC_char** keys;
    litaC_types__TypeInfo** values;
    litaC_types__TypeInfo* emptyValue;
    const litaC_char* emptyKey;
    
};

struct litaC_system__Process {
    FILE* pipe;
    
};

struct litaC_lex__SrcPos {
    const litaC_char* filename;
    const litaC_char* lineStart;
    const litaC_char* start;
    const litaC_char* end;
    litaC_i32 lineNumber;
    litaC_i32 position;
    
};

struct litaC_types__ConstTypeInfo {
    litaC_types__TypeInfo info;
    litaC_types__TypeInfo* constOf;
    
};

struct litaC_generics__Template {
    litaC_array__Array_cb_GenericParam_ce_* genericParams;
    litaC_array__Array_cb__ptr_TypeSpec_ce_* genericArgs;
    
};

struct litaC_array__Array_cb_Reference_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_references__Reference* elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_map__MapEntry_cb__ptr_const_char_c__ptr_Module_ce_ {
    const litaC_char* key;
    litaC_module__Module* value;
    litaC_module__Module** valuePtr;
    
};

struct litaC_workspace__Workspace {
    const litaC_mem__Allocator* allocator;
    litaC_lsp__LspServer* lsp;
    const litaC_char* rootPath;
    litaC_map__Map_cb__ptr_const_char_c__ptr_TextDocument_ce_ openedDocuments;
    
};

struct litaC_protocol__Range {
    litaC_protocol__Position start;
    litaC_protocol__Position end;
    
};

struct litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(const litaC_char*);
    litaC_bool (*equalFn)(const litaC_char*,const litaC_char*);
    const litaC_mem__Allocator* alloc;
    const litaC_char** keys;
    litaC_symbols__Symbol** values;
    litaC_symbols__Symbol* emptyValue;
    const litaC_char* emptyKey;
    
};

struct litaC_string_view__StringView {
    const litaC_char* buffer;
    litaC_i32 length;
    
};

struct litaC_array__Array_cb__ptr_JsonNode_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_json__JsonNode** elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_array__Array_cb_Array_cb_GenericParam_ce__ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_array__Array_cb_GenericParam_ce_* elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_map__MapEntry_cb_i64_c__ptr_PtrTypeInfo_ce_ {
    litaC_i64 key;
    litaC_types__PtrTypeInfo* value;
    litaC_types__PtrTypeInfo** valuePtr;
    
};

struct litaC_string__String {
    litaC_char* buffer;
    litaC_i32 length;
    litaC_i32 capacity;
    
};

struct litaC_lita__LitaOptions {
    litaC_char srcPath[_MAX_PATH];
    litaC_char libPath[_MAX_PATH];
    litaC_char litaPath[_MAX_PATH];
    litaC_char inputFile[_MAX_PATH];
    litaC_char outputFile[_MAX_PATH];
    litaC_char outputPath[_MAX_PATH];
    const litaC_char* compileCmd;
    litaC_bool checkerOnly;
    litaC_bool cOutputOnly;
    litaC_bool run;
    litaC_bool showProfileInfo;
    litaC_bool languageServer;
    litaC_bool isDebug;
    litaC_bool instrument;
    litaC_bool testsOnly;
    const litaC_char* testsRegex;
    litaC_bool testFileOnly;
    litaC_lita__TypeInfoOption typeOption;
    litaC_char cPrefix[32];
    litaC_bool cFormat;
    
};

struct litaC_map__Map_cb__ptr_const_char_c__ptr_Module_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(const litaC_char*);
    litaC_bool (*equalFn)(const litaC_char*,const litaC_char*);
    const litaC_mem__Allocator* alloc;
    const litaC_char** keys;
    litaC_module__Module** values;
    litaC_module__Module* emptyValue;
    const litaC_char* emptyKey;
    
};

struct litaC_mem__Allocation {
    litaC_void* addr;
    litaC_usize size;
    litaC_u64 line;
    litaC_char filename[256];
    
};

struct litaC_array__Array_cb_GenericParam_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__GenericParam* elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_array__Array_cb_ModuleImport_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_module__ModuleImport* elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_array__Array_cb__ptr_Module_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_module__Module** elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_profile__ProfileEntry {
    const litaC_char* functionName;
    litaC_u64 count;
    litaC_f64 startTime;
    litaC_f64 totalTime;
    
};

struct litaC_types__FieldPositionResult {
    litaC_types__AggregateTypeInfo* aggInfo;
    litaC_i32 position;
    
};

struct litaC_ast__TypeSpec {
    litaC_ast__TypeSpecKind kind;
    litaC_lex__SrcPos pos;
    litaC_ast__TypeSpec* base;
    litaC_types__TypeInfo* typeInfo;
    
};

struct litaC_ast__FieldStmt {
    litaC_ast__StmtKind kind;
    litaC_types__TypeInfo* typeInfo;
    union  {
        litaC_ast__EnumDecl* enumField;
        litaC_ast__AggregateDecl* aggregateField;
        litaC_ast__VarFieldDecl* varField;
        litaC_ast__TraitFieldDecl* traitField;
        litaC_ast__Expr* poisonField;
        
    };
    
};

struct litaC_introspection__Introspect {
    litaC_lita__Lita* lita;
    
};


struct litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(litaC_i64);
    litaC_bool (*equalFn)(litaC_i64,litaC_i64);
    const litaC_mem__Allocator* alloc;
    litaC_i64* keys;
    litaC_array__Array_cb_i64_ce_* values;
    litaC_array__Array_cb_i64_ce_ emptyValue;
    litaC_i64 emptyKey;
    
};

struct litaC_map__MapIterator_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_ {
    litaC_map__Map_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_* m;
    litaC_i32 it;
    litaC_i32 count;
    
};

struct litaC_array__Array_cb__ptr_TypeSpec_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__TypeSpec** elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_map__MapIterator_cb__ptr_const_char_c__ptr_Module_ce_ {
    litaC_map__Map_cb__ptr_const_char_c__ptr_Module_ce_* m;
    litaC_i32 it;
    litaC_i32 count;
    
};

struct litaC_types__FieldPath {
    litaC_ast__FieldStmt fields[256];
    litaC_i32 numOfFields;
    
};

struct litaC_types__GenericTypeInfo {
    litaC_types__TypeInfo typeInfo;
    litaC_i64 genericTypeid;
    
};

struct litaC_preprocessor__CallContext {
    litaC_preprocessor__Preprocessor* pp;
    litaC_checker__TypeChecker* checker;
    litaC_ast__CompStmt* comp;
    litaC_string_buffer__StringBuffer buffer;
    
};

struct litaC_checker__LabelInfo {
    litaC_string_view__StringView name;
    litaC_bool defined;
    litaC_ast__Stmt* stmt;
    
};

struct litaC_references__Reference {
    litaC_i64 type;
    litaC_lex__SrcPos pos;
    
};



struct litaC_map__Map_cb_i64_c__ptr_ConstTypeInfo_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(litaC_i64);
    litaC_bool (*equalFn)(litaC_i64,litaC_i64);
    const litaC_mem__Allocator* alloc;
    litaC_i64* keys;
    litaC_types__ConstTypeInfo** values;
    litaC_types__ConstTypeInfo* emptyValue;
    litaC_i64 emptyKey;
    
};

struct litaC_ast__PtrTypeSpec {
    litaC_ast__TypeSpec spec;
    
};

struct litaC_ast__Attributes {
    litaC_bool isPublic;
    litaC_bool isGlobal;
    litaC_bool isUsing;
    litaC_array__Array_cb__ptr_NoteStmt_ce_ notes;
    
};

struct litaC_module__ModuleId {
    litaC_char filename[_MAX_PATH];
    litaC_string_view__StringView packageName;
    litaC_string_view__StringView name;
    
};

union litaC_json__JsonValue {
    litaC_bool boolValue;
    litaC_f64 doubleValue;
    litaC_i64 intValue;
    const litaC_char* strValue;
    litaC_json__JsonObject* objValue;
    litaC_array__Array_cb__ptr_JsonNode_ce_* arrayValue;
    
};

struct litaC_array__Array_cb_Entry_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_json__Entry* elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_array__Array_cb__ptr_Allocation_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_mem__Allocation** elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_map__MapEntry_cb_i64_c_Array_cb_i64_ce__ce_ {
    litaC_i64 key;
    litaC_array__Array_cb_i64_ce_ value;
    litaC_array__Array_cb_i64_ce_* valuePtr;
    
};

struct litaC_array__Array_cb__ptr_const_char_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    const litaC_char** elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_array__Array_cb__ptr_ParameterDecl_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__ParameterDecl** elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_map__MapEntry_cb__ptr_const_char_c__ptr_Symbol_ce_ {
    const litaC_char* key;
    litaC_symbols__Symbol* value;
    litaC_symbols__Symbol** valuePtr;
    
};

struct litaC_array__Array_cb__ptr_Stmt_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__Stmt** elements;
    const litaC_mem__Allocator* alloc;
    
};

union litaC_lex__Value {
    litaC_f64 floatValue;
    litaC_i64 intValue;
    litaC_u64 uintValue;
    litaC_string_view__StringView str;
    
};

struct litaC_types__PtrTypeInfo {
    litaC_types__TypeInfo info;
    litaC_types__TypeInfo* ptrOf;
    
};

struct litaC_lita__Metric {
    litaC_usize bytesAllocated;
    litaC_u32 allocationCount;
    litaC_f64 executionTime;
    litaC_f64 startTime;
    
};

struct litaC_array__Array_cb__ptr_Decl_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__Decl** elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_mem__Allocator {
    litaC_void* (*allocFn)(const litaC_mem__Allocator*,litaC_usize);
    litaC_void* (*callocFn)(const litaC_mem__Allocator*,litaC_usize,litaC_usize);
    litaC_void* (*reallocFn)(const litaC_mem__Allocator*,litaC_void*,litaC_usize,litaC_usize);
    litaC_void (*freeFn)(const litaC_mem__Allocator*,litaC_void*);
    
};

struct litaC_array__Array_cb_FieldStmt_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__FieldStmt* elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_map__MapEntry_cb__ptr_Symbol_c_Dependency_ce_ {
    litaC_symbols__Symbol* key;
    litaC_dependency_graph__Dependency value;
    litaC_dependency_graph__Dependency* valuePtr;
    
};

struct litaC_array__Array_cb_SrcPos_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_lex__SrcPos* elements;
    const litaC_mem__Allocator* alloc;
    
};

struct litaC_ast__Node {
    litaC_ast__StmtKind kind;
    litaC_ast__Node* parent;
    litaC_lex__SrcPos startPos;
    litaC_lex__SrcPos endPos;
    
};

struct litaC_ast__Stmt {
    litaC_ast__Node node;
    
};

struct litaC_lex__Token {
    litaC_lex__TokenType type;
    litaC_lex__Mod mod;
    litaC_types__TypeInfo* typeInfo;
    litaC_lex__SrcPos pos;
    litaC_lex__Value value;
    
};

struct litaC_ast__Decl {
    litaC_ast__Stmt stmt;
    litaC_symbols__Symbol* sym;
    litaC_lex__Token name;
    litaC_ast__Attributes attributes;
    
};

struct litaC_ast__EnumDecl {
    litaC_ast__Decl decl;
    litaC_array__Array_cb__ptr_EnumFieldEntryDecl_ce_ fields;
    
};

struct litaC_ast__ContinueStmt {
    litaC_ast__Stmt stmt;
    
};

struct litaC_ast__IfStmt {
    litaC_ast__Stmt stmt;
    litaC_ast__Expr* cond;
    litaC_ast__Stmt* then;
    litaC_ast__Stmt* elseStmt;
    
};

struct litaC_ast__VarFieldDecl {
    litaC_ast__Decl decl;
    litaC_ast__TypeSpec* type;
    litaC_ast__Expr* defaultExpr;
    
};

struct litaC_ast__Operand {
    litaC_types__TypeInfo* typeInfo;
    litaC_bool isRightValue;
    litaC_bool isConst;
    litaC_lex__Value val;
    
};

struct litaC_ast__Expr {
    litaC_ast__Stmt stmt;
    litaC_ast__Operand operand;
    litaC_types__TypeInfo* expectedType;
    
};

struct litaC_ast__BinaryExpr {
    litaC_ast__Expr expr;
    litaC_ast__Expr* left;
    litaC_lex__TokenType operator;
    litaC_ast__Expr* right;
    
};

struct litaC_ast__GroupExpr {
    litaC_ast__Expr expr;
    litaC_ast__Expr* groupedExpr;
    
};

struct litaC_ast__SizeOfExpr {
    litaC_ast__Expr expr;
    litaC_ast__Expr* sizeOfExpr;
    
};

struct litaC_ast__PoisonExpr {
    litaC_ast__Expr expr;
    
};

struct litaC_symbols__Symbol {
    litaC_symbols__SymbolKind kind;
    litaC_char name[256];
    litaC_symbols__SymbolState state;
    litaC_ast__Decl* decl;
    litaC_types__TypeInfo* type;
    litaC_symbols__Symbol* usingParent;
    litaC_module__Module* declared;
    litaC_module__Module* usingModule;
    litaC_i32 flags;
    litaC_lex__Value val;
    litaC_module__Module* genericCallsiteModule;
    litaC_array__Array_cb__ptr_TypeInfo_ce_ genericArgs;
    litaC_array__Array_cb_GenericParam_ce_ genericParams;
    
};

struct litaC_parser__Parser {
    const litaC_mem__Allocator* allocator;
    litaC_phase_result__PhaseResult* result;
    litaC_lita__Lita* lita;
    const litaC_char* filename;
    litaC_i32 totalLines;
    litaC_array__Array_cb_Token_ce_ tokens;
    litaC_i32 current;
    litaC_lex__SrcPos currentPos;
    litaC_i32 breakLevel;
    litaC_i32 loopLevel;
    litaC_i32 switchLevel;
    litaC_i32 funcLevel;
    litaC_i32 aggregateLevel;
    litaC_u32 tryLevel;
    litaC_u64 tryErrorCounter;
    litaC_bool panicMode;
    
};

struct litaC_workspace__TextDocument {
    litaC_char filename[_MAX_PATH];
    litaC_string_buffer__StringBuffer text;
    
};

struct litaC_protocol__Location {
    const litaC_char* uri;
    litaC_protocol__Range range;
    
};

struct litaC_types__EnumTypeInfo {
    litaC_types__TypeInfo info;
    litaC_ast__EnumDecl* decl;
    
};

struct litaC_cgen__CGen {
    litaC_lita__Lita* lita;
    litaC_string_buffer__StringBuffer buf;
    litaC_string_buffer__StringBuffer line;
    litaC_bool format;
    litaC_i32 indent;
    litaC_i32 aggregateLevel;
    litaC_bool bufferFlush;
    litaC_i32 funcIndex;
    litaC_i32 tmpVar;
    litaC_types__FuncTypeInfo* currentFunc;
    litaC_cgen__CGenScope* currentScope;
    FILE* output;
    
};


struct litaC_util__SourceLocation {
    litaC_util__SourceLocationKind kind;
    litaC_module__Module* module;
    litaC_protocol__Location location;
    union  {
        litaC_ast__Node* node;
        litaC_ast__TypeSpec* type;
        
    };
    
};


struct litaC_util__SourceLookup {
    litaC_lsp__LspServer* lsp;
    litaC_protocol__Position lookupPos;
    litaC_util__SourceLocation result;
    
};

struct litaC_mem__DebugAllocator {
    litaC_mem__Allocator alloc;
    const litaC_mem__Allocator* decorated;
    litaC_array__Array_cb__ptr_Allocation_ce_ allocations;
    litaC_u32 totalAllocations;
    litaC_usize totalBytesAllocated;
    litaC_usize totalBytesFreed;
    
};

struct litaC_map__Map_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(litaC_types_new__ArrayEntry);
    litaC_bool (*equalFn)(litaC_types_new__ArrayEntry,litaC_types_new__ArrayEntry);
    const litaC_mem__Allocator* alloc;
    litaC_types_new__ArrayEntry* keys;
    litaC_types__ArrayTypeInfo** values;
    litaC_types__ArrayTypeInfo* emptyValue;
    litaC_types_new__ArrayEntry emptyKey;
    
};

struct litaC_ast__NameTypeSpec {
    litaC_ast__TypeSpec spec;
    const litaC_char* name;
    litaC_array__Array_cb__ptr_TypeSpec_ce_ genericArgs;
    
};

struct litaC_ast__FuncPtrTypeSpec {
    litaC_ast__TypeSpec spec;
    litaC_array__Array_cb__ptr_TypeSpec_ce_ args;
    litaC_ast__TypeSpec* ret;
    litaC_bool hasVarargs;
    litaC_array__Array_cb_GenericParam_ce_ genericParams;
    
};

struct litaC_ast__ImportDecl {
    litaC_ast__Decl decl;
    litaC_lex__Token alias;
    litaC_bool isUsing;
    litaC_module__ModuleId* moduleId;
    
};

struct litaC_ast__NotesDecl {
    litaC_ast__Decl decl;
    litaC_array__Array_cb__ptr_NoteStmt_ce_ notes;
    
};

struct litaC_ast__EmptyStmt {
    litaC_ast__Stmt stmt;
    
};

struct litaC_ast__NoteStmt {
    litaC_ast__Stmt stmt;
    litaC_lex__Token name;
    litaC_array__Array_cb_Token_ce_ attributes;
    
};

struct litaC_ast__CharExpr {
    litaC_ast__Expr expr;
    litaC_lex__Token character;
    
};

struct litaC_ast__InitExpr {
    litaC_ast__Expr expr;
    litaC_array__Array_cb__ptr_TypeSpec_ce_ genericArgs;
    litaC_ast__NameTypeSpec* type;
    litaC_array__Array_cb__ptr_InitArgExpr_ce_ arguments;
    
};

struct litaC_ast__SubscriptSetExpr {
    litaC_ast__Expr expr;
    litaC_ast__Expr* object;
    litaC_ast__Expr* index;
    litaC_lex__TokenType operator;
    litaC_ast__Expr* value;
    
};

struct litaC_phase_result__PhaseError {
    litaC_phase_result__ErrorType type;
    const litaC_char* message;
    litaC_lex__SrcPos pos;
    
};

struct litaC_types__FuncTypeInfo {
    litaC_types__GenericTypeInfo info;
    litaC_types__TypeInfo* returnType;
    litaC_ast__FuncDecl* decl;
    
};

struct litaC_symbols__ProgramSymbols {
    litaC_module__Module* root;
    litaC_array__Array_cb__ptr_Symbol_ce_ values;
    litaC_array__Array_cb__ptr_Symbol_ce_ symbolTypes;
    litaC_array__Array_cb__ptr_Symbol_ce_ symbolFuncs;
    litaC_symbols__Symbol* mainEntry;
    litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_ interfaceImpls;
    
};

struct litaC_mem__LinearAllocator {
    litaC_mem__Allocator alloc;
    litaC_void* mem;
    litaC_usize size;
    litaC_usize currentOffset;
    litaC_u32 totalAllocations;
    litaC_usize totalBytesAllocated;
    
};

struct litaC_preprocessor__Preprocessor {
    litaC_lita__Lita* lita;
    ape_t* ape;
    litaC_preprocessor__CallContext callContext;
    litaC_array__Array_cb__ptr_CompStmt_ce_ preCheckers;
    
};

struct litaC_map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(litaC_usize);
    litaC_bool (*equalFn)(litaC_usize,litaC_usize);
    const litaC_mem__Allocator* alloc;
    litaC_usize* keys;
    litaC_array__Array_cb_SrcPos_ce_* values;
    litaC_array__Array_cb_SrcPos_ce_ emptyValue;
    litaC_usize emptyKey;
    
};

struct litaC_references__ReferenceDatabase {
    const litaC_mem__Allocator* allocator;
    litaC_array__Array_cb_Reference_ce_ typeReferences;
    litaC_array__Array_cb_FieldReference_ce_ fieldReferences;
    litaC_map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_ symbols;
    
};

struct litaC_lita__Lita {
    const litaC_mem__Allocator* allocator;
    litaC_mem__LinearAllocator linearAllocator;
    litaC_preprocessor__Preprocessor preprocessor;
    litaC_phase_result__PhaseResult result;
    litaC_map__Map_cb__ptr_const_char_c__ptr_Module_ce_ modules;
    litaC_lita__Metric metrics[litaC_lita__MetricType_MAX_METRIC_TYPES];
    litaC_u32 totalSourceLines;
    litaC_u32 totalAllocations;
    litaC_lita__LitaOptions* options;
    litaC_char binaryFilename[_MAX_PATH];
    litaC_char sourceFilename[_MAX_PATH];
    litaC_symbols__ProgramSymbols programSymbols;
    litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_ genericSymbols;
    litaC_references__ReferenceDatabase references;
    
};

struct litaC_regex__Regex {
    re_t reg;
    
};

struct litaC_references__FieldReference {
    litaC_i64 parent;
    litaC_i32 offset;
    litaC_lex__SrcPos pos;
    
};

struct litaC_lsp__LspServer {
    litaC_mem__LinearAllocator requestAllocator;
    litaC_mem__LinearAllocator applicationAllocator;
    litaC_lita__Lita* lita;
    litaC_string_buffer__StringBuffer message;
    litaC_string_buffer__StringBuffer output;
    litaC_string_buffer__StringBuffer outbound;
    litaC_bool isInitialized;
    litaC_bool isRunning;
    litaC_workspace__Workspace workspace;
    FILE* logFile;
    
};

struct litaC_map__Map_cb__ptr_Symbol_c_Dependency_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(litaC_symbols__Symbol*);
    litaC_bool (*equalFn)(litaC_symbols__Symbol*,litaC_symbols__Symbol*);
    const litaC_mem__Allocator* alloc;
    litaC_symbols__Symbol** keys;
    litaC_dependency_graph__Dependency* values;
    litaC_dependency_graph__Dependency emptyValue;
    litaC_symbols__Symbol* emptyKey;
    
};

struct litaC_ast__ConstTypeSpec {
    litaC_ast__TypeSpec spec;
    
};

struct litaC_ast__GenericDecl {
    litaC_ast__Decl declaration;
    litaC_array__Array_cb_GenericParam_ce_ genericParams;
    
};

struct litaC_ast__FuncDecl {
    litaC_ast__GenericDecl decl;
    litaC_ast__ParametersStmt* params;
    litaC_ast__Stmt* body;
    litaC_ast__TypeSpec* returnType;
    litaC_i32 flags;
    
};

struct litaC_ast__BreakStmt {
    litaC_ast__Stmt stmt;
    
};

struct litaC_ast__FuncBodyStmt {
    litaC_ast__Stmt stmt;
    litaC_array__Array_cb__ptr_Stmt_ce_ stmts;
    
};

struct litaC_ast__SwitchCaseStmt {
    litaC_ast__Stmt stmt;
    litaC_ast__Expr* cond;
    litaC_ast__Stmt* body;
    
};

struct litaC_ast__ArrayDesignationExpr {
    litaC_ast__Expr expr;
    litaC_ast__Expr* index;
    litaC_ast__Expr* value;
    
};

struct litaC_ast__OffsetOfExpr {
    litaC_ast__Expr expr;
    litaC_ast__TypeSpec* type;
    litaC_lex__Token field;
    
};

struct litaC_ast__TypeOfExpr {
    litaC_ast__Expr expr;
    litaC_ast__Expr* typeOfExpr;
    litaC_ast__TypeSpec* type;
    
};

struct litaC_json__JsonNode {
    const litaC_mem__Allocator* alloc;
    litaC_json__JsonType type;
    litaC_json__JsonValue value;
    
};

struct litaC_lex__Lexer {
    const litaC_mem__Allocator* allocator;
    const litaC_char* filename;
    litaC_lex__Token token;
    const litaC_char* stream;
    const litaC_char* lineStart;
    litaC_i32 lineNumber;
    litaC_i32 position;
    const litaC_char* errorMsg;
    
};

struct litaC_types__ArrayTypeInfo {
    litaC_types__TypeInfo info;
    litaC_types__TypeInfo* arrayOf;
    litaC_usize length;
    litaC_ast__Expr* numOfElements;
    litaC_bool isLengthDefined;
    
};

struct litaC_ast__TypedefDecl {
    litaC_ast__GenericDecl decl;
    litaC_ast__TypeSpec* type;
    
};

struct litaC_ast__DeferStmt {
    litaC_ast__Stmt stmt;
    litaC_ast__Stmt* deferedStmt;
    
};

struct litaC_ast__LabelStmt {
    litaC_ast__Stmt stmt;
    litaC_lex__Token label;
    
};

struct litaC_ast__TraitFieldDecl {
    litaC_ast__Decl decl;
    litaC_ast__TypeSpec* type;
    
};

struct litaC_ast__BooleanExpr {
    litaC_ast__Expr expr;
    litaC_bool boolean;
    
};

struct litaC_ast__IdentifierExpr {
    litaC_ast__Expr expr;
    litaC_ast__NameTypeSpec* type;
    litaC_symbols__Symbol* sym;
    
};

struct litaC_ast__StringExpr {
    litaC_ast__Expr expr;
    litaC_lex__Token string;
    
};

struct litaC_types__AggregateTypeInfo {
    litaC_types__GenericTypeInfo info;
    litaC_ast__AggregateDecl* decl;
    
};

struct litaC_cgen__CGenScope {
    litaC_cgen__CGenScope* parent;
    litaC_array__Array_cb__ptr_Stmt_ce_ defers;
    litaC_array__Array_cb__ptr_const_char_ce_ constDefs;
    litaC_bool isLoop;
    litaC_bool isSwitch;
    
};

struct litaC_json__Token {
    litaC_json__TokenKind kind;
    litaC_json__SrcPos pos;
    const litaC_char* start;
    const litaC_char* end;
    union  {
        litaC_i64 intNumValue;
        litaC_f64 realNumValue;
        const litaC_char* strValue;
        const litaC_char* name;
        
    };
    
};

struct litaC_ast__ArrayTypeSpec {
    litaC_ast__TypeSpec spec;
    litaC_ast__Expr* numElements;
    
};

struct litaC_ast__GenericParam {
    litaC_lex__Token name;
    
};

struct litaC_ast__VarDecl {
    litaC_ast__Decl decl;
    litaC_ast__TypeSpec* typeSpec;
    litaC_ast__Expr* expr;
    
};

struct litaC_ast__PoisonDecl {
    litaC_ast__Decl decl;
    
};

struct litaC_ast__EnumFieldEntryDecl {
    litaC_ast__Decl decl;
    litaC_ast__Expr* value;
    
};

struct litaC_ast__ParametersStmt {
    litaC_ast__Stmt stmt;
    litaC_array__Array_cb__ptr_ParameterDecl_ce_ params;
    litaC_bool isVararg;
    
};

struct litaC_ast__WhileStmt {
    litaC_ast__Stmt stmt;
    litaC_ast__Expr* cond;
    litaC_ast__Stmt* body;
    
};

struct litaC_ast__CallArg {
    litaC_ast__Expr* argExpr;
    litaC_lex__Token argName;
    litaC_i32 index;
    
};

struct litaC_ast__NullExpr {
    litaC_ast__Expr expr;
    
};

struct litaC_ast__TernaryExpr {
    litaC_ast__Expr expr;
    litaC_ast__Expr* cond;
    litaC_ast__Expr* then;
    litaC_ast__Expr* other;
    
};

struct litaC_json__JsonObject {
    litaC_map__Map_cb__ptr_const_char_c_i32_ce_ indexes;
    litaC_array__Array_cb_Entry_ce_ values;
    
};

struct litaC_symbols__Scope {
    litaC_symbols__ScopeKind kind;
    const litaC_mem__Allocator* allocator;
    litaC_phase_result__PhaseResult* result;
    litaC_symbols__Scope* parent;
    litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_ symbols;
    litaC_module__Module* module;
    
};

struct litaC_types_new__TypeCache {
    const litaC_mem__Allocator* allocator;
    litaC_map__Map_cb_i64_c__ptr_ConstTypeInfo_ce_ constCache;
    litaC_map__Map_cb_i64_c__ptr_PtrTypeInfo_ce_ ptrCache;
    litaC_map__Map_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_ arrayCache;
    litaC_map__Map_cb__ptr_const_char_c__ptr_TypeInfo_ce_ genericCache;
    
};

struct litaC_checker__TypeChecker {
    litaC_lita__Lita* lita;
    litaC_module__Module* current;
    litaC_array__Array_cb__ptr_Module_ce_ moduleStack;
    litaC_array__Array_cb__ptr_FuncTypeInfo_ce_ funcDeclStack;
    litaC_array__Array_cb__ptr_Symbol_ce_ pendingValues;
    litaC_array__Array_cb__ptr_Symbol_ce_ symbolTypes;
    litaC_array__Array_cb__ptr_Symbol_ce_ symbolFuncs;
    litaC_symbols__Symbol* mainEntry;
    litaC_checker__GenericContext genericContext;
    litaC_array__Array_cb_Array_cb_GenericParam_ce__ce_ genericParamStack;
    litaC_array__Array_cb__ptr_Symbol_ce_ genericTemplates;
    litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_ interfaceImpls;
    litaC_checker__LabelInfo labels[256];
    litaC_i32 numOfLabels;
    litaC_types_new__TypeCache typeCache;
    litaC_u32 randomNameIndex;
    litaC_bool bypassing;
    
};

struct litaC_ast__AggregateDecl {
    litaC_ast__GenericDecl decl;
    litaC_array__Array_cb_FieldStmt_ce_ fields;
    litaC_i32 flags;
    
};

struct litaC_ast__CompStmt {
    litaC_ast__Stmt stmt;
    const litaC_char* type;
    const litaC_char* expr;
    litaC_ast__CompStmt* end;
    litaC_ast__Stmt* evaluatedStmt;
    litaC_array__Array_cb__ptr_Stmt_ce_ body;
    
};

struct litaC_ast__GotoStmt {
    litaC_ast__Stmt stmt;
    litaC_lex__Token label;
    
};

struct litaC_ast__SwitchStmt {
    litaC_ast__Stmt stmt;
    litaC_ast__Expr* cond;
    litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_ cases;
    litaC_ast__Stmt* defaultStmt;
    
};

struct litaC_ast__ArrayInitExpr {
    litaC_ast__Expr expr;
    litaC_ast__TypeSpec* type;
    litaC_array__Array_cb__ptr_Expr_ce_ values;
    
};

struct litaC_ast__GetExpr {
    litaC_ast__Expr expr;
    litaC_ast__Expr* object;
    litaC_ast__IdentifierExpr* field;
    litaC_i32 flags;
    
};

struct litaC_ast__SetExpr {
    litaC_ast__Expr expr;
    litaC_ast__Expr* object;
    litaC_ast__IdentifierExpr* field;
    litaC_lex__TokenType operator;
    litaC_ast__Expr* value;
    litaC_i32 flags;
    
};

struct litaC_ast__UnaryExpr {
    litaC_ast__Expr expr;
    litaC_lex__TokenType operator;
    litaC_ast__Expr* unaryExpr;
    
};

struct litaC_module__Module {
    litaC_module__ModuleId id;
    litaC_char* text;
    litaC_ast__ModuleStmt* ast;
    litaC_symbols__Scope symbols;
    litaC_symbols__Scope* currentScope;
    litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_* genericSymbols;
    litaC_i32 flags;
    litaC_array__Array_cb_ModuleImport_ce_ importedBy;
    const litaC_mem__Allocator* allocator;
    
};


struct litaC_dependency_graph__DependencyGraph {
    litaC_array__Array_cb__ptr_Symbol_ce_ sortedPrimitives;
    litaC_array__Array_cb__ptr_Symbol_ce_ sortedGlobals;
    litaC_array__Array_cb__ptr_Symbol_ce_ sortedAggregates;
    litaC_array__Array_cb__ptr_Symbol_ce_ sortedFuncs;
    litaC_array__Array_cb__ptr_Symbol_ce_ sortedSymbols;
    litaC_map__Map_cb__ptr_Symbol_c_Dependency_ce_ dependencies;
    litaC_lita__Lita* lita;
    
};


struct litaC_types__FuncPtrTypeInfo {
    litaC_types__GenericTypeInfo info;
    litaC_array__Array_cb_GenericParam_ce_ genericParams;
    litaC_types__TypeInfo* returnType;
    litaC_array__Array_cb__ptr_TypeInfo_ce_ paramDecls;
    litaC_bool hasVarargs;
    litaC_bool isTrait;
    
};

struct litaC_mem__Arena {
    litaC_mem__Allocator alloc;
    const litaC_mem__Allocator* decorated;
    litaC_u8* region;
    litaC_usize size;
    litaC_usize current;
    litaC_mem__Arena* next;
    
};

struct litaC_ast__NativeDecl {
    litaC_ast__Decl decl;
    litaC_types__TypeInfo* typeInfo;
    
};

struct litaC_ast__DoWhileStmt {
    litaC_ast__Stmt stmt;
    litaC_ast__Expr* cond;
    litaC_ast__Stmt* body;
    
};

struct litaC_ast__ModuleStmt {
    litaC_ast__Stmt stmt;
    litaC_array__Array_cb__ptr_ImportDecl_ce_ imports;
    litaC_array__Array_cb__ptr_NoteStmt_ce_ notes;
    litaC_array__Array_cb__ptr_Decl_ce_ declarations;
    
};

struct litaC_ast__CastExpr {
    litaC_ast__Expr expr;
    litaC_ast__TypeSpec* castTo;
    litaC_ast__Expr* exprToCast;
    
};

struct litaC_ast__InitArgExpr {
    litaC_ast__Expr expr;
    litaC_lex__Token fieldName;
    litaC_i32 argPosition;
    litaC_ast__Expr* value;
    
};

struct litaC_ast__SubscriptGetExpr {
    litaC_ast__Expr expr;
    litaC_ast__Expr* object;
    litaC_ast__Expr* index;
    
};

struct litaC_cmdline__CmdParser {
    litaC_array__Array_cb_Option_ce_ options;
    litaC_array__Array_cb__ptr_const_char_ce_ args;
    litaC_char errors[256];
    litaC_cmdline__CmdParserStatus status;
    const litaC_char* header;
    
};

struct litaC_ast__ParameterDecl {
    litaC_ast__Decl decl;
    litaC_ast__TypeSpec* type;
    litaC_ast__Expr* defaultExpr;
    litaC_types__TypeInfo* typeInfo;
    
};

struct litaC_ast__BlockStmt {
    litaC_ast__Stmt stmt;
    litaC_array__Array_cb__ptr_Stmt_ce_ stmts;
    
};

struct litaC_ast__ForStmt {
    litaC_ast__Stmt stmt;
    litaC_ast__Stmt* init;
    litaC_ast__Expr* cond;
    litaC_ast__Stmt* post;
    litaC_ast__Stmt* body;
    
};

struct litaC_ast__ReturnStmt {
    litaC_ast__Stmt stmt;
    litaC_ast__Expr* expr;
    
};

struct litaC_ast__FuncCallExpr {
    litaC_ast__Expr expr;
    litaC_ast__Expr* object;
    litaC_array__Array_cb__ptr_TypeSpec_ce_ genericArgs;
    litaC_array__Array_cb_CallArg_ce_ arguments;
    
};

struct litaC_ast__NumberExpr {
    litaC_ast__Expr expr;
    litaC_lex__Token number;
    
};

struct litaC_ast__TypeIdentifierExpr {
    litaC_ast__Expr expr;
    litaC_ast__TypeSpec* type;
    litaC_symbols__Symbol* sym;
    
};

struct litaC_json__JsonParser {
    const litaC_mem__Allocator* alloc;
    litaC_json__JsonParserStatus status;
    litaC_char errorMsg[256];
    litaC_json__Token token;
    litaC_string_buffer__StringBuffer buffer;
    const litaC_char* stream;
    const litaC_char* lineStart;
    
};

const litaC_mem__Allocator* litaC_mem__cAllocator = (const litaC_mem__Allocator*)(&((litaC_mem__Allocator) {
    .allocFn = &(litaC_mem__cMalloc),
    .callocFn = &(litaC_mem__cCalloc),
    .reallocFn = &(litaC_mem__cRealloc),
    .freeFn = &(litaC_mem__cFree)
}));
litaC_mem__DebugAllocator* litaC_mem__debugAllocator = (&((litaC_mem__DebugAllocator) {
    
}));
LITAC_THREADLOCAL 
const litaC_mem__Allocator* litaC_mem__defaultAllocator = (const litaC_mem__Allocator*)(&((litaC_mem__Allocator) {
    .allocFn = &(litaC_mem__cMalloc),
    .callocFn = &(litaC_mem__cCalloc),
    .reallocFn = &(litaC_mem__cRealloc),
    .freeFn = &(litaC_mem__cFree)
}));

#define litaC_system__OPEN_MODE ("rt")

#define litaC_system__PATH_SEPARATOR ("\\")
const litaC_char* litaC_system__uriEscapeChars[256] =  {
    ['!'] = "%21",
    ['#'] = "%23",
    ['$'] = "%24",
    ['%'] = "%25",
    ['&'] = "%26",
    ['\''] = "%27",
    ['('] = "%28",
    [')'] = "%29",
    ['*'] = "%2A",
    ['+'] = "%2B",
    [','] = "%2C",
    ['/'] = "%2F",
    [':'] = "%3A",
    [';'] = "%3B",
    ['='] = "%3D",
    ['?'] = "%3F",
    ['@'] = "%40",
    ['['] = "%5B",
    [']'] = "%5D"
};
litaC_f64 litaC_system_win__systemFreq;
litaC_u64 litaC_system_win__systemStart = 0;
litaC_char litaC_system_win__pwd[_MAX_PATH] =  {
    0
};

litaC_profile__ProfileEntry litaC_profile__profileEntries[1] =  {
    
};
const litaC_char* litaC_lex__tokenText[litaC_lex__TokenType_MAX_TOKEN_TYPES] =  {
    [litaC_lex__TokenType_IMPORT] = "import",
    [litaC_lex__TokenType_STRUCT] = "struct",
    [litaC_lex__TokenType_UNION] = "union",
    [litaC_lex__TokenType_TRAIT] = "trait",
    [litaC_lex__TokenType_ENUM] = "enum",
    [litaC_lex__TokenType_FUNC] = "func",
    [litaC_lex__TokenType_TYPEDEF] = "typedef",
    [litaC_lex__TokenType_VAR] = "var",
    [litaC_lex__TokenType_CONST] = "const",
    [litaC_lex__TokenType_NULL] = "null",
    [litaC_lex__TokenType_VOID] = "void",
    [litaC_lex__TokenType_TRUE] = "true",
    [litaC_lex__TokenType_FALSE] = "false",
    [litaC_lex__TokenType_BOOL] = "bool",
    [litaC_lex__TokenType_CHAR] = "char",
    [litaC_lex__TokenType_I8] = "i8",
    [litaC_lex__TokenType_U8] = "u8",
    [litaC_lex__TokenType_I16] = "i16",
    [litaC_lex__TokenType_U16] = "u16",
    [litaC_lex__TokenType_I32] = "i32",
    [litaC_lex__TokenType_U32] = "u32",
    [litaC_lex__TokenType_I64] = "i64",
    [litaC_lex__TokenType_U64] = "u64",
    [litaC_lex__TokenType_F32] = "f32",
    [litaC_lex__TokenType_F64] = "f64",
    [litaC_lex__TokenType_USIZE] = "usize",
    [litaC_lex__TokenType_FOR] = "for",
    [litaC_lex__TokenType_WHILE] = "while",
    [litaC_lex__TokenType_DO] = "do",
    [litaC_lex__TokenType_IF] = "if",
    [litaC_lex__TokenType_ELSE] = "else",
    [litaC_lex__TokenType_SWITCH] = "switch",
    [litaC_lex__TokenType_CASE] = "case",
    [litaC_lex__TokenType_DEFAULT] = "default",
    [litaC_lex__TokenType_DEFER] = "defer",
    [litaC_lex__TokenType_BREAK] = "break",
    [litaC_lex__TokenType_CONTINUE] = "continue",
    [litaC_lex__TokenType_RETURN] = "return",
    [litaC_lex__TokenType_GOTO] = "goto",
    [litaC_lex__TokenType_SIZEOF] = "sizeof",
    [litaC_lex__TokenType_TYPEOF] = "typeof",
    [litaC_lex__TokenType_OFFSETOF] = "offsetof",
    [litaC_lex__TokenType_AS] = "as",
    [litaC_lex__TokenType_PUBLIC] = "public",
    [litaC_lex__TokenType_USING] = "using",
    [litaC_lex__TokenType_PLUS] = "+",
    [litaC_lex__TokenType_MINUS] = "-",
    [litaC_lex__TokenType_STAR] = "*",
    [litaC_lex__TokenType_MOD] = "%",
    [litaC_lex__TokenType_SLASH] = "/",
    [litaC_lex__TokenType_DOLLAR] = "$",
    [litaC_lex__TokenType_HASH] = "#",
    [litaC_lex__TokenType_DOT] = ".",
    [litaC_lex__TokenType_VAR_ARGS] = "...",
    [litaC_lex__TokenType_AT] = "@",
    [litaC_lex__TokenType_QUESTION_MARK] = "?",
    [litaC_lex__TokenType_COMMA] = ",",
    [litaC_lex__TokenType_SEMICOLON] = ";",
    [litaC_lex__TokenType_COLON] = ":",
    [litaC_lex__TokenType_COLON_COLON] = "::",
    [litaC_lex__TokenType_DOUBLE_QUOTE] = "\"",
    [litaC_lex__TokenType_LESS_THAN] = "<",
    [litaC_lex__TokenType_LESS_EQUALS] = "<=",
    [litaC_lex__TokenType_GREATER_THAN] = ">",
    [litaC_lex__TokenType_GREATER_EQUALS] = ">=",
    [litaC_lex__TokenType_EQUALS_EQUALS] = "==",
    [litaC_lex__TokenType_EQUALS] = "=",
    [litaC_lex__TokenType_NOT_EQUALS] = "!=",
    [litaC_lex__TokenType_PLUS_EQ] = "+=",
    [litaC_lex__TokenType_MINUS_EQ] = "-=",
    [litaC_lex__TokenType_DIV_EQ] = "/=",
    [litaC_lex__TokenType_MUL_EQ] = "*=",
    [litaC_lex__TokenType_MOD_EQ] = "%=",
    [litaC_lex__TokenType_LSHIFT_EQ] = "<<=",
    [litaC_lex__TokenType_RSHIFT_EQ] = ">>=",
    [litaC_lex__TokenType_BNOT_EQ] = "~=",
    [litaC_lex__TokenType_XOR_EQ] = "^=",
    [litaC_lex__TokenType_BAND_EQ] = "&=",
    [litaC_lex__TokenType_BOR_EQ] = "|=",
    [litaC_lex__TokenType_LSHIFT] = "<<",
    [litaC_lex__TokenType_RSHIFT] = ">>",
    [litaC_lex__TokenType_BNOT] = "~",
    [litaC_lex__TokenType_XOR] = "^",
    [litaC_lex__TokenType_BAND] = "&",
    [litaC_lex__TokenType_BOR] = "|",
    [litaC_lex__TokenType_LEFT_PAREN] = "(",
    [litaC_lex__TokenType_RIGHT_PAREN] = ")",
    [litaC_lex__TokenType_LEFT_BRACKET] = "[",
    [litaC_lex__TokenType_RIGHT_BRACKET] = "]",
    [litaC_lex__TokenType_LEFT_BRACE] = "{",
    [litaC_lex__TokenType_RIGHT_BRACE] = "}",
    [litaC_lex__TokenType_NOT] = "!",
    [litaC_lex__TokenType_OR] = "||",
    [litaC_lex__TokenType_AND] = "&&",
    [litaC_lex__TokenType_STRING] = "STRING",
    [litaC_lex__TokenType_IDENTIFIER] = "IDENTIFER",
    [litaC_lex__TokenType_INT_NUMBER] = "INT_NUMBER",
    [litaC_lex__TokenType_FLOAT_NUMBER] = "FLOAT_NUMBER",
    [litaC_lex__TokenType_ERROR] = "ERROR",
    [litaC_lex__TokenType_END_OF_FILE] = "EOF"
};
litaC_i32 litaC_lex__charToDigit[256] =  {
    ['0'] = 0,
    ['1'] = 1,
    ['2'] = 2,
    ['3'] = 3,
    ['4'] = 4,
    ['5'] = 5,
    ['6'] = 6,
    ['7'] = 7,
    ['8'] = 8,
    ['9'] = 9,
    ['a'] = 10,
    ['A'] = 10,
    ['b'] = 11,
    ['B'] = 11,
    ['c'] = 12,
    ['C'] = 12,
    ['d'] = 13,
    ['D'] = 13,
    ['e'] = 14,
    ['E'] = 14,
    ['f'] = 15,
    ['F'] = 15
};
litaC_char litaC_lex__escapeToChar[256] =  {
    ['b'] = '\b',
    ['f'] = '\f',
    ['n'] = '\n',
    ['r'] = '\r',
    ['t'] = '\t',
    ['\\'] = '\\',
    ['\''] = '\'',
    ['"'] = '"',
    ['0'] = '\0',
    ['/'] = '/'
};
const litaC_char** litaC_lex__keywordCache[9] =  {
    [0] = (const litaC_char*[1]) {
        NULL
    },
    [1] = (const litaC_char*[1]) {
        NULL
    },
    [2] = (const litaC_char*[6]) {
        "i8",
        "u8",
        "do",
        "if",
        "as",
        NULL
    },
    [3] = (const litaC_char*[11]) {
        "var",
        "i16",
        "u16",
        "i32",
        "u32",
        "i64",
        "u64",
        "f32",
        "f64",
        "for",
        NULL
    },
    [4] = (const litaC_char*[11]) {
        "enum",
        "func",
        "null",
        "void",
        "true",
        "bool",
        "char",
        "else",
        "case",
        "goto",
        NULL
    },
    [5] = (const litaC_char*[10]) {
        "trait",
        "union",
        "const",
        "false",
        "usize",
        "defer",
        "while",
        "break",
        "using",
        NULL
    },
    [6] = (const litaC_char*[8]) {
        "import",
        "struct",
        "switch",
        "return",
        "sizeof",
        "typeof",
        "public",
        NULL
    },
    [7] = (const litaC_char*[3]) {
        "typedef",
        "default",
        NULL
    },
    [8] = (const litaC_char*[3]) {
        "continue",
        "offsetof",
        NULL
    }
};
litaC_lex__TokenType* litaC_lex__keywordCacheIndex[9] =  {
    [2] = (litaC_lex__TokenType[5]) {
        litaC_lex__TokenType_I8,
        litaC_lex__TokenType_U8,
        litaC_lex__TokenType_DO,
        litaC_lex__TokenType_IF,
        litaC_lex__TokenType_AS
    },
    [3] = (litaC_lex__TokenType[10]) {
        litaC_lex__TokenType_VAR,
        litaC_lex__TokenType_I16,
        litaC_lex__TokenType_U16,
        litaC_lex__TokenType_I32,
        litaC_lex__TokenType_U32,
        litaC_lex__TokenType_I64,
        litaC_lex__TokenType_U64,
        litaC_lex__TokenType_F32,
        litaC_lex__TokenType_F64,
        litaC_lex__TokenType_FOR
    },
    [4] = (litaC_lex__TokenType[10]) {
        litaC_lex__TokenType_ENUM,
        litaC_lex__TokenType_FUNC,
        litaC_lex__TokenType_NULL,
        litaC_lex__TokenType_VOID,
        litaC_lex__TokenType_TRUE,
        litaC_lex__TokenType_BOOL,
        litaC_lex__TokenType_CHAR,
        litaC_lex__TokenType_ELSE,
        litaC_lex__TokenType_CASE,
        litaC_lex__TokenType_GOTO
    },
    [5] = (litaC_lex__TokenType[9]) {
        litaC_lex__TokenType_TRAIT,
        litaC_lex__TokenType_UNION,
        litaC_lex__TokenType_CONST,
        litaC_lex__TokenType_FALSE,
        litaC_lex__TokenType_USIZE,
        litaC_lex__TokenType_DEFER,
        litaC_lex__TokenType_WHILE,
        litaC_lex__TokenType_BREAK,
        litaC_lex__TokenType_USING
    },
    [6] = (litaC_lex__TokenType[7]) {
        litaC_lex__TokenType_IMPORT,
        litaC_lex__TokenType_STRUCT,
        litaC_lex__TokenType_SWITCH,
        litaC_lex__TokenType_RETURN,
        litaC_lex__TokenType_SIZEOF,
        litaC_lex__TokenType_TYPEOF,
        litaC_lex__TokenType_PUBLIC
    },
    [7] = (litaC_lex__TokenType[2]) {
        litaC_lex__TokenType_TYPEDEF,
        litaC_lex__TokenType_DEFAULT
    },
    [8] = (litaC_lex__TokenType[2]) {
        litaC_lex__TokenType_CONTINUE,
        litaC_lex__TokenType_OFFSETOF
    }
};
const litaC_char* litaC_types__typeKindText[litaC_types__TypeKind_MAX_TYPE_KINDS + 1] =  {
    [litaC_types__TypeKind_BOOL] = "bool",
    [litaC_types__TypeKind_CHAR] = "char",
    [litaC_types__TypeKind_I8] = "i8",
    [litaC_types__TypeKind_U8] = "u8",
    [litaC_types__TypeKind_I16] = "i16",
    [litaC_types__TypeKind_U16] = "u16",
    [litaC_types__TypeKind_I32] = "i32",
    [litaC_types__TypeKind_U32] = "u32",
    [litaC_types__TypeKind_I64] = "i64",
    [litaC_types__TypeKind_U64] = "u64",
    [litaC_types__TypeKind_F32] = "f32",
    [litaC_types__TypeKind_F64] = "f64",
    [litaC_types__TypeKind_USIZE] = "usize",
    [litaC_types__TypeKind_NULL] = "null",
    [litaC_types__TypeKind_VOID] = "void",
    [litaC_types__TypeKind_STR] = "string",
    [litaC_types__TypeKind_ARRAY] = "array",
    [litaC_types__TypeKind_PTR] = "pointer",
    [litaC_types__TypeKind_FUNC_PTR] = "func_pointer",
    [litaC_types__TypeKind_STRUCT] = "struct",
    [litaC_types__TypeKind_UNION] = "union",
    [litaC_types__TypeKind_TRAIT] = "trait",
    [litaC_types__TypeKind_ENUM] = "enum",
    [litaC_types__TypeKind_FUNC] = "func",
    [litaC_types__TypeKind_CONST] = "const",
    [litaC_types__TypeKind_GENERIC_PARAM] = "generic_param",
    [litaC_types__TypeKind_POISON] = "poison",
    [litaC_types__TypeKind_MAX_TYPE_KINDS] = ""
};
litaC_i64 litaC_types__idGen = (litaC_i64)litaC_types__TypeKind_MAX_TYPE_KINDS;
litaC_types__TypeInfo litaC_types__BOOL_TYPE =  {
    .kind = litaC_types__TypeKind_BOOL,
    .typeid = (litaC_i64)litaC_types__TypeKind_BOOL,
    .name = "bool",
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__CHAR_TYPE =  {
    .kind = litaC_types__TypeKind_CHAR,
    .typeid = (litaC_i64)litaC_types__TypeKind_CHAR,
    .name = "char",
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__I8_TYPE =  {
    .kind = litaC_types__TypeKind_I8,
    .typeid = (litaC_i64)litaC_types__TypeKind_I8,
    .name = "i8",
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__U8_TYPE =  {
    .kind = litaC_types__TypeKind_U8,
    .typeid = (litaC_i64)litaC_types__TypeKind_U8,
    .name = "u8",
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__I16_TYPE =  {
    .kind = litaC_types__TypeKind_I16,
    .typeid = (litaC_i64)litaC_types__TypeKind_I16,
    .name = "i16",
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__U16_TYPE =  {
    .kind = litaC_types__TypeKind_U16,
    .typeid = (litaC_i64)litaC_types__TypeKind_U16,
    .name = "u16",
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__I32_TYPE =  {
    .kind = litaC_types__TypeKind_I32,
    .typeid = (litaC_i64)litaC_types__TypeKind_I32,
    .name = "i32",
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__U32_TYPE =  {
    .kind = litaC_types__TypeKind_U32,
    .typeid = (litaC_i64)litaC_types__TypeKind_U32,
    .name = "u32",
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__I64_TYPE =  {
    .kind = litaC_types__TypeKind_I64,
    .typeid = (litaC_i64)litaC_types__TypeKind_I64,
    .name = "i64",
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__U64_TYPE =  {
    .kind = litaC_types__TypeKind_U64,
    .typeid = (litaC_i64)litaC_types__TypeKind_U64,
    .name = "u64",
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__F32_TYPE =  {
    .kind = litaC_types__TypeKind_F32,
    .typeid = (litaC_i64)litaC_types__TypeKind_F32,
    .name = "f32",
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__F64_TYPE =  {
    .kind = litaC_types__TypeKind_F64,
    .typeid = (litaC_i64)litaC_types__TypeKind_F64,
    .name = "f64",
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__USIZE_TYPE =  {
    .kind = litaC_types__TypeKind_USIZE,
    .typeid = (litaC_i64)litaC_types__TypeKind_USIZE,
    .name = "usize",
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__NULL_TYPE =  {
    .kind = litaC_types__TypeKind_NULL,
    .typeid = (litaC_i64)litaC_types__TypeKind_NULL,
    .name = "null",
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__VOID_TYPE =  {
    .kind = litaC_types__TypeKind_VOID,
    .typeid = (litaC_i64)litaC_types__TypeKind_VOID,
    .name = "void",
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__STR_TYPE =  {
    .kind = litaC_types__TypeKind_STR,
    .typeid = (litaC_i64)litaC_types__TypeKind_STR,
    .name = "*const char",
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__POISON_TYPE =  {
    .kind = litaC_types__TypeKind_POISON,
    .typeid = (litaC_i64)litaC_types__TypeKind_POISON,
    .name = "<poison>",
    .sym = NULL
};
litaC_lex__Token litaC_module__BUILTIN_IMPORT_TOKEN =  {
    .type = litaC_lex__TokenType_STRING,
    .value =  {
        .str =  {
            .buffer = "builtin",
            .length = 7
        }
    }
};
litaC_module__Module litaC_module__builtins =  {
    
};
FILE* litaC_common__outputFile = NULL;

#define litaC_lita__LITA_VERSION ("0.1.1-alpha")
const litaC_char* litaC_error_codes__errorCodeText[41] =  {
    [litaC_error_codes__ErrorCode_INVALID_ASSIGNMENT] = "Invalid assignment statement",
    [litaC_error_codes__ErrorCode_INVALID_CONST_EXPR] = "Invalid constant expression",
    [litaC_error_codes__ErrorCode_INVALID_ARRAY_DIMENSION_EXPR] = "Invalid array dimension expression",
    [litaC_error_codes__ErrorCode_INVALID_CHARACTER] = "Invalid character",
    [litaC_error_codes__ErrorCode_INVALID_NUMBER] = "Invalid number",
    [litaC_error_codes__ErrorCode_INVALID_FIELD] = "Invalid field member",
    [litaC_error_codes__ErrorCode_INVALID_IMPORT_ACCESS] = "Invalid import access",
    [litaC_error_codes__ErrorCode_INVALID_CONTINUE] = "Invalid continue statement",
    [litaC_error_codes__ErrorCode_INVALID_BREAK] = "Invalid break statement",
    [litaC_error_codes__ErrorCode_INVALID_OBJECT_INIT] = "Invalid structure initializer",
    [litaC_error_codes__ErrorCode_INVALID_MODULE_ACCESS] = "Invalid module access",
    [litaC_error_codes__ErrorCode_INVALID_VARARG_POSITION] = "Invalid variable argument position",
    [litaC_error_codes__ErrorCode_INVALID_NOTE_DECL] = "Invalid note declaration, must preceed either a 'var' or 'const' declaration",
    [litaC_error_codes__ErrorCode_INVALID_LABEL_STMT] = "Invalid label statement, goto labels are only valid in functions",
    [litaC_error_codes__ErrorCode_INVALID_COMP_STMT] = "Invalid compile time statement",
    [litaC_error_codes__ErrorCode_INVALID_DEFAULT_ASSIGNMENT] = "Invalid default assignment statement, only allowed for 'struct'",
    [litaC_error_codes__ErrorCode_INVALID_TRAIT_MEMBER] = "Invalid trait member, only function pointers are allowed",
    [litaC_error_codes__ErrorCode_MISSING_COMMA] = "Missing ,",
    [litaC_error_codes__ErrorCode_MISSING_SEMICOLON] = "Missing ;",
    [litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACE] = "Missing }",
    [litaC_error_codes__ErrorCode_MISSING_EQUALS] = "Missing =",
    [litaC_error_codes__ErrorCode_MISSING_IDENTIFIER] = "Missing identifier",
    [litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACKET] = "Missing ]",
    [litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN] = "Missing )",
    [litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN] = "Missing (",
    [litaC_error_codes__ErrorCode_MISSING_LEFT_BRACE] = "Missing {",
    [litaC_error_codes__ErrorCode_MISSING_ARRAY_BRACKETS] = "Missing []",
    [litaC_error_codes__ErrorCode_MISSING_COLON] = "Missing :",
    [litaC_error_codes__ErrorCode_MISSING_WHILE] = "Missing 'while'",
    [litaC_error_codes__ErrorCode_MISSING_AS] = "Missing 'as'",
    [litaC_error_codes__ErrorCode_MISSING_GENERIC_END] = "Missing >",
    [litaC_error_codes__ErrorCode_MISSING_COMP_STMT_END] = "Missing #end",
    [litaC_error_codes__ErrorCode_RANGE_INTEGER] = "Integer literal out of range",
    [litaC_error_codes__ErrorCode_RANGE_LONG] = "Long literal out of range",
    [litaC_error_codes__ErrorCode_RANGE_REAL] = "Real literal out of range",
    [litaC_error_codes__ErrorCode_UNEXPECTED_EOF] = "Unexpected end of file",
    [litaC_error_codes__ErrorCode_UNEXPECTED_TOKEN] = "Unexpected token",
    [litaC_error_codes__ErrorCode_UNIMPLEMENTED] = "Unimplemented feature",
    [litaC_error_codes__ErrorCode_UNKNOWN_ERROR] = "An unknown error occured",
    [litaC_error_codes__ErrorCode_TOO_MANY_ERRORS] = "Too many syntax errors",
    [litaC_error_codes__ErrorCode_MAX_NUM_ERROR_CODES] = ""
};
litaC_lex__TokenType litaC_parser__DECL_ADJUST_TOKENS[11] =  {
    litaC_lex__TokenType_IMPORT,
    litaC_lex__TokenType_HASH,
    litaC_lex__TokenType_PUBLIC,
    litaC_lex__TokenType_VAR,
    litaC_lex__TokenType_CONST,
    litaC_lex__TokenType_FUNC,
    litaC_lex__TokenType_STRUCT,
    litaC_lex__TokenType_UNION,
    litaC_lex__TokenType_TRAIT,
    litaC_lex__TokenType_ENUM,
    litaC_lex__TokenType_TYPEDEF
};
litaC_lex__TokenType litaC_parser__STMT_ADJUST_TOKENS[11] =  {
    litaC_lex__TokenType_IMPORT,
    litaC_lex__TokenType_HASH,
    litaC_lex__TokenType_PUBLIC,
    litaC_lex__TokenType_VAR,
    litaC_lex__TokenType_CONST,
    litaC_lex__TokenType_FUNC,
    litaC_lex__TokenType_STRUCT,
    litaC_lex__TokenType_UNION,
    litaC_lex__TokenType_TRAIT,
    litaC_lex__TokenType_ENUM,
    litaC_lex__TokenType_TYPEDEF
};
const litaC_char* litaC_cgen__escapeStrings[256] =  {
    ['\b'] = "\\b",
    ['\f'] = "\\f",
    ['\n'] = "\\n",
    ['\r'] = "\\r",
    ['\t'] = "\\t",
    ['\\'] = "\\\\",
    ['\''] = "\\'",
    ['\0'] = "\\0"
};
const litaC_char* litaC_cgen__escapeChars[256] =  {
    ['b'] = "\\\\b",
    ['f'] = "\\\\f",
    ['n'] = "\\\\n",
    ['r'] = "\\\\r",
    ['t'] = "\\\\t",
    ['\\'] = "\\\\",
    ['\''] = "\\'",
    ['"'] = "\\\\\"",
    ['\0'] = "\\0"
};
litaC_dependency_graph__Dependency litaC_dependency_graph__EmptyDependency =  {
    .state = litaC_dependency_graph__State_EMPTY
};
const litaC_char* litaC_json__escapeStrings[256] =  {
    ['\b'] = "\\b",
    ['\f'] = "\\f",
    ['\n'] = "\\n",
    ['\r'] = "\\r",
    ['\t'] = "\\t",
    ['\\'] = "\\\\",
    ['\''] = "\\'",
    ['\0'] = "\\0"
};
const litaC_char* litaC_json__escapeChars[256] =  {
    ['b'] = "\\\\b",
    ['f'] = "\\\\f",
    ['n'] = "\\\\n",
    ['r'] = "\\\\r",
    ['t'] = "\\\\t",
    ['\\'] = "\\\\",
    ['\''] = "\\'",
    ['"'] = "\\\\\"",
    ['\0'] = "\\0"
};
litaC_json__JsonNode* litaC_json__JSON_NULL = &((litaC_json__JsonNode) {
    .alloc = NULL,
    .type = litaC_json__JsonType_NULL,
    .value =  {
        0
    }
});
litaC_json__JsonNode* litaC_json__JSON_TRUE = &((litaC_json__JsonNode) {
    .alloc = NULL,
    .type = litaC_json__JsonType_BOOLEAN,
    .value =  {
        .boolValue = litaC_true
    }
});
litaC_json__JsonNode* litaC_json__JSON_FALSE = &((litaC_json__JsonNode) {
    .alloc = NULL,
    .type = litaC_json__JsonType_BOOLEAN,
    .value =  {
        .boolValue = litaC_false
    }
});
const litaC_char* litaC_json__tokenKindNames[14] =  {
    [litaC_json__TokenKind_EOF] = "EOF",
    [litaC_json__TokenKind_ERROR] = "ERROR",
    [litaC_json__TokenKind_COMMA] = ",",
    [litaC_json__TokenKind_COLON] = ":",
    [litaC_json__TokenKind_LEFT_BRACE] = "{",
    [litaC_json__TokenKind_RIGHT_BRACE] = "}",
    [litaC_json__TokenKind_LEFT_BRACKET] = "[",
    [litaC_json__TokenKind_RIGHT_BRACKET] = "]",
    [litaC_json__TokenKind_NULL] = "null",
    [litaC_json__TokenKind_INT_NUMBER] = "int",
    [litaC_json__TokenKind_REAL_NUMBER] = "float",
    [litaC_json__TokenKind_TRUE] = "true",
    [litaC_json__TokenKind_FALSE] = "false",
    [litaC_json__TokenKind_STRING] = "string"
};
litaC_i32 litaC_json__charToDigit[256] =  {
    ['0'] = 0,
    ['1'] = 1,
    ['2'] = 2,
    ['3'] = 3,
    ['4'] = 4,
    ['5'] = 5,
    ['6'] = 6,
    ['7'] = 7,
    ['8'] = 8,
    ['9'] = 9,
    ['a'] = 10,
    ['A'] = 10,
    ['b'] = 11,
    ['B'] = 11,
    ['c'] = 12,
    ['C'] = 12,
    ['d'] = 13,
    ['D'] = 13,
    ['e'] = 14,
    ['E'] = 14,
    ['f'] = 15,
    ['F'] = 15
};
litaC_char litaC_json__escapeToChar[256] =  {
    ['0'] = '\0',
    ['\''] = '\'',
    ['"'] = '"',
    ['\\'] = '\\',
    ['n'] = '\n',
    ['r'] = '\r',
    ['t'] = '\t',
    ['/'] = '/'
};

#define litaC_lsp__VERSION ("0.12")
litaC_main__ParseStatus litaC_main__ParseArgs(litaC_i32 litaC_n,litaC_char** litaC_args,litaC_lita__LitaOptions* litaC_options) {
    litaC_cmdline__CmdParser litaC_parser = litaC_cmdline__CmdParserInit(litaC_mem__defaultAllocator);
    
    litaC_parser.header = "<usage> litac [options] [source file to compile]\nOPTIONS:";
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "languageServer", '\0', "Start the LitaC language server", 0, NULL);
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "lib", '\0', "The LitaC library path", litaC_cmdline__OptionFlag_HAS_ARGUMENT, NULL);
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "cPrefx", '\0', "The symbol prefix to use on the generated C code output", litaC_cmdline__OptionFlag_HAS_ARGUMENT, NULL);
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "cFormat", '\0', "Formats the C output", 0, NULL);
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "run", '\0', "Runs the program after a successful compile", 0, NULL);
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "checkerOnly", '\0', "Only runs the type checker, does not compile", 0, NULL);
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "cOnly", '\0', "Only creates the C output file, does not cimple the generated C code", 0, NULL);
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "profile", '\0', "Reports profile metrics of the compiler", 0, NULL);
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "disableLine", '\0', "Disables #line dorective in C output", 0, NULL);
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "debug", '\0', "Enables debug mode", 0, NULL);
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "verbose", '\0', "Enables verbose output", 0, NULL);
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "instrument", '\0', "Enables profile instrumentation of @profile annotated functions", 0, NULL);
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "srcDir", '\0', "Specifies the source code directory, defaults to the parent folder of the supplied source file", litaC_cmdline__OptionFlag_HAS_ARGUMENT, NULL);
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "doc", '\0', "Generates document output", 0, NULL);
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "docDir", '\0', "Directory where the generated documents are written to, defaults to './output'", litaC_cmdline__OptionFlag_HAS_ARGUMENT, NULL);
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "docAll", '\0', "Includes non-public types in the documentation generation", 0, NULL);
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "output", 'o', "The name of the compiled binary", litaC_cmdline__OptionFlag_HAS_ARGUMENT, NULL);
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "outputDir", '\0', "The directory in which the C ouput files are stored", litaC_cmdline__OptionFlag_HAS_ARGUMENT, NULL);
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "version", 'v', "Displays the LitaC version", 0, NULL);
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "help", 'h', "Displays this help", 0, NULL);
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "types", 't', "Includes TypeInfo for reflection\n<arg> can be:\nall       Means all types will have reflection values\ntagged    Means only basic types and types annotated with @typeinfo will have reflection values", litaC_cmdline__OptionFlag_HAS_ARGUMENT, NULL);
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "test", '\0', "Runs functions annotated with @test\n<arg> is a regex of which tests should be run", litaC_cmdline__OptionFlag_HAS_ARGUMENT, NULL);
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "testFile", '\0', "Runs functions annotated with @test in the suppplied source file only", 0, NULL);
    litaC_cmdline__CmdParser_addOption(&((litaC_parser)), "buildCmd", 'b', "The underlying C compiler build and compile command.  Variables will be substituted if found:\n%output%\tThe executable name\n%input%\tThe file(s) generated", litaC_cmdline__OptionFlag_HAS_ARGUMENT, NULL);
    if(litaC_cmdline__CmdParser_parse(&((litaC_parser)), litaC_n, litaC_args) != litaC_cmdline__CmdParserStatus_OK) {
        {
            goto err_print;
            
            
            
        }
        
    } 
    
    if(litaC_cmdline__CmdParser_hasOption(&((litaC_parser)), "version")) {
        {
            printf("Version: %s\n", litaC_lita__LITA_VERSION);
            goto terminate;
            
            
            
        }
        
    } 
    
    if(litaC_cmdline__CmdParser_hasOption(&((litaC_parser)), "help")) {
        {
            {
                litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(16, NULL);
                
                litaC_cmdline__CmdParser_printHelp(&((litaC_parser)), &((litaC_sb)));
                printf("%s\n", litaC_string_buffer__StringBuffer_cStr(&((litaC_sb))));
                litaC_string_buffer__StringBuffer_free(&((litaC_sb)));
                
                
            }
            goto terminate;
            
            
            
        }
        
    } 
    
    litaC_options->languageServer = litaC_cmdline__CmdParser_hasOption(&((litaC_parser)), "languageServer");
    if(!(litaC_options->languageServer)) {
        {
            if(litaC_array__Array_size_cb__ptr_const_char_ce_(&((litaC_parser.args))) < 2) {
                {
                    printf("Missing input file\n");
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_system__GetAbsolutePath(litaC_system__CurrentWorkingPath(), litaC_array__Array_get_cb__ptr_const_char_ce_(&((litaC_parser.args)), 1), litaC_options->inputFile);
            
            
        }
        
    } 
    
    const litaC_char* litaC_lib = litaC_system__GetEnv("LITAC_HOME");
    if(!(litaC_lib)) {
        litaC_lib = "";
        
    } 
    
    litaC_system__GetAbsolutePath("", litaC_lib, litaC_options->litaPath);
    litaC_options->checkerOnly = litaC_cmdline__CmdParser_hasOption(&((litaC_parser)), "checkerOnly");
    litaC_options->cOutputOnly = litaC_cmdline__CmdParser_hasOption(&((litaC_parser)), "cOnly");
    litaC_options->showProfileInfo = litaC_cmdline__CmdParser_hasOption(&((litaC_parser)), "profile");
    litaC_options->run = litaC_cmdline__CmdParser_hasOption(&((litaC_parser)), "run");
    litaC_options->isDebug = litaC_cmdline__CmdParser_hasOption(&((litaC_parser)), "debug");
    litaC_options->cFormat = litaC_cmdline__CmdParser_hasOption(&((litaC_parser)), "cFormat");
    litaC_options->instrument = litaC_cmdline__CmdParser_hasOption(&((litaC_parser)), "instrument");
    litaC_options->typeOption = litaC_lita__TypeInfoOption_NONE;
    if(litaC_cmdline__CmdParser_hasOption(&((litaC_parser)), "types")) {
        {
            const litaC_char* litaC_opt = litaC_cmdline__CmdParser_getOption(&((litaC_parser)), "types")->value;
            if(strcmp(litaC_opt, "all") == 0) {
                {
                    litaC_options->typeOption = litaC_lita__TypeInfoOption_ALL;
                    
                    
                }
                
            } else {
                if(strcmp(litaC_opt, "tagged") == 0) {
                    {
                        litaC_options->typeOption = litaC_lita__TypeInfoOption_TAGGED;
                        
                        
                    }
                    
                } 
                
            } 
            
            
            
        }
        
    } 
    
    if(litaC_cmdline__CmdParser_hasOption(&((litaC_parser)), "test")) {
        {
            litaC_options->testsRegex = litaC_cmdline__CmdParser_getOption(&((litaC_parser)), "test")->value;
            litaC_options->testsOnly = litaC_true;
            
            
        }
        
    } 
    
    if(litaC_cmdline__CmdParser_hasOption(&((litaC_parser)), "testFile")) {
        {
            litaC_options->testFileOnly = litaC_true;
            litaC_options->testsOnly = litaC_true;
            
            
        }
        
    } 
    
    if(litaC_cmdline__CmdParser_hasOption(&((litaC_parser)), "buildCmd")) {
        {
            litaC_options->compileCmd = litaC_cmdline__CmdParser_getOption(&((litaC_parser)), "buildCmd")->value;
            
            
        }
        
    } else {
        {
            litaC_options->compileCmd = "clang %input% -std=c99 -o %output% -D_CRT_SECURE_NO_WARNINGS";
            
            
        }
    } 
    
    const litaC_char* litaC_cPrefix = (litaC_cmdline__CmdParser_hasOption(&((litaC_parser)), "cPrefix")) ? litaC_cmdline__CmdParser_getOption(&((litaC_parser)), "cPrefix")->value : "litaC_";
    strncpy(litaC_options->cPrefix, litaC_cPrefix, litaC_lita__MAX_PREFIX_SIZE);
    const litaC_char* litaC_outputFile = (litaC_cmdline__CmdParser_hasOption(&((litaC_parser)), "output")) ? litaC_cmdline__CmdParser_getOption(&((litaC_parser)), "output")->value : "a";
    strncpy(litaC_options->outputFile, litaC_outputFile, _MAX_PATH);
    const litaC_char* litaC_outputPath = (litaC_cmdline__CmdParser_hasOption(&((litaC_parser)), "outputDir")) ? litaC_cmdline__CmdParser_getOption(&((litaC_parser)), "outputDir")->value : "./output";
    strncpy(litaC_options->outputPath, litaC_outputPath, _MAX_PATH);
    litaC_i32 litaC_len = strlen(litaC_options->outputPath);
    if(litaC_len > 0) {
        {
            if(litaC_options->outputPath[litaC_len - 1] != '/') {
                {
                    strcat(litaC_options->outputPath, "/");
                    
                    
                }
                
            } 
            
            litaC_char litaC_output[_MAX_PATH] =  {
                0
            };
            litaC_system__GetAbsolutePath(litaC_system__CurrentWorkingPath(), litaC_options->outputPath, litaC_output);
            strncpy(litaC_options->outputPath, litaC_output, _MAX_PATH);
            
            
        }
        
    } 
    
    if(litaC_cmdline__CmdParser_hasOption(&((litaC_parser)), "srcDir")) {
        {
            strncpy(litaC_options->srcPath, litaC_cmdline__CmdParser_getOption(&((litaC_parser)), "srcDir")->value, _MAX_PATH);
            
            
        }
        
    } 
    
    if(strnlen(litaC_options->srcPath, _MAX_PATH) == 0) {
        {
            litaC_system__FilePath(litaC_options->inputFile, litaC_options->srcPath);
            
            
        }
        
    } 
    
    {
        litaC_main__ParseStatus ___result = litaC_main__ParseStatus_OK;
        litaC_cmdline__CmdParser_free(&((litaC_parser)));
        return ___result;
        
    }
    
    terminate:;
    
    {
        litaC_main__ParseStatus ___result = litaC_main__ParseStatus_TERMINATE;
        litaC_cmdline__CmdParser_free(&((litaC_parser)));
        return ___result;
        
    }
    
    err_print:;
    
    {
        litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(16, NULL);
        
        litaC_cmdline__CmdParser_printHelp(&((litaC_parser)), &((litaC_sb)));
        printf("%s", litaC_string_buffer__StringBuffer_cStr(&((litaC_sb))));
        litaC_string_buffer__StringBuffer_free(&((litaC_sb)));
        
        
    }
    err:;
    
    {
        litaC_main__ParseStatus ___result = litaC_main__ParseStatus_ERROR;
        litaC_cmdline__CmdParser_free(&((litaC_parser)));
        return ___result;
        
    }
    
    litaC_cmdline__CmdParser_free(&((litaC_parser)));
    
}

litaC_void* litaC_mem__memduplicate(const litaC_void* litaC_p,litaC_usize litaC_len,const litaC_mem__Allocator* litaC_a) {
    litaC_void* litaC_copy = litaC_mem__Allocator_alloc(litaC_a, litaC_len);
    memcpy(litaC_copy, litaC_p, litaC_len);
    return litaC_copy;
    
    
}

litaC_bool litaC_mem__isPowerOfTwo(litaC_usize litaC_x) {
    return (litaC_x & (litaC_x - 1)) == 0;
    
    
}

litaC_usize litaC_mem__alignForward(litaC_usize litaC_ptr,litaC_usize litaC_align) {
    assert(litaC_mem__isPowerOfTwo(litaC_align));
    litaC_usize litaC_p = litaC_ptr;
    litaC_usize litaC_a = litaC_align;
    litaC_usize litaC_modulo = litaC_p & (litaC_a - 1);
    if(litaC_modulo != 0) {
        {
            litaC_p += (litaC_a - litaC_modulo);
            
            
        }
        
    } 
    
    return litaC_p;
    
    
}

LITAC_INLINE 
litaC_void* litaC_mem__Allocator_alloc(const litaC_mem__Allocator* litaC_a,litaC_usize litaC_size) {
    return litaC_a->allocFn(litaC_a, litaC_size);
    
    
}

LITAC_INLINE 
litaC_void* litaC_mem__Allocator_calloc(const litaC_mem__Allocator* litaC_a,litaC_usize litaC_num,litaC_usize litaC_size) {
    return litaC_a->callocFn(litaC_a, litaC_num, litaC_size);
    
    
}

LITAC_INLINE 
litaC_void* litaC_mem__Allocator_realloc(const litaC_mem__Allocator* litaC_a,litaC_void* litaC_ptr,litaC_usize litaC_oldsize,litaC_usize litaC_newsize) {
    return litaC_a->reallocFn(litaC_a, litaC_ptr, litaC_oldsize, litaC_newsize);
    
    
}

LITAC_INLINE 
litaC_void litaC_mem__Allocator_free(const litaC_mem__Allocator* litaC_a,litaC_void* litaC_ptr) {
    litaC_a->freeFn(litaC_a, litaC_ptr);
    
}

litaC_void* litaC_mem__cMalloc(const litaC_mem__Allocator* litaC_a,litaC_usize litaC_size) {
    return malloc(litaC_size);
    
    
}

litaC_void* litaC_mem__cCalloc(const litaC_mem__Allocator* litaC_a,litaC_usize litaC_num,litaC_usize litaC_size) {
    return calloc(litaC_num, litaC_size);
    
    
}

litaC_void* litaC_mem__cRealloc(const litaC_mem__Allocator* litaC_a,litaC_void* litaC_ptr,litaC_usize litaC_oldSize,litaC_usize litaC_size) {
    return realloc(litaC_ptr, litaC_size);
    
    
}

litaC_void litaC_mem__cFree(const litaC_mem__Allocator* litaC_a,litaC_void* litaC_ptr) {
    return free(litaC_ptr);
    
    
}

litaC_void litaC_mem__Arena_init(litaC_mem__Arena* litaC_arena,litaC_usize litaC_size,const litaC_mem__Allocator* litaC_alloc) {
    litaC_arena->decorated = litaC_alloc;
    litaC_arena->region = (litaC_u8*)litaC_mem__Allocator_calloc(litaC_alloc, litaC_size, sizeof(litaC_u8));
    litaC_arena->current = 0;
    litaC_arena->size = litaC_size;
    litaC_arena->next = NULL;
    litaC_arena->alloc = (litaC_mem__Allocator) {
        .allocFn = &(litaC_mem__ArenaMalloc),
        .callocFn = &(litaC_mem__ArenaCalloc),
        .reallocFn = &(litaC_mem__ArenaRealloc),
        .freeFn = &(litaC_mem__ArenaFree)
    };
    
}

litaC_void litaC_mem__Arena_free(litaC_mem__Arena* litaC_arena) {
    const litaC_mem__Allocator* litaC_alloc = litaC_arena->decorated;
    litaC_mem__Allocator_free(litaC_alloc, (litaC_void*)litaC_arena->region);
    litaC_mem__Arena* litaC_next = NULL;
    litaC_mem__Arena* litaC_last = litaC_arena->next;
    if(litaC_last == NULL) {
        {
            return;
            
            
            
        }
        
    } 
    
    do {
        {
            litaC_next = litaC_last->next;
            litaC_mem__Allocator_free(litaC_alloc, (litaC_void*)litaC_last->region);
            litaC_mem__Allocator_free(litaC_alloc, (litaC_void*)litaC_last);
            litaC_last = litaC_next;
            
            
        }
    }
    while(litaC_next != NULL);
    
}

litaC_void* litaC_mem__Arena_malloc(litaC_mem__Arena* litaC_arena,litaC_usize litaC_size) {
    litaC_mem__Arena* litaC_a = litaC_arena;
    litaC_mem__Arena* litaC_last = litaC_arena;
    do {
        {
            if((litaC_a->size - litaC_a->current) > litaC_size) {
                {
                    litaC_a->current += litaC_size;
                    return (litaC_void*)(litaC_a->region + (litaC_a->current - litaC_size));
                    
                    
                    
                }
                
            } 
            
            litaC_last = litaC_a;
            
            
        }
    }
    while((litaC_a = litaC_a->next) != NULL);
    litaC_usize litaC_asize = (litaC_size > litaC_mem__PAGE_SIZE) ? litaC_size : litaC_mem__PAGE_SIZE;
    litaC_mem__Arena* litaC_next = litaC_mem__new_cb_Arena_ce_(litaC_arena->decorated);
    litaC_mem__Arena_init(litaC_next, litaC_asize, litaC_arena->decorated);
    litaC_last->next = litaC_next;
    litaC_next->current += litaC_size;
    return (litaC_void*)litaC_next->region;
    
    
}

litaC_void* litaC_mem__ArenaMalloc(const litaC_mem__Allocator* litaC_alloc,litaC_usize litaC_size) {
    litaC_mem__Arena* litaC_arena = (litaC_mem__Arena*)litaC_alloc;
    return litaC_mem__Arena_malloc(litaC_arena, litaC_size);
    
    
}

litaC_void* litaC_mem__ArenaCalloc(const litaC_mem__Allocator* litaC_alloc,litaC_usize litaC_num,litaC_usize litaC_size) {
    litaC_mem__Arena* litaC_arena = (litaC_mem__Arena*)litaC_alloc;
    litaC_void* litaC_result = litaC_mem__Arena_malloc(litaC_arena, litaC_size * litaC_num);
    if(litaC_result) {
        {
            memset(litaC_result, 0, litaC_size * litaC_num);
            
            
        }
        
    } 
    
    return litaC_result;
    
    
}

litaC_void* litaC_mem__ArenaRealloc(const litaC_mem__Allocator* litaC_alloc,litaC_void* litaC_ptr,litaC_usize litaC_oldSize,litaC_usize litaC_size) {
    if(litaC_ptr == NULL) {
        {
            return litaC_mem__ArenaMalloc(litaC_alloc, litaC_size);
            
            
            
        }
        
    } 
    
    litaC_mem__Arena* litaC_arena = (litaC_mem__Arena*)litaC_alloc;
    litaC_void* litaC_result = litaC_mem__Arena_malloc(litaC_arena, litaC_size);
    if(litaC_result) {
        {
            litaC_usize litaC_len = MIN(litaC_oldSize, litaC_size);
            memcpy(litaC_result, litaC_ptr, litaC_len);
            litaC_mem__ArenaFree(litaC_alloc, litaC_ptr);
            
            
        }
        
    } 
    
    return litaC_result;
    
    
}

litaC_void litaC_mem__ArenaFree(const litaC_mem__Allocator* litaC_alloc,litaC_void* litaC_ptr) {
    
}

litaC_void litaC_mem__LinearAllocator_init(litaC_mem__LinearAllocator* litaC_this,litaC_void* litaC_mem,litaC_usize litaC_size) {
    litaC_this->alloc = (litaC_mem__Allocator) {
        .allocFn = &(litaC_mem__LinearMalloc),
        .callocFn = &(litaC_mem__LinearCalloc),
        .reallocFn = &(litaC_mem__LinearRealloc),
        .freeFn = &(litaC_mem__LinearFree)
    };
    litaC_this->mem = litaC_mem;
    litaC_this->size = litaC_size;
    litaC_this->totalBytesAllocated = 0;
    litaC_this->totalAllocations = 0;
    litaC_this->currentOffset = 0;
    
}


litaC_void litaC_mem__LinearAllocator_clear(litaC_mem__LinearAllocator* litaC_this) {
    memset(litaC_this->mem, 0, litaC_this->size);
    litaC_this->totalBytesAllocated = 0;
    litaC_this->totalAllocations = 0;
    litaC_this->currentOffset = 0;
    
}

litaC_void* litaC_mem__LinearAllocator_malloc(litaC_mem__LinearAllocator* litaC_this,litaC_usize litaC_size) {
    litaC_usize litaC_currPtr = (litaC_usize)litaC_this->mem + litaC_this->currentOffset;
    litaC_usize litaC_offset = litaC_mem__alignForward(litaC_currPtr, LITAC_DEFAULT_ALIGNMENT);
    litaC_offset -= (litaC_usize)litaC_this->mem;
    if((litaC_offset + litaC_size) > litaC_this->size) {
        {
            printf("Failed to allocate: %zu\n", litaC_size);
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_this->currentOffset = (litaC_size + litaC_offset);
    litaC_this->totalBytesAllocated = (litaC_size + litaC_offset);
    litaC_this->totalAllocations += 1;
    litaC_char* litaC_ptr = ((litaC_char*)litaC_this->mem) + litaC_offset;
    return litaC_ptr;
    
    
}

litaC_void* litaC_mem__LinearMalloc(const litaC_mem__Allocator* litaC_alloc,litaC_usize litaC_size) {
    litaC_mem__LinearAllocator* litaC_this = (litaC_mem__LinearAllocator*)litaC_alloc;
    return litaC_mem__LinearAllocator_malloc(litaC_this, litaC_size);
    
    
}

litaC_void* litaC_mem__LinearCalloc(const litaC_mem__Allocator* litaC_alloc,litaC_usize litaC_num,litaC_usize litaC_size) {
    litaC_mem__LinearAllocator* litaC_this = (litaC_mem__LinearAllocator*)litaC_alloc;
    litaC_void* litaC_result = litaC_mem__LinearAllocator_malloc(litaC_this, litaC_size * litaC_num);
    if(litaC_result) {
        {
            memset(litaC_result, 0, litaC_size * litaC_num);
            
            
        }
        
    } 
    
    return litaC_result;
    
    
}

litaC_void* litaC_mem__LinearRealloc(const litaC_mem__Allocator* litaC_alloc,litaC_void* litaC_ptr,litaC_usize litaC_oldSize,litaC_usize litaC_size) {
    if(litaC_ptr == NULL) {
        {
            return litaC_mem__LinearMalloc(litaC_alloc, litaC_size);
            
            
            
        }
        
    } 
    
    litaC_mem__LinearAllocator* litaC_this = (litaC_mem__LinearAllocator*)litaC_alloc;
    litaC_void* litaC_result = litaC_mem__LinearAllocator_malloc(litaC_this, litaC_size);
    if(litaC_result) {
        {
            litaC_usize litaC_len = MIN(litaC_oldSize, litaC_size);
            memcpy(litaC_result, litaC_ptr, litaC_len);
            
            
        }
        
    } 
    
    return litaC_result;
    
    
}

litaC_void litaC_mem__LinearFree(const litaC_mem__Allocator* litaC_alloc,litaC_void* litaC_ptr) {
    
}

litaC_void litaC_mem__DebugAllocator_init(litaC_mem__DebugAllocator* litaC_d,const litaC_mem__Allocator* litaC_alloc) {
    litaC_d->alloc = (litaC_mem__Allocator) {
        .allocFn = &(litaC_mem__DebugMalloc),
        .callocFn = &(litaC_mem__DebugCalloc),
        .reallocFn = &(litaC_mem__DebugRealloc),
        .freeFn = &(litaC_mem__DebugFree)
    };
    litaC_d->decorated = litaC_alloc;
    litaC_array__Array_init_cb__ptr_Allocation_ce_(&((litaC_d->allocations)), 128, litaC_alloc);
    litaC_d->totalBytesAllocated = 0;
    litaC_d->totalAllocations = 0;
    
}

litaC_void litaC_mem__DebugAllocator_free(litaC_mem__DebugAllocator* litaC_d) {
    litaC_array__Array_free_cb__ptr_Allocation_ce_(&((litaC_d->allocations)));
    
}

litaC_void litaC_mem__DebugAllocator_report(litaC_mem__DebugAllocator* litaC_d) {
    printf("Leaked Allocations: {\n");
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Allocation_ce_(&((litaC_d->allocations)));litaC_i += 1) {
        {
            litaC_mem__Allocation* litaC_a = litaC_array__Array_get_cb__ptr_Allocation_ce_(&((litaC_d->allocations)), litaC_i);
            printf("   Leak at %p allocated in '%s' at line: %ju\n", litaC_a->addr, litaC_a->filename, litaC_a->line);
            
            
        }
    }
    printf("}\n");
    
}

litaC_void* litaC_mem__DebugAllocator_malloc(litaC_mem__DebugAllocator* litaC_d,litaC_usize litaC_size,const litaC_char* litaC_file,litaC_u64 litaC_line) {
    litaC_void* litaC_mem = litaC_mem__Allocator_alloc(litaC_d->decorated, litaC_size);
    if(litaC_mem) {
        {
            litaC_mem__Allocation* litaC_allocation = litaC_mem__new_cb_Allocation_ce_(litaC_d->decorated);
            litaC_allocation->addr = litaC_mem;
            litaC_allocation->size = litaC_size;
            litaC_allocation->line = litaC_line;
            strncpy(litaC_allocation->filename, litaC_file, litaC_mem__MAX_PATH);
            litaC_array__Array_add_cb__ptr_Allocation_ce_(&((litaC_d->allocations)), litaC_allocation);
            litaC_d->totalBytesAllocated += litaC_size;
            litaC_d->totalAllocations += 1;
            
            
        }
        
    } 
    
    return litaC_mem;
    
    
}

litaC_void* litaC_mem__DebugMalloc(const litaC_mem__Allocator* litaC_alloc,litaC_usize litaC_size) {
    litaC_mem__DebugAllocator* litaC_debug = (litaC_mem__DebugAllocator*)litaC_alloc;
    return litaC_mem__DebugAllocator_malloc(litaC_debug, litaC_size, "", 0);
    
    
}

litaC_void* litaC_mem__DebugCalloc(const litaC_mem__Allocator* litaC_alloc,litaC_usize litaC_num,litaC_usize litaC_size) {
    litaC_mem__DebugAllocator* litaC_debug = (litaC_mem__DebugAllocator*)litaC_alloc;
    litaC_void* litaC_result = litaC_mem__DebugAllocator_malloc(litaC_debug, litaC_size * litaC_num, "", 0);
    if(litaC_result) {
        {
            memset(litaC_result, 0, litaC_size * litaC_num);
            
            
        }
        
    } 
    
    return litaC_result;
    
    
}

litaC_void* litaC_mem__DebugRealloc(const litaC_mem__Allocator* litaC_alloc,litaC_void* litaC_ptr,litaC_usize litaC_oldSize,litaC_usize litaC_size) {
    if(litaC_ptr == NULL) {
        {
            return litaC_mem__DebugMalloc(litaC_alloc, litaC_size);
            
            
            
        }
        
    } 
    
    litaC_mem__DebugAllocator* litaC_debug = (litaC_mem__DebugAllocator*)litaC_alloc;
    litaC_void* litaC_result = litaC_mem__DebugAllocator_malloc(litaC_debug, litaC_size, "", 0);
    if(litaC_result) {
        {
            litaC_usize litaC_len = MIN(litaC_oldSize, litaC_size);
            memcpy(litaC_result, litaC_ptr, litaC_len);
            litaC_mem__DebugFree(litaC_alloc, litaC_ptr);
            
            
        }
        
    } 
    
    return litaC_result;
    
    
}

litaC_void litaC_mem__DebugFree(const litaC_mem__Allocator* litaC_alloc,litaC_void* litaC_ptr) {
    if(litaC_ptr == NULL) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_mem__DebugAllocator* litaC_debug = (litaC_mem__DebugAllocator*)litaC_alloc;
    litaC_void* litaC_addr = litaC_ptr;
    litaC_bool litaC_found = litaC_false;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Allocation_ce_(&((litaC_debug->allocations)));) {
        {
            litaC_mem__Allocation* litaC_allocation = litaC_array__Array_get_cb__ptr_Allocation_ce_(&((litaC_debug->allocations)), litaC_i);
            if(litaC_allocation->addr == litaC_addr) {
                {
                    litaC_debug->totalBytesFreed += litaC_allocation->size;
                    litaC_array__Array_removeAt_cb__ptr_Allocation_ce_(&((litaC_debug->allocations)), litaC_i);
                    litaC_mem__Allocator_free(litaC_debug->decorated, litaC_allocation);
                    litaC_found = litaC_true;
                    break;
                    
                    
                }
                
            } else {
                {
                    litaC_i += 1;
                    
                    
                }
            } 
            
            
            
        }
    }
    if(!(litaC_found)) {
        {
            printf("Allocation not found: %p\n", litaC_ptr);
            
            
        }
        
    } 
    
    litaC_mem__Allocator_free(litaC_debug->decorated, litaC_ptr);
    
}

litaC_i64 litaC_io__FileLength(const litaC_char* litaC_fileName) {
    FILE* litaC_fp = fopen(litaC_fileName, "r");
    if(litaC_fp == NULL) {
        {
            return -(1);
            
            
            
        }
        
    } 
    
    
    if(fseek(litaC_fp, 0, SEEK_END)) {
        {
            {
                litaC_i64 ___result = -(1);
                fclose(litaC_fp);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_i64 litaC_len = ftell(litaC_fp);
    {
        litaC_i64 ___result = litaC_len;
        fclose(litaC_fp);
        return ___result;
        
    }
    
    fclose(litaC_fp);
    
}

litaC_io__FileStatus litaC_io__ReadFile(const litaC_char* litaC_fileName,litaC_char** litaC_data,const litaC_mem__Allocator* litaC_alloc) {
    FILE* litaC_fp = fopen(litaC_fileName, "r");
    if(litaC_fp == NULL) {
        {
            return litaC_io__FileStatus_FileNotFoundError;
            
            
            
        }
        
    } 
    
    
    if(fseek(litaC_fp, 0, SEEK_END)) {
        {
            {
                litaC_io__FileStatus ___result = litaC_io__FileStatus_IOError;
                fclose(litaC_fp);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_i64 litaC_len = ftell(litaC_fp);
    if(litaC_len < 0L) {
        {
            {
                litaC_io__FileStatus ___result = litaC_io__FileStatus_IOError;
                fclose(litaC_fp);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    if(fseek(litaC_fp, 0, SEEK_SET)) {
        {
            {
                litaC_io__FileStatus ___result = litaC_io__FileStatus_IOError;
                fclose(litaC_fp);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_char* litaC_buf = (litaC_char*)litaC_mem__Allocator_alloc(litaC_alloc, sizeof(litaC_char) * ((litaC_u64)litaC_len + 1UL));
    (*(litaC_data)) = litaC_buf;
    litaC_i64 litaC_newLen = fread(litaC_buf, sizeof(litaC_char), litaC_len, litaC_fp);
    if(ferror(litaC_fp)) {
        {
            {
                litaC_io__FileStatus ___result = litaC_io__FileStatus_IOError;
                fclose(litaC_fp);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_buf[litaC_newLen] = '\0';
    {
        litaC_io__FileStatus ___result = litaC_io__FileStatus_Ok;
        fclose(litaC_fp);
        return ___result;
        
    }
    
    fclose(litaC_fp);
    
}

litaC_io__FileStatus litaC_io__WriteFile(const litaC_char* litaC_fileName,const litaC_char* litaC_buffer,litaC_usize litaC_len) {
    FILE* litaC_fp = fopen(litaC_fileName, "w");
    if(litaC_fp == NULL) {
        {
            return litaC_io__FileStatus_FileNotFoundError;
            
            
            
        }
        
    } 
    
    
    {
        litaC_io__FileStatus ___result = litaC_io__WriteBytes(litaC_fp, litaC_buffer, litaC_len);
        fclose(litaC_fp);
        return ___result;
        
    }
    
    fclose(litaC_fp);
    
}

litaC_io__FileStatus litaC_io__WriteBytes(FILE* litaC_fp,const litaC_char* litaC_buffer,litaC_usize litaC_len) {
    litaC_u64 litaC_bytesWritten = fwrite((const litaC_void*)litaC_buffer, sizeof(litaC_char), litaC_len, litaC_fp);
    if(litaC_bytesWritten != litaC_len) {
        {
            return litaC_io__FileStatus_IOError;
            
            
            
        }
        
    } 
    
    return litaC_io__FileStatus_Ok;
    
    
}

litaC_cmdline__CmdParser litaC_cmdline__CmdParserInit(const litaC_mem__Allocator* litaC_allocator) {
    litaC_cmdline__CmdParser litaC_parser =  {
        
    };
    litaC_cmdline__CmdParser_init(&((litaC_parser)), litaC_allocator);
    return litaC_parser;
    
    
}

litaC_void litaC_cmdline__CmdParser_init(litaC_cmdline__CmdParser* litaC_p,const litaC_mem__Allocator* litaC_allocator) {
    litaC_p->options = litaC_array__ArrayInit_cb_Option_ce_(16, litaC_allocator);
    litaC_p->args = litaC_array__ArrayInit_cb__ptr_const_char_ce_(16, litaC_allocator);
    litaC_p->status = litaC_cmdline__CmdParserStatus_OK;
    
}

litaC_void litaC_cmdline__CmdParser_free(litaC_cmdline__CmdParser* litaC_p) {
    litaC_array__Array_free_cb_Option_ce_(&((litaC_p->options)));
    litaC_array__Array_free_cb__ptr_const_char_ce_(&((litaC_p->args)));
    
}

litaC_void litaC_cmdline__CmdParser_addOption(litaC_cmdline__CmdParser* litaC_p,const litaC_char* litaC_longName,litaC_char litaC_shortName,const litaC_char* litaC_description,litaC_i32 litaC_flags,const litaC_char* litaC_defaultValue) {
    litaC_array__Array_add_cb_Option_ce_(&((litaC_p->options)), (litaC_cmdline__Option) {
        .name = litaC_longName,
        .shortName = litaC_shortName,
        .description = litaC_description,
        .value = NULL,
        .flags = litaC_flags,
        .defaultValue = litaC_defaultValue
    });
    
}

litaC_cmdline__Option* litaC_cmdline__CmdParser_getOption(litaC_cmdline__CmdParser* litaC_p,const litaC_char* litaC_longName) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_Option_ce_(&((litaC_p->options)));litaC_i += 1) {
        {
            litaC_cmdline__Option* litaC_opt = &(litaC_p->options.elements[litaC_i]);
            if(strcmp(litaC_opt->name, litaC_longName) == 0) {
                {
                    return litaC_opt;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return NULL;
    
    
}

litaC_cmdline__Option* litaC_cmdline__CmdParser_getOptionShort(litaC_cmdline__CmdParser* litaC_p,litaC_char litaC_shortName) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_Option_ce_(&((litaC_p->options)));litaC_i += 1) {
        {
            litaC_cmdline__Option* litaC_opt = &(litaC_p->options.elements[litaC_i]);
            if(litaC_opt->shortName == litaC_shortName) {
                {
                    return litaC_opt;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return NULL;
    
    
}

litaC_bool litaC_cmdline__CmdParser_hasOption(litaC_cmdline__CmdParser* litaC_p,const litaC_char* litaC_longName) {
    litaC_cmdline__Option* litaC_opt = litaC_cmdline__CmdParser_getOption(litaC_p, litaC_longName);
    if(!(litaC_opt)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_opt->flags & litaC_cmdline__OptionFlag_IS_USED;
    
    
}

litaC_bool litaC_cmdline__CmdParser_hasOptionShort(litaC_cmdline__CmdParser* litaC_p,litaC_char litaC_shortName) {
    litaC_cmdline__Option* litaC_opt = litaC_cmdline__CmdParser_getOptionShort(litaC_p, litaC_shortName);
    if(!(litaC_opt)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_opt->flags & litaC_cmdline__OptionFlag_IS_USED;
    
    
}

litaC_cmdline__CmdParserStatus litaC_cmdline__CmdParser_parse(litaC_cmdline__CmdParser* litaC_p,litaC_i32 litaC_argc,litaC_char** litaC_argv) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_argc;litaC_i += 1) {
        {
            litaC_char* litaC_arg = litaC_argv[litaC_i];
            litaC_i32 litaC_len = strlen(litaC_arg);
            litaC_cmdline__Option* litaC_opt = NULL;
            if(litaC_len && litaC_arg[0] == '-') {
                {
                    litaC_char* litaC_normalizedArg = litaC_arg + 1;
                    litaC_opt = (litaC_len < 3) ? litaC_cmdline__CmdParser_getOptionShort(litaC_p, litaC_normalizedArg[0]) : litaC_cmdline__CmdParser_getOption(litaC_p, litaC_normalizedArg);
                    
                    
                }
                
            } 
            
            if(litaC_opt) {
                {
                    if(litaC_opt->flags & litaC_cmdline__OptionFlag_HAS_ARGUMENT) {
                        {
                            if(litaC_i + 1 >= litaC_argc) {
                                {
                                    snprintf(litaC_p->errors, litaC_cmdline__MAX_MESSAGE_SIZE, "'%s' is missing argument", litaC_arg);
                                    litaC_p->status = litaC_cmdline__CmdParserStatus_MISSING_ARGUMENT;
                                    return litaC_p->status;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_opt->value = litaC_argv[litaC_i + 1];
                            litaC_i += 1;
                            
                            
                        }
                        
                    } 
                    
                    litaC_opt->flags |= litaC_cmdline__OptionFlag_IS_USED;
                    
                    
                }
                
            } else {
                {
                    litaC_array__Array_add_cb__ptr_const_char_ce_(&((litaC_p->args)), litaC_arg);
                    
                    
                }
            } 
            
            
            
        }
    }
    return litaC_cmdline__CmdParserStatus_OK;
    
    
}

litaC_void litaC_cmdline__CmdParser_printHelp(litaC_cmdline__CmdParser* litaC_p,litaC_string_buffer__StringBuffer* litaC_sb) {
    if(litaC_p->header) {
        {
            litaC_string_buffer__StringBuffer_append(litaC_sb, "%s\n", litaC_p->header);
            
            
        }
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_Option_ce_(&((litaC_p->options)));litaC_i += 1) {
        {
            litaC_cmdline__Option* litaC_opt = &(litaC_p->options.elements[litaC_i]);
            if(litaC_opt->shortName != '\0') {
                {
                    litaC_string_buffer__StringBuffer_append(litaC_sb, "    -%c, -%-16s", litaC_opt->shortName, litaC_opt->name);
                    
                    
                }
                
            } else {
                {
                    litaC_string_buffer__StringBuffer_append(litaC_sb, "    -%-20s", litaC_opt->name);
                    
                    
                }
            } 
            
            const litaC_char* litaC_it = litaC_opt->description;
            while(*(litaC_it)) {
                {
                    litaC_char litaC_c = *(litaC_it);
                    
                    if(litaC_c == '\n') {
                        {
                            litaC_string_buffer__StringBuffer_append(litaC_sb, "\n%25s", "");
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_string_buffer__StringBuffer_append(litaC_sb, "%c", litaC_c);
                            
                            
                        }
                    } 
                    
                    litaC_it += 1;
                    
                    
                }
            }
            litaC_string_buffer__StringBuffer_append(litaC_sb, "\n");
            
            
        }
    }
    
}

litaC_string_buffer__StringBuffer litaC_string_buffer__StringBufferInit(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_string_buffer__StringBuffer litaC_sb =  {
        
    };
    litaC_string_buffer__StringBuffer_init(&((litaC_sb)), litaC_initialSize, litaC_alloc);
    return litaC_sb;
    
    
}

litaC_void litaC_string_buffer__StringBuffer_init(litaC_string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_b->alloc = litaC_alloc;
    litaC_b->length = 0;
    litaC_b->capacity = litaC_initialSize;
    litaC_i32 litaC_length = litaC_initialSize;
    litaC_b->buffer = (litaC_char*)litaC_mem__Allocator_calloc(litaC_alloc, litaC_length, sizeof(litaC_char));
    
}

litaC_void litaC_string_buffer__StringBuffer_free(litaC_string_buffer__StringBuffer* litaC_b) {
    if(litaC_b && litaC_b->buffer) {
        {
            litaC_mem__Allocator_free(litaC_b->alloc, (litaC_void*)litaC_b->buffer);
            litaC_b->buffer = NULL;
            litaC_b->length = 0;
            litaC_b->capacity = 0;
            
            
        }
        
    } 
    
    
}

litaC_void litaC_string_buffer__StringBuffer_appendStr(litaC_string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_str) {
    if(litaC_str == NULL) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_len = strlen(litaC_str);
    litaC_string_buffer__StringBuffer_appendStrn(litaC_b, litaC_str, litaC_len);
    
}

litaC_void litaC_string_buffer__StringBuffer_appendStrn(litaC_string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len) {
    if(litaC_str == NULL || litaC_len < 1) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_b->length + litaC_len > litaC_b->capacity) {
        {
            litaC_string_buffer__BufferGrow(litaC_b, litaC_len);
            
            
        }
        
    } 
    
    memcpy((litaC_void*)(&(litaC_b->buffer[litaC_b->length])), (const litaC_void*)litaC_str, litaC_len * sizeof(litaC_char));
    litaC_b->length += litaC_len;
    
}

litaC_i32 litaC_string_buffer__StringBuffer_appendFloat(litaC_string_buffer__StringBuffer* litaC_b,litaC_f64 litaC_f) {
    return litaC_string_buffer__StringBuffer_append(litaC_b, "%f", litaC_f);
    
    
}

litaC_i32 litaC_string_buffer__StringBuffer_appendI32(litaC_string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_i) {
    return litaC_string_buffer__StringBuffer_append(litaC_b, "%d", litaC_i);
    
    
}

litaC_i32 litaC_string_buffer__StringBuffer_appendI64(litaC_string_buffer__StringBuffer* litaC_b,litaC_i64 litaC_i) {
    return litaC_string_buffer__StringBuffer_append(litaC_b, "%ld", litaC_i);
    
    
}

litaC_i32 litaC_string_buffer__StringBuffer_appendU32(litaC_string_buffer__StringBuffer* litaC_b,litaC_u32 litaC_i) {
    return litaC_string_buffer__StringBuffer_append(litaC_b, "%u", litaC_i);
    
    
}

litaC_i32 litaC_string_buffer__StringBuffer_appendU64(litaC_string_buffer__StringBuffer* litaC_b,litaC_u64 litaC_i) {
    return litaC_string_buffer__StringBuffer_append(litaC_b, "%lu", litaC_i);
    
    
}

litaC_i32 litaC_string_buffer__StringBuffer_appendChar(litaC_string_buffer__StringBuffer* litaC_b,litaC_char litaC_c) {
    if(litaC_b->length + 1 >= litaC_b->capacity) {
        {
            litaC_string_buffer__BufferGrow(litaC_b, 1);
            
            
        }
        
    } 
    
    litaC_b->buffer[litaC_b->length] = litaC_c;
    litaC_b->length += 1;
    return litaC_b->length;
    
    
}

litaC_i32 litaC_string_buffer__StringBuffer_append(litaC_string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_format,...) {
    va_list litaC_args1;
    va_start(litaC_args1, litaC_format);
    litaC_i32 litaC_len = _vscprintf(litaC_format, litaC_args1);
    if(litaC_b->length + litaC_len >= litaC_b->capacity) {
        {
            litaC_string_buffer__BufferGrow(litaC_b, (litaC_len + 1) - litaC_b->capacity);
            
            
        }
        
    } 
    
    litaC_len = vsnprintf(&(litaC_b->buffer[litaC_b->length]), litaC_len + 1, litaC_format, litaC_args1);
    va_end(litaC_args1);
    if(litaC_len < 0) {
        {
            return litaC_len;
            
            
            
        }
        
    } 
    
    litaC_b->length += litaC_len;
    return litaC_len;
    
    
}

litaC_i32 litaC_string_buffer__StringBuffer_appendArgs(litaC_string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_format,va_list litaC_args) {
    va_list litaC_copyArgs;
    va_copy(litaC_copyArgs, litaC_args);
    litaC_i32 litaC_len = _vscprintf(litaC_format, litaC_copyArgs);
    if(litaC_b->length + litaC_len >= litaC_b->capacity) {
        {
            litaC_string_buffer__BufferGrow(litaC_b, (litaC_len + 1) - litaC_b->capacity);
            
            
        }
        
    } 
    
    litaC_len = vsnprintf(&(litaC_b->buffer[litaC_b->length]), litaC_len + 1, litaC_format, litaC_copyArgs);
    va_end(litaC_copyArgs);
    if(litaC_len < 0) {
        {
            return litaC_len;
            
            
            
        }
        
    } 
    
    litaC_b->length += litaC_len;
    return litaC_len;
    
    
}

litaC_void litaC_string_buffer__StringBuffer_delete(litaC_string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_start,litaC_i32 litaC_end) {
    if(litaC_b->length == 0) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_start < 0) {
        {
            litaC_start = 0;
            
            
        }
        
    } 
    
    if(litaC_end > litaC_b->length) {
        {
            litaC_end = litaC_b->length;
            
            
        }
        
    } 
    
    if(litaC_start > litaC_end) {
        {
            return;
            
            
            
        }
        
    } 
    
    memmove((litaC_void*)(&(litaC_b->buffer[litaC_start])), (const litaC_void*)(&(litaC_b->buffer[litaC_end])), (litaC_b->length - litaC_end) * sizeof(litaC_char));
    litaC_b->length -= (litaC_end - litaC_start);
    
}

litaC_bool litaC_string_buffer__StringBuffer_contains(litaC_string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len) {
    return litaC_string_buffer__StringBuffer_indexOf(litaC_b, litaC_str, litaC_len) > -(1);
    
    
}

litaC_i32 litaC_string_buffer__StringBuffer_indexOf(litaC_string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len) {
    return litaC_string_buffer__StringBuffer_indexOfAt(litaC_b, litaC_str, litaC_len, 0);
    
    
}

litaC_i32 litaC_string_buffer__StringBuffer_indexOfAt(litaC_string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len,litaC_i32 litaC_fromIndex) {
    litaC_string_view__StringView litaC_view = litaC_string_buffer__StringBuffer_asStringView(litaC_b);
    return litaC_string_view__StringView_indexOfAt(litaC_view, litaC_str, litaC_len, litaC_fromIndex);
    
    
}

litaC_i32 litaC_string_buffer__StringBuffer_replace(litaC_string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_start,litaC_i32 litaC_end,const litaC_char* litaC_str) {
    litaC_string_buffer__StringBuffer_delete(litaC_b, litaC_start, litaC_end);
    return litaC_string_buffer__StringBuffer_insert(litaC_b, litaC_start, "%s", litaC_str);
    
    
}

litaC_i32 litaC_string_buffer__StringBuffer_insert(litaC_string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_index,const litaC_char* litaC_format,...) {
    if(litaC_index < 0) {
        {
            litaC_index = 0;
            
            
        }
        
    } 
    
    if(litaC_index > litaC_b->length) {
        {
            litaC_index = litaC_b->length;
            
            
        }
        
    } 
    
    va_list litaC_args;
    va_start(litaC_args, litaC_format);
    litaC_i32 litaC_len = _vscprintf(litaC_format, litaC_args);
    if(litaC_len < 0) {
        {
            return litaC_len;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_required = litaC_b->length + litaC_len + 1;
    if(litaC_required >= litaC_b->capacity) {
        {
            litaC_string_buffer__BufferGrow(litaC_b, litaC_required - litaC_b->capacity);
            
            
        }
        
    } 
    
    litaC_char litaC_startChar = litaC_b->buffer[litaC_index];
    litaC_i32 litaC_moveLength = litaC_b->length - litaC_index;
    memmove((litaC_void*)(&(litaC_b->buffer[litaC_index + litaC_len])), (const litaC_void*)(&(litaC_b->buffer[litaC_index])), litaC_moveLength * sizeof(litaC_char));
    litaC_i32 litaC_n = vsnprintf(&(litaC_b->buffer[litaC_index]), litaC_len + 1, litaC_format, litaC_args);
    va_end(litaC_args);
    if(litaC_n < 0) {
        {
            return litaC_n;
            
            
            
        }
        
    } 
    
    litaC_b->buffer[litaC_index + litaC_len] = litaC_startChar;
    litaC_b->length += litaC_n;
    return litaC_len;
    
    
}

litaC_i32 litaC_string_buffer__StringBuffer_copyTo(litaC_string_buffer__StringBuffer* litaC_b,litaC_char* litaC_buf,litaC_i32 litaC_len,litaC_bool litaC_addZero) {
    litaC_string_view__StringView litaC_view = litaC_string_buffer__StringBuffer_asStringView(litaC_b);
    return litaC_string_view__StringView_copyTo(litaC_view, litaC_buf, litaC_len, litaC_addZero);
    
    
}

litaC_void litaC_string_buffer__StringBuffer_forEach(litaC_string_buffer__StringBuffer* litaC_b,litaC_bool (*litaC_fn)(litaC_char)) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_b->length;litaC_i += 1) {
        {
            if(litaC_fn(litaC_b->buffer[litaC_i])) {
                {
                    break;
                    
                    
                }
                
            } 
            
            
            
        }
    }
    
}

LITAC_INLINE 
litaC_bool litaC_string_buffer__StringBuffer_empty(litaC_string_buffer__StringBuffer* litaC_b) {
    return litaC_b->length == 0;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_string_buffer__StringBuffer_size(litaC_string_buffer__StringBuffer* litaC_b) {
    return litaC_b->length;
    
    
}

LITAC_INLINE 
litaC_void litaC_string_buffer__StringBuffer_clear(litaC_string_buffer__StringBuffer* litaC_b) {
    litaC_b->length = 0;
    
}

const litaC_char* litaC_string_buffer__StringBuffer_cStrConst(litaC_string_buffer__StringBuffer* litaC_b) {
    return (const litaC_char*)litaC_string_buffer__StringBuffer_cStr(litaC_b);
    
    
}

litaC_char* litaC_string_buffer__StringBuffer_cStr(litaC_string_buffer__StringBuffer* litaC_b) {
    if(litaC_b->length + 1 > litaC_b->capacity) {
        {
            litaC_string_buffer__BufferGrow(litaC_b, 1);
            
            
        }
        
    } 
    
    litaC_b->buffer[litaC_b->length] = '\0';
    return litaC_b->buffer;
    
    
}

LITAC_INLINE 
litaC_string_view__StringView litaC_string_buffer__StringBuffer_asStringView(litaC_string_buffer__StringBuffer* litaC_b) {
    return (litaC_string_view__StringView) {
        .buffer = litaC_b->buffer,
        .length = litaC_b->length
    };
    
    
}

litaC_char litaC_string_buffer__StringBuffer_get(litaC_string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_index) {
    if(litaC_index < 0 || litaC_index >= litaC_b->length) {
        {
            return '\0';
            
            
            
        }
        
    } 
    
    return litaC_b->buffer[litaC_index];
    
    
}

litaC_void litaC_string_buffer__StringBuffer_reserve(litaC_string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_length) {
    litaC_i32 litaC_available = litaC_b->capacity - litaC_b->length;
    if(litaC_available >= litaC_length) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_string_buffer__BufferGrow(litaC_b, litaC_length - litaC_available);
    
}

litaC_void litaC_string_buffer__BufferGrow(litaC_string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_b->capacity * 2;
    litaC_i32 litaC_minReq = litaC_b->capacity + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_char) * (litaC_u64)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_char) * (litaC_u64)litaC_b->capacity);
    litaC_char* litaC_newBuffer = (litaC_char*)litaC_mem__Allocator_realloc(litaC_b->alloc, (litaC_void*)litaC_b->buffer, litaC_oldlength, litaC_newlength);
    assert(litaC_newBuffer);
    litaC_b->buffer = litaC_newBuffer;
    litaC_b->capacity = litaC_n;
    
}

litaC_string_view__StringView litaC_string_view__StringViewInit(const litaC_char* litaC_str,litaC_i32 litaC_len) {
    if(litaC_str == NULL) {
        {
            return (litaC_string_view__StringView) {
                .buffer = NULL,
                .length = 0
            };
            
            
            
        }
        
    } 
    
    return (litaC_string_view__StringView) {
        .buffer = litaC_str,
        .length = ((litaC_len < 0)) ? strlen(litaC_str) : litaC_len
    };
    
    
}

litaC_u32 litaC_string_view__StringView_hash(litaC_string_view__StringView litaC_b) {
    litaC_u32 litaC_hash = 5381U;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_b.length;litaC_i += 1) {
        {
            litaC_hash = ((litaC_hash << 5U) + litaC_hash) ^ ((litaC_u32)(litaC_b.buffer[litaC_i]));
            
            
        }
    }
    return litaC_hash;
    
    
}

litaC_string_view__StringView litaC_string_view__StringView_substring(litaC_string_view__StringView litaC_b,litaC_i32 litaC_start,litaC_i32 litaC_end) {
    litaC_i32 litaC_endIndex = (litaC_end < 0) ? litaC_b.length : litaC_end;
    if(litaC_endIndex <= litaC_start || litaC_start < 0 || litaC_start >= litaC_b.length) {
        {
            return (litaC_string_view__StringView) {
                .buffer = NULL,
                .length = 0
            };
            
            
            
        }
        
    } 
    
    return (litaC_string_view__StringView) {
        .buffer = &(litaC_b.buffer[litaC_start]),
        .length = litaC_endIndex - litaC_start
    };
    
    
}

litaC_bool litaC_string_view__StringView_startsWith(litaC_string_view__StringView litaC_b,const litaC_char* litaC_prefix,litaC_i32 litaC_len,litaC_i32 litaC_fromIndex) {
    if(!(litaC_prefix)) {
        return litaC_false;
        
        
    } 
    
    const litaC_char* litaC_ta = litaC_b.buffer;
    litaC_i32 litaC_to = litaC_fromIndex;
    const litaC_char* litaC_pa = litaC_prefix;
    litaC_i32 litaC_po = 0;
    litaC_i32 litaC_pc = ((litaC_len < 0)) ? strlen(litaC_prefix) : litaC_len;
    if((litaC_fromIndex < 0) || (litaC_fromIndex > litaC_b.length - litaC_pc)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    while((litaC_pc -= 1) >= 0) {
        {
            if(litaC_ta[litaC_to] != litaC_pa[litaC_po]) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_to += 1;
            litaC_po += 1;
            
            
        }
    }
    return litaC_true;
    
    
}

litaC_bool litaC_string_view__StringView_endsWith(litaC_string_view__StringView litaC_b,const litaC_char* litaC_suffix,litaC_i32 litaC_len) {
    if(!(litaC_suffix)) {
        return litaC_false;
        
        
    } 
    
    litaC_len = ((litaC_len < 0)) ? strlen(litaC_suffix) : litaC_len;
    return litaC_string_view__StringView_startsWith(litaC_b, litaC_suffix, litaC_len, litaC_b.length - litaC_len);
    
    
}

litaC_bool litaC_string_view__StringView_equals(litaC_string_view__StringView litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len) {
    if(!(litaC_str)) {
        {
            return litaC_b.buffer == NULL;
            
            
            
        }
        
    } 
    
    litaC_len = ((litaC_len < 0)) ? strlen(litaC_str) : litaC_len;
    if(litaC_b.length != litaC_len) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    return strncmp(litaC_b.buffer, litaC_str, litaC_len) == 0;
    
    
}

litaC_bool litaC_string_view__StringView_equalsStringView(litaC_string_view__StringView litaC_b,litaC_string_view__StringView litaC_other) {
    return litaC_string_view__StringView_equals(litaC_b, litaC_other.buffer, litaC_other.length);
    
    
}

litaC_bool litaC_string_view__StringView_contains(litaC_string_view__StringView litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len) {
    return litaC_string_view__StringView_indexOf(litaC_b, litaC_str, litaC_len) > -(1);
    
    
}

litaC_i32 litaC_string_view__StringView_indexOf(litaC_string_view__StringView litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len) {
    return litaC_string_view__StringView_indexOfAt(litaC_b, litaC_str, litaC_len, 0);
    
    
}

litaC_i32 litaC_string_view__StringView_indexOfAt(litaC_string_view__StringView litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len,litaC_i32 litaC_fromIndex) {
    if(!(litaC_str)) {
        return -(1);
        
        
    } 
    
    const litaC_char* litaC_target = litaC_str;
    const litaC_char* litaC_source = litaC_b.buffer;
    litaC_i32 litaC_targetOffset = 0;
    litaC_i32 litaC_sourceOffset = 0;
    litaC_char litaC_first = litaC_target[0];
    litaC_i32 litaC_targetCount = litaC_len;
    if(litaC_len < 0) {
        {
            litaC_targetCount = strlen(litaC_str);
            
            
        }
        
    } 
    
    litaC_i32 litaC_max = litaC_sourceOffset + (litaC_b.length - litaC_targetCount);
    for(litaC_i32 litaC_i = litaC_sourceOffset + litaC_fromIndex;litaC_i <= litaC_max;litaC_i += 1) {
        {
            if(litaC_source[litaC_i] != litaC_first) {
                {
                    while(litaC_i <= litaC_max && litaC_source[litaC_i] != litaC_first) {
                        {
                            litaC_i += 1;
                            
                            
                        }
                    }
                    
                    
                }
                
            } 
            
            if(litaC_i <= litaC_max) {
                {
                    litaC_i32 litaC_j = litaC_i + 1;
                    litaC_i32 litaC_end = litaC_j + litaC_targetCount - 1;
                    for(litaC_i32 litaC_k = litaC_targetOffset + 1;litaC_j < litaC_end && litaC_source[litaC_j] == litaC_target[litaC_k];) {
                        {
                            litaC_j += 1;
                            litaC_k += 1;
                            
                            
                        }
                    }
                    if(litaC_j == litaC_end) {
                        {
                            return litaC_i - litaC_sourceOffset;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return -(1);
    
    
}

litaC_i32 litaC_string_view__StringView_copyTo(litaC_string_view__StringView litaC_b,litaC_char* litaC_buf,litaC_i32 litaC_len,litaC_bool litaC_addZero) {
    if(!(litaC_buf) || litaC_len == 0) {
        return 0;
        
        
    } 
    
    litaC_i32 litaC_bytesCopied = litaC_len;
    if(litaC_b.length < litaC_len) {
        {
            litaC_bytesCopied = litaC_b.length;
            
            
        }
        
    } 
    
    memcpy((litaC_void*)litaC_buf, (const litaC_void*)(&(litaC_b.buffer[0])), litaC_bytesCopied * sizeof(litaC_char));
    if(litaC_addZero) {
        litaC_buf[litaC_bytesCopied] = '\0';
        
    } 
    
    return (litaC_bytesCopied);
    
    
}

litaC_string_view__StringView litaC_string_view__StringView_copy(litaC_string_view__StringView litaC_s,const litaC_mem__Allocator* litaC_allocator) {
    if(litaC_s.length < 1) {
        {
            return (litaC_string_view__StringView) {
                .buffer = NULL,
                .length = 0
            };
            
            
            
        }
        
    } 
    
    litaC_char* litaC_copiedStr = (litaC_char*)litaC_mem__Allocator_alloc(litaC_allocator, (litaC_s.length + 1) * sizeof(litaC_char));
    memcpy(litaC_copiedStr, litaC_s.buffer, litaC_s.length);
    litaC_copiedStr[litaC_s.length] = '\0';
    return (litaC_string_view__StringView) {
        .buffer = litaC_copiedStr,
        .length = litaC_s.length
    };
    
    
}

litaC_void litaC_string_view__StringView_forEach(litaC_string_view__StringView litaC_b,litaC_bool (*litaC_fn)(litaC_char)) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_b.length;litaC_i += 1) {
        {
            if(litaC_fn(litaC_b.buffer[litaC_i])) {
                {
                    break;
                    
                    
                }
                
            } 
            
            
            
        }
    }
    
}

litaC_bool litaC_string_view__StringView_empty(litaC_string_view__StringView litaC_b) {
    return litaC_b.length == 0;
    
    
}

litaC_i32 litaC_string_view__StringView_size(litaC_string_view__StringView litaC_b) {
    return litaC_b.length;
    
    
}

litaC_void litaC_string_view__StringView_clear(litaC_string_view__StringView litaC_b) {
    litaC_b.length = 0;
    
}

litaC_char litaC_string_view__StringView_get(litaC_string_view__StringView litaC_b,litaC_i32 litaC_index) {
    if(litaC_index < 0 || litaC_index >= litaC_b.length) {
        {
            return '\0';
            
            
            
        }
        
    } 
    
    return litaC_b.buffer[litaC_index];
    
    
}

const litaC_char* litaC_system__OSAsStr(Lita_OSType litaC_type) {
    switch(litaC_type) {
        case Lita_OSType_WINDOWS: {
            return "WINDOWS";
            
            
            
        }
        case Lita_OSType_ANDROID: {
            return "ANDROID";
            
            
            
        }
        case Lita_OSType_LINUX: {
            return "LINUX";
            
            
            
        }
        case Lita_OSType_BSD: {
            return "BSD";
            
            
            
        }
        case Lita_OSType_IOS: {
            return "IOS";
            
            
            
        }
        case Lita_OSType_MAC: {
            return "MAC";
            
            
            
        }
        case Lita_OSType_OTHER: {
            return "OTHER";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}



litaC_bool litaC_system__SystemInit() {
    return litaC_system_win___SystemInit();
    
    
}

Lita_OSType litaC_system__GetOS() {
    return litaOS;
    
    
}

litaC_char* litaC_system__GetEnv(const litaC_char* litaC_varName) {
    return getenv(litaC_varName);
    
    
}

const litaC_char* litaC_system__CurrentWorkingPath() {
    return litaC_system_win___CurrentWorkingPath();
    
    
}

litaC_bool litaC_system__FileExists(const litaC_char* litaC_filename) {
    FileStat litaC_s;
    return _stat(litaC_filename, &(litaC_s)) == 0;
    
    
}

litaC_bool litaC_system__Mkdir(const litaC_char* litaC_dir) {
    return litaC_system_win___Mkdir(litaC_dir);
    
    
}

litaC_char* litaC_system__FilePath(const litaC_char* litaC_filename,litaC_char* litaC_out) {
    litaC_i32 litaC_index = 0;
    if(!(litaC_filename)) {
        {
            goto end;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_len = strlen(litaC_filename);
    if(litaC_len > 0) {
        {
            for(litaC_index = litaC_len - 1;
            litaC_index >= 0;litaC_index -= 1) {
                {
                    litaC_char litaC_c = litaC_filename[litaC_index];
                    if(litaC_c == '/' || litaC_c == '\\') {
                        {
                            memcpy(litaC_out, litaC_filename, litaC_index);
                            goto end;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            litaC_index = 0;
            
            
        }
        
    } 
    
    end:;
    
    litaC_out[litaC_index] = '\0';
    return litaC_out;
    
    
}

litaC_i32 litaC_system__strcicmp(const litaC_char* litaC_a,const litaC_char* litaC_b) {
    if(litaC_a == litaC_b) {
        return 0;
        
        
    } 
    
    if(!(litaC_a) && litaC_b) {
        return -(1);
        
        
    } 
    
    if(litaC_a && !(litaC_b)) {
        return 1;
        
        
    } 
    
    for(;;) {
        {
            litaC_char litaC_ac = *(litaC_a);
            litaC_char litaC_bc = *(litaC_b);
            if(!(litaC_ac) && litaC_bc) {
                return -(1);
                
                
            } 
            
            if(litaC_ac && !(litaC_bc)) {
                return 1;
                
                
            } 
            
            if(!(litaC_ac) && !(litaC_bc)) {
                return 0;
                
                
            } 
            
            litaC_i32 litaC_d = tolower(litaC_ac) - tolower(litaC_bc);
            if(litaC_d != 0) {
                {
                    return litaC_d;
                    
                    
                    
                }
                
            } 
            
            litaC_a += 1;
            litaC_b += 1;
            
            
        }
    }
    return 0;
    
    
}

litaC_char* litaC_system__GetAbsolutePath(const litaC_char* litaC_pwd,const litaC_char* litaC_path,litaC_char* litaC_output) {
    litaC_string__String litaC_absStr = litaC_string__StringInit(litaC_output, _MAX_PATH, 0);
    litaC_string_view__StringView litaC_pathStr = litaC_string_view__StringViewInit(litaC_path, -(1));
    if(litaC_string_view__StringView_startsWith(litaC_pathStr, ".", -(1), 0)) {
        {
            litaC_string__String_append(&((litaC_absStr)), "%s/", litaC_pwd);
            
            
        }
        
    } 
    
    const litaC_char* litaC_start = litaC_path;
    while(*(litaC_path)) {
        {
            if(litaC_path[0] == '\\') {
                {
                    if(litaC_path[1] == '\\') {
                        {
                            litaC_path += 1;
                            
                            
                        }
                        
                    } 
                    
                    litaC_string__String_appendChar(&((litaC_absStr)), '/');
                    
                    
                }
                
            } else {
                if(litaC_path[0] == '.') {
                    {
                        if(litaC_path[1] == '.') {
                            {
                                litaC_i32 litaC_len = litaC_absStr.length;
                                litaC_i32 litaC_index = litaC_len - 1;
                                litaC_i32 litaC_upCount = 0;
                                for(;litaC_index >= 0;litaC_index -= 1) {
                                    {
                                        if(litaC_absStr.buffer[litaC_index] == '/' || litaC_absStr.buffer[litaC_index] == '\\') {
                                            {
                                                litaC_upCount += 1;
                                                if(litaC_upCount > 1) {
                                                    {
                                                        break;
                                                        
                                                        
                                                    }
                                                    
                                                } 
                                                
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        
                                        
                                    }
                                }
                                if(litaC_index < 0) {
                                    {
                                        litaC_index = 0;
                                        
                                        
                                    }
                                    
                                } 
                                
                                litaC_absStr.length = litaC_index;
                                if(litaC_absStr.buffer[litaC_index] == '/' || litaC_absStr.buffer[litaC_index] == '\\') {
                                    {
                                        litaC_absStr.length = litaC_index + 1;
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } else {
                            if(litaC_path[1] == '/' || litaC_path[1] == '\\') {
                                {
                                    litaC_path += 1;
                                    
                                    
                                }
                                
                            } else {
                                {
                                    litaC_string__String_appendChar(&((litaC_absStr)), '.');
                                    
                                    
                                }
                            } 
                            
                        } 
                        
                        
                        
                    }
                    
                } else {
                    {
                        litaC_string__String_appendChar(&((litaC_absStr)), *(litaC_path));
                        
                        
                    }
                } 
                
            } 
            
            litaC_path += 1;
            
            
        }
    }
    return litaC_string__String_cStr(litaC_absStr);
    
    
}

litaC_bool litaC_system__PathEquals(const litaC_char* litaC_a,const litaC_char* litaC_b) {
    return litaC_system__strcicmp(litaC_a, litaC_b) == 0;
    
    
}

litaC_char* litaC_system__FilePathToUri(const litaC_char* litaC_path,litaC_char* litaC_output) {
    litaC_string__String litaC_outputStr = litaC_string__StringInit(litaC_output, _MAX_PATH, 0);
    litaC_string__String_append(&((litaC_outputStr)), "%s", "file:///");
    while(*(litaC_path)) {
        {
            const litaC_char* litaC_escaped = litaC_system__uriEscapeChars[*(litaC_path)];
            if(litaC_escaped) {
                {
                    litaC_string__String_append(&((litaC_outputStr)), "%s", litaC_escaped);
                    
                    
                }
                
            } else {
                {
                    litaC_string__String_appendChar(&((litaC_outputStr)), *(litaC_path));
                    
                    
                }
            } 
            
            litaC_path += 1;
            
            
        }
    }
    return litaC_string__String_cStr(litaC_outputStr);
    
    
}

litaC_char* litaC_system__UriToFilePath(const litaC_char* litaC_uri,litaC_char* litaC_output) {
    if(strncmp(litaC_uri, "file:///", 8) == 0) {
        {
            litaC_uri = &(litaC_uri[8]);
            
            
        }
        
    } 
    
    litaC_string__String litaC_outputStr = litaC_string__StringInit(litaC_output, _MAX_PATH, 0);
    while(*(litaC_uri)) {
        {
            if(*(litaC_uri) == '%') {
                {
                    litaC_char litaC_escaped[2] =  {
                        0
                    };
                    if(litaC_uri[1] == '2') {
                        {
                            if(litaC_uri[2] == '1') {
                                {
                                    litaC_string__String_appendChar(&((litaC_outputStr)), '!');
                                    
                                    
                                }
                                
                            } else {
                                if(litaC_uri[2] == '3') {
                                    {
                                        litaC_string__String_appendChar(&((litaC_outputStr)), '#');
                                        
                                        
                                    }
                                    
                                } else {
                                    if(litaC_uri[2] == '4') {
                                        {
                                            litaC_string__String_appendChar(&((litaC_outputStr)), '$');
                                            
                                            
                                        }
                                        
                                    } else {
                                        if(litaC_uri[2] == '5') {
                                            {
                                                litaC_string__String_appendChar(&((litaC_outputStr)), '%');
                                                
                                                
                                            }
                                            
                                        } else {
                                            if(litaC_uri[2] == '6') {
                                                {
                                                    litaC_string__String_appendChar(&((litaC_outputStr)), '&');
                                                    
                                                    
                                                }
                                                
                                            } else {
                                                if(litaC_uri[2] == '7') {
                                                    {
                                                        litaC_string__String_appendChar(&((litaC_outputStr)), '\'');
                                                        
                                                        
                                                    }
                                                    
                                                } else {
                                                    if(litaC_uri[2] == '8') {
                                                        {
                                                            litaC_string__String_appendChar(&((litaC_outputStr)), '(');
                                                            
                                                            
                                                        }
                                                        
                                                    } else {
                                                        if(litaC_uri[2] == '9') {
                                                            {
                                                                litaC_string__String_appendChar(&((litaC_outputStr)), ')');
                                                                
                                                                
                                                            }
                                                            
                                                        } else {
                                                            if(litaC_uri[2] == 'A') {
                                                                {
                                                                    litaC_string__String_appendChar(&((litaC_outputStr)), '*');
                                                                    
                                                                    
                                                                }
                                                                
                                                            } else {
                                                                if(litaC_uri[2] == 'B') {
                                                                    {
                                                                        litaC_string__String_appendChar(&((litaC_outputStr)), '+');
                                                                        
                                                                        
                                                                    }
                                                                    
                                                                } else {
                                                                    if(litaC_uri[2] == 'C') {
                                                                        {
                                                                            litaC_string__String_appendChar(&((litaC_outputStr)), ',');
                                                                            
                                                                            
                                                                        }
                                                                        
                                                                    } else {
                                                                        if(litaC_uri[2] == 'F') {
                                                                            {
                                                                                litaC_string__String_appendChar(&((litaC_outputStr)), '/');
                                                                                
                                                                                
                                                                            }
                                                                            
                                                                        } else {
                                                                            {
                                                                                litaC_string__String_append(&((litaC_outputStr)), "%s", "%2");
                                                                                litaC_uri += 2;
                                                                                continue;
                                                                                
                                                                                
                                                                            }
                                                                        } 
                                                                        
                                                                    } 
                                                                    
                                                                } 
                                                                
                                                            } 
                                                            
                                                        } 
                                                        
                                                    } 
                                                    
                                                } 
                                                
                                            } 
                                            
                                        } 
                                        
                                    } 
                                    
                                } 
                                
                            } 
                            
                            
                            
                        }
                        
                    } else {
                        if(litaC_uri[1] == '3') {
                            {
                                if(litaC_uri[2] == 'A') {
                                    {
                                        litaC_string__String_appendChar(&((litaC_outputStr)), ':');
                                        
                                        
                                    }
                                    
                                } else {
                                    if(litaC_uri[2] == 'B') {
                                        {
                                            litaC_string__String_appendChar(&((litaC_outputStr)), ';');
                                            
                                            
                                        }
                                        
                                    } else {
                                        if(litaC_uri[2] == 'D') {
                                            {
                                                litaC_string__String_appendChar(&((litaC_outputStr)), '=');
                                                
                                                
                                            }
                                            
                                        } else {
                                            if(litaC_uri[2] == 'F') {
                                                {
                                                    litaC_string__String_appendChar(&((litaC_outputStr)), '?');
                                                    
                                                    
                                                }
                                                
                                            } else {
                                                {
                                                    litaC_string__String_append(&((litaC_outputStr)), "%s", "%2");
                                                    litaC_uri += 2;
                                                    continue;
                                                    
                                                    
                                                }
                                            } 
                                            
                                        } 
                                        
                                    } 
                                    
                                } 
                                
                                
                                
                            }
                            
                        } else {
                            if(litaC_uri[1] == '4') {
                                {
                                    if(litaC_uri[2] == '0') {
                                        {
                                            litaC_string__String_appendChar(&((litaC_outputStr)), '@');
                                            
                                            
                                        }
                                        
                                    } else {
                                        {
                                            litaC_string__String_append(&((litaC_outputStr)), "%s", "%2");
                                            litaC_uri += 2;
                                            continue;
                                            
                                            
                                        }
                                    } 
                                    
                                    
                                    
                                }
                                
                            } else {
                                if(litaC_uri[1] == '5') {
                                    {
                                        if(litaC_uri[2] == 'B') {
                                            {
                                                litaC_string__String_appendChar(&((litaC_outputStr)), '[');
                                                
                                                
                                            }
                                            
                                        } else {
                                            if(litaC_uri[2] == 'D') {
                                                {
                                                    litaC_string__String_appendChar(&((litaC_outputStr)), ']');
                                                    
                                                    
                                                }
                                                
                                            } else {
                                                {
                                                    litaC_string__String_append(&((litaC_outputStr)), "%s", "%2");
                                                    litaC_uri += 2;
                                                    continue;
                                                    
                                                    
                                                }
                                            } 
                                            
                                        } 
                                        
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        litaC_string__String_appendChar(&((litaC_outputStr)), *(litaC_uri));
                                        litaC_uri += 1;
                                        continue;
                                        
                                        
                                    }
                                } 
                                
                            } 
                            
                        } 
                        
                    } 
                    
                    litaC_uri += 3;
                    continue;
                    
                    
                }
                
            } 
            
            litaC_string__String_appendChar(&((litaC_outputStr)), *(litaC_uri));
            litaC_uri += 1;
            
            
        }
    }
    return litaC_string__String_cStr(litaC_outputStr);
    
    
}


litaC_f64 litaC_system__SystemTimeMSec() {
    return litaC_system_win___SystemTimeMSec();
    
    
}

const litaC_char* litaC_system__CurrentDateTime() {
    time_t litaC_rawtime;
    tm* litaC_timeinfo;
    time(&(litaC_rawtime));
    litaC_timeinfo = localtime(&(litaC_rawtime));
    return asctime(litaC_timeinfo);
    
    
}

litaC_system__Process litaC_system__SystemExec(const litaC_char* litaC_command) {
    FILE* litaC_pipe = _popen(litaC_command, litaC_system__OPEN_MODE);
    return (litaC_system__Process) {
        .pipe = litaC_pipe
    };
    
    
}

litaC_i64 litaC_system__Process_readOutput(litaC_system__Process* litaC_this,litaC_char* litaC_buffer,litaC_usize litaC_length) {
    if(!(litaC_this->pipe)) {
        {
            return -(1);
            
            
            
        }
        
    } 
    
    return fread(litaC_buffer, sizeof(litaC_char), litaC_length, litaC_this->pipe);
    
    
}

litaC_u64 litaC_system__Process_writeInput(litaC_system__Process* litaC_this,litaC_char* litaC_buffer,litaC_usize litaC_length) {
    if(!(litaC_this->pipe)) {
        {
            return -(1);
            
            
            
        }
        
    } 
    
    return fwrite(litaC_buffer, sizeof(litaC_char), litaC_length, litaC_this->pipe);
    
    
}

litaC_void litaC_system__Process_close(litaC_system__Process* litaC_this) {
    if(litaC_this->pipe) {
        _pclose(litaC_this->pipe);
        
    } 
    
    
}

litaC_string__String litaC_string__StringInit(litaC_char* litaC_str,litaC_i32 litaC_capacity,litaC_i32 litaC_len) {
    if(litaC_str == NULL) {
        {
            return (litaC_string__String) {
                .buffer = NULL,
                .length = 0,
                .capacity = 0
            };
            
            
            
        }
        
    } 
    
    if(litaC_len < 0) {
        {
            litaC_len = strlen(litaC_str);
            
            
        }
        
    } 
    
    if(litaC_len > litaC_capacity) {
        {
            litaC_len = litaC_capacity;
            
            
        }
        
    } 
    
    return (litaC_string__String) {
        .buffer = litaC_str,
        .length = litaC_len,
        .capacity = litaC_capacity
    };
    
    
}

litaC_i32 litaC_string__String_format(litaC_string__String* litaC_s,const litaC_char* litaC_format,...) {
    va_list litaC_args;
    va_start(litaC_args, litaC_format);
    litaC_i32 litaC_len = vsnprintf(litaC_s->buffer, litaC_s->capacity, litaC_format, litaC_args);
    va_end(litaC_args);
    if(litaC_len < 0) {
        {
            return litaC_len;
            
            
            
        }
        
    } 
    
    litaC_s->length = litaC_len;
    return litaC_len;
    
    
}

litaC_i32 litaC_string__String_append(litaC_string__String* litaC_s,const litaC_char* litaC_format,...) {
    va_list litaC_args1;
    va_start(litaC_args1, litaC_format);
    litaC_i32 litaC_len = vsnprintf(litaC_s->buffer + litaC_s->length, litaC_s->capacity - litaC_s->length, litaC_format, litaC_args1);
    va_end(litaC_args1);
    if(litaC_len < 0) {
        {
            return litaC_len;
            
            
            
        }
        
    } 
    
    litaC_s->length += litaC_len;
    return litaC_len;
    
    
}

litaC_void litaC_string__String_setStrn(litaC_string__String* litaC_s,const litaC_char* litaC_str,litaC_i32 litaC_len) {
    if(litaC_str == NULL || litaC_len < 1) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_len > litaC_s->capacity) {
        {
            litaC_len = litaC_s->capacity;
            
            
        }
        
    } 
    
    memcpy((litaC_void*)(&(litaC_s->buffer[0])), (const litaC_void*)litaC_str, litaC_len * sizeof(litaC_char));
    litaC_s->length = litaC_len;
    
}

litaC_void litaC_string__String_appendChar(litaC_string__String* litaC_s,litaC_char litaC_c) {
    if(litaC_s->length >= litaC_s->capacity) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_s->buffer[litaC_s->length] = litaC_c;
    litaC_s->length += 1;
    
}

litaC_string_view__StringView litaC_string__String_substring(litaC_string__String litaC_s,litaC_i32 litaC_start,litaC_i32 litaC_end) {
    if(litaC_start < 0 || litaC_end < litaC_start) {
        {
            return (litaC_string_view__StringView) {
                .buffer = NULL,
                .length = 0
            };
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_len = litaC_end - litaC_start;
    return (litaC_string_view__StringView) {
        .buffer = litaC_s.buffer + litaC_start,
        .length = litaC_len
    };
    
    
}

litaC_string_view__StringView litaC_string__String_asView(litaC_string__String litaC_s) {
    return (litaC_string_view__StringView) {
        .buffer = litaC_s.buffer,
        .length = litaC_s.length
    };
    
    
}

litaC_void litaC_string__String_memset(litaC_string__String litaC_s,litaC_i32 litaC_value) {
    if(litaC_s.capacity < 1) {
        return;
        
        
    } 
    
    memset((litaC_void*)litaC_s.buffer, litaC_value, litaC_s.capacity * sizeof(litaC_char));
    
}

litaC_void litaC_string__String_toLower(litaC_string__String litaC_s) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_s.length;litaC_i += 1) {
        {
            litaC_s.buffer[litaC_i] = (litaC_char)tolower(litaC_s.buffer[litaC_i]);
            
            
        }
    }
    
}

litaC_void litaC_string__String_toUpper(litaC_string__String litaC_s) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_s.length;litaC_i += 1) {
        {
            litaC_s.buffer[litaC_i] = (litaC_char)toupper(litaC_s.buffer[litaC_i]);
            
            
        }
    }
    
}

litaC_string__String litaC_string__String_copy(litaC_string__String litaC_s,const litaC_mem__Allocator* litaC_allocator) {
    if(litaC_s.length < 1) {
        {
            return (litaC_string__String) {
                .buffer = NULL,
                .length = 0,
                .capacity = 0
            };
            
            
            
        }
        
    } 
    
    litaC_char* litaC_copiedStr = (litaC_char*)litaC_mem__Allocator_alloc(litaC_allocator, (litaC_s.length + 1) * sizeof(litaC_char));
    memcpy(litaC_copiedStr, litaC_s.buffer, litaC_s.length);
    litaC_copiedStr[litaC_s.length] = '\0';
    return (litaC_string__String) {
        .buffer = litaC_copiedStr,
        .length = litaC_s.length,
        .capacity = litaC_s.length
    };
    
    
}

litaC_void litaC_string__String_adjust(litaC_string__String* litaC_s) {
    litaC_s->length = strnlen(litaC_s->buffer, litaC_s->capacity);
    
}

litaC_void litaC_string__String_clear(litaC_string__String* litaC_s) {
    litaC_string__String_memset(*((litaC_s)), 0);
    litaC_s->length = 0;
    
}

litaC_bool litaC_string__String_empty(litaC_string__String litaC_s) {
    return litaC_s.length < 1;
    
    
}

litaC_i32 litaC_string__String_size(litaC_string__String litaC_s) {
    return litaC_s.length;
    
    
}

litaC_char* litaC_string__String_cStr(litaC_string__String litaC_s) {
    litaC_s.buffer[litaC_s.length] = '\0';
    return litaC_s.buffer;
    
    
}

const litaC_char* litaC_string__String_cStrConst(litaC_string__String litaC_s) {
    litaC_s.buffer[litaC_s.length] = '\0';
    return (const litaC_char*)litaC_s.buffer;
    
    
}

litaC_char* litaC_string__StringCopy(const litaC_char* litaC_original,litaC_i32 litaC_len,const litaC_mem__Allocator* litaC_allocator) {
    if(litaC_len < 0) {
        {
            litaC_len = strlen(litaC_original);
            
            
        }
        
    } 
    
    litaC_char* litaC_copiedStr = (litaC_char*)litaC_mem__Allocator_alloc(litaC_allocator, (litaC_len + 1) * sizeof(litaC_char));
    memcpy(litaC_copiedStr, litaC_original, litaC_len);
    litaC_copiedStr[litaC_len] = '\0';
    return litaC_copiedStr;
    
    
}


LITAC_INLINE 
litaC_bool litaC_system_win___SystemInit() {
    if(litaC_system_win__systemStart == 0) {
        {
            LARGE_INTEGER litaC_freq;
            if(!(QueryPerformanceFrequency(&(litaC_freq)))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_system_win__systemFreq = (litaC_f64)litaC_freq.QuadPart / 1000.0;
            LARGE_INTEGER litaC_time;
            QueryPerformanceCounter(&(litaC_time));
            litaC_system_win__systemStart = litaC_time.QuadPart;
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

LITAC_INLINE 
const litaC_char* litaC_system_win___CurrentWorkingPath() {
    static 
    litaC_char litaC_path[_MAX_PATH];
    if(litaC_system_win__pwd[0] == 0) {
        {
            GetCurrentDirectory(_MAX_PATH, litaC_path);
            litaC_system__GetAbsolutePath("", litaC_path, litaC_system_win__pwd);
            
            
        }
        
    } 
    
    return litaC_system_win__pwd;
    
    
}

LITAC_INLINE 
litaC_bool litaC_system_win___Mkdir(const litaC_char* litaC_dir) {
    CreateDirectoryA(litaC_dir, NULL);
    litaC_string_view__StringView litaC_view = litaC_string_view__StringViewInit(litaC_dir, -(1));
    if(litaC_string_view__StringView_endsWith(litaC_view, "/", -(1))) {
        {
            litaC_char litaC_path[_MAX_PATH] =  {
                0
            };
            litaC_string__String litaC_normalized = litaC_string__StringInit(litaC_path, _MAX_PATH, -(1));
            litaC_string__String_format(&((litaC_normalized)), "%.*s", litaC_view.length - 1, litaC_view.buffer);
            return litaC_system__FileExists(litaC_string__String_cStr(litaC_normalized));
            
            
            
        }
        
    } 
    
    return litaC_system__FileExists(litaC_dir);
    
    
}

LITAC_INLINE 

litaC_f64 litaC_system_win___SystemTimeMSec() {
    LARGE_INTEGER litaC_time;
    QueryPerformanceCounter(&(litaC_time));
    assert(litaC_system_win__systemFreq != 0);
    return ((litaC_f64)(litaC_time.QuadPart - litaC_system_win__systemStart) / litaC_system_win__systemFreq) / 1000.0;
    
    
}

litaC_u32 litaC_map__StrHashFn(const litaC_char* litaC_str) {
    litaC_u32 litaC_hash = 5381U;
    while(*(litaC_str)) {
        {
            litaC_hash = ((litaC_hash << 5U) + litaC_hash) ^ ((litaC_u32)(*(litaC_str)));
            litaC_str += 1;
            
            
        }
    }
    return litaC_hash;
    
    
}

litaC_bool litaC_map__StrEqualFn(const litaC_char* litaC_a,const litaC_char* litaC_b) {
    if(!(litaC_a) && !(litaC_b)) {
        return litaC_true;
        
        
    } 
    
    if(!(litaC_a) || !(litaC_b)) {
        return litaC_false;
        
        
    } 
    
    return strcmp(litaC_a, litaC_b) == 0;
    
    
}

litaC_u32 litaC_map__nextPowerOf2(litaC_u32 litaC_n) {
    litaC_i32 litaC_count = 0;
    if(litaC_n && !((litaC_n & (litaC_n - 1)))) {
        return litaC_n;
        
        
    } 
    
    while(litaC_n != 0) {
        {
            litaC_n >>= 1;
            litaC_count += 1;
            
            
        }
    }
    return 1 << litaC_count;
    
    
}


litaC_void litaC_profile__StartWatch(litaC_profile__ProfileTag litaC_tag) {
    litaC_profile__ProfileEntry* litaC_entry = &(litaC_profile__profileEntries[litaC_tag]);
    litaC_entry->count += 1;
    litaC_entry->startTime = litaC_system__SystemTimeMSec();
    
}


litaC_void litaC_profile__StopWatch(litaC_profile__ProfileTag litaC_tag) {
    litaC_f64 litaC_endTime = litaC_system__SystemTimeMSec();
    litaC_profile__ProfileEntry* litaC_entry = &(litaC_profile__profileEntries[litaC_tag]);
    litaC_entry->totalTime += (litaC_endTime - litaC_entry->startTime);
    
}


litaC_void litaC_profile__ExportTimings(const litaC_char* litaC_filename) {
    printf("Exporting '%s' with %d instrumented functions...\n", litaC_filename, litaC_profile__ProfileTag_MAX_PROFILE_TAGS);
    
}

litaC_bool litaC_lex__Token_nameEquals(litaC_lex__Token* litaC_token,const litaC_char* litaC_str) {
    if(litaC_token->type != litaC_lex__TokenType_IDENTIFIER) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_string_view__StringView_equals(litaC_token->value.str, litaC_str, -(1));
    
    
}

litaC_i32 litaC_lex__SrcPos_getLineLength(litaC_lex__SrcPos* litaC_p) {
    if(!(litaC_p->lineStart)) {
        return -(1);
        
        
    } 
    
    litaC_i32 litaC_len = 0;
    while(litaC_p->lineStart[litaC_len] != '\0') {
        {
            if(litaC_p->lineStart[litaC_len] == '\n') {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_len += 1;
            
            
        }
    }
    return litaC_len;
    
    
}


const litaC_char* litaC_lex__Token_asString(litaC_lex__Token* litaC_t) {
    static 
    litaC_char litaC_buffer[260];
    if(litaC_t->type == litaC_lex__TokenType_IDENTIFIER || litaC_t->type == litaC_lex__TokenType_STRING) {
        {
            litaC_string__String litaC_str = litaC_string__StringInit(litaC_buffer, 260, -(1));
            litaC_string__String_format(&((litaC_str)), "%.*s", litaC_t->value.str.length, litaC_t->value.str.buffer);
            return litaC_string__String_cStr(litaC_str);
            
            
            
        }
        
    } 
    
    return litaC_lex__tokenText[litaC_t->type];
    
    
}

litaC_void litaC_lex__Token_print(litaC_lex__Token* litaC_token) {
    printf("%s: '%s' '%.*s' ", litaC_lex__TokenTypeAsStr(litaC_token->type), litaC_lex__Token_asString(litaC_token), (litaC_i32)(litaC_token->pos.end - litaC_token->pos.start), litaC_token->pos.start);
    if(litaC_token->type == litaC_lex__TokenType_INT_NUMBER) {
        {
            printf("value: '%lld'", litaC_token->value.intValue);
            printf(" typeInfo: %s", litaC_types__TypeKindAsStr(litaC_token->typeInfo->kind));
            
            
        }
        
    } else {
        if(litaC_token->type == litaC_lex__TokenType_FLOAT_NUMBER) {
            {
                printf("value: '%f'", litaC_token->value.floatValue);
                printf(" typeInfo: %s", litaC_types__TypeKindAsStr(litaC_token->typeInfo->kind));
                
                
            }
            
        } else {
            if(litaC_token->type == litaC_lex__TokenType_STRING) {
                {
                    printf("value: '%.*s'", litaC_token->value.str.length, litaC_token->value.str.buffer);
                    
                    
                }
                
            } else {
                if(litaC_token->type == litaC_lex__TokenType_ERROR) {
                    {
                        printf("error: '%s'", "X");
                        
                        
                    }
                    
                } 
                
            } 
            
        } 
        
    } 
    
    printf("\n");
    
}

litaC_lex__Lexer litaC_lex__LexerInit(const litaC_char* litaC_filename,const litaC_char* litaC_text,const litaC_mem__Allocator* litaC_allocator) {
    return (litaC_lex__Lexer) {
        .allocator = litaC_allocator,
        .token =  {
            .type = litaC_lex__TokenType_END_OF_FILE,
            .typeInfo = NULL,
            .pos =  {
                .filename = litaC_filename,
                .start = litaC_text,
                .end = NULL
            }
        },
        .stream = litaC_text,
        .lineStart = litaC_text,
        .lineNumber = 1,
        .position = 1,
        .errorMsg = NULL
    };
    
    
}

litaC_bool litaC_lex__Lexer_hasError(litaC_lex__Lexer* litaC_l) {
    return litaC_l->errorMsg != NULL;
    
    
}

litaC_void litaC_lex__Lexer_error(litaC_lex__Lexer* litaC_l,const litaC_char* litaC_format,...) {
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_l->allocator);
    va_list litaC_args;
    va_start(litaC_args, litaC_format);
    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), litaC_format, litaC_args);
    va_end(litaC_args);
    litaC_l->errorMsg = litaC_string_buffer__StringBuffer_cStr(&((litaC_sb)));
    litaC_lex__Lexer_errorToken(litaC_l);
    
}

litaC_char litaC_lex__Lexer_nextChar(litaC_lex__Lexer* litaC_l) {
    litaC_char litaC_c = *(litaC_l->stream);
    if(litaC_c == '\n') {
        {
            litaC_l->lineStart = litaC_l->stream + 1;
            litaC_l->lineNumber += 1;
            litaC_l->position = 0;
            
            
        }
        
    } 
    
    litaC_l->stream += 1;
    litaC_l->position += 1;
    return *(litaC_l->stream);
    
    
}

litaC_lex__Token litaC_lex__Lexer_eofToken(litaC_lex__Lexer* litaC_l) {
    litaC_l->token.type = litaC_lex__TokenType_END_OF_FILE;
    litaC_l->token.pos.lineStart = litaC_l->lineStart;
    litaC_l->token.pos.lineNumber = litaC_l->lineNumber;
    litaC_l->token.pos.position = litaC_l->position;
    return litaC_l->token;
    
    
}

litaC_lex__Token litaC_lex__Lexer_errorToken(litaC_lex__Lexer* litaC_l) {
    litaC_l->token.type = litaC_lex__TokenType_ERROR;
    litaC_l->token.pos.lineStart = litaC_l->lineStart;
    litaC_l->token.pos.lineNumber = litaC_l->lineNumber;
    litaC_l->token.pos.position = litaC_l->position;
    return litaC_l->token;
    
    
}

litaC_void litaC_lex__Lexer_skipWhitespace(litaC_lex__Lexer* litaC_l) {
    while(isspace(*(litaC_l->stream))) {
        {
            litaC_lex__Lexer_nextChar(litaC_l);
            
            
        }
    }
    
}

litaC_void litaC_lex__Lexer_skipComments(litaC_lex__Lexer* litaC_l) {
    if(*(litaC_l->stream) == '/') {
        {
            if(litaC_l->stream[1] == '/') {
                {
                    litaC_lex__Lexer_nextChar(litaC_l);
                    do {
                        {
                            litaC_lex__Lexer_nextChar(litaC_l);
                            if(*(litaC_l->stream) == '\n') {
                                {
                                    break;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                    }
                    while(!(litaC_lex__Lexer_eof(litaC_l)));
                    
                    
                }
                
            } else {
                if(litaC_l->stream[1] == '*') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        do {
                            {
                                litaC_lex__Lexer_nextChar(litaC_l);
                                if((litaC_l->stream[0] == '*' && litaC_l->stream[1] == '/')) {
                                    {
                                        litaC_lex__Lexer_nextChar(litaC_l);
                                        litaC_lex__Lexer_nextChar(litaC_l);
                                        break;
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                        }
                        while(!(litaC_lex__Lexer_eof(litaC_l)));
                        
                        
                    }
                    
                } 
                
            } 
            
            
            
        }
        
    } 
    
    
}

litaC_bool litaC_lex__Lexer_isValidIdentifierStart(litaC_lex__Lexer* litaC_l,litaC_char litaC_c) {
    return ((litaC_c == '_') || (litaC_c >= 'A' && litaC_c <= 'Z') || (litaC_c >= 'a' && litaC_c <= 'z'));
    
    
}

litaC_bool litaC_lex__Lexer_isValidIdentifierChar(litaC_lex__Lexer* litaC_l,litaC_char litaC_c) {
    return ((litaC_c == '_') || (isdigit(litaC_c)) || (isalpha(litaC_c)));
    
    
}

litaC_bool litaC_lex__Lexer_isSymbolStart(litaC_lex__Lexer* litaC_l,litaC_char litaC_c) {
    return ((litaC_c > ' ' && litaC_c < '0') || (litaC_c > '9' && litaC_c < 'A') || (litaC_c > 'Z' && litaC_c < '_') || (litaC_c > 'z' && litaC_c < 127));
    
    
}

litaC_bool litaC_lex__Lexer_checkKeyword(litaC_lex__Lexer* litaC_l) {
    litaC_i32 litaC_len = litaC_l->token.value.str.length;
    if(litaC_len < litaC_lex__MAX_KEYWORD_CACHE) {
        {
            const litaC_char** litaC_keywords = litaC_lex__keywordCache[litaC_len];
            for(litaC_i32 litaC_i = 0;;litaC_i += 1) {
                {
                    const litaC_char* litaC_keyword = litaC_keywords[litaC_i];
                    if(!(litaC_keyword)) {
                        break;
                        
                    } 
                    
                    if(strncmp(litaC_l->token.value.str.buffer, litaC_keyword, litaC_len) == 0) {
                        {
                            litaC_l->token.type = litaC_lex__keywordCacheIndex[litaC_len][litaC_i];
                            return litaC_true;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } 
    
    return litaC_false;
    
    
}

litaC_lex__Token litaC_lex__Lexer_scanWord(litaC_lex__Lexer* litaC_l) {
    litaC_i32 litaC_length = 0;
    while(litaC_lex__Lexer_isValidIdentifierChar(litaC_l, *(litaC_l->stream))) {
        {
            litaC_l->stream += 1;
            litaC_length += 1;
            
            
        }
    }
    litaC_l->position += litaC_length;
    litaC_l->token.pos.end = litaC_l->stream;
    litaC_l->token.type = litaC_lex__TokenType_IDENTIFIER;
    litaC_l->token.value.str = litaC_string_view__StringViewInit(litaC_l->token.pos.start, litaC_length);
    litaC_lex__Lexer_checkKeyword(litaC_l);
    return litaC_l->token;
    
    
}

litaC_void litaC_lex__Lexer_scanInt(litaC_lex__Lexer* litaC_l,litaC_char* litaC_stream) {
    litaC_i32 litaC_base = 10;
    litaC_char* litaC_start_digits = litaC_stream;
    if(*(litaC_stream) == '0') {
        {
            litaC_stream += 1;
            if(tolower(*(litaC_stream)) == 'x') {
                {
                    litaC_stream += 1;
                    litaC_base = 16;
                    litaC_start_digits = litaC_stream;
                    
                    
                }
                
            } else {
                if(tolower(*(litaC_stream)) == 'b') {
                    {
                        litaC_stream += 1;
                        litaC_base = 2;
                        litaC_start_digits = litaC_stream;
                        
                        
                    }
                    
                } else {
                    if(isdigit(*(litaC_stream))) {
                        {
                            litaC_base = 8;
                            litaC_start_digits = litaC_stream;
                            
                            
                        }
                        
                    } 
                    
                } 
                
            } 
            
            
            
        }
        
    } 
    
    litaC_i64 litaC_val = 0;
    for(;;) {
        {
            litaC_i32 litaC_digit = litaC_lex__charToDigit[(litaC_i32)(*(litaC_stream))];
            if(litaC_digit == 0 && *(litaC_stream) != '0') {
                {
                    break;
                    
                    
                }
                
            } 
            
            if(litaC_digit >= litaC_base) {
                {
                    litaC_lex__Lexer_error(litaC_l, "Digit '%c' out of range for base %d", *(litaC_stream), litaC_base);
                    litaC_digit = 0;
                    
                    
                }
                
            } 
            
            if(litaC_val > (ULLONG_MAX - litaC_digit) / litaC_base) {
                {
                    litaC_lex__Lexer_error(litaC_l, "Integer literal overflow");
                    while(isdigit(*(litaC_stream))) {
                        {
                            litaC_stream += 1;
                            
                            
                        }
                    }
                    litaC_val = 0;
                    break;
                    
                    
                }
                
            } 
            
            litaC_val = litaC_val * litaC_base + litaC_digit;
            litaC_stream += 1;
            
            
        }
    }
    if(litaC_stream == litaC_start_digits) {
        {
            litaC_lex__Lexer_error(litaC_l, "Expected base %d digit, got '%c'", litaC_base, *(litaC_stream));
            
            
        }
        
    } 
    
    if(litaC_lex__Lexer_hasError(litaC_l)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_l->token.type = litaC_lex__TokenType_INT_NUMBER;
    litaC_l->token.value.intValue = litaC_val;
    
}

litaC_void litaC_lex__Lexer_scanFloat(litaC_lex__Lexer* litaC_l,litaC_char* litaC_stream) {
    litaC_char* litaC_start = litaC_stream;
    while(isdigit(*(litaC_stream))) {
        {
            litaC_stream += 1;
            
            
        }
    }
    if(*(litaC_stream) == '.') {
        {
            litaC_stream += 1;
            
            
        }
        
    } 
    
    while(isdigit(*(litaC_stream))) {
        {
            litaC_stream += 1;
            
            
        }
    }
    if(tolower(*(litaC_stream)) == 'e') {
        {
            litaC_stream += 1;
            if(*(litaC_stream) == '+' || *(litaC_stream) == '-') {
                {
                    litaC_stream += 1;
                    
                    
                }
                
            } 
            
            if(!(isdigit(*(litaC_stream)))) {
                {
                    litaC_lex__Lexer_error(litaC_l, "Expected digit after float literal exponent, found '%c'.", *(litaC_stream));
                    
                    
                }
                
            } 
            
            while(isdigit(*(litaC_stream))) {
                {
                    litaC_stream += 1;
                    
                    
                }
            }
            
            
        }
        
    } 
    
    litaC_f64 litaC_val = strtod(litaC_start, NULL);
    if(litaC_val == HUGE_VAL) {
        {
            litaC_lex__Lexer_error(litaC_l, "Float literal overflow");
            
            
        }
        
    } 
    
    if(litaC_lex__Lexer_hasError(litaC_l)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_l->token.type = litaC_lex__TokenType_FLOAT_NUMBER;
    litaC_l->token.value.floatValue = litaC_val;
    
}

litaC_void litaC_lex__Lexer_scanTypeInfo(litaC_lex__Lexer* litaC_l) {
    litaC_char litaC_c = *(litaC_l->stream);
    if(litaC_c == 'u' || litaC_c == 'i') {
        {
            if(litaC_l->token.typeInfo == &(litaC_types__F32_TYPE) || litaC_l->token.typeInfo == &(litaC_types__F64_TYPE)) {
                {
                    litaC_lex__Lexer_error(litaC_l, "Integer type designation on floating point number not allowed");
                    return;
                    
                    
                    
                }
                
            } 
            
            const litaC_char* litaC_start = litaC_l->stream;
            litaC_i32 litaC_len = 0;
            do {
                {
                    litaC_len += 1;
                    litaC_lex__Lexer_nextChar(litaC_l);
                    if(!(isdigit(*(litaC_l->stream)))) {
                        {
                            break;
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            while(!(litaC_lex__Lexer_eof(litaC_l)));
            litaC_types__TypeKind litaC_kind = litaC_types__TypeKindFromString(litaC_start, litaC_len);
            switch(litaC_kind) {
                case litaC_types__TypeKind_I8: {
                    {
                        litaC_l->token.typeInfo = &(litaC_types__I8_TYPE);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_types__TypeKind_U8: {
                    {
                        litaC_l->token.typeInfo = &(litaC_types__U8_TYPE);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_types__TypeKind_I16: {
                    {
                        litaC_l->token.typeInfo = &(litaC_types__I16_TYPE);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_types__TypeKind_U16: {
                    {
                        litaC_l->token.typeInfo = &(litaC_types__U16_TYPE);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_types__TypeKind_I32: {
                    {
                        litaC_l->token.typeInfo = &(litaC_types__I32_TYPE);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_types__TypeKind_U32: {
                    {
                        litaC_l->token.typeInfo = &(litaC_types__U32_TYPE);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_types__TypeKind_I64: {
                    {
                        litaC_l->token.typeInfo = &(litaC_types__I64_TYPE);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_types__TypeKind_U64: {
                    {
                        litaC_l->token.typeInfo = &(litaC_types__U64_TYPE);
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        litaC_lex__Lexer_error(litaC_l, "Invalid number type designator");
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
        
    } else {
        if(tolower(litaC_c) == 'f' || tolower(litaC_c) == 'd') {
            {
                const litaC_char* litaC_start = litaC_l->stream;
                litaC_i32 litaC_len = 0;
                do {
                    {
                        litaC_len += 1;
                        litaC_lex__Lexer_nextChar(litaC_l);
                        if(!(isdigit(*(litaC_l->stream)))) {
                            {
                                break;
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                while(!(litaC_lex__Lexer_eof(litaC_l)));
                if(litaC_len == 1) {
                    {
                        if(tolower(litaC_c) == 'f') {
                            {
                                litaC_l->token.typeInfo = &(litaC_types__F32_TYPE);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_l->token.typeInfo = &(litaC_types__F64_TYPE);
                                
                                
                            }
                        } 
                        
                        
                        
                    }
                    
                } else {
                    {
                        litaC_types__TypeKind litaC_kind = litaC_types__TypeKindFromString(litaC_start, litaC_len);
                        switch(litaC_kind) {
                            case litaC_types__TypeKind_F32: {
                                {
                                    litaC_l->token.typeInfo = &(litaC_types__F32_TYPE);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_types__TypeKind_F64: {
                                {
                                    litaC_l->token.typeInfo = &(litaC_types__F64_TYPE);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            default: {
                                {
                                    litaC_lex__Lexer_error(litaC_l, "Invalid number type designator");
                                    
                                    
                                }
                                
                                
                            }
                        }
                        
                        
                    }
                } 
                
                
                
            }
            
        } 
        
    } 
    
    
}

litaC_bool litaC_lex__IsHexChar(litaC_char litaC_c) {
    return litaC_c == 'a' || litaC_c == 'A' || litaC_c == 'b' || litaC_c == 'B' || litaC_c == 'c' || litaC_c == 'C' || litaC_c == 'd' || litaC_c == 'D' || litaC_c == 'e' || litaC_c == 'E' || litaC_c == 'f' || litaC_c == 'F';
    
    
}

litaC_lex__Token litaC_lex__Lexer_scanNumber(litaC_lex__Lexer* litaC_l) {
    const litaC_char* litaC_start = litaC_l->stream;
    litaC_char litaC_numBuf[256];
    litaC_i32 litaC_numIndex = 0;
    litaC_bool litaC_hasDecimal = litaC_false;
    litaC_bool litaC_hasExpo = litaC_false;
    litaC_bool litaC_isHex = litaC_false;
    while(!(litaC_lex__Lexer_eof(litaC_l))) {
        {
            litaC_char litaC_c = *(litaC_l->stream);
            if(litaC_c == '.') {
                {
                    if(litaC_hasDecimal) {
                        {
                            break;
                            
                            
                        }
                        
                    } 
                    
                    litaC_hasDecimal = litaC_true;
                    
                    
                }
                
            } else {
                if(tolower(litaC_c) == 'e' && !(litaC_isHex)) {
                    {
                        if(litaC_hasExpo) {
                            {
                                break;
                                
                                
                            }
                            
                        } 
                        
                        litaC_hasExpo = litaC_true;
                        
                        
                    }
                    
                } else {
                    if(!(isdigit(litaC_c)) && litaC_c != '_') {
                        {
                            if(litaC_c == 'x' || litaC_c == 'X') {
                                {
                                    litaC_isHex = litaC_true;
                                    
                                    
                                }
                                
                            } else {
                                if(litaC_isHex) {
                                    {
                                        if(!(litaC_lex__IsHexChar(litaC_c))) {
                                            {
                                                break;
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        break;
                                        
                                        
                                    }
                                } 
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                } 
                
            } 
            
            if(litaC_c != '_') {
                {
                    litaC_numBuf[litaC_numIndex] = litaC_c;
                    litaC_numIndex += 1;
                    
                    
                }
                
            } 
            
            litaC_l->stream += 1;
            
            
        }
    }
    litaC_numBuf[litaC_numIndex] = '\0';
    if(litaC_hasDecimal || litaC_hasExpo) {
        {
            litaC_lex__Lexer_scanFloat(litaC_l, litaC_numBuf);
            litaC_l->token.typeInfo = &(litaC_types__F64_TYPE);
            
            
        }
        
    } else {
        {
            litaC_lex__Lexer_scanInt(litaC_l, litaC_numBuf);
            litaC_l->token.typeInfo = &(litaC_types__I32_TYPE);
            if(litaC_l->token.value.intValue > INT_MAX) {
                {
                    if(litaC_l->token.value.intValue > UINT_MAX) {
                        {
                            litaC_l->token.typeInfo = &(litaC_types__I64_TYPE);
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_l->token.typeInfo = &(litaC_types__U32_TYPE);
                            
                            
                        }
                    } 
                    
                    
                    
                }
                
            } 
            
            
            
        }
    } 
    
    if(litaC_lex__Lexer_hasError(litaC_l)) {
        {
            return litaC_lex__Lexer_errorToken(litaC_l);
            
            
            
        }
        
    } 
    
    litaC_lex__Lexer_scanTypeInfo(litaC_l);
    litaC_l->token.pos.end = litaC_l->stream;
    return litaC_l->token;
    
    
}

litaC_lex__Token litaC_lex__Lexer_scanChar(litaC_lex__Lexer* litaC_l) {
    litaC_u32 litaC_c = (litaC_u32)litaC_lex__Lexer_nextChar(litaC_l);
    litaC_char litaC_value = '\0';
    if(litaC_c == '\\') {
        {
            litaC_c = litaC_lex__Lexer_nextChar(litaC_l);
            if(litaC_lex__escapeToChar[litaC_c] == 0 && litaC_c != '0') {
                {
                    return litaC_lex__Lexer_errorToken(litaC_l);
                    
                    
                    
                }
                
            } 
            
            litaC_lex__Lexer_nextChar(litaC_l);
            litaC_value = litaC_lex__escapeToChar[litaC_c];
            
            
        }
        
    } else {
        {
            litaC_value = (litaC_char)litaC_c;
            litaC_lex__Lexer_nextChar(litaC_l);
            
            
        }
    } 
    
    if(*(litaC_l->stream) != '\'') {
        {
            return litaC_lex__Lexer_errorToken(litaC_l);
            
            
            
        }
        
    } 
    
    litaC_lex__Lexer_nextChar(litaC_l);
    litaC_l->token.type = litaC_lex__TokenType_CHAR;
    litaC_l->token.pos.end = litaC_l->stream;
    litaC_l->token.value.intValue = litaC_value;
    return litaC_l->token;
    
    
}

litaC_lex__Token litaC_lex__Lexer_scanString(litaC_lex__Lexer* litaC_l) {
    litaC_i32 litaC_length = 0;
    litaC_bool litaC_isVerbatim = litaC_false;
    if(litaC_l->stream[0] == '"') {
        {
            if(litaC_l->stream[1] == '"' && litaC_l->stream[2] == '"') {
                {
                    litaC_isVerbatim = litaC_true;
                    litaC_lex__Lexer_nextChar(litaC_l);
                    litaC_lex__Lexer_nextChar(litaC_l);
                    
                    
                }
                
            } 
            
            litaC_lex__Lexer_nextChar(litaC_l);
            litaC_l->token.value.str.buffer = litaC_l->stream;
            while(!(litaC_lex__Lexer_eof(litaC_l))) {
                {
                    if(litaC_l->stream[0] == '\\') {
                        {
                            litaC_char litaC_c = litaC_l->stream[1];
                            if(litaC_lex__escapeToChar[litaC_c] == 0 && litaC_c != '0') {
                                {
                                    return litaC_lex__Lexer_errorToken(litaC_l);
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_lex__Lexer_nextChar(litaC_l);
                            litaC_length += 1;
                            
                            
                        }
                        
                    } else {
                        if(litaC_l->stream[0] == '"') {
                            {
                                if(!(litaC_isVerbatim)) {
                                    {
                                        litaC_lex__Lexer_nextChar(litaC_l);
                                        break;
                                        
                                        
                                    }
                                    
                                } else {
                                    if(litaC_l->stream[1] == '"' && litaC_l->stream[2] == '"') {
                                        {
                                            litaC_lex__Lexer_nextChar(litaC_l);
                                            litaC_lex__Lexer_nextChar(litaC_l);
                                            litaC_lex__Lexer_nextChar(litaC_l);
                                            break;
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                    } 
                    
                    litaC_lex__Lexer_nextChar(litaC_l);
                    litaC_length += 1;
                    
                    
                }
            }
            
            
        }
        
    } 
    
    litaC_l->token.type = litaC_lex__TokenType_STRING;
    litaC_l->token.value.str.length = litaC_length;
    litaC_l->token.pos.end = litaC_l->stream;
    if(litaC_isVerbatim) {
        {
            litaC_l->token.mod = litaC_lex__Mod_MULTISTR;
            
            
        }
        
    } else {
        {
            litaC_l->token.mod = litaC_lex__Mod_NONE;
            
            
        }
    } 
    
    return litaC_l->token;
    
    
}

litaC_lex__Token litaC_lex__Lexer_scanSymbol(litaC_lex__Lexer* litaC_l) {
    litaC_char litaC_c = *(litaC_l->stream);
    litaC_lex__Lexer_nextChar(litaC_l);
    switch(litaC_c) {
        case '+': {
            {
                litaC_l->token.type = litaC_lex__TokenType_PLUS;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_PLUS_EQ;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '-': {
            {
                litaC_l->token.type = litaC_lex__TokenType_MINUS;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_MINUS_EQ;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '*': {
            {
                litaC_l->token.type = litaC_lex__TokenType_STAR;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_MUL_EQ;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '%': {
            {
                litaC_l->token.type = litaC_lex__TokenType_MOD;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_MOD_EQ;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '/': {
            {
                litaC_l->token.type = litaC_lex__TokenType_SLASH;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_DIV_EQ;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '$': {
            {
                litaC_l->token.type = litaC_lex__TokenType_DOLLAR;
                break;
                
                
            }
            
            
        }
        case '#': {
            {
                litaC_l->token.type = litaC_lex__TokenType_HASH;
                break;
                
                
            }
            
            
        }
        case '.': {
            {
                litaC_l->token.type = litaC_lex__TokenType_DOT;
                if(litaC_l->stream[0] == '.') {
                    {
                        if(litaC_l->stream[1] == '.') {
                            {
                                litaC_lex__Lexer_nextChar(litaC_l);
                                litaC_lex__Lexer_nextChar(litaC_l);
                                litaC_l->token.type = litaC_lex__TokenType_VAR_ARGS;
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '@': {
            {
                litaC_l->token.type = litaC_lex__TokenType_AT;
                break;
                
                
            }
            
            
        }
        case '?': {
            {
                litaC_l->token.type = litaC_lex__TokenType_QUESTION_MARK;
                break;
                
                
            }
            
            
        }
        case ',': {
            {
                litaC_l->token.type = litaC_lex__TokenType_COMMA;
                break;
                
                
            }
            
            
        }
        case ';': {
            {
                litaC_l->token.type = litaC_lex__TokenType_SEMICOLON;
                break;
                
                
            }
            
            
        }
        case ':': {
            {
                litaC_l->token.type = litaC_lex__TokenType_COLON;
                if(litaC_l->stream[0] == ':') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_COLON_COLON;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '"': {
            {
                litaC_l->token.type = litaC_lex__TokenType_DOUBLE_QUOTE;
                break;
                
                
            }
            
            
        }
        case '<': {
            {
                litaC_l->token.type = litaC_lex__TokenType_LESS_THAN;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_LESS_EQUALS;
                        
                        
                    }
                    
                } else {
                    if(litaC_l->stream[0] == '<') {
                        {
                            litaC_lex__Lexer_nextChar(litaC_l);
                            litaC_l->token.type = litaC_lex__TokenType_LSHIFT;
                            if(litaC_l->stream[0] == '=') {
                                {
                                    litaC_lex__Lexer_nextChar(litaC_l);
                                    litaC_l->token.type = litaC_lex__TokenType_LSHIFT_EQ;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '>': {
            {
                litaC_l->token.type = litaC_lex__TokenType_GREATER_THAN;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_GREATER_EQUALS;
                        
                        
                    }
                    
                } else {
                    if(litaC_l->stream[0] == '>' && litaC_l->stream[1] == '=') {
                        {
                            litaC_lex__Lexer_nextChar(litaC_l);
                            litaC_lex__Lexer_nextChar(litaC_l);
                            litaC_l->token.type = litaC_lex__TokenType_RSHIFT_EQ;
                            
                            
                        }
                        
                    } 
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '=': {
            {
                litaC_l->token.type = litaC_lex__TokenType_EQUALS;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_EQUALS_EQUALS;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '!': {
            {
                litaC_l->token.type = litaC_lex__TokenType_NOT;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_NOT_EQUALS;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '~': {
            {
                litaC_l->token.type = litaC_lex__TokenType_BNOT;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_BNOT_EQ;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '^': {
            {
                litaC_l->token.type = litaC_lex__TokenType_XOR;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_XOR_EQ;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '&': {
            {
                litaC_l->token.type = litaC_lex__TokenType_BAND;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_BAND_EQ;
                        
                        
                    }
                    
                } else {
                    if(litaC_l->stream[0] == '&') {
                        {
                            litaC_lex__Lexer_nextChar(litaC_l);
                            litaC_l->token.type = litaC_lex__TokenType_AND;
                            
                            
                        }
                        
                    } 
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '|': {
            {
                litaC_l->token.type = litaC_lex__TokenType_BOR;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_BOR_EQ;
                        
                        
                    }
                    
                } else {
                    if(litaC_l->stream[0] == '|') {
                        {
                            litaC_lex__Lexer_nextChar(litaC_l);
                            litaC_l->token.type = litaC_lex__TokenType_OR;
                            
                            
                        }
                        
                    } 
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '(': {
            {
                litaC_l->token.type = litaC_lex__TokenType_LEFT_PAREN;
                break;
                
                
            }
            
            
        }
        case ')': {
            {
                litaC_l->token.type = litaC_lex__TokenType_RIGHT_PAREN;
                break;
                
                
            }
            
            
        }
        case '[': {
            {
                litaC_l->token.type = litaC_lex__TokenType_LEFT_BRACKET;
                break;
                
                
            }
            
            
        }
        case ']': {
            {
                litaC_l->token.type = litaC_lex__TokenType_RIGHT_BRACKET;
                break;
                
                
            }
            
            
        }
        case '{': {
            {
                litaC_l->token.type = litaC_lex__TokenType_LEFT_BRACE;
                break;
                
                
            }
            
            
        }
        case '}': {
            {
                litaC_l->token.type = litaC_lex__TokenType_RIGHT_BRACE;
                break;
                
                
            }
            
            
        }
        default: {
            {
                return litaC_lex__Lexer_errorToken(litaC_l);
                
                
                
            }
            
            
        }
    }
    litaC_l->token.pos.end = litaC_l->stream;
    return litaC_l->token;
    
    
}

litaC_bool litaC_lex__Lexer_eof(litaC_lex__Lexer* litaC_l) {
    return *(litaC_l->stream) == '\0';
    
    
}

litaC_lex__Token litaC_lex__Lexer_nextToken(litaC_lex__Lexer* litaC_l) {
    repeat:;
    
    if(litaC_lex__Lexer_eof(litaC_l)) {
        {
            return litaC_lex__Lexer_eofToken(litaC_l);
            
            
            
        }
        
    } 
    
    litaC_lex__Lexer_skipComments(litaC_l);
    litaC_l->token.pos.lineNumber = litaC_l->lineNumber;
    litaC_l->token.pos.lineStart = litaC_l->lineStart;
    litaC_l->token.pos.start = litaC_l->stream;
    litaC_l->token.pos.position = litaC_l->position;
    litaC_l->token.typeInfo = NULL;
    litaC_char litaC_c = *(litaC_l->stream);
    switch(litaC_c) {
        case '\0': {
            {
                return litaC_lex__Lexer_eofToken(litaC_l);
                
                
                
            }
            
            
        }
        case ' ': 
        case '\n': 
        case '\r': 
        case '\t': {
            {
                litaC_lex__Lexer_skipWhitespace(litaC_l);
                goto repeat;
                
                
                
            }
            
            
        }
        case '"': {
            {
                return litaC_lex__Lexer_scanString(litaC_l);
                
                
                
            }
            
            
        }
        case '\'': {
            {
                return litaC_lex__Lexer_scanChar(litaC_l);
                
                
                
            }
            
            
        }
        default: {
            {
                if(litaC_lex__Lexer_isValidIdentifierStart(litaC_l, litaC_c)) {
                    {
                        return litaC_lex__Lexer_scanWord(litaC_l);
                        
                        
                        
                    }
                    
                } 
                
                if(isdigit(litaC_c)) {
                    {
                        return litaC_lex__Lexer_scanNumber(litaC_l);
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lex__Lexer_isSymbolStart(litaC_l, litaC_c)) {
                    {
                        return litaC_lex__Lexer_scanSymbol(litaC_l);
                        
                        
                        
                    }
                    
                } 
                
                return litaC_lex__Lexer_errorToken(litaC_l);
                
                
                
            }
            
            
        }
    }
    return litaC_lex__Lexer_eofToken(litaC_l);
    
    
}

litaC_types__TypeKind litaC_types__TypeKindFromString(const litaC_char* litaC_str,litaC_i32 litaC_len) {
    litaC_string_view__StringView litaC_view = litaC_string_view__StringViewInit(litaC_str, litaC_len);
    for(litaC_i32 litaC_i = litaC_types__TypeKind_BOOL;litaC_i < litaC_types__TypeKind_MAX_TYPE_KINDS;litaC_i += 1) {
        {
            if(litaC_string_view__StringView_equals(litaC_view, litaC_types__typeKindText[litaC_i], -(1))) {
                {
                    return litaC_i;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_types__TypeKind_MAX_TYPE_KINDS;
    
    
}

litaC_bool litaC_types__IsPtr(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_type->kind == litaC_types__TypeKind_CONST) {
        {
            litaC_types__ConstTypeInfo* litaC_constInfo = (litaC_types__ConstTypeInfo*)litaC_type;
            return litaC_types__IsPtr(litaC_constInfo->constOf);
            
            
            
        }
        
    } 
    
    return litaC_type->kind == litaC_types__TypeKind_PTR;
    
    
}

litaC_bool litaC_types__IsPtrLike(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_PTR: 
        case litaC_types__TypeKind_STR: 
        case litaC_types__TypeKind_ARRAY: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__ConstTypeInfo* litaC_constInfo = (litaC_types__ConstTypeInfo*)litaC_type;
                return litaC_types__IsPtrLike(litaC_constInfo->constOf);
                
                
                
            }
            
            
        }
        default: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
    }
    
}

litaC_bool litaC_types__IsPtrOf(litaC_types__TypeInfo* litaC_type,litaC_types__TypeKind litaC_kind) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__PtrTypeInfo* litaC_ptrInfo = (litaC_types__PtrTypeInfo*)litaC_type;
                return litaC_ptrInfo->ptrOf->kind == litaC_kind;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STR: {
            {
                return litaC_kind == litaC_types__TypeKind_CHAR;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__ArrayTypeInfo* litaC_arrayInfo = (litaC_types__ArrayTypeInfo*)litaC_type;
                return litaC_arrayInfo->arrayOf->kind == litaC_kind;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__ConstTypeInfo* litaC_constInfo = (litaC_types__ConstTypeInfo*)litaC_type;
                return litaC_constInfo->constOf->kind == litaC_kind;
                
                
                
            }
            
            
        }
        default: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
    }
    
}

litaC_bool litaC_types__IsFuncLike(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_FUNC: 
        case litaC_types__TypeKind_FUNC_PTR: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        default: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
    }
    
}

litaC_bool litaC_types__IsPrimitive(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_type->kind < litaC_types__TypeKind_STR;
    
    
}

litaC_bool litaC_types__IsNumberLike(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_BOOL: 
        case litaC_types__TypeKind_CHAR: 
        case litaC_types__TypeKind_I8: 
        case litaC_types__TypeKind_U8: 
        case litaC_types__TypeKind_I16: 
        case litaC_types__TypeKind_U16: 
        case litaC_types__TypeKind_I32: 
        case litaC_types__TypeKind_U32: 
        case litaC_types__TypeKind_I64: 
        case litaC_types__TypeKind_U64: 
        case litaC_types__TypeKind_F32: 
        case litaC_types__TypeKind_F64: 
        case litaC_types__TypeKind_USIZE: 
        case litaC_types__TypeKind_PTR: 
        case litaC_types__TypeKind_STR: 
        case litaC_types__TypeKind_ARRAY: 
        case litaC_types__TypeKind_NULL: 
        case litaC_types__TypeKind_ENUM: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__ConstTypeInfo* litaC_constInfo = (litaC_types__ConstTypeInfo*)litaC_type;
                return litaC_types__IsNumberLike(litaC_constInfo->constOf);
                
                
                
            }
            
            
        }
        default: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
    }
    
}

litaC_bool litaC_types__IsInteger(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_BOOL: 
        case litaC_types__TypeKind_CHAR: 
        case litaC_types__TypeKind_I8: 
        case litaC_types__TypeKind_U8: 
        case litaC_types__TypeKind_I16: 
        case litaC_types__TypeKind_U16: 
        case litaC_types__TypeKind_I32: 
        case litaC_types__TypeKind_U32: 
        case litaC_types__TypeKind_I64: 
        case litaC_types__TypeKind_U64: 
        case litaC_types__TypeKind_USIZE: 
        case litaC_types__TypeKind_ENUM: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__ConstTypeInfo* litaC_constInfo = (litaC_types__ConstTypeInfo*)litaC_type;
                return litaC_types__IsInteger(litaC_constInfo->constOf);
                
                
                
            }
            
            
        }
        default: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
    }
    
}

litaC_bool litaC_types__IsBooleanable(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_BOOL: 
        case litaC_types__TypeKind_CHAR: 
        case litaC_types__TypeKind_I8: 
        case litaC_types__TypeKind_U8: 
        case litaC_types__TypeKind_I16: 
        case litaC_types__TypeKind_U16: 
        case litaC_types__TypeKind_I32: 
        case litaC_types__TypeKind_U32: 
        case litaC_types__TypeKind_I64: 
        case litaC_types__TypeKind_U64: 
        case litaC_types__TypeKind_F32: 
        case litaC_types__TypeKind_F64: 
        case litaC_types__TypeKind_USIZE: 
        case litaC_types__TypeKind_PTR: 
        case litaC_types__TypeKind_STR: 
        case litaC_types__TypeKind_ARRAY: 
        case litaC_types__TypeKind_NULL: 
        case litaC_types__TypeKind_FUNC_PTR: 
        case litaC_types__TypeKind_ENUM: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__ConstTypeInfo* litaC_constInfo = (litaC_types__ConstTypeInfo*)litaC_type;
                return litaC_types__IsBooleanable(litaC_constInfo->constOf);
                
                
                
            }
            
            
        }
        default: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
    }
    
}

litaC_types__FuncPtrTypeInfo* litaC_types__AsTraitFuncPtr(litaC_types__TypeInfo* litaC_type,const litaC_char* litaC_name,litaC_types_new__TypeCache* litaC_typeCache) {
    if(!(litaC_type)) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    assert(litaC_type->kind == litaC_types__TypeKind_FUNC_PTR);
    litaC_types__FuncPtrTypeInfo* litaC_funcPtr = (litaC_types__FuncPtrTypeInfo*)litaC_type;
    assert(litaC_funcPtr->isTrait);
    litaC_array__Array_cb__ptr_TypeInfo_ce_ litaC_params = litaC_array__ArrayInit_cb__ptr_TypeInfo_ce_(litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcPtr->paramDecls))) + 1, litaC_typeCache->allocator);
    litaC_array__Array_add_cb__ptr_TypeInfo_ce_(&((litaC_params)), (litaC_types__TypeInfo*)litaC_types_new__TypeCache_newPtrTypeInfo(litaC_typeCache, &(litaC_types__VOID_TYPE)));
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcPtr->paramDecls)));litaC_i += 1) {
        {
            litaC_array__Array_add_cb__ptr_TypeInfo_ce_(&((litaC_params)), litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_funcPtr->paramDecls)), litaC_i));
            
            
        }
    }
    litaC_types__FuncPtrTypeInfo* litaC_result = litaC_types_new__TypeCache_newFuncPtrTypeInfo(litaC_typeCache, litaC_funcPtr->genericParams, litaC_funcPtr->returnType, litaC_params, litaC_funcPtr->hasVarargs);
    litaC_result->info.typeInfo.name = litaC_name;
    return litaC_result;
    
    
}

litaC_types__AggregateTypeInfo* litaC_types__AsAggregate(litaC_types__TypeInfo* litaC_type) {
    assert(litaC_types__IsAggregateLike(litaC_type));
    if(litaC_types__IsAggregate(litaC_type)) {
        {
            if(litaC_type->kind == litaC_types__TypeKind_CONST) {
                {
                    litaC_types__ConstTypeInfo* litaC_constInfo = (litaC_types__ConstTypeInfo*)litaC_type;
                    return litaC_types__AsAggregate(litaC_constInfo->constOf);
                    
                    
                    
                }
                
            } 
            
            return (litaC_types__AggregateTypeInfo*)litaC_type;
            
            
            
        }
        
    } 
    
    if(litaC_types__IsPtrAggregate(litaC_type)) {
        {
            litaC_types__TypeInfo* litaC_ptrInfo = NULL;
            if(litaC_type->kind == litaC_types__TypeKind_CONST) {
                {
                    litaC_types__ConstTypeInfo* litaC_constInfo = (litaC_types__ConstTypeInfo*)litaC_type;
                    litaC_ptrInfo = litaC_constInfo->constOf;
                    
                    
                }
                
            } else {
                {
                    litaC_ptrInfo = ((litaC_types__PtrTypeInfo*)litaC_type)->ptrOf;
                    
                    
                }
            } 
            
            return litaC_types__AsAggregate(litaC_ptrInfo);
            
            
            
        }
        
    } 
    
    assert(litaC_false);
    return NULL;
    
    
}

litaC_bool litaC_types__IsAggregateLike(litaC_types__TypeInfo* litaC_type) {
    return litaC_types__IsAggregate(litaC_type) || litaC_types__IsPtrAggregate(litaC_type);
    
    
}

litaC_bool litaC_types__IsAggregate(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_type->kind == litaC_types__TypeKind_CONST) {
        {
            litaC_types__ConstTypeInfo* litaC_constInfo = (litaC_types__ConstTypeInfo*)litaC_type;
            return litaC_types__IsAggregate(litaC_constInfo->constOf);
            
            
            
        }
        
    } 
    
    return litaC_type->kind == litaC_types__TypeKind_STRUCT || litaC_type->kind == litaC_types__TypeKind_UNION || litaC_type->kind == litaC_types__TypeKind_TRAIT;
    
    
}

litaC_bool litaC_types__IsPtrAggregate(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_types__IsPtr(litaC_type))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_ptrInfo = NULL;
    if(litaC_type->kind == litaC_types__TypeKind_CONST) {
        {
            litaC_types__ConstTypeInfo* litaC_constInfo = (litaC_types__ConstTypeInfo*)litaC_type;
            litaC_ptrInfo = litaC_constInfo->constOf;
            
            
        }
        
    } else {
        {
            litaC_ptrInfo = ((litaC_types__PtrTypeInfo*)litaC_type)->ptrOf;
            
            
        }
    } 
    
    return litaC_types__IsAggregate(litaC_ptrInfo);
    
    
}

litaC_bool litaC_types__IsTrait(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_type->kind == litaC_types__TypeKind_CONST) {
        {
            litaC_types__ConstTypeInfo* litaC_constInfo = (litaC_types__ConstTypeInfo*)litaC_type;
            return litaC_types__IsTrait(litaC_constInfo->constOf);
            
            
            
        }
        
    } 
    
    return litaC_type->kind == litaC_types__TypeKind_TRAIT;
    
    
}

litaC_bool litaC_types__IsPtrTrait(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_types__IsPtr(litaC_type))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_ptrInfo = NULL;
    if(litaC_type->kind == litaC_types__TypeKind_CONST) {
        {
            litaC_types__ConstTypeInfo* litaC_constInfo = (litaC_types__ConstTypeInfo*)litaC_type;
            litaC_ptrInfo = litaC_constInfo->constOf;
            
            
        }
        
    } else {
        {
            litaC_ptrInfo = ((litaC_types__PtrTypeInfo*)litaC_type)->ptrOf;
            
            
        }
    } 
    
    return litaC_types__IsTrait(litaC_ptrInfo);
    
    
}

litaC_bool litaC_types__IsTraitLike(litaC_types__TypeInfo* litaC_type) {
    return litaC_types__IsTrait(litaC_type) || litaC_types__IsPtrTrait(litaC_type);
    
    
}

litaC_bool litaC_types__IsFieldAccessible(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_types__IsAggregate(litaC_type) || litaC_types__IsPtrAggregate(litaC_type) || litaC_type->kind == litaC_types__TypeKind_ENUM) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    return litaC_false;
    
    
}

litaC_bool litaC_types__IsGenericCapable(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_FUNC: 
        case litaC_types__TypeKind_FUNC_PTR: 
        case litaC_types__TypeKind_STRUCT: 
        case litaC_types__TypeKind_TRAIT: 
        case litaC_types__TypeKind_UNION: {
            return litaC_true;
            
            
            
        }
        default: {
            return litaC_false;
            
            
            
        }
    }
    
}

litaC_types__TypeInfo* litaC_types__TypeInfo_getBaseType(litaC_types__TypeInfo* litaC_this) {
    if(!(litaC_this)) {
        return NULL;
        
        
    } 
    
    switch(litaC_this->kind) {
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__PtrTypeInfo* litaC_info = (litaC_types__PtrTypeInfo*)litaC_this;
                return litaC_types__TypeInfo_getBaseType(litaC_info->ptrOf);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__ConstTypeInfo* litaC_info = (litaC_types__ConstTypeInfo*)litaC_this;
                return litaC_types__TypeInfo_getBaseType(litaC_info->constOf);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__ArrayTypeInfo* litaC_info = (litaC_types__ArrayTypeInfo*)litaC_this;
                if(litaC_info->arrayOf->kind == litaC_types__TypeKind_ARRAY) {
                    {
                        return litaC_types__TypeInfo_getBaseType(litaC_info->arrayOf);
                        
                        
                        
                    }
                    
                } 
                
                return litaC_info->arrayOf;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STR: {
            {
                return &(litaC_types__CHAR_TYPE);
                
                
                
            }
            
            
        }
        default: {
            {
                return litaC_this;
                
                
                
            }
            
            
        }
    }
    
}

litaC_types__TypeInfo* litaC_types__TypeInfo_getTypeOf(litaC_types__TypeInfo* litaC_this) {
    if(!(litaC_this)) {
        return NULL;
        
        
    } 
    
    switch(litaC_this->kind) {
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__PtrTypeInfo* litaC_info = (litaC_types__PtrTypeInfo*)litaC_this;
                return litaC_info->ptrOf;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__ConstTypeInfo* litaC_info = (litaC_types__ConstTypeInfo*)litaC_this;
                return litaC_info->constOf;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__ArrayTypeInfo* litaC_info = (litaC_types__ArrayTypeInfo*)litaC_this;
                return litaC_info->arrayOf;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STR: {
            {
                return &(litaC_types__CHAR_TYPE);
                
                
                
            }
            
            
        }
        default: {
            {
                return NULL;
                
                
                
            }
            
            
        }
    }
    
}

const litaC_char* litaC_types__TypeInfo_toStringDebug(litaC_types__TypeInfo* litaC_this) {
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, NULL);
    litaC_types__TypeInfo_toString(litaC_this, &((litaC_sb)));
    return litaC_string_buffer__StringBuffer_cStr(&((litaC_sb)));
    
    
}

litaC_void litaC_types__TypeInfo_toString(litaC_types__TypeInfo* litaC_this,litaC_string_buffer__StringBuffer* litaC_sb) {
    if(!(litaC_this)) {
        return;
        
        
    } 
    
    switch(litaC_this->kind) {
        case litaC_types__TypeKind_BOOL: 
        case litaC_types__TypeKind_CHAR: 
        case litaC_types__TypeKind_I8: 
        case litaC_types__TypeKind_U8: 
        case litaC_types__TypeKind_I16: 
        case litaC_types__TypeKind_U16: 
        case litaC_types__TypeKind_I32: 
        case litaC_types__TypeKind_U32: 
        case litaC_types__TypeKind_I64: 
        case litaC_types__TypeKind_U64: 
        case litaC_types__TypeKind_F32: 
        case litaC_types__TypeKind_F64: 
        case litaC_types__TypeKind_USIZE: 
        case litaC_types__TypeKind_NULL: 
        case litaC_types__TypeKind_VOID: 
        case litaC_types__TypeKind_STRUCT: 
        case litaC_types__TypeKind_UNION: 
        case litaC_types__TypeKind_TRAIT: 
        case litaC_types__TypeKind_ENUM: 
        case litaC_types__TypeKind_GENERIC_PARAM: {
            litaC_string_buffer__StringBuffer_appendStr(litaC_sb, litaC_this->name);
            break;
            
            
        }
        case litaC_types__TypeKind_STR: {
            {
                litaC_string_buffer__StringBuffer_appendStr(litaC_sb, "*const char");
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__ArrayTypeInfo* litaC_arrayInfo = (litaC_types__ArrayTypeInfo*)litaC_this;
                if(litaC_arrayInfo->length) {
                    {
                        litaC_string_buffer__StringBuffer_append(litaC_sb, "[%llu]", litaC_arrayInfo->length);
                        
                        
                    }
                    
                } else {
                    {
                        litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, "[]", 2);
                        
                        
                    }
                } 
                
                litaC_types__TypeInfo_toString(litaC_arrayInfo->arrayOf, litaC_sb);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__PtrTypeInfo* litaC_ptrInfo = (litaC_types__PtrTypeInfo*)litaC_this;
                litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, "*", 1);
                litaC_types__TypeInfo_toString(litaC_ptrInfo->ptrOf, litaC_sb);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__ConstTypeInfo* litaC_constInfo = (litaC_types__ConstTypeInfo*)litaC_this;
                litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, "const ", 6);
                litaC_types__TypeInfo_toString(litaC_constInfo->constOf, litaC_sb);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC_PTR: {
            {
                litaC_types__FuncPtrTypeInfo* litaC_funcPtrInfo = (litaC_types__FuncPtrTypeInfo*)litaC_this;
                litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, "func", 4);
                if(!(litaC_array__Array_empty_cb_GenericParam_ce_(&((litaC_funcPtrInfo->genericParams))))) {
                    {
                        litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, "<", 1);
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_funcPtrInfo->genericParams)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, ",", 1);
                                    
                                } 
                                
                                litaC_lex__Token litaC_t = litaC_array__Array_get_cb_GenericParam_ce_(&((litaC_funcPtrInfo->genericParams)), litaC_i).name;
                                litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, litaC_t.value.str.buffer, litaC_t.value.str.length);
                                
                                
                            }
                        }
                        litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, ">", 1);
                        
                        
                    }
                    
                } 
                
                litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, "(", 1);
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcPtrInfo->paramDecls)));litaC_i += 1) {
                    {
                        if(litaC_i > 0) {
                            litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, ",", 1);
                            
                        } 
                        
                        litaC_types__TypeInfo* litaC_paramType = litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_funcPtrInfo->paramDecls)), litaC_i);
                        litaC_types__TypeInfo_toString(litaC_paramType, litaC_sb);
                        
                        
                    }
                }
                litaC_string_buffer__StringBuffer_appendStr(litaC_sb, ") : ");
                litaC_types__TypeInfo_toString(litaC_funcPtrInfo->returnType, litaC_sb);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC: {
            {
                litaC_types__FuncTypeInfo* litaC_funcInfo = (litaC_types__FuncTypeInfo*)litaC_this;
                litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, "func", 4);
                if(!(litaC_array__Array_empty_cb_GenericParam_ce_(&((litaC_funcInfo->decl->decl.genericParams))))) {
                    {
                        litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, "<", 1);
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_funcInfo->decl->decl.genericParams)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, ",", 1);
                                    
                                } 
                                
                                litaC_lex__Token litaC_t = litaC_array__Array_get_cb_GenericParam_ce_(&((litaC_funcInfo->decl->decl.genericParams)), litaC_i).name;
                                litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, litaC_t.value.str.buffer, litaC_t.value.str.length);
                                
                                
                            }
                        }
                        litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, ">", 1);
                        
                        
                    }
                    
                } 
                
                litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, "(", 1);
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params)));litaC_i += 1) {
                    {
                        if(litaC_i > 0) {
                            litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, ",", 1);
                            
                        } 
                        
                        litaC_ast__ParameterDecl* litaC_paramType = litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params)), litaC_i);
                        litaC_types__TypeInfo_toString(litaC_paramType->typeInfo, litaC_sb);
                        
                        
                    }
                }
                litaC_string_buffer__StringBuffer_appendStr(litaC_sb, ") : ");
                litaC_types__TypeInfo_toString(litaC_funcInfo->returnType, litaC_sb);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_POISON: {
            {
                litaC_string_buffer__StringBuffer_appendStr(litaC_sb, "<poison>");
                break;
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    
}

litaC_bool litaC_types__TypeInfo_strictEquals(litaC_types__TypeInfo* litaC_this,litaC_types__TypeInfo* litaC_other) {
    if(litaC_this == litaC_other) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    if(litaC_this && !(litaC_other)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_this) && litaC_other) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_this->kind != litaC_types__TypeKind_GENERIC_PARAM && litaC_other->kind != litaC_types__TypeKind_GENERIC_PARAM) {
        {
            if(litaC_other->kind != litaC_this->kind) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    switch(litaC_this->kind) {
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__PtrTypeInfo* litaC_thisInfo = (litaC_types__PtrTypeInfo*)litaC_this;
                litaC_types__PtrTypeInfo* litaC_otherInfo = (litaC_types__PtrTypeInfo*)litaC_other;
                return litaC_types__TypeInfo_strictEquals(litaC_thisInfo->ptrOf, litaC_otherInfo->ptrOf);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__ConstTypeInfo* litaC_thisInfo = (litaC_types__ConstTypeInfo*)litaC_this;
                litaC_types__ConstTypeInfo* litaC_otherInfo = (litaC_types__ConstTypeInfo*)litaC_other;
                return litaC_types__TypeInfo_strictEquals(litaC_thisInfo->constOf, litaC_otherInfo->constOf);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__ArrayTypeInfo* litaC_thisInfo = (litaC_types__ArrayTypeInfo*)litaC_this;
                litaC_types__ArrayTypeInfo* litaC_otherInfo = (litaC_types__ArrayTypeInfo*)litaC_other;
                if(litaC_thisInfo->length != litaC_otherInfo->length) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_types__TypeInfo_strictEquals(litaC_thisInfo->arrayOf, litaC_otherInfo->arrayOf);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC_PTR: {
            {
                litaC_types__FuncPtrTypeInfo* litaC_thisInfo = (litaC_types__FuncPtrTypeInfo*)litaC_this;
                litaC_types__FuncPtrTypeInfo* litaC_otherInfo = (litaC_types__FuncPtrTypeInfo*)litaC_other;
                if(litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_thisInfo->paramDecls))) != litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_otherInfo->paramDecls)))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_types__TypeInfo_strictEquals(litaC_thisInfo->returnType, litaC_otherInfo->returnType))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_thisInfo->paramDecls)));litaC_i += 1) {
                    {
                        litaC_types__TypeInfo* litaC_a = litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_thisInfo->paramDecls)), litaC_i);
                        litaC_types__TypeInfo* litaC_b = litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_otherInfo->paramDecls)), litaC_i);
                        if(litaC_types__TypeInfo_strictEquals(litaC_a, litaC_b)) {
                            {
                                return litaC_false;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_GENERIC_PARAM: {
            {
                if(litaC_other->kind == litaC_types__TypeKind_GENERIC_PARAM) {
                    {
                        return strcmp(litaC_this->name, litaC_other->name) == 0;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_true;
                
                
                
            }
            
            
        }
        default: {
            {
                if(litaC_other->kind == litaC_types__TypeKind_GENERIC_PARAM) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_this->typeid == litaC_other->typeid;
                
                
                
            }
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_bool litaC_types__TypeInfo_isAssignable(litaC_types__TypeInfo* litaC_this,litaC_types__TypeInfo* litaC_other,litaC_checker__TypeChecker* litaC_checker) {
    assert(litaC_this != NULL);
    assert(litaC_other != NULL);
    if(litaC_other->typeid == litaC_this->typeid) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    switch(litaC_this->kind) {
        case litaC_types__TypeKind_BOOL: {
            {
                if(litaC_other->kind == litaC_types__TypeKind_VOID) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CHAR: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_U32;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I8: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_I8;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U8: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_U8;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I16: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_I16;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U16: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_U16;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I32: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_I32 || litaC_other->kind == litaC_types__TypeKind_ENUM;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U32: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_U32 || litaC_other->kind == litaC_types__TypeKind_ENUM;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I64: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_I64 || litaC_other->kind == litaC_types__TypeKind_ENUM;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U64: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_U64 || litaC_other->kind == litaC_types__TypeKind_ENUM;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_F32: {
            {
                return litaC_other->kind == litaC_types__TypeKind_F32 || litaC_other->kind <= litaC_types__TypeKind_U32;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_F64: {
            {
                return litaC_other->kind == litaC_types__TypeKind_F32 || litaC_other->kind == litaC_types__TypeKind_F64;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_USIZE: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_USIZE || litaC_other->kind == litaC_types__TypeKind_NULL || litaC_types__IsPtrLike(litaC_other);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_NULL: {
            {
                return litaC_other->kind == litaC_types__TypeKind_NULL;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_VOID: {
            {
                return litaC_other->kind == litaC_types__TypeKind_VOID;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STR: {
            {
                if(litaC_types__IsInteger(litaC_other)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_other, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                if(litaC_types__IsInteger(litaC_other)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_other, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_PTR: {
            {
                if(litaC_types__IsInteger(litaC_other)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_other, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__ConstTypeInfo* litaC_thisInfo = (litaC_types__ConstTypeInfo*)litaC_this;
                if(litaC_other->kind != litaC_types__TypeKind_CONST) {
                    {
                        return litaC_types__TypeInfo_isAssignable(litaC_thisInfo->constOf, litaC_other, litaC_checker);
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__ConstTypeInfo* litaC_otherInfo = (litaC_types__ConstTypeInfo*)litaC_other;
                return litaC_types__TypeInfo_isAssignable(litaC_thisInfo->constOf, litaC_otherInfo->constOf, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STRUCT: {
            {
                if(litaC_other->kind != litaC_types__TypeKind_STRUCT) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_this->typeid == litaC_other->typeid;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_UNION: {
            {
                if(litaC_other->kind != litaC_types__TypeKind_UNION) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_this->typeid == litaC_other->typeid;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_TRAIT: {
            {
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_other, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ENUM: {
            {
                if(litaC_types__IsInteger(litaC_other)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_other->kind != litaC_types__TypeKind_ENUM) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_this->typeid == litaC_other->typeid;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC_PTR: {
            {
                if(litaC_other->kind == litaC_types__TypeKind_NULL) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_types__IsPtrOf(litaC_other, litaC_types__TypeKind_VOID)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_types__IsFuncLike(litaC_other))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__FuncPtrTypeInfo* litaC_thisInfo = (litaC_types__FuncPtrTypeInfo*)litaC_this;
                if(litaC_other->kind != litaC_types__TypeKind_FUNC) {
                    {
                        return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_other, litaC_checker);
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__FuncTypeInfo* litaC_funcInfo = (litaC_types__FuncTypeInfo*)litaC_other;
                if(litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params))) != litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_thisInfo->paramDecls)))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_funcInfo->decl->params->isVararg != litaC_thisInfo->hasVarargs) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_types__TypeInfo_strictEquals(litaC_funcInfo->returnType, litaC_thisInfo->returnType))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_thisInfo->paramDecls)));litaC_i += 1) {
                    {
                        litaC_types__TypeInfo* litaC_a = litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_thisInfo->paramDecls)), litaC_i);
                        litaC_ast__ParameterDecl* litaC_b = litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params)), litaC_i);
                        if(!(litaC_b->typeInfo)) {
                            {
                                return litaC_false;
                                
                                
                                
                            }
                            
                        } 
                        
                        if(!(litaC_types__TypeInfo_strictEquals(litaC_a, litaC_b->typeInfo))) {
                            {
                                return litaC_false;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_POISON: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
        default: {
            {
                printf("Type: %s\n", litaC_types__typeKindText[litaC_this->kind]);
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_bool litaC_types__TypeInfo_isDeclarable(litaC_types__TypeInfo* litaC_this,litaC_types__TypeInfo* litaC_other,litaC_checker__TypeChecker* litaC_checker) {
    switch(litaC_this->kind) {
        case litaC_types__TypeKind_BOOL: {
            {
                return litaC_other->kind == litaC_types__TypeKind_BOOL;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CHAR: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_U32;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I8: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_I8;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U8: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_U8;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I16: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_I16;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U16: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_U16;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I32: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_I32 || litaC_other->kind == litaC_types__TypeKind_ENUM;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U32: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_U32 || litaC_other->kind == litaC_types__TypeKind_ENUM;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I64: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_I64 || litaC_other->kind == litaC_types__TypeKind_ENUM;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U64: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_U64 || litaC_other->kind == litaC_types__TypeKind_ENUM;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_F32: {
            {
                return litaC_other->kind == litaC_types__TypeKind_F32 || litaC_other->kind <= litaC_types__TypeKind_U32;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_F64: {
            {
                return litaC_other->kind == litaC_types__TypeKind_F32 || litaC_other->kind == litaC_types__TypeKind_F64;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_USIZE: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_USIZE || litaC_other->kind == litaC_types__TypeKind_NULL || litaC_types__IsPtrLike(litaC_other);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_NULL: {
            {
                return litaC_other->kind == litaC_types__TypeKind_NULL;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_VOID: {
            {
                return litaC_other->kind == litaC_types__TypeKind_VOID;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STR: {
            {
                if(litaC_types__IsPtr(litaC_other)) {
                    {
                        litaC_types__PtrTypeInfo* litaC_otherPtr = (litaC_types__PtrTypeInfo*)litaC_other;
                        if(litaC_otherPtr->ptrOf->kind == litaC_types__TypeKind_CONST) {
                            {
                                litaC_types__ConstTypeInfo* litaC_constOf = (litaC_types__ConstTypeInfo*)litaC_otherPtr->ptrOf;
                                return litaC_constOf->constOf->kind == litaC_types__TypeKind_CHAR;
                                
                                
                                
                            }
                            
                        } 
                        
                        return litaC_otherPtr->ptrOf->kind == litaC_types__TypeKind_CHAR;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_other->kind == litaC_types__TypeKind_STR;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__ArrayTypeInfo* litaC_thisArray = (litaC_types__ArrayTypeInfo*)litaC_this;
                if(litaC_other->kind == litaC_types__TypeKind_STR) {
                    {
                        if(litaC_thisArray->arrayOf->kind == litaC_types__TypeKind_CONST) {
                            {
                                return litaC_types__IsPtrOf(litaC_thisArray->arrayOf, litaC_types__TypeKind_CHAR);
                                
                                
                                
                            }
                            
                        } 
                        
                        if(!(litaC_types__IsPtrOf(&((litaC_thisArray->info)), litaC_types__TypeKind_CHAR))) {
                            {
                                return litaC_false;
                                
                                
                                
                            }
                            
                        } 
                        
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_other->kind == litaC_types__TypeKind_PTR) {
                    {
                        litaC_types__PtrTypeInfo* litaC_otherPtr = (litaC_types__PtrTypeInfo*)litaC_other;
                        return litaC_types__TypeInfo_isDeclarable(litaC_thisArray->arrayOf, litaC_otherPtr->ptrOf, litaC_checker);
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_other->kind != litaC_types__TypeKind_ARRAY) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__ArrayTypeInfo* litaC_otherArray = (litaC_types__ArrayTypeInfo*)litaC_other;
                if(!(litaC_types__TypeInfo_isDeclarable(litaC_thisArray->arrayOf, litaC_otherArray->arrayOf, litaC_checker))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_thisArray->length)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_thisArray->length == litaC_otherArray->length;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_PTR: {
            {
                if(litaC_other->kind == litaC_types__TypeKind_NULL) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_other->kind == litaC_types__TypeKind_FUNC_PTR) {
                    {
                        if(litaC_types__IsPtrOf(litaC_this, litaC_types__TypeKind_VOID)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_types__IsPtrLike(litaC_other))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__PtrTypeInfo* litaC_thisPtr = (litaC_types__PtrTypeInfo*)litaC_this;
                litaC_bool litaC_isVoidPtr = litaC_false;
                litaC_bool litaC_isConst = litaC_false;
                litaC_types__TypeInfo* litaC_ptrOf = litaC_thisPtr->ptrOf;
                if(litaC_thisPtr->ptrOf->kind == litaC_types__TypeKind_CONST) {
                    {
                        litaC_types__ConstTypeInfo* litaC_thisConst = (litaC_types__ConstTypeInfo*)litaC_thisPtr->ptrOf;
                        litaC_ptrOf = litaC_thisConst->constOf;
                        litaC_isConst = litaC_true;
                        
                        
                    }
                    
                } 
                
                if(litaC_ptrOf->kind == litaC_types__TypeKind_VOID) {
                    {
                        litaC_isVoidPtr = litaC_true;
                        
                        
                    }
                    
                } 
                
                switch(litaC_other->kind) {
                    case litaC_types__TypeKind_PTR: {
                        {
                            litaC_types__PtrTypeInfo* litaC_otherPtr = (litaC_types__PtrTypeInfo*)litaC_other;
                            if(litaC_otherPtr->ptrOf->kind == litaC_types__TypeKind_CONST) {
                                {
                                    if(!(litaC_isConst)) {
                                        {
                                            return litaC_false;
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            if(litaC_isVoidPtr) {
                                {
                                    return litaC_true;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            if(litaC_types__IsTrait(litaC_ptrOf)) {
                                {
                                    litaC_types__TypeInfo* litaC_otherPtrOf = litaC_types__TypeInfo_getBaseType(&((litaC_otherPtr->info)));
                                    if(litaC_types__IsTrait(litaC_otherPtrOf)) {
                                        {
                                            return litaC_ptrOf->typeid == litaC_otherPtrOf->typeid;
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    return litaC_false;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            if(litaC_types__IsPtrAggregate(litaC_this) && litaC_types__IsPtrAggregate(litaC_other)) {
                                {
                                    litaC_types__AggregateTypeInfo* litaC_otherAgg = (litaC_types__AggregateTypeInfo*)litaC_types__TypeInfo_getBaseType(litaC_other);
                                    litaC_types__AggregateTypeInfo* litaC_thisAgg = (litaC_types__AggregateTypeInfo*)litaC_types__TypeInfo_getBaseType(litaC_this);
                                    if(litaC_otherAgg->info.typeInfo.typeid == litaC_thisAgg->info.typeInfo.typeid) {
                                        {
                                            return litaC_true;
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    litaC_ast__FieldStmt litaC_field = litaC_types__AggregateTypeInfo_getFieldByType(litaC_otherAgg, litaC_thisAgg, litaC_true);
                                    return (litaC_field.kind == litaC_ast__StmtKind_VAR_FIELD_DECL) || (litaC_field.kind == litaC_ast__StmtKind_TRAIT_FIELD_DECL);
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            return litaC_types__TypeInfo_isDeclarable(litaC_thisPtr->ptrOf, litaC_otherPtr->ptrOf, litaC_checker);
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_ARRAY: {
                        {
                            if(litaC_isVoidPtr) {
                                {
                                    return litaC_true;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_types__ArrayTypeInfo* litaC_otherArray = (litaC_types__ArrayTypeInfo*)litaC_other;
                            return litaC_types__TypeInfo_isDeclarable(litaC_thisPtr->ptrOf, litaC_otherArray->arrayOf, litaC_checker);
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_STR: {
                        {
                            if(!(litaC_isConst)) {
                                {
                                    return litaC_false;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            if(litaC_isVoidPtr) {
                                {
                                    return litaC_true;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            return litaC_types__TypeInfo_isDeclarable(litaC_thisPtr->ptrOf, &(litaC_types__CHAR_TYPE), litaC_checker);
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_CONST: {
                        {
                            return litaC_false;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_FUNC_PTR: {
                        {
                            return litaC_true;
                            
                            
                            
                        }
                        
                        
                    }
                    default: {
                        {
                            return litaC_false;
                            
                            
                            
                        }
                        
                        
                    }
                }
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__ConstTypeInfo* litaC_constInfo = (litaC_types__ConstTypeInfo*)litaC_this;
                if(litaC_other->kind == litaC_types__TypeKind_CONST) {
                    {
                        litaC_types__ConstTypeInfo* litaC_otherConst = (litaC_types__ConstTypeInfo*)litaC_other;
                        litaC_other = litaC_otherConst->constOf;
                        
                        
                    }
                    
                } 
                
                return litaC_types__TypeInfo_isDeclarable(litaC_constInfo->constOf, litaC_other, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC_PTR: {
            {
                if(litaC_other->kind == litaC_types__TypeKind_NULL) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_types__IsPtrOf(litaC_other, litaC_types__TypeKind_VOID)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_other->kind != litaC_types__TypeKind_FUNC_PTR) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__FuncPtrTypeInfo* litaC_fnPtrInfo = (litaC_types__FuncPtrTypeInfo*)litaC_this;
                litaC_types__FuncPtrTypeInfo* litaC_otherFnPtrInfo = (litaC_types__FuncPtrTypeInfo*)litaC_other;
                if(litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_fnPtrInfo->paramDecls))) != litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_otherFnPtrInfo->paramDecls)))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_fnPtrInfo->hasVarargs != litaC_otherFnPtrInfo->hasVarargs) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_types__TypeInfo_strictEquals(litaC_fnPtrInfo->returnType, litaC_otherFnPtrInfo->returnType))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_fnPtrInfo->paramDecls)));litaC_i += 1) {
                    {
                        litaC_types__TypeInfo* litaC_a = litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_fnPtrInfo->paramDecls)), litaC_i);
                        litaC_types__TypeInfo* litaC_b = litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_otherFnPtrInfo->paramDecls)), litaC_i);
                        if(!(litaC_types__TypeInfo_strictEquals(litaC_a, litaC_b))) {
                            {
                                return litaC_false;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STRUCT: {
            {
                if(litaC_other->kind != litaC_types__TypeKind_STRUCT) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_this->typeid == litaC_other->typeid) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_other;
                if(litaC_array__Array_empty_cb_FieldStmt_ce_(&((litaC_aggInfo->decl->fields)))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                litaC_ast__FieldStmt litaC_field = litaC_types__AggregateTypeInfo_getFieldByPosition(litaC_aggInfo, 0);
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_field.typeInfo, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_UNION: {
            {
                if(litaC_other->kind != litaC_types__TypeKind_UNION) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_this->typeid == litaC_other->typeid) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_other;
                if(litaC_array__Array_empty_cb_FieldStmt_ce_(&((litaC_aggInfo->decl->fields)))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                litaC_ast__FieldStmt litaC_field = litaC_types__AggregateTypeInfo_getFieldByPosition(litaC_aggInfo, 0);
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_field.typeInfo, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_TRAIT: {
            {
                if(litaC_this->typeid == litaC_other->typeid) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_types__IsPtrAggregate(litaC_other))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_types__TypeInfo_getBaseType(litaC_other);
                return litaC_types__AggregateTypeInfo_implementsTrait(litaC_aggInfo, litaC_this, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ENUM: {
            {
                if(litaC_other->kind != litaC_types__TypeKind_ENUM) {
                    {
                        return litaC_types__IsInteger(litaC_other);
                        
                        
                        
                    }
                    
                } 
                
                return litaC_this->typeid == litaC_other->typeid;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC: {
            {
                assert(litaC_false);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_POISON: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_bool litaC_types__TypeInfo_canCastTo(litaC_types__TypeInfo* litaC_this,litaC_types__TypeInfo* litaC_castTo,litaC_checker__TypeChecker* litaC_checker) {
    if(litaC_types__IsPtrOf(litaC_castTo, litaC_types__TypeKind_VOID)) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    if(litaC_castTo->kind == litaC_types__TypeKind_NULL) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_this->kind) {
        case litaC_types__TypeKind_BOOL: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CHAR: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I8: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U8: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I16: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U16: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I32: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U32: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I64: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U64: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_F32: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_F64: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_USIZE: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_NULL: {
            {
                return litaC_types__IsPtrLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_VOID: {
            {
                return litaC_castTo->kind == litaC_types__TypeKind_VOID;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STR: {
            {
                if(litaC_types__IsPtrLike(litaC_castTo)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_castTo, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                return litaC_types__IsPtrLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_PTR: {
            {
                if(litaC_castTo->kind == litaC_types__TypeKind_PTR) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_types__IsInteger(litaC_castTo)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_castTo, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC_PTR: {
            {
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_castTo, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STRUCT: {
            {
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_castTo, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_UNION: {
            {
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_castTo, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_TRAIT: {
            {
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_castTo, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ENUM: {
            {
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_castTo, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC: {
            {
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_castTo, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                if(litaC_castTo->kind != litaC_types__TypeKind_CONST) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_castTo, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_POISON: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_bool litaC_types__IsFuncImpl(litaC_types__FuncPtrTypeInfo* litaC_traitFn,litaC_types__TypeInfo* litaC_fn,litaC_checker__TypeChecker* litaC_checker) {
    assert(litaC_traitFn);
    assert(litaC_fn);
    if(litaC_fn->kind != litaC_types__TypeKind_FUNC) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__FuncTypeInfo* litaC_funcInfo = (litaC_types__FuncTypeInfo*)litaC_fn;
    if(litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params))) != litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_traitFn->paramDecls))) + 1) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_funcInfo->decl->params->isVararg != litaC_traitFn->hasVarargs) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_types__TypeInfo_strictEquals(litaC_funcInfo->returnType, litaC_traitFn->returnType))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_firstArg = litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params)), 0)->typeInfo;
    if(!(litaC_types__IsPtrAggregate(litaC_firstArg))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_traitFn->paramDecls)));litaC_i += 1) {
        {
            litaC_types__TypeInfo* litaC_a = litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_traitFn->paramDecls)), litaC_i);
            litaC_ast__ParameterDecl* litaC_b = litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params)), litaC_i + 1);
            if(!(litaC_b->typeInfo)) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            if(!(litaC_types__TypeInfo_strictEquals(litaC_a, litaC_b->typeInfo))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_true;
    
    
}

litaC_ast__TypeSpec* litaC_types__TypeInfo_asTypeSpec(litaC_types__TypeInfo* litaC_this,const litaC_mem__Allocator* litaC_allocator) {
    litaC_lex__SrcPos litaC_pos = ((litaC_this->sym)) ? litaC_this->sym->decl->stmt.node.startPos : (litaC_lex__SrcPos) {
        
    };
    switch(litaC_this->kind) {
        case litaC_types__TypeKind_BOOL: {
            {
                return (litaC_ast__TypeSpec*)litaC_ast_new__NewNameTypeSpec(litaC_pos, "bool", litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CHAR: {
            {
                return (litaC_ast__TypeSpec*)litaC_ast_new__NewNameTypeSpec(litaC_pos, "char", litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I8: {
            {
                return (litaC_ast__TypeSpec*)litaC_ast_new__NewNameTypeSpec(litaC_pos, "i8", litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U8: {
            {
                return (litaC_ast__TypeSpec*)litaC_ast_new__NewNameTypeSpec(litaC_pos, "u8", litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I16: {
            {
                return (litaC_ast__TypeSpec*)litaC_ast_new__NewNameTypeSpec(litaC_pos, "i16", litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U16: {
            {
                return (litaC_ast__TypeSpec*)litaC_ast_new__NewNameTypeSpec(litaC_pos, "u16", litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I32: {
            {
                return (litaC_ast__TypeSpec*)litaC_ast_new__NewNameTypeSpec(litaC_pos, "i32", litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U32: {
            {
                return (litaC_ast__TypeSpec*)litaC_ast_new__NewNameTypeSpec(litaC_pos, "u32", litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I64: {
            {
                return (litaC_ast__TypeSpec*)litaC_ast_new__NewNameTypeSpec(litaC_pos, "i64", litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U64: {
            {
                return (litaC_ast__TypeSpec*)litaC_ast_new__NewNameTypeSpec(litaC_pos, "u64", litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_F32: {
            {
                return (litaC_ast__TypeSpec*)litaC_ast_new__NewNameTypeSpec(litaC_pos, "f32", litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_F64: {
            {
                return (litaC_ast__TypeSpec*)litaC_ast_new__NewNameTypeSpec(litaC_pos, "f64", litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_USIZE: {
            {
                return (litaC_ast__TypeSpec*)litaC_ast_new__NewNameTypeSpec(litaC_pos, "usize", litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_NULL: {
            {
                return (litaC_ast__TypeSpec*)litaC_ast_new__NewNameTypeSpec(litaC_pos, "null", litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_VOID: {
            {
                return (litaC_ast__TypeSpec*)litaC_ast_new__NewNameTypeSpec(litaC_pos, "void", litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STR: {
            {
                return (litaC_ast__TypeSpec*)litaC_ast_new__NewNameTypeSpec(litaC_pos, "*const char", litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__ArrayTypeInfo* litaC_arrayInfo = (litaC_types__ArrayTypeInfo*)litaC_this;
                litaC_ast__ArrayTypeSpec* litaC_arrayTypeSpec = (litaC_ast__ArrayTypeSpec*)litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind_ARRAY, litaC_pos, litaC_allocator);
                litaC_arrayTypeSpec->spec.base = litaC_types__TypeInfo_asTypeSpec(litaC_arrayInfo->arrayOf, litaC_allocator);
                litaC_arrayTypeSpec->numElements = litaC_arrayInfo->numOfElements;
                return (litaC_ast__TypeSpec*)litaC_arrayTypeSpec;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__PtrTypeInfo* litaC_ptrInfo = (litaC_types__PtrTypeInfo*)litaC_this;
                litaC_ast__PtrTypeSpec* litaC_ptrTypeSpec = (litaC_ast__PtrTypeSpec*)litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind_PTR, litaC_pos, litaC_allocator);
                litaC_ptrTypeSpec->spec.base = litaC_types__TypeInfo_asTypeSpec(litaC_ptrInfo->ptrOf, litaC_allocator);
                return (litaC_ast__TypeSpec*)litaC_ptrTypeSpec;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__ConstTypeInfo* litaC_constInfo = (litaC_types__ConstTypeInfo*)litaC_this;
                litaC_ast__ConstTypeSpec* litaC_constTypeSpec = (litaC_ast__ConstTypeSpec*)litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind_CONST, litaC_pos, litaC_allocator);
                litaC_constTypeSpec->spec.base = litaC_types__TypeInfo_asTypeSpec(litaC_constInfo->constOf, litaC_allocator);
                return (litaC_ast__TypeSpec*)litaC_constTypeSpec;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC_PTR: {
            {
                litaC_types__FuncPtrTypeInfo* litaC_funcInfo = (litaC_types__FuncPtrTypeInfo*)litaC_this;
                litaC_array__Array_cb__ptr_TypeSpec_ce_ litaC_args =  {
                    
                };
                litaC_array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_args)), litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcInfo->paramDecls))), litaC_allocator);
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcInfo->paramDecls)));litaC_i += 1) {
                    {
                        litaC_types__TypeInfo* litaC_param = litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_funcInfo->paramDecls)), litaC_i);
                        litaC_array__Array_add_cb__ptr_TypeSpec_ce_(&((litaC_args)), litaC_types__TypeInfo_asTypeSpec(litaC_param, litaC_allocator));
                        
                        
                    }
                }
                litaC_ast__FuncPtrTypeSpec* litaC_result = (litaC_ast__FuncPtrTypeSpec*)litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind_FUNC_PTR, litaC_pos, litaC_allocator);
                litaC_result->ret = litaC_types__TypeInfo_asTypeSpec(litaC_funcInfo->returnType, litaC_allocator);
                litaC_result->args = litaC_args;
                litaC_result->hasVarargs = litaC_funcInfo->hasVarargs;
                litaC_result->genericParams = litaC_funcInfo->genericParams;
                return (litaC_ast__TypeSpec*)litaC_result;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_TRAIT: 
        case litaC_types__TypeKind_UNION: 
        case litaC_types__TypeKind_STRUCT: {
            {
                litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_this;
                litaC_ast__NameTypeSpec* litaC_result = litaC_ast_new__NewNameTypeSpec(litaC_pos, litaC_aggInfo->info.typeInfo.name, litaC_allocator);
                litaC_array__Array_cb__ptr_TypeSpec_ce_ litaC_args =  {
                    
                };
                litaC_array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_args)), litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_aggInfo->decl->decl.genericParams))), litaC_allocator);
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_aggInfo->decl->decl.genericParams)));litaC_i += 1) {
                    {
                        litaC_ast__GenericParam litaC_param = litaC_array__Array_get_cb_GenericParam_ce_(&((litaC_aggInfo->decl->decl.genericParams)), litaC_i);
                        litaC_char* litaC_name = (litaC_char*)litaC_mem__Allocator_alloc(litaC_allocator, (litaC_param.name.value.str.length + 1) * sizeof(litaC_char));
                        litaC_string_view__StringView_copyTo(litaC_param.name.value.str, litaC_name, litaC_param.name.value.str.length, litaC_true);
                        litaC_array__Array_add_cb__ptr_TypeSpec_ce_(&((litaC_args)), (litaC_ast__TypeSpec*)litaC_ast_new__NewNameTypeSpec(litaC_pos, litaC_name, litaC_allocator));
                        
                        
                    }
                }
                litaC_result->genericArgs = litaC_args;
                return (litaC_ast__TypeSpec*)litaC_result;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ENUM: {
            {
                litaC_types__EnumTypeInfo* litaC_info = (litaC_types__EnumTypeInfo*)litaC_this;
                return (litaC_ast__TypeSpec*)litaC_ast_new__NewNameTypeSpec(litaC_pos, litaC_info->info.name, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC: {
            {
                litaC_types__FuncTypeInfo* litaC_info = (litaC_types__FuncTypeInfo*)litaC_this;
                return (litaC_ast__TypeSpec*)litaC_ast_new__NewNameTypeSpec(litaC_pos, litaC_info->info.typeInfo.name, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_POISON: {
            {
                return (litaC_ast__TypeSpec*)litaC_ast_new__NewNameTypeSpec(litaC_pos, "<poison>", litaC_allocator);
                
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return NULL;
    
    
}

litaC_types__FuncPtrTypeInfo* litaC_types__FuncTypeInfo_asPtr(litaC_types__FuncTypeInfo* litaC_this,litaC_types_new__TypeCache* litaC_typeCache) {
    litaC_array__Array_cb_GenericParam_ce_ litaC_genericParams = litaC_array__ArrayInit_cb_GenericParam_ce_(litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_this->decl->decl.genericParams))), litaC_typeCache->allocator);
    litaC_array__Array_addAll_cb_GenericParam_ce_(&((litaC_genericParams)), &((litaC_this->decl->decl.genericParams)));
    litaC_array__Array_cb__ptr_TypeInfo_ce_ litaC_paramDecls = litaC_array__ArrayInit_cb__ptr_TypeInfo_ce_(litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_this->decl->params->params))), litaC_typeCache->allocator);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_this->decl->params->params)));litaC_i += 1) {
        {
            litaC_ast__ParameterDecl* litaC_p = litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_this->decl->params->params)), litaC_i);
            litaC_array__Array_add_cb__ptr_TypeInfo_ce_(&((litaC_paramDecls)), litaC_p->typeInfo);
            
            
        }
    }
    litaC_types__FuncPtrTypeInfo* litaC_funcPtr = litaC_types_new__TypeCache_newFuncPtrTypeInfo(litaC_typeCache, litaC_genericParams, litaC_this->returnType, litaC_paramDecls, litaC_this->decl->flags & litaC_ast__FuncFlags_HAS_VARARGS);
    litaC_funcPtr->info.typeInfo.name = litaC_this->info.typeInfo.name;
    return litaC_funcPtr;
    
    
}

litaC_ast__EnumFieldEntryDecl* litaC_types__EnumTypeInfo_getField(litaC_types__EnumTypeInfo* litaC_this,const litaC_char* litaC_name) {
    assert(litaC_this != NULL);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_this->decl->fields)));litaC_i += 1) {
        {
            litaC_ast__EnumFieldEntryDecl* litaC_field = litaC_array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_this->decl->fields)), litaC_i);
            if(litaC_string_view__StringView_equals(litaC_field->decl.name.value.str, litaC_name, -(1))) {
                {
                    return litaC_field;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return NULL;
    
    
}

litaC_i32 litaC_types__EnumTypeInfo_getFieldIndex(litaC_types__EnumTypeInfo* litaC_this,const litaC_char* litaC_name) {
    assert(litaC_this != NULL);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_this->decl->fields)));litaC_i += 1) {
        {
            litaC_ast__EnumFieldEntryDecl* litaC_field = litaC_array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_this->decl->fields)), litaC_i);
            if(litaC_string_view__StringView_equals(litaC_field->decl.name.value.str, litaC_name, -(1))) {
                {
                    return litaC_i;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return -(1);
    
    
}

const litaC_char* litaC_types__AggregateTypeInfo_getBaseName(litaC_types__AggregateTypeInfo* litaC_this,litaC_char* litaC_name) {
    assert(litaC_this != NULL);
    litaC_i32 litaC_index = 0;
    const litaC_char* litaC_n = litaC_this->info.typeInfo.name;
    while(*(litaC_n)) {
        {
            litaC_char litaC_c = *(litaC_n);
            if(litaC_c == '<') {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_name[litaC_index] = litaC_c;
            litaC_n += 1;
            litaC_index += 1;
            
            
        }
    }
    litaC_name[litaC_index] = '\0';
    return litaC_name;
    
    
}

litaC_ast__FieldStmt litaC_types__AggregateTypeInfo_getFieldByPosition(litaC_types__AggregateTypeInfo* litaC_this,litaC_i32 litaC_position) {
    assert(litaC_this != NULL);
    if(litaC_position < 0 || litaC_position >= litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_this->decl->fields)))) {
        {
            return (litaC_ast__FieldStmt) {
                .kind = litaC_ast__StmtKind_POISON_EXPR
            };
            
            
            
        }
        
    } 
    
    return litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_this->decl->fields)), litaC_position);
    
    
}

litaC_ast__FieldStmt litaC_types__AggregateTypeInfo_getField(litaC_types__AggregateTypeInfo* litaC_this,const litaC_char* litaC_name) {
    assert(litaC_this != NULL);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_this->decl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_this->decl->fields)), litaC_i);
            switch(litaC_field.kind) {
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        litaC_ast__TraitFieldDecl* litaC_varField = litaC_field.traitField;
                        if(litaC_string_view__StringView_equals(litaC_varField->decl.name.value.str, litaC_name, -(1))) {
                            {
                                if(!(litaC_field.typeInfo)) {
                                    {
                                        goto err;
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                return litaC_field;
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                        if(litaC_string_view__StringView_equals(litaC_varField->decl.name.value.str, litaC_name, -(1))) {
                            {
                                if(!(litaC_field.typeInfo)) {
                                    {
                                        goto err;
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                return litaC_field;
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                    {
                        litaC_ast__EnumDecl* litaC_enumField = litaC_field.enumField;
                        if(litaC_string_view__StringView_equals(litaC_enumField->decl.name.value.str, litaC_name, -(1))) {
                            {
                                return litaC_field;
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                    {
                        litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                        if(litaC_aggField->decl.declaration.name.type == litaC_lex__TokenType_VOID) {
                            {
                                litaC_types__AggregateTypeInfo* litaC_aggType = (litaC_types__AggregateTypeInfo*)litaC_aggField->decl.declaration.sym->type;
                                litaC_ast__FieldStmt litaC_result = litaC_types__AggregateTypeInfo_getField(litaC_aggType, litaC_name);
                                if(litaC_result.kind != litaC_ast__StmtKind_POISON_EXPR) {
                                    {
                                        return litaC_result;
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_string_view__StringView_equals(litaC_aggField->decl.declaration.name.value.str, litaC_name, -(1))) {
                            {
                                return litaC_field;
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        goto err;
                        
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    err:;
    
    return (litaC_ast__FieldStmt) {
        .kind = litaC_ast__StmtKind_POISON_EXPR
    };
    
    
}


litaC_i32 litaC_types__AggregateTypeInfo_getFieldIndex(litaC_types__AggregateTypeInfo* litaC_this,const litaC_char* litaC_name) {
    assert(litaC_this != NULL);
    litaC_i32 litaC_index = 0;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_this->decl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_this->decl->fields)), litaC_i);
            switch(litaC_field.kind) {
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        litaC_ast__TraitFieldDecl* litaC_varField = litaC_field.traitField;
                        if(litaC_string_view__StringView_equals(litaC_varField->decl.name.value.str, litaC_name, -(1))) {
                            {
                                if(!(litaC_field.typeInfo)) {
                                    {
                                        goto err;
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                return litaC_index;
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                        if(litaC_string_view__StringView_equals(litaC_varField->decl.name.value.str, litaC_name, -(1))) {
                            {
                                if(!(litaC_field.typeInfo)) {
                                    {
                                        goto err;
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                return litaC_index;
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                    {
                        litaC_ast__EnumDecl* litaC_enumField = litaC_field.enumField;
                        if(litaC_string_view__StringView_equals(litaC_enumField->decl.name.value.str, litaC_name, -(1))) {
                            {
                                return litaC_index;
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                    {
                        litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                        if(litaC_aggField->decl.declaration.name.type == litaC_lex__TokenType_VOID) {
                            {
                                litaC_types__AggregateTypeInfo* litaC_aggType = (litaC_types__AggregateTypeInfo*)litaC_aggField->decl.declaration.sym->type;
                                litaC_i32 litaC_result = litaC_types__AggregateTypeInfo_getFieldIndex(litaC_aggType, litaC_name);
                                if(litaC_result < 0) {
                                    {
                                        litaC_index += litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_aggType->decl->fields)));
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        return litaC_index + litaC_result;
                                        
                                        
                                        
                                    }
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_string_view__StringView_equals(litaC_aggField->decl.declaration.name.value.str, litaC_name, -(1))) {
                            {
                                return litaC_index;
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        goto err;
                        
                        
                        
                    }
                    
                    
                }
            }
            litaC_index += 1;
            
            
        }
    }
    err:;
    
    return -(1);
    
    
}


litaC_types__FieldPositionResult litaC_types__AggregateTypeInfo_getFieldPosition(litaC_types__AggregateTypeInfo* litaC_this,const litaC_char* litaC_name) {
    litaC_types__FieldPath litaC_path =  {
        
    };
    if(litaC_types__AggregateTypeInfo_getFieldPath(litaC_this, litaC_name, &(litaC_path))) {
        {
            litaC_types__AggregateTypeInfo* litaC_aggInfo = litaC_this;
            litaC_i32 litaC_index = litaC_path.numOfFields - 1;
            while(litaC_index > 0) {
                {
                    litaC_types__TypeInfo* litaC_fieldInfo = litaC_path.fields[litaC_index].typeInfo;
                    if(litaC_types__IsAggregate(litaC_fieldInfo)) {
                        {
                            litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_fieldInfo;
                            break;
                            
                            
                        }
                        
                    } 
                    
                    litaC_index -= 1;
                    
                    
                }
            }
            return (litaC_types__FieldPositionResult) {
                .aggInfo = litaC_aggInfo,
                .position = litaC_types__AggregateTypeInfo_getFieldIndex(litaC_aggInfo, litaC_name)
            };
            
            
            
        }
        
    } 
    
    return (litaC_types__FieldPositionResult) {
        .aggInfo = NULL,
        .position = -(1)
    };
    
    
}


litaC_ast__FieldStmt litaC_types__AggregateTypeInfo_getFieldByType(litaC_types__AggregateTypeInfo* litaC_this,litaC_types__AggregateTypeInfo* litaC_type,litaC_bool litaC_isParent) {
    assert(litaC_this != NULL);
    litaC_bool litaC_isGenericCapable = litaC_symbols__Symbol_isGenericCapable(litaC_type->info.typeInfo.sym);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_this->decl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_this->decl->fields)), litaC_i);
            if(!(litaC_types__IsAggregateLike(litaC_field.typeInfo))) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_isParent && litaC_field.kind == litaC_ast__StmtKind_VAR_FIELD_DECL) {
                {
                    if(!(litaC_field.varField->decl.attributes.isUsing)) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            litaC_types__AggregateTypeInfo* litaC_fieldBaseType = (litaC_types__AggregateTypeInfo*)litaC_types__TypeInfo_getBaseType(litaC_field.typeInfo);
            if(litaC_symbols__Symbol_isGenericCapable(litaC_fieldBaseType->info.typeInfo.sym) && litaC_isGenericCapable) {
                {
                    if(litaC_fieldBaseType->info.genericTypeid == litaC_type->info.genericTypeid) {
                        {
                            return litaC_field;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            if(litaC_fieldBaseType->info.typeInfo.typeid == litaC_type->info.typeInfo.typeid) {
                {
                    return litaC_field;
                    
                    
                    
                }
                
            } 
            
            switch(litaC_field.kind) {
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                    {
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                    {
                        litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                        if(litaC_aggField->decl.declaration.name.type == litaC_lex__TokenType_VOID) {
                            {
                                litaC_types__AggregateTypeInfo* litaC_aggType = (litaC_types__AggregateTypeInfo*)litaC_aggField->decl.declaration.sym->type;
                                litaC_ast__FieldStmt litaC_result = litaC_types__AggregateTypeInfo_getFieldByType(litaC_aggType, litaC_type, litaC_false);
                                if(litaC_result.kind != litaC_ast__StmtKind_POISON_EXPR) {
                                    {
                                        return litaC_result;
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    return (litaC_ast__FieldStmt) {
        .kind = litaC_ast__StmtKind_POISON_EXPR
    };
    
    
}

litaC_ast__FieldStmt litaC_types__AggregateTypeInfo_getFieldWithUsing(litaC_types__AggregateTypeInfo* litaC_this,const litaC_char* litaC_name) {
    assert(litaC_this != NULL);
    litaC_ast__FieldStmt litaC_fieldStmt = litaC_types__AggregateTypeInfo_getField(litaC_this, litaC_name);
    if(litaC_fieldStmt.kind != litaC_ast__StmtKind_POISON_EXPR) {
        {
            return litaC_fieldStmt;
            
            
            
        }
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_this->decl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_this->decl->fields)), litaC_i);
            switch(litaC_field.kind) {
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        continue;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                        if(!(litaC_varField->decl.attributes.isUsing)) {
                            {
                                continue;
                                
                                
                            }
                            
                        } 
                        
                        if(!(litaC_types__IsAggregate(litaC_field.typeInfo)) && !(litaC_types__IsPtrAggregate(litaC_field.typeInfo))) {
                            {
                                continue;
                                
                                
                            }
                            
                        } 
                        
                        litaC_types__AggregateTypeInfo* litaC_baseType = (litaC_types__AggregateTypeInfo*)litaC_types__TypeInfo_getBaseType(litaC_field.typeInfo);
                        assert(litaC_baseType->info.typeInfo.kind == litaC_types__TypeKind_STRUCT || litaC_baseType->info.typeInfo.kind == litaC_types__TypeKind_UNION);
                        litaC_fieldStmt = litaC_types__AggregateTypeInfo_getFieldWithUsing(litaC_baseType, litaC_name);
                        if(litaC_fieldStmt.kind != litaC_ast__StmtKind_POISON_EXPR) {
                            {
                                return litaC_fieldStmt;
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        continue;
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    return (litaC_ast__FieldStmt) {
        .kind = litaC_ast__StmtKind_POISON_EXPR
    };
    
    
}

litaC_void litaC_types__FieldPath_add(litaC_types__FieldPath* litaC_this,litaC_ast__FieldStmt litaC_field) {
    litaC_this->fields[litaC_this->numOfFields] = litaC_field;
    litaC_this->numOfFields += 1;
    assert(litaC_this->numOfFields < litaC_types__MAX_FIELD_PATH);
    
}

litaC_void litaC_types__FieldPath_pop(litaC_types__FieldPath* litaC_this) {
    litaC_this->numOfFields -= 1;
    if(litaC_this->numOfFields < 0) {
        {
            litaC_this->numOfFields = 0;
            
            
        }
        
    } 
    
    
}

litaC_bool litaC_types__AggregateTypeInfo_getFieldPath(litaC_types__AggregateTypeInfo* litaC_this,const litaC_char* litaC_name,litaC_types__FieldPath* litaC_path) {
    assert(litaC_this != NULL);
    litaC_ast__FieldStmt litaC_fieldStmt = litaC_types__AggregateTypeInfo_getField(litaC_this, litaC_name);
    if(litaC_fieldStmt.kind != litaC_ast__StmtKind_POISON_EXPR) {
        {
            litaC_types__FieldPath_add(litaC_path, litaC_fieldStmt);
            return litaC_true;
            
            
            
        }
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_this->decl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_this->decl->fields)), litaC_i);
            switch(litaC_field.kind) {
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        continue;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                        if(!(litaC_varField->decl.attributes.isUsing)) {
                            {
                                continue;
                                
                                
                            }
                            
                        } 
                        
                        if(!(litaC_types__IsAggregate(litaC_field.typeInfo)) && !(litaC_types__IsPtrAggregate(litaC_field.typeInfo))) {
                            {
                                continue;
                                
                                
                            }
                            
                        } 
                        
                        litaC_types__AggregateTypeInfo* litaC_baseType = (litaC_types__AggregateTypeInfo*)litaC_types__TypeInfo_getBaseType(litaC_field.typeInfo);
                        assert(litaC_types__IsAggregate(&((litaC_baseType->info.typeInfo))));
                        litaC_types__FieldPath_add(litaC_path, litaC_field);
                        if(litaC_types__AggregateTypeInfo_getFieldPath(litaC_baseType, litaC_name, litaC_path)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_types__FieldPath_pop(litaC_path);
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        continue;
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_bool litaC_types__AggregateTypeInfo_getFieldPathByType(litaC_types__AggregateTypeInfo* litaC_this,litaC_types__AggregateTypeInfo* litaC_type,litaC_types__FieldPath* litaC_path) {
    assert(litaC_this != NULL);
    litaC_ast__FieldStmt litaC_fieldStmt = litaC_types__AggregateTypeInfo_getFieldByType(litaC_this, litaC_type, litaC_true);
    if(litaC_fieldStmt.kind != litaC_ast__StmtKind_POISON_EXPR) {
        {
            litaC_types__FieldPath_add(litaC_path, litaC_fieldStmt);
            return litaC_true;
            
            
            
        }
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_this->decl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_this->decl->fields)), litaC_i);
            switch(litaC_field.kind) {
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        continue;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                        if(!(litaC_varField->decl.attributes.isUsing)) {
                            {
                                continue;
                                
                                
                            }
                            
                        } 
                        
                        if(!(litaC_types__IsAggregateLike(litaC_field.typeInfo))) {
                            {
                                continue;
                                
                                
                            }
                            
                        } 
                        
                        litaC_types__AggregateTypeInfo* litaC_baseType = (litaC_types__AggregateTypeInfo*)litaC_types__TypeInfo_getBaseType(litaC_field.typeInfo);
                        assert(litaC_baseType->info.typeInfo.kind == litaC_types__TypeKind_STRUCT || litaC_baseType->info.typeInfo.kind == litaC_types__TypeKind_UNION);
                        litaC_types__FieldPath_add(litaC_path, litaC_field);
                        if(litaC_types__AggregateTypeInfo_getFieldPathByType(litaC_baseType, litaC_type, litaC_path)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_types__FieldPath_pop(litaC_path);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                    {
                        assert(litaC_false);
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        continue;
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    return litaC_false;
    
    
}


const litaC_char* litaC_types__AggregateTypeInfo_getFunctionName(litaC_types__AggregateTypeInfo* litaC_this,litaC_char* litaC_result,const litaC_char* litaC_methodName) {
    memset(litaC_result, 0, litaC_symbols__MAX_SYMBOL_NAME);
    litaC_types__AggregateTypeInfo_getBaseName(litaC_this, litaC_result);
    strcat(litaC_result, "_");
    strcat(litaC_result, litaC_methodName);
    return (litaC_result);
    
    
}

litaC_symbols__Symbol* litaC_types__AggregateTypeInfo_getMethod(litaC_types__AggregateTypeInfo* litaC_this,litaC_module__Module* litaC_module,const litaC_char* litaC_methodName) {
    litaC_char litaC_funcName[256] =  {
        0
    };
    litaC_types__AggregateTypeInfo_getFunctionName(litaC_this, litaC_funcName, litaC_methodName);
    litaC_symbols__Symbol* litaC_methodSym = litaC_module__Module_getType(litaC_this->info.typeInfo.sym->declared, litaC_funcName);
    if(litaC_methodSym == NULL || litaC_methodSym->kind != litaC_symbols__SymbolKind_FUNC) {
        {
            litaC_methodSym = litaC_module__Module_getType(litaC_module, litaC_funcName);
            
            
        }
        
    } 
    
    if(litaC_methodSym == NULL || litaC_methodSym->kind != litaC_symbols__SymbolKind_FUNC) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_ast__FuncDecl* litaC_decl = (litaC_ast__FuncDecl*)litaC_methodSym->decl;
    if(!((litaC_decl->flags & litaC_ast__FuncFlags_IS_METHOD))) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    if(litaC_array__Array_empty_cb__ptr_ParameterDecl_ce_(&((litaC_decl->params->params)))) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_base = litaC_types__TypeInfo_getBaseType(litaC_array__Array_first_cb__ptr_ParameterDecl_ce_(&((litaC_decl->params->params)))->typeInfo);
    if(litaC_methodSym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
        {
            litaC_types__GenericTypeInfo* litaC_thisGenericType = (litaC_types__GenericTypeInfo*)litaC_this;
            litaC_types__GenericTypeInfo* litaC_baseGenericType = (litaC_types__GenericTypeInfo*)litaC_base;
            if(litaC_thisGenericType->genericTypeid == litaC_baseGenericType->genericTypeid) {
                {
                    return litaC_methodSym;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(litaC_types__TypeInfo_strictEquals(&((litaC_this->info.typeInfo)), litaC_base)) {
        {
            return litaC_methodSym;
            
            
            
        }
        
    } 
    
    return NULL;
    
    
}

litaC_bool litaC_types__AggregateTypeInfo_implementsTrait(litaC_types__AggregateTypeInfo* litaC_this,litaC_types__TypeInfo* litaC_iface,litaC_checker__TypeChecker* litaC_checker) {
    if(!(litaC_types__IsAggregateLike(litaC_iface))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__AggregateTypeInfo* litaC_aggIface = litaC_types__AsAggregate(litaC_iface);
    if(!(litaC_aggIface->info.typeInfo.sym) || !((litaC_aggIface->info.typeInfo.sym->flags & litaC_symbols__SymbolFlags_IS_TRAIT))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_checker__TypeChecker_implementsTrait(litaC_checker, litaC_this, litaC_aggIface);
    
    
}

litaC_i64 litaC_types__NextTypeId() {
    litaC_types__idGen += 1;
    return litaC_types__idGen;
    
    
}

litaC_ast__TypeSpec* litaC_ast_new__NewVoidTypeSpec(litaC_lex__SrcPos litaC_pos,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__NameTypeSpec* litaC_voidSpec = (litaC_ast__NameTypeSpec*)litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind_NAME, litaC_pos, litaC_allocator);
    litaC_voidSpec->name = "void";
    return (litaC_ast__TypeSpec*)litaC_voidSpec;
    
    
}

litaC_ast__NameTypeSpec* litaC_ast_new__NewNameTypeSpec(litaC_lex__SrcPos litaC_pos,const litaC_char* litaC_name,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__NameTypeSpec* litaC_result = litaC_mem__new_cb_NameTypeSpec_ce_(litaC_allocator);
    litaC_result->spec.kind = litaC_ast__TypeSpecKind_NAME;
    litaC_result->spec.pos = litaC_pos;
    litaC_result->spec.base = NULL;
    litaC_result->name = litaC_name;
    litaC_array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_result->genericArgs)), 0, litaC_allocator);
    return litaC_result;
    
    
}

litaC_ast__TypeSpec* litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind litaC_kind,litaC_lex__SrcPos litaC_pos,const litaC_mem__Allocator* litaC_allocator) {
    switch(litaC_kind) {
        case litaC_ast__TypeSpecKind_NONE: {
            {
                litaC_ast__TypeSpec* litaC_result = litaC_mem__new_cb_TypeSpec_ce_(litaC_allocator);
                litaC_result->kind = litaC_ast__TypeSpecKind_NONE;
                litaC_result->pos = litaC_pos;
                litaC_result->base = NULL;
                return litaC_result;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_ARRAY: {
            {
                litaC_ast__ArrayTypeSpec* litaC_result = litaC_mem__new_cb_ArrayTypeSpec_ce_(litaC_allocator);
                litaC_result->spec.kind = litaC_ast__TypeSpecKind_ARRAY;
                litaC_result->spec.pos = litaC_pos;
                litaC_result->spec.base = NULL;
                litaC_result->numElements = NULL;
                return (litaC_ast__TypeSpec*)litaC_result;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_PTR: {
            {
                litaC_ast__PtrTypeSpec* litaC_result = litaC_mem__new_cb_PtrTypeSpec_ce_(litaC_allocator);
                litaC_result->spec.kind = litaC_ast__TypeSpecKind_PTR;
                litaC_result->spec.pos = litaC_pos;
                litaC_result->spec.base = NULL;
                return (litaC_ast__TypeSpec*)litaC_result;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_CONST: {
            {
                litaC_ast__ConstTypeSpec* litaC_result = litaC_mem__new_cb_ConstTypeSpec_ce_(litaC_allocator);
                litaC_result->spec.kind = litaC_ast__TypeSpecKind_CONST;
                litaC_result->spec.pos = litaC_pos;
                litaC_result->spec.base = NULL;
                return (litaC_ast__TypeSpec*)litaC_result;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_NAME: {
            {
                litaC_ast__NameTypeSpec* litaC_result = litaC_mem__new_cb_NameTypeSpec_ce_(litaC_allocator);
                litaC_result->spec.kind = litaC_ast__TypeSpecKind_NAME;
                litaC_result->spec.pos = litaC_pos;
                litaC_result->spec.base = NULL;
                litaC_result->name = NULL;
                litaC_array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_result->genericArgs)), 0, litaC_allocator);
                return (litaC_ast__TypeSpec*)litaC_result;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_FUNC_PTR: {
            {
                litaC_ast__FuncPtrTypeSpec* litaC_result = litaC_mem__new_cb_FuncPtrTypeSpec_ce_(litaC_allocator);
                litaC_result->spec.kind = litaC_ast__TypeSpecKind_FUNC_PTR;
                litaC_result->spec.pos = litaC_pos;
                litaC_result->spec.base = NULL;
                litaC_array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_result->args)), 0, litaC_allocator);
                litaC_result->ret = NULL;
                litaC_result->hasVarargs = litaC_false;
                litaC_array__Array_init_cb_GenericParam_ce_(&((litaC_result->genericParams)), 0, litaC_allocator);
                return (litaC_ast__TypeSpec*)litaC_result;
                
                
                
            }
            
            
        }
        default: {
            {
                litaC_common__Panic("Invalid TypeSpecKind: '%d'\n", litaC_kind);
                
                
            }
            
            
        }
    }
    return NULL;
    
    
}

litaC_ast__Decl* litaC_ast_new__NewImportDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_name,litaC_lex__Token litaC_alias,litaC_bool litaC_isUsing,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__ImportDecl* litaC_decl = litaC_mem__new_cb_ImportDecl_ce_(litaC_allocator);
    litaC_decl->decl.stmt.node.kind = litaC_ast__StmtKind_IMPORT_DECL;
    litaC_decl->decl.stmt.node.startPos = litaC_startPos;
    litaC_decl->decl.stmt.node.endPos = litaC_endPos;
    litaC_decl->decl.name = litaC_name;
    litaC_decl->alias = litaC_alias;
    litaC_decl->isUsing = litaC_isUsing;
    return (litaC_ast__Decl*)litaC_decl;
    
    
}

litaC_ast__Decl* litaC_ast_new__NewVarDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_name,litaC_ast__TypeSpec* litaC_type,litaC_ast__Expr* litaC_expr,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__VarDecl* litaC_decl = litaC_mem__new_cb_VarDecl_ce_(litaC_allocator);
    litaC_decl->decl.stmt.node.kind = litaC_ast__StmtKind_VAR_DECL;
    litaC_decl->decl.stmt.node.startPos = litaC_startPos;
    litaC_decl->decl.stmt.node.endPos = litaC_endPos;
    litaC_decl->decl.name = litaC_name;
    litaC_decl->typeSpec = litaC_type;
    litaC_decl->expr = litaC_expr;
    return (litaC_ast__Decl*)litaC_decl;
    
    
}

litaC_ast__Decl* litaC_ast_new__NewFuncDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_name,litaC_array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_ast__ParametersStmt* litaC_params,litaC_ast__Stmt* litaC_body,litaC_ast__TypeSpec* litaC_returnType,litaC_i32 litaC_flags,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__FuncDecl* litaC_decl = litaC_mem__new_cb_FuncDecl_ce_(litaC_allocator);
    litaC_decl->decl.declaration.stmt.node.kind = litaC_ast__StmtKind_FUNC_DECL;
    litaC_decl->decl.declaration.stmt.node.startPos = litaC_startPos;
    litaC_decl->decl.declaration.stmt.node.endPos = litaC_endPos;
    litaC_decl->decl.declaration.name = litaC_name;
    litaC_decl->decl.genericParams = litaC_genericParams;
    litaC_decl->params = litaC_ast__Node_becomeParentOf_cb_ParametersStmt_ce_(&((litaC_decl->decl.declaration.stmt.node)), litaC_params);
    litaC_decl->body = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_decl->decl.declaration.stmt.node)), litaC_body);
    litaC_decl->returnType = litaC_returnType;
    litaC_decl->flags = litaC_flags;
    return (litaC_ast__Decl*)litaC_decl;
    
    
}

litaC_ast__Decl* litaC_ast_new__NewAggregateDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__StmtKind litaC_kind,litaC_lex__Token litaC_name,litaC_array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_array__Array_cb_FieldStmt_ce_ litaC_fields,litaC_i32 litaC_flags,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__AggregateDecl* litaC_decl = litaC_mem__new_cb_AggregateDecl_ce_(litaC_allocator);
    litaC_decl->decl.declaration.stmt.node.kind = litaC_kind;
    litaC_decl->decl.declaration.stmt.node.startPos = litaC_startPos;
    litaC_decl->decl.declaration.stmt.node.endPos = litaC_endPos;
    litaC_decl->decl.declaration.name = litaC_name;
    litaC_decl->decl.genericParams = litaC_genericParams;
    litaC_decl->fields = litaC_fields;
    litaC_decl->flags = litaC_flags;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_fields)), litaC_i);
            switch(litaC_field.kind) {
                case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                    {
                        litaC_ast__Node_becomeParentOf_cb_EnumDecl_ce_(&((litaC_decl->decl.declaration.stmt.node)), litaC_field.enumField);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                    {
                        litaC_ast__Node_becomeParentOf_cb_AggregateDecl_ce_(&((litaC_decl->decl.declaration.stmt.node)), litaC_field.aggregateField);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        litaC_ast__Node_becomeParentOf_cb_TraitFieldDecl_ce_(&((litaC_decl->decl.declaration.stmt.node)), litaC_field.traitField);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__Node_becomeParentOf_cb_VarFieldDecl_ce_(&((litaC_decl->decl.declaration.stmt.node)), litaC_field.varField);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_POISON_EXPR: {
                    {
                        litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_decl->decl.declaration.stmt.node)), litaC_field.poisonField);
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        assert(litaC_false);
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    return (litaC_ast__Decl*)litaC_decl;
    
    
}

litaC_ast__Decl* litaC_ast_new__NewStructDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_name,litaC_array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_array__Array_cb_FieldStmt_ce_ litaC_fields,litaC_i32 litaC_flags,const litaC_mem__Allocator* litaC_allocator) {
    return litaC_ast_new__NewAggregateDecl(litaC_startPos, litaC_endPos, litaC_ast__StmtKind_STRUCT_DECL, litaC_name, litaC_genericParams, litaC_fields, litaC_flags, litaC_allocator);
    
    
}

litaC_ast__Decl* litaC_ast_new__NewUnionDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_name,litaC_array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_array__Array_cb_FieldStmt_ce_ litaC_fields,litaC_i32 litaC_flags,const litaC_mem__Allocator* litaC_allocator) {
    return litaC_ast_new__NewAggregateDecl(litaC_startPos, litaC_endPos, litaC_ast__StmtKind_UNION_DECL, litaC_name, litaC_genericParams, litaC_fields, litaC_flags, litaC_allocator);
    
    
}

litaC_ast__Decl* litaC_ast_new__NewTraitDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_name,litaC_array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_array__Array_cb_FieldStmt_ce_ litaC_fields,litaC_i32 litaC_flags,const litaC_mem__Allocator* litaC_allocator) {
    return litaC_ast_new__NewAggregateDecl(litaC_startPos, litaC_endPos, litaC_ast__StmtKind_TRAIT_DECL, litaC_name, litaC_genericParams, litaC_fields, litaC_flags, litaC_allocator);
    
    
}

litaC_ast__Decl* litaC_ast_new__NewEnumDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_name,litaC_array__Array_cb__ptr_EnumFieldEntryDecl_ce_ litaC_fields,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__EnumDecl* litaC_decl = litaC_mem__new_cb_EnumDecl_ce_(litaC_allocator);
    litaC_decl->decl.stmt.node.kind = litaC_ast__StmtKind_ENUM_DECL;
    litaC_decl->decl.stmt.node.startPos = litaC_startPos;
    litaC_decl->decl.stmt.node.endPos = litaC_endPos;
    litaC_decl->decl.name = litaC_name;
    litaC_decl->fields = *(litaC_ast__Node_becomeParentOfChildren_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_decl->decl.stmt.node)), &((litaC_fields))));
    return (litaC_ast__Decl*)litaC_decl;
    
    
}

litaC_ast__Decl* litaC_ast_new__NewTypedefDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_name,litaC_array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_ast__TypeSpec* litaC_type,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__TypedefDecl* litaC_decl = litaC_mem__new_cb_TypedefDecl_ce_(litaC_allocator);
    litaC_decl->decl.declaration.stmt.node.kind = litaC_ast__StmtKind_TYPEDEF_DECL;
    litaC_decl->decl.declaration.stmt.node.startPos = litaC_startPos;
    litaC_decl->decl.declaration.stmt.node.endPos = litaC_endPos;
    litaC_decl->decl.declaration.name = litaC_name;
    litaC_decl->decl.genericParams = litaC_genericParams;
    litaC_decl->type = litaC_type;
    return (litaC_ast__Decl*)litaC_decl;
    
    
}

litaC_ast__Decl* litaC_ast_new__NewParameterDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_name,litaC_ast__TypeSpec* litaC_type,litaC_ast__Expr* litaC_defaultExpr,litaC_bool litaC_isUsing,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__ParameterDecl* litaC_decl = litaC_mem__new_cb_ParameterDecl_ce_(litaC_allocator);
    litaC_decl->decl.stmt.node.kind = litaC_ast__StmtKind_PARAM_DECL;
    litaC_decl->decl.stmt.node.startPos = litaC_startPos;
    litaC_decl->decl.stmt.node.endPos = litaC_endPos;
    litaC_decl->decl.name = litaC_name;
    litaC_decl->type = litaC_type;
    litaC_decl->defaultExpr = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_decl->decl.stmt.node)), litaC_defaultExpr);
    litaC_decl->decl.attributes.isUsing = litaC_isUsing;
    return (litaC_ast__Decl*)litaC_decl;
    
    
}

litaC_ast__Decl* litaC_ast_new__NewNotesDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_array__Array_cb__ptr_NoteStmt_ce_ litaC_notes,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__NotesDecl* litaC_decl = litaC_mem__new_cb_NotesDecl_ce_(litaC_allocator);
    litaC_decl->decl.stmt.node.kind = litaC_ast__StmtKind_NOTES_DECL;
    litaC_decl->decl.stmt.node.startPos = litaC_startPos;
    litaC_decl->decl.stmt.node.endPos = litaC_endPos;
    litaC_decl->notes = litaC_notes;
    return (litaC_ast__Decl*)litaC_decl;
    
    
}

litaC_ast__Decl* litaC_ast_new__NewBuiltinDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_types__TypeInfo* litaC_type,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__NativeDecl* litaC_decl = litaC_mem__new_cb_NativeDecl_ce_(litaC_allocator);
    litaC_decl->decl.stmt.node.kind = litaC_ast__StmtKind_NATIVE_DECL;
    litaC_decl->decl.stmt.node.startPos = litaC_startPos;
    litaC_decl->decl.stmt.node.endPos = litaC_endPos;
    litaC_decl->typeInfo = litaC_type;
    return (litaC_ast__Decl*)litaC_decl;
    
    
}

litaC_ast__Decl* litaC_ast_new__NewPoisonDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__PoisonDecl* litaC_decl = litaC_mem__new_cb_PoisonDecl_ce_(litaC_allocator);
    litaC_decl->decl.stmt.node.kind = litaC_ast__StmtKind_POISON_DECL;
    litaC_decl->decl.stmt.node.startPos = litaC_startPos;
    litaC_decl->decl.stmt.node.endPos = litaC_endPos;
    return (litaC_ast__Decl*)litaC_decl;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewTernaryExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_ast__Expr* litaC_then,litaC_ast__Expr* litaC_other,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__TernaryExpr* litaC_expr = litaC_mem__new_cb_TernaryExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_TERNARY_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->cond = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_cond);
    litaC_expr->then = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_then);
    litaC_expr->other = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_other);
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewBinaryExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_left,litaC_lex__TokenType litaC_operator,litaC_ast__Expr* litaC_right,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__BinaryExpr* litaC_binExpr = litaC_mem__new_cb_BinaryExpr_ce_(litaC_allocator);
    litaC_binExpr->expr.stmt.node.kind = litaC_ast__StmtKind_BINARY_EXPR;
    litaC_binExpr->expr.stmt.node.startPos = litaC_startPos;
    litaC_binExpr->left = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_binExpr->expr.stmt.node)), litaC_left);
    litaC_binExpr->operator = litaC_operator;
    litaC_binExpr->right = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_binExpr->expr.stmt.node)), litaC_right);
    litaC_binExpr->expr.stmt.node.endPos = litaC_endPos;
    return (litaC_ast__Expr*)litaC_binExpr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewUnaryExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__TokenType litaC_operator,litaC_ast__Expr* litaC_expr,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__UnaryExpr* litaC_unaryExpr = litaC_mem__new_cb_UnaryExpr_ce_(litaC_allocator);
    litaC_unaryExpr->expr.stmt.node.kind = litaC_ast__StmtKind_UNARY_EXPR;
    litaC_unaryExpr->expr.stmt.node.startPos = litaC_startPos;
    litaC_unaryExpr->unaryExpr = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_unaryExpr->expr.stmt.node)), litaC_expr);
    litaC_unaryExpr->operator = litaC_operator;
    litaC_unaryExpr->expr.stmt.node.endPos = litaC_endPos;
    return (litaC_ast__Expr*)litaC_unaryExpr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewInitExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__NameTypeSpec* litaC_type,litaC_array__Array_cb__ptr_InitArgExpr_ce_ litaC_arguments,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__InitExpr* litaC_initExpr = litaC_mem__new_cb_InitExpr_ce_(litaC_allocator);
    litaC_initExpr->expr.stmt.node.kind = litaC_ast__StmtKind_INIT_EXPR;
    litaC_initExpr->expr.stmt.node.startPos = litaC_startPos;
    litaC_initExpr->expr.stmt.node.endPos = litaC_endPos;
    litaC_initExpr->type = litaC_type;
    litaC_initExpr->arguments = litaC_arguments;
    litaC_ast__Node_becomeParentOfChildren_cb__ptr_InitArgExpr_ce_(&((litaC_initExpr->expr.stmt.node)), &((litaC_initExpr->arguments)));
    return (litaC_ast__Expr*)litaC_initExpr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewFuncCallExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_object,litaC_array__Array_cb_CallArg_ce_ litaC_arguments,litaC_array__Array_cb__ptr_TypeSpec_ce_ litaC_genericArgs,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__FuncCallExpr* litaC_expr = litaC_mem__new_cb_FuncCallExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_FUNC_CALL_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->object = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_object);
    litaC_expr->genericArgs = litaC_genericArgs;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_CallArg_ce_(&((litaC_arguments)));litaC_i += 1) {
        {
            litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_array__Array_get_cb_CallArg_ce_(&((litaC_arguments)), litaC_i).argExpr);
            
            
        }
    }
    litaC_expr->arguments = litaC_arguments;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewSubscriptGetExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_object,litaC_ast__Expr* litaC_index,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__SubscriptGetExpr* litaC_expr = litaC_mem__new_cb_SubscriptGetExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_SUBSCRIPT_GET_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->object = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_object);
    litaC_expr->index = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_index);
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewSubscriptSetExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_object,litaC_ast__Expr* litaC_index,litaC_lex__TokenType litaC_operator,litaC_ast__Expr* litaC_value,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__SubscriptSetExpr* litaC_expr = litaC_mem__new_cb_SubscriptSetExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_SUBSCRIPT_SET_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->object = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_object);
    litaC_expr->index = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_index);
    litaC_expr->operator = litaC_operator;
    litaC_expr->value = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_value);
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewGetExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_object,litaC_ast__IdentifierExpr* litaC_field,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__GetExpr* litaC_expr = litaC_mem__new_cb_GetExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_GET_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->object = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_object);
    litaC_expr->field = (litaC_ast__IdentifierExpr*)litaC_ast__Node_becomeParentOf_cb_IdentifierExpr_ce_(&((litaC_expr->expr.stmt.node)), litaC_field);
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewSetExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_object,litaC_ast__IdentifierExpr* litaC_field,litaC_lex__TokenType litaC_operator,litaC_ast__Expr* litaC_value,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__SetExpr* litaC_expr = litaC_mem__new_cb_SetExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_SET_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->object = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_object);
    litaC_expr->field = (litaC_ast__IdentifierExpr*)litaC_ast__Node_becomeParentOf_cb_IdentifierExpr_ce_(&((litaC_expr->expr.stmt.node)), litaC_field);
    litaC_expr->operator = litaC_operator;
    litaC_expr->value = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_value);
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewIdentifierExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__NameTypeSpec* litaC_type,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__IdentifierExpr* litaC_expr = litaC_mem__new_cb_IdentifierExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_IDENTIFIER_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->type = litaC_type;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewTypeIdentifierExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__TypeSpec* litaC_type,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__TypeIdentifierExpr* litaC_expr = litaC_mem__new_cb_TypeIdentifierExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_TYPE_IDENTIFIER_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->type = litaC_type;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewCastExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_castExpr,litaC_ast__TypeSpec* litaC_castTo,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__CastExpr* litaC_expr = litaC_mem__new_cb_CastExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_CAST_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->exprToCast = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_castExpr);
    litaC_expr->castTo = litaC_castTo;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewArrayDesignationExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_index,litaC_ast__Expr* litaC_value,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__ArrayDesignationExpr* litaC_expr = litaC_mem__new_cb_ArrayDesignationExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_ARRAY_DESIGNATION_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->index = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_index);
    litaC_expr->value = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_value);
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewInitArgExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_fieldName,litaC_i32 litaC_position,litaC_ast__Expr* litaC_value,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__InitArgExpr* litaC_expr = litaC_mem__new_cb_InitArgExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_INIT_ARG_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->fieldName = litaC_fieldName;
    litaC_expr->argPosition = litaC_position;
    litaC_expr->value = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_value);
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewBooleanExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_bool litaC_boolean,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__BooleanExpr* litaC_expr = litaC_mem__new_cb_BooleanExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_BOOLEAN_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->boolean = litaC_boolean;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewNullExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__NullExpr* litaC_expr = litaC_mem__new_cb_NullExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_NULL_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewNumberExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_number,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__NumberExpr* litaC_expr = litaC_mem__new_cb_NumberExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_NUMBER_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->number = litaC_number;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewStringExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_string,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__StringExpr* litaC_expr = litaC_mem__new_cb_StringExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_STRING_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->string = litaC_string;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewCharExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_character,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__CharExpr* litaC_expr = litaC_mem__new_cb_CharExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_CHAR_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->character = litaC_character;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewGroupExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_groupedExpr,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__GroupExpr* litaC_expr = litaC_mem__new_cb_GroupExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_GROUP_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->groupedExpr = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_groupedExpr);
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewArrayInitExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__TypeSpec* litaC_type,litaC_array__Array_cb__ptr_Expr_ce_ litaC_values,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__ArrayInitExpr* litaC_expr = litaC_mem__new_cb_ArrayInitExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_ARRAY_INIT_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->type = litaC_type;
    litaC_expr->values = *(litaC_ast__Node_becomeParentOfChildren_cb__ptr_Expr_ce_(&((litaC_expr->expr.stmt.node)), &((litaC_values))));
    assert(litaC_expr->type->kind == litaC_ast__TypeSpecKind_ARRAY);
    litaC_ast__ArrayTypeSpec* litaC_arrayType = (litaC_ast__ArrayTypeSpec*)litaC_expr->type;
    if(!(litaC_arrayType->numElements) && !(litaC_array__Array_empty_cb__ptr_Expr_ce_(&((litaC_expr->values))))) {
        {
            litaC_lex__Token litaC_token =  {
                .type = litaC_lex__TokenType_USIZE,
                .typeInfo = &(litaC_types__USIZE_TYPE),
                .pos = litaC_startPos,
                .value =  {
                    .intValue = litaC_array__Array_size_cb__ptr_Expr_ce_(&((litaC_expr->values)))
                }
            };
            litaC_arrayType->numElements = litaC_ast_new__NewNumberExpr(litaC_startPos, litaC_startPos, litaC_token, litaC_allocator);
            
            
        }
        
    } 
    
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewSizeOfExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_sizeOfExpr,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__SizeOfExpr* litaC_expr = litaC_mem__new_cb_SizeOfExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_SIZE_OF_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->sizeOfExpr = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_sizeOfExpr);
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewTypeOfExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_typeOfExpr,litaC_ast__TypeSpec* litaC_type,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__TypeOfExpr* litaC_expr = litaC_mem__new_cb_TypeOfExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_TYPE_OF_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->typeOfExpr = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_typeOfExpr);
    litaC_expr->type = litaC_type;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewOffsetOfExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__TypeSpec* litaC_type,litaC_lex__Token litaC_field,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__OffsetOfExpr* litaC_expr = litaC_mem__new_cb_OffsetOfExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_OFFSET_OF_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->type = litaC_type;
    litaC_expr->field = litaC_field;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewPoisonExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__PoisonExpr* litaC_expr = litaC_mem__new_cb_PoisonExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_POISON_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewModuleStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_array__Array_cb__ptr_ImportDecl_ce_ litaC_imports,litaC_array__Array_cb__ptr_NoteStmt_ce_ litaC_notes,litaC_array__Array_cb__ptr_Decl_ce_ litaC_declarations,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__ModuleStmt* litaC_stmt = litaC_mem__new_cb_ModuleStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_MODULE_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->imports = litaC_imports;
    litaC_stmt->notes = litaC_notes;
    litaC_stmt->declarations = litaC_declarations;
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewCompStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_char* litaC_type,const litaC_char* litaC_expr,litaC_array__Array_cb__ptr_Stmt_ce_ litaC_body,litaC_ast__CompStmt* litaC_end,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__CompStmt* litaC_stmt = litaC_mem__new_cb_CompStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_COMP_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->type = litaC_type;
    litaC_stmt->expr = litaC_expr;
    litaC_stmt->end = litaC_end;
    litaC_stmt->body = litaC_body;
    litaC_stmt->evaluatedStmt = NULL;
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewFuncBodyStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_array__Array_cb__ptr_Stmt_ce_ litaC_stmts,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__BlockStmt* litaC_stmt = litaC_mem__new_cb_BlockStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_FUNC_BODY_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->stmts = *(litaC_ast__Node_becomeParentOfChildren_cb__ptr_Stmt_ce_(&((litaC_stmt->stmt.node)), &((litaC_stmts))));
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewBlockStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_array__Array_cb__ptr_Stmt_ce_ litaC_stmts,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__BlockStmt* litaC_stmt = litaC_mem__new_cb_BlockStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_BLOCK_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->stmts = *(litaC_ast__Node_becomeParentOfChildren_cb__ptr_Stmt_ce_(&((litaC_stmt->stmt.node)), &((litaC_stmts))));
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewIfStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_ast__Stmt* litaC_then,litaC_ast__Stmt* litaC_other,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__IfStmt* litaC_stmt = litaC_mem__new_cb_IfStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_IF_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->cond = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_stmt->stmt.node)), litaC_cond);
    litaC_stmt->then = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_stmt->stmt.node)), litaC_then);
    litaC_stmt->elseStmt = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_stmt->stmt.node)), litaC_other);
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewWhileStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_ast__Stmt* litaC_body,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__WhileStmt* litaC_stmt = litaC_mem__new_cb_WhileStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_WHILE_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->cond = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_stmt->stmt.node)), litaC_cond);
    litaC_stmt->body = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_stmt->stmt.node)), litaC_body);
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewDoWhileStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_ast__Stmt* litaC_body,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__DoWhileStmt* litaC_stmt = litaC_mem__new_cb_DoWhileStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_DO_WHILE_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->cond = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_stmt->stmt.node)), litaC_cond);
    litaC_stmt->body = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_stmt->stmt.node)), litaC_body);
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewForStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Stmt* litaC_init,litaC_ast__Expr* litaC_cond,litaC_ast__Stmt* litaC_post,litaC_ast__Stmt* litaC_body,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__ForStmt* litaC_stmt = litaC_mem__new_cb_ForStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_FOR_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->init = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_stmt->stmt.node)), litaC_init);
    litaC_stmt->cond = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_stmt->stmt.node)), litaC_cond);
    litaC_stmt->post = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_stmt->stmt.node)), litaC_post);
    litaC_stmt->body = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_stmt->stmt.node)), litaC_body);
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewSwitchCaseStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_ast__Stmt* litaC_body,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__SwitchCaseStmt* litaC_stmt = litaC_mem__new_cb_SwitchCaseStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_SWITCH_CASE_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->cond = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_stmt->stmt.node)), litaC_cond);
    litaC_stmt->body = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_stmt->stmt.node)), litaC_body);
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewSwitchStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_ litaC_cases,litaC_ast__Stmt* litaC_defaultStmt,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__SwitchStmt* litaC_stmt = litaC_mem__new_cb_SwitchStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_SWITCH_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->cond = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_stmt->stmt.node)), litaC_cond);
    litaC_stmt->cases = *(litaC_ast__Node_becomeParentOfChildren_cb__ptr_SwitchCaseStmt_ce_(&((litaC_stmt->stmt.node)), &((litaC_cases))));
    litaC_stmt->defaultStmt = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_stmt->stmt.node)), litaC_defaultStmt);
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewBreakStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__BreakStmt* litaC_stmt = litaC_mem__new_cb_BreakStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_BREAK_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewContinueStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__ContinueStmt* litaC_stmt = litaC_mem__new_cb_ContinueStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_CONTINUE_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewReturnStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_expr,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__ReturnStmt* litaC_stmt = litaC_mem__new_cb_ReturnStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_RETURN_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->expr = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_stmt->stmt.node)), litaC_expr);
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewDeferStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Stmt* litaC_defered,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__DeferStmt* litaC_stmt = litaC_mem__new_cb_DeferStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_DEFER_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->deferedStmt = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_stmt->stmt.node)), litaC_defered);
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewGotoStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_label,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__GotoStmt* litaC_stmt = litaC_mem__new_cb_GotoStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_GOTO_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->label = litaC_label;
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewLabelStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_label,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__LabelStmt* litaC_stmt = litaC_mem__new_cb_LabelStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_LABEL_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->label = litaC_label;
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewNoteStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_name,litaC_array__Array_cb_Token_ce_ litaC_attributes,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__NoteStmt* litaC_stmt = litaC_mem__new_cb_NoteStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_NOTE_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->name = litaC_name;
    litaC_stmt->attributes = litaC_attributes;
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewEmptyStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__EmptyStmt* litaC_stmt = litaC_mem__new_cb_EmptyStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_EMPTY_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewParametersStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_array__Array_cb__ptr_ParameterDecl_ce_ litaC_params,litaC_bool litaC_isVararg,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__ParametersStmt* litaC_stmt = litaC_mem__new_cb_ParametersStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_PARAMETERS_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->params = *(litaC_ast__Node_becomeParentOfChildren_cb__ptr_ParameterDecl_ce_(&((litaC_stmt->stmt.node)), &((litaC_params))));
    litaC_stmt->isVararg = litaC_isVararg;
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewVarFieldDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_fieldName,litaC_ast__TypeSpec* litaC_type,litaC_ast__Attributes litaC_attributes,litaC_ast__Expr* litaC_defaultExpr,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__VarFieldDecl* litaC_stmt = litaC_mem__new_cb_VarFieldDecl_ce_(litaC_allocator);
    litaC_stmt->decl.stmt.node.kind = litaC_ast__StmtKind_VAR_FIELD_DECL;
    litaC_stmt->decl.stmt.node.startPos = litaC_startPos;
    litaC_stmt->decl.stmt.node.endPos = litaC_endPos;
    litaC_stmt->decl.name = litaC_fieldName;
    litaC_stmt->type = litaC_type;
    litaC_stmt->decl.attributes = litaC_attributes;
    litaC_stmt->defaultExpr = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_stmt->decl.stmt.node)), litaC_defaultExpr);
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewTraitFieldDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_fieldName,litaC_ast__TypeSpec* litaC_type,litaC_ast__Attributes litaC_attributes,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__TraitFieldDecl* litaC_stmt = litaC_mem__new_cb_TraitFieldDecl_ce_(litaC_allocator);
    litaC_stmt->decl.stmt.node.kind = litaC_ast__StmtKind_TRAIT_FIELD_DECL;
    litaC_stmt->decl.stmt.node.startPos = litaC_startPos;
    litaC_stmt->decl.stmt.node.endPos = litaC_endPos;
    litaC_stmt->decl.name = litaC_fieldName;
    litaC_stmt->type = litaC_type;
    litaC_stmt->decl.attributes = litaC_attributes;
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewEnumFieldEntryDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_fieldName,litaC_ast__Expr* litaC_value,litaC_ast__Attributes litaC_attributes,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__EnumFieldEntryDecl* litaC_stmt = litaC_mem__new_cb_EnumFieldEntryDecl_ce_(litaC_allocator);
    litaC_stmt->decl.stmt.node.kind = litaC_ast__StmtKind_ENUM_FIELD_ENTRY_DECL;
    litaC_stmt->decl.stmt.node.startPos = litaC_startPos;
    litaC_stmt->decl.stmt.node.endPos = litaC_endPos;
    litaC_stmt->decl.name = litaC_fieldName;
    litaC_stmt->decl.attributes = litaC_attributes;
    litaC_stmt->value = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_stmt->decl.stmt.node)), litaC_value);
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_void litaC_ast__Node_setSrcPos(litaC_ast__Node* litaC_n,litaC_lex__SrcPos litaC_start,litaC_lex__SrcPos litaC_end) {
    litaC_n->startPos = litaC_start;
    litaC_n->endPos = litaC_end;
    
}

litaC_array__Array_cb_CallArg_ce_* litaC_ast__Node_becomeParentOfChildrenCallArgs(litaC_ast__Node* litaC_n,litaC_array__Array_cb_CallArg_ce_* litaC_children) {
    litaC_i32 litaC_size = litaC_array__Array_size_cb_CallArg_ce_(litaC_children);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_size;litaC_i += 1) {
        {
            litaC_ast__Expr* litaC_child = litaC_array__Array_get_cb_CallArg_ce_(litaC_children, litaC_i).argExpr;
            if(litaC_child) {
                {
                    litaC_ast__Node_becomeParentOf_cb_Expr_ce_(litaC_n, litaC_child);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_children;
    
    
}

litaC_bool litaC_ast__IsExpr(litaC_ast__Node* litaC_node) {
    if(!(litaC_node)) {
        return litaC_false;
        
        
    } 
    
    switch(litaC_node->kind) {
        case litaC_ast__StmtKind_ARRAY_DESIGNATION_EXPR: 
        case litaC_ast__StmtKind_ARRAY_INIT_EXPR: 
        case litaC_ast__StmtKind_BINARY_EXPR: 
        case litaC_ast__StmtKind_BOOLEAN_EXPR: 
        case litaC_ast__StmtKind_CAST_EXPR: 
        case litaC_ast__StmtKind_CHAR_EXPR: 
        case litaC_ast__StmtKind_FUNC_CALL_EXPR: 
        case litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR: 
        case litaC_ast__StmtKind_GET_EXPR: 
        case litaC_ast__StmtKind_GROUP_EXPR: 
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: 
        case litaC_ast__StmtKind_INIT_EXPR: 
        case litaC_ast__StmtKind_INIT_ARG_EXPR: 
        case litaC_ast__StmtKind_NULL_EXPR: 
        case litaC_ast__StmtKind_NUMBER_EXPR: 
        case litaC_ast__StmtKind_OFFSET_OF_EXPR: 
        case litaC_ast__StmtKind_SET_EXPR: 
        case litaC_ast__StmtKind_SIZE_OF_EXPR: 
        case litaC_ast__StmtKind_STRING_EXPR: 
        case litaC_ast__StmtKind_SUBSCRIPT_GET_EXPR: 
        case litaC_ast__StmtKind_SUBSCRIPT_SET_EXPR: 
        case litaC_ast__StmtKind_TERNARY_EXPR: 
        case litaC_ast__StmtKind_TYPE_IDENTIFIER_EXPR: 
        case litaC_ast__StmtKind_TYPE_OF_EXPR: 
        case litaC_ast__StmtKind_UNARY_EXPR: 
        case litaC_ast__StmtKind_POISON_EXPR: {
            return litaC_true;
            
            
            
        }
        default: {
            return litaC_false;
            
            
            
        }
    }
    
}

litaC_bool litaC_ast__IsDecl(litaC_ast__Node* litaC_node) {
    if(!(litaC_node)) {
        return litaC_false;
        
        
    } 
    
    switch(litaC_node->kind) {
        case litaC_ast__StmtKind_IMPORT_DECL: 
        case litaC_ast__StmtKind_CONST_DECL: 
        case litaC_ast__StmtKind_VAR_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: 
        case litaC_ast__StmtKind_UNION_DECL: 
        case litaC_ast__StmtKind_TRAIT_DECL: 
        case litaC_ast__StmtKind_ENUM_DECL: 
        case litaC_ast__StmtKind_FUNC_DECL: 
        case litaC_ast__StmtKind_TYPEDEF_DECL: 
        case litaC_ast__StmtKind_PARAM_DECL: 
        case litaC_ast__StmtKind_NATIVE_DECL: 
        case litaC_ast__StmtKind_POISON_DECL: {
            return litaC_true;
            
            
            
        }
        default: {
            return litaC_false;
            
            
            
        }
    }
    
}

litaC_bool litaC_ast__Decl_hasNote(litaC_ast__Decl* litaC_d,const litaC_char* litaC_name) {
    return litaC_ast__Decl_getNote(litaC_d, litaC_name) != NULL;
    
    
}

litaC_ast__NoteStmt* litaC_ast__Decl_getNote(litaC_ast__Decl* litaC_d,const litaC_char* litaC_name) {
    if(!(litaC_d)) {
        return NULL;
        
        
    } 
    
    if(litaC_array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_d->attributes.notes)))) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_d->attributes.notes)));litaC_i += 1) {
        {
            litaC_ast__NoteStmt* litaC_note = litaC_array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_d->attributes.notes)), litaC_i);
            if(litaC_lex__Token_nameEquals(&((litaC_note->name)), litaC_name)) {
                {
                    return litaC_note;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return NULL;
    
    
}

litaC_ast__TypeSpec* litaC_ast__TypeSpec_getBaseType(litaC_ast__TypeSpec* litaC_this) {
    if(!(litaC_this)) {
        return NULL;
        
        
    } 
    
    switch(litaC_this->kind) {
        case litaC_ast__TypeSpecKind_NONE: {
            {
                return NULL;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_NAME: {
            {
                return litaC_this;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_ARRAY: 
        case litaC_ast__TypeSpecKind_PTR: 
        case litaC_ast__TypeSpecKind_CONST: {
            {
                return litaC_ast__TypeSpec_getBaseType(litaC_this->base);
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_FUNC_PTR: {
            {
                return litaC_this;
                
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return NULL;
    
    
}

litaC_bool litaC_ast__FuncDecl_getName(litaC_ast__FuncDecl* litaC_f,litaC_char* litaC_name) {
    if(litaC_f->decl.declaration.name.type != litaC_lex__TokenType_IDENTIFIER) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_f->flags & litaC_ast__FuncFlags_IS_METHOD) {
        {
            if(litaC_array__Array_empty_cb__ptr_ParameterDecl_ce_(&((litaC_f->params->params)))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_ast__ParameterDecl* litaC_first = litaC_array__Array_first_cb__ptr_ParameterDecl_ce_(&((litaC_f->params->params)));
            if(!(litaC_first->type)) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_ast__TypeSpec* litaC_typeSpec = litaC_first->type;
            retry:;
            
            if(litaC_typeSpec->kind != litaC_ast__TypeSpecKind_NAME) {
                {
                    if(litaC_typeSpec->kind == litaC_ast__TypeSpecKind_PTR) {
                        {
                            litaC_ast__PtrTypeSpec* litaC_ptrSpec = (litaC_ast__PtrTypeSpec*)litaC_typeSpec;
                            litaC_typeSpec = litaC_ptrSpec->spec.base;
                            goto retry;
                            
                            
                            
                        }
                        
                    } else {
                        if(litaC_typeSpec->kind == litaC_ast__TypeSpecKind_CONST) {
                            {
                                litaC_ast__ConstTypeSpec* litaC_constSpec = (litaC_ast__ConstTypeSpec*)litaC_typeSpec;
                                litaC_typeSpec = litaC_constSpec->spec.base;
                                goto retry;
                                
                                
                                
                            }
                            
                        } 
                        
                    } 
                    
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_ast__NameTypeSpec* litaC_type = (litaC_ast__NameTypeSpec*)litaC_typeSpec;
            litaC_i32 litaC_totalLen = litaC_f->decl.declaration.name.value.str.length + strlen(litaC_type->name) + 2;
            if(litaC_totalLen > litaC_symbols__MAX_SYMBOL_NAME) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_string__String litaC_nameStr = litaC_string__StringInit(litaC_name, litaC_symbols__MAX_SYMBOL_NAME, 0);
            litaC_string__String_format(&((litaC_nameStr)), "%s_%.*s", litaC_type->name, litaC_f->decl.declaration.name.value.str.length, litaC_f->decl.declaration.name.value.str.buffer);
            return litaC_true;
            
            
            
        }
        
    } 
    
    litaC_string__String litaC_nameStr = litaC_string__StringInit(litaC_name, litaC_symbols__MAX_SYMBOL_NAME, 0);
    litaC_string__String_format(&((litaC_nameStr)), "%.*s", litaC_f->decl.declaration.name.value.str.length, litaC_f->decl.declaration.name.value.str.buffer);
    return litaC_true;
    
    
}

litaC_bool litaC_ast__Expr_isIdentifier(litaC_ast__Expr* litaC_expr) {
    if(!(litaC_expr)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_expr->stmt.node.kind == litaC_ast__StmtKind_IDENTIFIER_EXPR || litaC_expr->stmt.node.kind == litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR || litaC_expr->stmt.node.kind == litaC_ast__StmtKind_TYPE_IDENTIFIER_EXPR;
    
    
}

litaC_bool litaC_ast__Expr_isConstNumberExpr(litaC_ast__Expr* litaC_expr) {
    if(!(litaC_expr)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_expr->stmt.node.kind) {
        case litaC_ast__StmtKind_NUMBER_EXPR: 
        case litaC_ast__StmtKind_BOOLEAN_EXPR: 
        case litaC_ast__StmtKind_CHAR_EXPR: 
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: 
        case litaC_ast__StmtKind_GET_EXPR: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SIZE_OF_EXPR: {
            {
                litaC_ast__SizeOfExpr* litaC_sizeofExpr = (litaC_ast__SizeOfExpr*)litaC_expr;
                return litaC_ast__Expr_isConstNumberExpr(litaC_sizeofExpr->sizeOfExpr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GROUP_EXPR: {
            {
                litaC_ast__GroupExpr* litaC_groupExpr = (litaC_ast__GroupExpr*)litaC_expr;
                return litaC_ast__Expr_isConstNumberExpr(litaC_groupExpr->groupedExpr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BINARY_EXPR: {
            {
                litaC_ast__BinaryExpr* litaC_binExpr = (litaC_ast__BinaryExpr*)litaC_expr;
                return litaC_ast__Expr_isConstNumberExpr(litaC_binExpr->left) && litaC_ast__Expr_isConstNumberExpr(litaC_binExpr->right);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNARY_EXPR: {
            {
                litaC_ast__UnaryExpr* litaC_unaryExpr = (litaC_ast__UnaryExpr*)litaC_expr;
                return litaC_ast__Expr_isConstNumberExpr(litaC_unaryExpr->unaryExpr);
                
                
                
            }
            
            
        }
        default: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_bool litaC_ast__Expr_isConstExpr(litaC_ast__Expr* litaC_expr) {
    if(!(litaC_expr)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_expr->stmt.node.kind) {
        case litaC_ast__StmtKind_NUMBER_EXPR: 
        case litaC_ast__StmtKind_BOOLEAN_EXPR: 
        case litaC_ast__StmtKind_CHAR_EXPR: 
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: 
        case litaC_ast__StmtKind_STRING_EXPR: 
        case litaC_ast__StmtKind_GET_EXPR: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SIZE_OF_EXPR: {
            {
                litaC_ast__SizeOfExpr* litaC_sizeofExpr = (litaC_ast__SizeOfExpr*)litaC_expr;
                return litaC_ast__Expr_isConstExpr(litaC_sizeofExpr->sizeOfExpr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GROUP_EXPR: {
            {
                litaC_ast__GroupExpr* litaC_groupExpr = (litaC_ast__GroupExpr*)litaC_expr;
                return litaC_ast__Expr_isConstExpr(litaC_groupExpr->groupedExpr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BINARY_EXPR: {
            {
                litaC_ast__BinaryExpr* litaC_binExpr = (litaC_ast__BinaryExpr*)litaC_expr;
                return litaC_ast__Expr_isConstExpr(litaC_binExpr->left) && litaC_ast__Expr_isConstExpr(litaC_binExpr->right);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNARY_EXPR: {
            {
                litaC_ast__UnaryExpr* litaC_unaryExpr = (litaC_ast__UnaryExpr*)litaC_expr;
                return litaC_ast__Expr_isConstExpr(litaC_unaryExpr->unaryExpr);
                
                
                
            }
            
            
        }
        default: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_i32 litaC_ast__CallArgSort(litaC_ast__CallArg litaC_a,litaC_ast__CallArg litaC_b) {
    return litaC_a.index - litaC_b.index;
    
    
}

litaC_bool litaC_symbols__Symbol_isGenericCapable(litaC_symbols__Symbol* litaC_this) {
    return litaC_this->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE || litaC_this->flags & litaC_symbols__SymbolFlags_IS_FROM_GENERIC_TEMPLATE;
    
    
}

litaC_symbols__Scope* litaC_symbols__NewScope(litaC_symbols__ScopeKind litaC_kind,litaC_symbols__Scope* litaC_parent,litaC_phase_result__PhaseResult* litaC_result,const litaC_mem__Allocator* litaC_allocator) {
    litaC_symbols__Scope* litaC_scope = litaC_mem__new_cb_Scope_ce_(litaC_allocator);
    litaC_symbols__Scope_init(litaC_scope, litaC_kind, litaC_parent, litaC_result, litaC_allocator);
    return litaC_scope;
    
    
}

litaC_void litaC_symbols__Scope_init(litaC_symbols__Scope* litaC_scope,litaC_symbols__ScopeKind litaC_kind,litaC_symbols__Scope* litaC_parent,litaC_phase_result__PhaseResult* litaC_result,const litaC_mem__Allocator* litaC_allocator) {
    litaC_scope->kind = litaC_kind;
    litaC_scope->allocator = litaC_allocator;
    litaC_scope->parent = litaC_parent;
    litaC_scope->result = litaC_result;
    litaC_scope->symbols = litaC_map__StrMap_cb__ptr_Symbol_ce_(NULL, 16, litaC_allocator);
    
}

litaC_symbols__Symbol* litaC_symbols__Scope_lookup(litaC_symbols__Scope* litaC_s,const litaC_char* litaC_name) {
    litaC_symbols__Symbol* litaC_sym = litaC_map__Map_get_cb__ptr_const_char_c__ptr_Symbol_ce_(&((litaC_s->symbols)), litaC_name);
    if(litaC_sym) {
        {
            return litaC_sym;
            
            
            
        }
        
    } 
    
    if(!(litaC_s->parent)) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    return litaC_symbols__Scope_lookup(litaC_s->parent, litaC_name);
    
    
}

litaC_symbols__Symbol* litaC_symbols__Scope_lookupByToken(litaC_symbols__Scope* litaC_s,litaC_lex__Token litaC_name) {
    if(litaC_name.type != litaC_lex__TokenType_IDENTIFIER) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_char litaC_buf[256];
    litaC_string_view__StringView_copyTo(litaC_name.value.str, litaC_buf, litaC_symbols__MAX_SYMBOL_NAME, litaC_true);
    return litaC_symbols__Scope_lookup(litaC_s, litaC_buf);
    
    
}

litaC_void litaC_symbols__Scope_importSymbol(litaC_symbols__Scope* litaC_this,const litaC_char* litaC_name,litaC_symbols__Symbol* litaC_symbol) {
    if(litaC_map__Map_contains_cb__ptr_const_char_c__ptr_Symbol_ce_(&((litaC_this->symbols)), litaC_name) && !(litaC_ast__Decl_hasNote(litaC_symbol->decl, "generated"))) {
        {
            litaC_symbols__Symbol* litaC_existingSym = litaC_map__Map_get_cb__ptr_const_char_c__ptr_Symbol_ce_(&((litaC_this->symbols)), litaC_name);
            litaC_ast__Decl* litaC_decl = litaC_existingSym->decl;
            litaC_phase_result__PhaseResult_addError(litaC_this->result, litaC_symbol->decl->stmt.node.startPos, "can't import symbol '%s' because it is already defined in %s:%d", litaC_name, litaC_decl->stmt.node.startPos.filename, litaC_decl->stmt.node.startPos.lineNumber);
            return;
            
            
            
        }
        
    } 
    
    litaC_map__Map_put_cb__ptr_const_char_c__ptr_Symbol_ce_(&((litaC_this->symbols)), litaC_name, litaC_symbol);
    
}

litaC_symbols__Symbol* litaC_symbols__Scope_addSymbol(litaC_symbols__Scope* litaC_this,const litaC_char* litaC_name,litaC_module__Module* litaC_module,litaC_ast__Decl* litaC_decl,litaC_i32 litaC_flags) {
    if(litaC_map__Map_contains_cb__ptr_const_char_c__ptr_Symbol_ce_(&((litaC_this->symbols)), litaC_name) && !(litaC_ast__Decl_hasNote(litaC_decl, "generated"))) {
        {
            litaC_symbols__Symbol* litaC_existingSym = litaC_map__Map_get_cb__ptr_const_char_c__ptr_Symbol_ce_(&((litaC_this->symbols)), litaC_name);
            litaC_ast__Decl* litaC_decl = litaC_existingSym->decl;
            litaC_phase_result__PhaseResult_addError(litaC_this->result, litaC_decl->stmt.node.startPos, "symbol '%s' already defined in %s:%d", litaC_name, litaC_decl->stmt.node.startPos.filename, litaC_decl->stmt.node.startPos.lineNumber);
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_bool litaC_isNewType = (litaC_decl->stmt.node.kind == litaC_ast__StmtKind_FUNC_DECL || litaC_decl->stmt.node.kind == litaC_ast__StmtKind_STRUCT_DECL || litaC_decl->stmt.node.kind == litaC_ast__StmtKind_UNION_DECL || litaC_decl->stmt.node.kind == litaC_ast__StmtKind_TRAIT_DECL || litaC_decl->stmt.node.kind == litaC_ast__StmtKind_TYPEDEF_DECL || litaC_decl->stmt.node.kind == litaC_ast__StmtKind_ENUM_DECL);
    if(litaC_this->kind == litaC_symbols__ScopeKind_FUNC) {
        {
            if(!(litaC_isNewType)) {
                {
                    litaC_flags |= litaC_symbols__SymbolFlags_IS_LOCAL;
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(litaC_ast__Decl_hasNote(litaC_decl, "foreign")) {
        {
            litaC_flags |= litaC_symbols__SymbolFlags_IS_FOREIGN;
            
            
        }
        
    } 
    
    if(litaC_decl->attributes.isPublic) {
        {
            litaC_flags |= litaC_symbols__SymbolFlags_IS_PUBLIC;
            
            
        }
        
    } 
    
    if(litaC_isNewType) {
        {
            litaC_flags |= litaC_symbols__SymbolFlags_IS_TYPE;
            
            
        }
        
    } 
    
    litaC_i32 litaC_kind = litaC_symbols__SymbolKind_VAR;
    switch(litaC_decl->stmt.node.kind) {
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            {
                litaC_flags |= litaC_symbols__SymbolFlags_IS_ALIAS;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_DECL: 
        case litaC_ast__StmtKind_TRAIT_DECL: 
        case litaC_ast__StmtKind_UNION_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: {
            {
                litaC_kind = litaC_symbols__SymbolKind_TYPE;
                if(litaC_decl->stmt.node.kind == litaC_ast__StmtKind_TRAIT_DECL) {
                    {
                        litaC_flags |= litaC_symbols__SymbolFlags_IS_TRAIT;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                litaC_kind = litaC_symbols__SymbolKind_FUNC;
                if(litaC_ast__Decl_hasNote(litaC_decl, "test")) {
                    {
                        litaC_flags |= litaC_symbols__SymbolFlags_IS_TEST;
                        
                        
                    }
                    
                } 
                
                litaC_ast__FuncDecl* litaC_funcDecl = (litaC_ast__FuncDecl*)litaC_decl;
                if(litaC_funcDecl->flags & litaC_ast__FuncFlags_IS_METHOD) {
                    {
                        litaC_flags |= litaC_symbols__SymbolFlags_IS_METHOD;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONST_DECL: {
            {
                litaC_kind = litaC_symbols__SymbolKind_CONST;
                litaC_flags |= litaC_symbols__SymbolFlags_IS_CONSTANT;
                break;
                
                
            }
            
            
        }
        default: {
            {
                litaC_kind = litaC_symbols__SymbolKind_VAR;
                break;
                
                
            }
            
            
        }
    }
    litaC_symbols__Symbol* litaC_sym = litaC_mem__new_cb_Symbol_ce_(litaC_this->allocator);
    litaC_sym->kind = litaC_kind;
    strncpy(litaC_sym->name, litaC_name, litaC_symbols__MAX_SYMBOL_NAME);
    litaC_sym->state = litaC_symbols__SymbolState_UNRESOLVED;
    litaC_sym->decl = litaC_decl;
    litaC_sym->type = NULL;
    litaC_sym->declared = litaC_module;
    litaC_sym->flags = litaC_flags;
    litaC_decl->sym = litaC_sym;
    litaC_map__Map_put_cb__ptr_const_char_c__ptr_Symbol_ce_(&((litaC_this->symbols)), litaC_sym->name, litaC_sym);
    return litaC_sym;
    
    
}

litaC_void litaC_symbols__Scope_print(litaC_symbols__Scope* litaC_this,const litaC_char* litaC_header) {
    printf("Scope %s {\n", litaC_header);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_this->symbols.capacity;litaC_i += 1) {
        {
            const litaC_char* litaC_symName = litaC_this->symbols.keys[litaC_i];
            litaC_symbols__Symbol* litaC_symbol = litaC_this->symbols.values[litaC_i];
            if(!(litaC_symName) || !(litaC_symbol)) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            printf("   '%s'\n", litaC_symName);
            
            
        }
    }
    printf("}\n");
    
}

litaC_module__Module* litaC_module__BuiltinsInit(litaC_lita__Lita* litaC_lita) {
    litaC_module__builtins.text = NULL;
    litaC_module__builtins.ast = NULL;
    litaC_module__builtins.flags = 0;
    litaC_module__builtins.allocator = litaC_lita->allocator;
    litaC_array__Array_init_cb_ModuleImport_ce_(&((litaC_module__builtins.importedBy)), 512, litaC_lita->allocator);
    litaC_symbols__Scope_init(&((litaC_module__builtins.symbols)), litaC_symbols__ScopeKind_MODULE, NULL, &((litaC_lita->result)), litaC_lita->allocator);
    litaC_module__builtins.genericSymbols = &(litaC_lita->genericSymbols);
    litaC_char litaC_filename[_MAX_PATH];
    litaC_string__String litaC_pathStr = litaC_string__StringInit(litaC_filename, _MAX_PATH, -(1));
    litaC_string__String_format(&((litaC_pathStr)), "%s/stdlib/std/builtins.lita", litaC_lita->options->litaPath);
    litaC_module__ModuleId_fromFile(&((litaC_module__builtins.id)), litaC_lita, litaC_string__String_cStr(litaC_pathStr));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__BOOL_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__CHAR_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__I8_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__U8_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__I16_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__U16_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__I32_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__U32_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__I64_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__U64_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__F32_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__F64_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__USIZE_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__NULL_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__VOID_TYPE));
    return &(litaC_module__builtins);
    
    
}

litaC_void litaC_module__AddBuiltin(litaC_lita__Lita* litaC_lita,litaC_types__TypeInfo* litaC_type) {
    litaC_symbols__Symbol* litaC_sym = litaC_symbols__Scope_addSymbol(&((litaC_module__builtins.symbols)), litaC_type->name, &(litaC_module__builtins), litaC_ast_new__NewBuiltinDecl((litaC_lex__SrcPos) {
        
    }, (litaC_lex__SrcPos) {
        
    }, litaC_type, litaC_lita->allocator), litaC_symbols__SymbolFlags_IS_BUILTIN | litaC_symbols__SymbolFlags_IS_TYPE | litaC_symbols__SymbolFlags_IS_FOREIGN);
    litaC_sym->state = litaC_symbols__SymbolState_RESOLVED;
    litaC_sym->type = litaC_type;
    litaC_type->sym = litaC_sym;
    
}

litaC_module__Module* litaC_module__NewModule(litaC_lita__Lita* litaC_lita,const litaC_char* litaC_filename) {
    litaC_module__Module* litaC_mod = litaC_mem__new_cb_Module_ce_(litaC_lita->allocator);
    litaC_module__Module_init(litaC_mod, &(litaC_lita->result), &(litaC_lita->genericSymbols), litaC_lita->allocator);
    litaC_module__ModuleId_fromFile(&((litaC_mod->id)), litaC_lita, litaC_filename);
    return litaC_mod;
    
    
}

litaC_void litaC_module__Module_init(litaC_module__Module* litaC_this,litaC_phase_result__PhaseResult* litaC_result,litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_* litaC_genericSymbols,const litaC_mem__Allocator* litaC_allocator) {
    litaC_this->text = NULL;
    litaC_this->ast = NULL;
    litaC_array__Array_init_cb_ModuleImport_ce_(&((litaC_this->importedBy)), 64, litaC_allocator);
    litaC_symbols__Scope_init(&((litaC_this->symbols)), litaC_symbols__ScopeKind_MODULE, &(litaC_module__builtins.symbols), litaC_result, litaC_allocator);
    litaC_this->flags = 0;
    litaC_this->allocator = litaC_allocator;
    litaC_this->currentScope = &(litaC_this->symbols);
    litaC_this->genericSymbols = litaC_genericSymbols;
    litaC_this->symbols.module = litaC_this;
    
}

litaC_symbols__Symbol* litaC_module__Module_getType(litaC_module__Module* litaC_this,const litaC_char* litaC_type) {
    litaC_symbols__Symbol* litaC_sym = litaC_symbols__Scope_lookup(&((litaC_this->symbols)), litaC_type);
    if(litaC_sym) {
        {
            return litaC_sym;
            
            
            
        }
        
    } 
    
    return litaC_map__Map_get_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_this->genericSymbols, litaC_type);
    
    
}

litaC_bool litaC_module__Module_isMethodForType(litaC_module__Module* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_symbols__Symbol* litaC_sym) {
    if(!((litaC_sym->flags & litaC_symbols__SymbolFlags_IS_METHOD))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__FuncTypeInfo* litaC_fn = (litaC_types__FuncTypeInfo*)litaC_sym->type;
    if(litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_fn->decl->params->params))) == 0) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_ast__ParameterDecl* litaC_firstArg = litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_fn->decl->params->params)), 0);
    if(!(litaC_firstArg->typeInfo)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_base = litaC_types__TypeInfo_getBaseType(litaC_firstArg->typeInfo);
    if(litaC_types__IsGenericCapable(litaC_type)) {
        {
            litaC_types__GenericTypeInfo* litaC_gen = (litaC_types__GenericTypeInfo*)litaC_type;
            if(litaC_types__IsGenericCapable(litaC_base)) {
                {
                    litaC_types__GenericTypeInfo* litaC_param = (litaC_types__GenericTypeInfo*)litaC_base;
                    if(litaC_gen->genericTypeid == litaC_param->genericTypeid) {
                        {
                            return litaC_true;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            if(litaC_gen->genericTypeid == litaC_base->typeid) {
                {
                    return litaC_true;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(litaC_base->typeid != litaC_type->typeid) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_i32 litaC_module__Module_getMethodsForType(litaC_module__Module* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_symbols__Symbol** litaC_result) {
    litaC_i32 litaC_numOfSymbols = 0;
    litaC_symbols__Scope* litaC_currentSyms = &(litaC_this->symbols);
    while(litaC_currentSyms) {
        {
            for(litaC_map__MapIterator_cb__ptr_const_char_c__ptr_Symbol_ce_ litaC_it = litaC_map__Map_iter_cb__ptr_const_char_c__ptr_Symbol_ce_(&((litaC_currentSyms->symbols)));litaC_map__MapIterator_hasNext_cb__ptr_const_char_c__ptr_Symbol_ce_(&((litaC_it)));) {
                {
                    litaC_map__MapEntry_cb__ptr_const_char_c__ptr_Symbol_ce_ litaC_n = litaC_map__MapIterator_next_cb__ptr_const_char_c__ptr_Symbol_ce_(&((litaC_it)));
                    litaC_symbols__Symbol* litaC_sym = litaC_n.value;
                    if(!(litaC_module__Module_isMethodForType(litaC_this, litaC_type, litaC_sym))) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    litaC_result[litaC_numOfSymbols] = litaC_sym;
                    litaC_numOfSymbols += 1;
                    
                    
                }
            }
            litaC_currentSyms = (litaC_currentSyms->parent) ? litaC_currentSyms->parent : NULL;
            
            
        }
    }
    return litaC_numOfSymbols;
    
    
}

litaC_void litaC_module__Module_importModule(litaC_module__Module* litaC_this,litaC_ast__ImportDecl* litaC_importDecl,litaC_module__Module* litaC_moduleToImport) {
    litaC_string_view__StringView* litaC_moduleName = NULL;
    if(litaC_importDecl->alias.type == litaC_lex__TokenType_IDENTIFIER) {
        {
            litaC_moduleName = &(litaC_importDecl->alias.value.str);
            
            
        }
        
    } 
    
    litaC_module__Module_importModuleSymbols(litaC_this, litaC_moduleToImport, litaC_moduleName, litaC_importDecl->isUsing);
    
}

litaC_void litaC_module__Module_importModuleSymbols(litaC_module__Module* litaC_this,litaC_module__Module* litaC_moduleToImport,litaC_string_view__StringView* litaC_moduleName,litaC_bool litaC_isUsing) {
    litaC_array__Array_add_cb_ModuleImport_ce_(&((litaC_moduleToImport->importedBy)), (litaC_module__ModuleImport) {
        litaC_this,
        litaC_moduleName,
        litaC_isUsing
    });
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_moduleToImport->symbols.symbols.capacity;litaC_i += 1) {
        {
            const litaC_char* litaC_symName = litaC_moduleToImport->symbols.symbols.keys[litaC_i];
            litaC_symbols__Symbol* litaC_symbol = litaC_moduleToImport->symbols.symbols.values[litaC_i];
            if(!(litaC_symName) || !(litaC_symbol)) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            litaC_module__Module_importModuleSymbol(litaC_this, litaC_moduleToImport, litaC_moduleName, litaC_symbol, litaC_symName, litaC_isUsing);
            
            
        }
    }
    
}

litaC_void litaC_module__Module_importModuleSymbol(litaC_module__Module* litaC_this,litaC_module__Module* litaC_moduleToImport,litaC_string_view__StringView* litaC_moduleName,litaC_symbols__Symbol* litaC_symbol,const litaC_char* litaC_symName,litaC_bool litaC_isUsing) {
    if(!((litaC_symbol->flags & litaC_symbols__SymbolFlags_IS_PUBLIC))) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(!(litaC_module__Module_equals(litaC_symbol->declared, litaC_moduleToImport))) {
        {
            if(!(litaC_symbol->usingModule) || !(litaC_module__Module_equals(litaC_symbol->usingModule, litaC_moduleToImport))) {
                {
                    return;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(litaC_module__Module_equals(litaC_symbol->declared, litaC_this)) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_isUsing && !(litaC_symbol->usingModule)) {
        {
            litaC_symbol->usingModule = litaC_this;
            
            
        }
        
    } 
    
    if(litaC_moduleName) {
        {
            litaC_string_buffer__StringBuffer litaC_name = litaC_string_buffer__StringBufferInit(litaC_symbols__MAX_SYMBOL_NAME, litaC_this->allocator);
            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_name)), litaC_moduleName->buffer, litaC_moduleName->length);
            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_name)), "::", 2);
            litaC_string_buffer__StringBuffer_appendStr(&((litaC_name)), litaC_symbol->name);
            litaC_symbols__Scope_importSymbol(&((litaC_this->symbols)), litaC_string_buffer__StringBuffer_cStrConst(&((litaC_name))), litaC_symbol);
            
            
        }
        
    } else {
        {
            litaC_symbols__Scope_importSymbol(&((litaC_this->symbols)), litaC_symName, litaC_symbol);
            
            
        }
    } 
    
    
}

LITAC_INLINE 
litaC_bool litaC_module__Module_equals(litaC_module__Module* litaC_this,litaC_module__Module* litaC_other) {
    return litaC_this == litaC_other;
    
    
}

litaC_void litaC_module__Module_print(litaC_module__Module* litaC_this,const litaC_char* litaC_header) {
    printf("Module %s %.*s {\n", litaC_header, litaC_this->id.name.length, litaC_this->id.name.buffer);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_this->symbols.symbols.capacity;litaC_i += 1) {
        {
            const litaC_char* litaC_symName = litaC_this->symbols.symbols.keys[litaC_i];
            litaC_symbols__Symbol* litaC_symbol = litaC_this->symbols.symbols.values[litaC_i];
            if(!(litaC_symName) || !(litaC_symbol)) {
                {
                    printf("   %d null\n", litaC_i);
                    continue;
                    
                    
                }
                
            } 
            
            printf("   %d '%s' %s\n", litaC_i, litaC_symName, litaC_symbols__SymbolKindAsStr(litaC_symbol->kind));
            
            
        }
    }
    printf("}\n");
    
}

litaC_void litaC_module__ModuleId_fromFile(litaC_module__ModuleId* litaC_moduleId,litaC_lita__Lita* litaC_lita,const litaC_char* litaC_filename) {
    litaC_system__GetAbsolutePath(litaC_system__CurrentWorkingPath(), litaC_filename, litaC_moduleId->filename);
    litaC_string_view__StringView litaC_pathStr = litaC_string_view__StringViewInit(litaC_moduleId->filename, -(1));
    litaC_moduleId->packageName = litaC_string_view__StringViewInit(litaC_moduleId->filename, 0);
    litaC_moduleId->name = litaC_module__GetModuleName(litaC_pathStr);
    
}

litaC_string_view__StringView litaC_module__GetModuleName(litaC_string_view__StringView litaC_pathStr) {
    litaC_i32 litaC_endIndex = -(1);
    litaC_i32 litaC_startIndex = -(1);
    for(litaC_i32 litaC_i = litaC_pathStr.length - 1;litaC_i >= 0;litaC_i -= 1) {
        {
            litaC_char litaC_c = litaC_pathStr.buffer[litaC_i];
            if(litaC_c == '.' && litaC_endIndex < 0) {
                {
                    litaC_endIndex = litaC_i;
                    
                    
                }
                
            } else {
                if(litaC_c == '/') {
                    {
                        litaC_startIndex = litaC_i + 1;
                        break;
                        
                        
                    }
                    
                } 
                
            } 
            
            
            
        }
    }
    if(litaC_endIndex < 0 || litaC_startIndex < 0 || litaC_startIndex > litaC_endIndex) {
        {
            return (litaC_string_view__StringView) {
                .buffer = 0,
                .length = 0
            };
            
            
            
        }
        
    } 
    
    return (litaC_string_view__StringView) {
        .buffer = litaC_pathStr.buffer + litaC_startIndex,
        .length = litaC_endIndex - litaC_startIndex
    };
    
    
}

litaC_phase_result__PhaseResult litaC_phase_result__PhaseResultInit(const litaC_mem__Allocator* litaC_allocator) {
    litaC_phase_result__PhaseResult litaC_result =  {
        .allocator = litaC_allocator,
        .enabled = litaC_true
    };
    litaC_array__Array_init_cb_PhaseError_ce_(&((litaC_result.errors)), 16, litaC_allocator);
    return litaC_result;
    
    
}

litaC_void litaC_phase_result__PhaseResult_addError(litaC_phase_result__PhaseResult* litaC_r,litaC_lex__SrcPos litaC_pos,const litaC_char* litaC_format,...) {
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_r->allocator);
    va_list litaC_args;
    va_start(litaC_args, litaC_format);
    litaC_string_buffer__StringBuffer_appendArgs(&((litaC_sb)), litaC_format, litaC_args);
    va_end(litaC_args);
    litaC_phase_result__PhaseResult_addErrorStr(litaC_r, litaC_pos, &((litaC_sb)));
    
}

litaC_void litaC_phase_result__PhaseResult_addErrorStr(litaC_phase_result__PhaseResult* litaC_r,litaC_lex__SrcPos litaC_pos,litaC_string_buffer__StringBuffer* litaC_sb) {
    if(!(litaC_r->enabled)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_array__Array_add_cb_PhaseError_ce_(&((litaC_r->errors)), (litaC_phase_result__PhaseError) {
        .type = litaC_phase_result__ErrorType_ERROR,
        .message = litaC_string_buffer__StringBuffer_cStr(litaC_sb),
        .pos = litaC_pos
    });
    
}

litaC_bool litaC_phase_result__PhaseResult_hasErrors(litaC_phase_result__PhaseResult* litaC_r) {
    return !(litaC_array__Array_empty_cb_PhaseError_ce_(&((litaC_r->errors))));
    
    
}

litaC_void litaC_common__Log(litaC_common__LogLevel litaC_level,const litaC_char* litaC_format,...) {
    va_list litaC_args;
    va_start(litaC_args, litaC_format);
    litaC_common__Logv(litaC_level, litaC_format, litaC_args);
    va_end(litaC_args);
    
}

litaC_void litaC_common__Logv(litaC_common__LogLevel litaC_level,const litaC_char* litaC_format,va_list litaC_args) {
    if(!(litaC_common__outputFile)) {
        {
            litaC_common__outputFile = fopen("./litac.log", "w");
            if(!(litaC_common__outputFile)) {
                {
                    litaC_common__outputFile = stdout;
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(litaC_level > litaC_common__LogLevel_DEBUG) {
        {
            vfprintf(stderr, litaC_format, litaC_args);
            fflush(stderr);
            
            
        }
        
    } else {
        {
            vfprintf(litaC_common__outputFile, litaC_format, litaC_args);
            fflush(litaC_common__outputFile);
            
            
        }
    } 
    
    if(litaC_level == litaC_common__LogLevel_FATAL) {
        {
            exit(2);
            
            
        }
        
    } 
    
    
}

litaC_void litaC_common__Info(const litaC_char* litaC_format,...) {
    va_list litaC_args;
    va_start(litaC_args, litaC_format);
    litaC_common__Logv(litaC_common__LogLevel_INFO, litaC_format, litaC_args);
    va_end(litaC_args);
    
}

litaC_void litaC_common__Debug(const litaC_char* litaC_format,...) {
    va_list litaC_args;
    va_start(litaC_args, litaC_format);
    litaC_common__Logv(litaC_common__LogLevel_DEBUG, litaC_format, litaC_args);
    va_end(litaC_args);
    
}

litaC_void litaC_common__Error(const litaC_char* litaC_format,...) {
    va_list litaC_args;
    va_start(litaC_args, litaC_format);
    litaC_common__Logv(litaC_common__LogLevel_ERROR, litaC_format, litaC_args);
    va_end(litaC_args);
    
}

litaC_void litaC_common__Panic(const litaC_char* litaC_format,...) {
    va_list litaC_args;
    va_start(litaC_args, litaC_format);
    litaC_common__Logv(litaC_common__LogLevel_FATAL, litaC_format, litaC_args);
    va_end(litaC_args);
    
}

litaC_char* litaC_common__EscapeName(const litaC_char* litaC_name,litaC_string_buffer__StringBuffer* litaC_sb) {
    litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, litaC_name, strlen(litaC_name));
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_sb->length;) {
        {
            litaC_char litaC_c = litaC_sb->buffer[litaC_i];
            switch(litaC_c) {
                case '*': {
                    litaC_string_buffer__StringBuffer_replace(litaC_sb, litaC_i, litaC_i + 1, "_ptr_");
                    litaC_i += 5;
                    break;
                    
                    
                }
                case '<': {
                    litaC_string_buffer__StringBuffer_replace(litaC_sb, litaC_i, litaC_i + 1, "_cb_");
                    litaC_i += 4;
                    break;
                    
                    
                }
                case '>': {
                    litaC_string_buffer__StringBuffer_replace(litaC_sb, litaC_i, litaC_i + 1, "_ce_");
                    litaC_i += 4;
                    break;
                    
                    
                }
                case '[': {
                    litaC_string_buffer__StringBuffer_replace(litaC_sb, litaC_i, litaC_i + 1, "_bb_");
                    litaC_i += 4;
                    break;
                    
                    
                }
                case ']': {
                    litaC_string_buffer__StringBuffer_replace(litaC_sb, litaC_i, litaC_i + 1, "_be_");
                    litaC_i += 4;
                    break;
                    
                    
                }
                case '(': {
                    litaC_string_buffer__StringBuffer_replace(litaC_sb, litaC_i, litaC_i + 1, "_pb_");
                    litaC_i += 4;
                    break;
                    
                    
                }
                case ')': {
                    litaC_string_buffer__StringBuffer_replace(litaC_sb, litaC_i, litaC_i + 1, "_pe_");
                    litaC_i += 4;
                    break;
                    
                    
                }
                case ',': {
                    litaC_string_buffer__StringBuffer_replace(litaC_sb, litaC_i, litaC_i + 1, "_c_");
                    litaC_i += 3;
                    break;
                    
                    
                }
                case ' ': {
                    litaC_string_buffer__StringBuffer_replace(litaC_sb, litaC_i, litaC_i + 1, "_");
                    litaC_i += 1;
                    break;
                    
                    
                }
                case ':': {
                    {
                        litaC_i32 litaC_n = litaC_i + 1;
                        if(litaC_n < litaC_sb->length) {
                            {
                                litaC_char litaC_nc = litaC_sb->buffer[litaC_n];
                                if(litaC_nc == ':') {
                                    {
                                        litaC_string_buffer__StringBuffer_replace(litaC_sb, litaC_i, litaC_i + 1, "__");
                                        litaC_i += 2;
                                        break;
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_string_buffer__StringBuffer_replace(litaC_sb, litaC_i, litaC_i + 1, "_r_");
                        litaC_i += 3;
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        litaC_i += 1;
                        break;
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    return litaC_string_buffer__StringBuffer_cStr(litaC_sb);
    
    
}

litaC_void litaC_lita__Lita_init(litaC_lita__Lita* litaC_this,litaC_lita__LitaOptions* litaC_options) {
    litaC_usize litaC_size = 1024 * 1024 * 1000;
    litaC_mem__LinearAllocator_init(&((litaC_this->linearAllocator)), litaC_mem__Allocator_alloc(litaC_mem__defaultAllocator, litaC_size), litaC_size);
    const litaC_mem__Allocator* litaC_allocator = (const litaC_mem__Allocator*)(&(litaC_this->linearAllocator));
    litaC_this->allocator = litaC_allocator;
    litaC_this->options = litaC_options;
    memset(litaC_this->binaryFilename, 0, _MAX_PATH);
    memset(litaC_this->sourceFilename, 0, _MAX_PATH);
    litaC_lita__Lita_reset(litaC_this);
    
}


litaC_void litaC_lita__Lita_reset(litaC_lita__Lita* litaC_this) {
    litaC_mem__LinearAllocator_clear(&((litaC_this->linearAllocator)));
    litaC_this->totalSourceLines = 0;
    litaC_this->totalAllocations = 0;
    litaC_preprocessor__Preprocessor_init(&((litaC_this->preprocessor)), litaC_this);
    litaC_this->result = litaC_phase_result__PhaseResultInit(litaC_this->allocator);
    litaC_this->modules = litaC_map__StrMap_cb__ptr_Module_ce_(NULL, 32, litaC_this->allocator);
    litaC_this->genericSymbols = litaC_map__StrMap_cb__ptr_Symbol_ce_(NULL, 128, litaC_this->allocator);
    litaC_references__ReferenceDatabase_init(&((litaC_this->references)), litaC_this->allocator);
    
}

litaC_void litaC_lita__Lita_free(litaC_lita__Lita* litaC_lita) {
    if(litaC_lita->linearAllocator.mem) {
        {
            litaC_mem__Allocator_free(litaC_mem__defaultAllocator, litaC_lita->linearAllocator.mem);
            
            
        }
        
    } 
    
    
}

litaC_void litaC_lita__Lita_addModule(litaC_lita__Lita* litaC_lita,litaC_module__Module* litaC_module) {
    litaC_map__Map_put_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_lita->modules)), litaC_module->id.filename, litaC_module);
    
}

litaC_void litaC_lita__Lita_startCapture(litaC_lita__Lita* litaC_lita,litaC_lita__MetricType litaC_type) {
    litaC_lita__Metric* litaC_metric = &(litaC_lita->metrics[litaC_type]);
    litaC_mem__LinearAllocator* litaC_allocator = (litaC_mem__LinearAllocator*)litaC_lita->allocator;
    litaC_metric->bytesAllocated = litaC_allocator->totalBytesAllocated;
    litaC_metric->allocationCount = litaC_allocator->totalAllocations;
    litaC_metric->startTime = litaC_system__SystemTimeMSec();
    
}

litaC_void litaC_lita__Lita_endCapture(litaC_lita__Lita* litaC_lita,litaC_lita__MetricType litaC_type) {
    litaC_lita__Metric* litaC_metric = &(litaC_lita->metrics[litaC_type]);
    litaC_mem__LinearAllocator* litaC_allocator = (litaC_mem__LinearAllocator*)litaC_lita->allocator;
    litaC_metric->bytesAllocated = litaC_allocator->totalBytesAllocated - litaC_metric->bytesAllocated;
    litaC_metric->allocationCount = litaC_allocator->totalAllocations - litaC_metric->allocationCount;
    litaC_metric->executionTime = litaC_system__SystemTimeMSec() - litaC_metric->startTime;
    
}

litaC_module__Module* litaC_lita__Lita_parse(litaC_lita__Lita* litaC_this) {
    litaC_lita__Lita_startCapture(litaC_this, litaC_lita__MetricType_PARSING);
    
    litaC_module__Module* litaC_builtin = litaC_module__BuiltinsInit(litaC_this);
    litaC_lita__Lita_addModule(litaC_this, litaC_builtin);
    if(!(litaC_lita__ParseModule(litaC_this, litaC_builtin, (litaC_lex__SrcPos) {
        
    }))) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->result)), (litaC_lex__SrcPos) {
                
            }, "unable to parse builtins.lita");
            {
                litaC_module__Module* ___result = NULL;
                litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_PARSING);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_module__Module* litaC_root = litaC_module__NewModule(litaC_this, litaC_this->options->inputFile);
    litaC_lita__Lita_addModule(litaC_this, litaC_root);
    if(!(litaC_lita__ParseModule(litaC_this, litaC_root, (litaC_lex__SrcPos) {
        
    }))) {
        {
            {
                litaC_module__Module* ___result = NULL;
                litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_PARSING);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_ast__ImportDecl* litaC_builtinImport = (litaC_ast__ImportDecl*)litaC_ast_new__NewImportDecl((litaC_lex__SrcPos) {
        
    }, (litaC_lex__SrcPos) {
        
    }, litaC_module__BUILTIN_IMPORT_TOKEN, (litaC_lex__Token) {
        .type = litaC_lex__TokenType_VOID
    }, litaC_false, litaC_this->allocator);
    litaC_builtinImport->moduleId = &(litaC_builtin->id);
    litaC_array__Array_add_cb__ptr_ImportDecl_ce_(&((litaC_root->ast->imports)), litaC_builtinImport);
    {
        litaC_module__Module* ___result = litaC_root;
        litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_PARSING);
        return ___result;
        
    }
    
    litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_PARSING);
    
}

litaC_bool litaC_lita__Lita_typeCheck(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module) {
    litaC_lita__Lita_startCapture(litaC_this, litaC_lita__MetricType_TYPE_CHECKING);
    
    litaC_checker__TypeChecker litaC_checker =  {
        
    };
    litaC_checker__TypeChecker_init(&((litaC_checker)), litaC_this);
    litaC_this->programSymbols = litaC_checker__TypeChecker_typeCheck(&((litaC_checker)), litaC_module);
    {
        litaC_bool ___result = litaC_array__Array_empty_cb_PhaseError_ce_(&((litaC_this->result.errors)));
        litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_TYPE_CHECKING);
        return ___result;
        
    }
    
    litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_TYPE_CHECKING);
    
}

litaC_bool litaC_lita__Lita_transpile(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module) {
    if(!(litaC_system__Mkdir(litaC_this->options->outputPath))) {
        {
            printf("Unable to create directory: '%s'", litaC_this->options->outputPath);
            return litaC_false;
            
            
            
        }
        
    } 
    
    memset(litaC_this->binaryFilename, 0, _MAX_PATH);
    memset(litaC_this->sourceFilename, 0, _MAX_PATH);
    strcat(litaC_this->sourceFilename, litaC_this->options->outputPath);
    strcat(litaC_this->sourceFilename, litaC_this->options->outputFile);
    strcpy(litaC_this->binaryFilename, litaC_this->sourceFilename);
    {
        strcat(litaC_this->binaryFilename, ".exe");
        
        
    }
    strcat(litaC_this->sourceFilename, ".c");
    if(litaC_this->options->cOutputOnly) {
        {
            if(!(litaC_lita__Lita_emitC(litaC_this, litaC_module, litaC_this->sourceFilename))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_this->options->compileCmd)) {
        {
            if(!(litaC_lita__Lita_compileWithLibtcc(litaC_this, litaC_module, litaC_this->binaryFilename))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } else {
        {
            if(!(litaC_lita__Lita_emitC(litaC_this, litaC_module, litaC_this->sourceFilename))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            if(!(litaC_lita__Lita_compileC(litaC_this, litaC_module, litaC_this->sourceFilename, litaC_this->binaryFilename))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    } 
    
    return litaC_true;
    
    
}

litaC_void litaC_lita__LibtccErrorFunc(litaC_void* litaC_data,const litaC_char* litaC_msg) {
    litaC_common__Error("%s\n", litaC_msg);
    
}

litaC_bool litaC_lita__Lita_compileWithLibtcc(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module,const litaC_char* litaC_binaryFilename) {
    litaC_lita__Lita_startCapture(litaC_this, litaC_lita__MetricType_CGEN);
    litaC_cgen__CGen litaC_cgen =  {
        
    };
    litaC_cgen__CGen_init(&((litaC_cgen)), litaC_this, NULL);
    litaC_cgen__CGen_emitProgram(&((litaC_cgen)), litaC_module);
    litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_CGEN);
    litaC_char* litaC_sourceCode = litaC_string_buffer__StringBuffer_cStr(&((litaC_cgen.buf)));
    TCCState* litaC_state = tcc_new();
    
    tcc_set_error_func(litaC_state, litaC_this, litaC_lita__LibtccErrorFunc);
    tcc_set_output_type(litaC_state, TCC_OUTPUT_EXE);
    tcc_output_file(litaC_state, litaC_binaryFilename);
    if(tcc_compile_string(litaC_state, litaC_sourceCode) < 0) {
        {
            {
                litaC_bool ___result = litaC_false;
                if(litaC_state) {
                    tcc_delete(litaC_state);
                    
                } 
                ;
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    {
        litaC_bool ___result = litaC_true;
        if(litaC_state) {
            tcc_delete(litaC_state);
            
        } 
        ;
        return ___result;
        
    }
    
    if(litaC_state) {
        tcc_delete(litaC_state);
        
    } 
    ;
    
}

litaC_bool litaC_lita__Lita_emitC(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module,const litaC_char* litaC_cFilename) {
    litaC_lita__Lita_startCapture(litaC_this, litaC_lita__MetricType_CGEN);
    FILE* litaC_fp = fopen(litaC_cFilename, "w");
    if(litaC_fp == NULL) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    
    litaC_cgen__CGen litaC_cgen =  {
        
    };
    litaC_cgen__CGen_init(&((litaC_cgen)), litaC_this, litaC_fp);
    litaC_cgen__CGen_emitProgram(&((litaC_cgen)), litaC_module);
    litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_CGEN);
    {
        litaC_bool ___result = litaC_array__Array_empty_cb_PhaseError_ce_(&((litaC_this->result.errors)));
        fclose(litaC_fp);
        return ___result;
        
    }
    
    fclose(litaC_fp);
    
}

litaC_bool litaC_lita__Lita_compileC(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module,const litaC_char* litaC_sourceFilename,const litaC_char* litaC_binaryFilename) {
    litaC_lita__Lita_startCapture(litaC_this, litaC_lita__MetricType_CCOMPILE);
    
    litaC_string_buffer__StringBuffer litaC_commandStr = litaC_string_buffer__StringBufferInit(1024, NULL);
    
    litaC_string_buffer__StringBuffer_appendStr(&((litaC_commandStr)), litaC_this->options->compileCmd);
    litaC_i32 litaC_index = litaC_string_buffer__StringBuffer_indexOf(&((litaC_commandStr)), "%output%", -(1));
    if(litaC_index > -(1)) {
        {
            litaC_string_buffer__StringBuffer_replace(&((litaC_commandStr)), litaC_index, litaC_index + strlen("%output%"), litaC_binaryFilename);
            
            
        }
        
    } 
    
    litaC_index = litaC_string_buffer__StringBuffer_indexOf(&((litaC_commandStr)), "%input%", -(1));
    if(litaC_index > -(1)) {
        {
            litaC_string_buffer__StringBuffer_replace(&((litaC_commandStr)), litaC_index, litaC_index + strlen("%input%"), litaC_sourceFilename);
            
            
        }
        
    } 
    
    if(system(litaC_string_buffer__StringBuffer_cStrConst(&((litaC_commandStr)))) == 0) {
        {
            {
                litaC_bool ___result = litaC_true;
                litaC_string_buffer__StringBuffer_free(&((litaC_commandStr)));
                litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_CCOMPILE);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    {
        litaC_bool ___result = litaC_false;
        litaC_string_buffer__StringBuffer_free(&((litaC_commandStr)));
        litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_CCOMPILE);
        return ___result;
        
    }
    
    litaC_string_buffer__StringBuffer_free(&((litaC_commandStr)));
    litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_CCOMPILE);
    
}

litaC_void litaC_lita__Lita_run(litaC_lita__Lita* litaC_this) {
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->allocator);
    
    litaC_char litaC_path[_MAX_PATH];
    litaC_system__FilePath(litaC_this->binaryFilename, litaC_path);
    litaC_i32 litaC_len = strlen(litaC_path);
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "cd ", 3);
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), litaC_path, litaC_len);
    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), " && .%s", litaC_system__PATH_SEPARATOR);
    litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), &(litaC_this->binaryFilename[litaC_len + 1]));
    system(litaC_string_buffer__StringBuffer_cStr(&((litaC_sb))));
    litaC_string_buffer__StringBuffer_free(&((litaC_sb)));
    
}

litaC_bool litaC_lita__FindModulePath(litaC_lita__Lita* litaC_lita,litaC_string_view__StringView litaC_moduleName,litaC_char* litaC_filename) {
    litaC_char litaC_path[_MAX_PATH] =  {
        0
    };
    litaC_string__String litaC_pathStr = litaC_string__StringInit(litaC_path, _MAX_PATH, -(1));
    
    litaC_string__String_format(&((litaC_pathStr)), "%s/%.*s.lita", litaC_lita->options->srcPath, litaC_moduleName.length, litaC_moduleName.buffer);
    if(litaC_system__FileExists(litaC_string__String_cStrConst(litaC_pathStr))) {
        {
            {
                litaC_bool ___result = litaC_true;
                {
                    litaC_system__GetAbsolutePath(litaC_system__CurrentWorkingPath(), litaC_string__String_cStr(litaC_pathStr), litaC_filename);
                    
                    
                };
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_string__String_format(&((litaC_pathStr)), "%s/%.*s.lita", litaC_lita->options->libPath, litaC_moduleName.length, litaC_moduleName.buffer);
    if(litaC_system__FileExists(litaC_string__String_cStrConst(litaC_pathStr))) {
        {
            {
                litaC_bool ___result = litaC_true;
                {
                    litaC_system__GetAbsolutePath(litaC_system__CurrentWorkingPath(), litaC_string__String_cStr(litaC_pathStr), litaC_filename);
                    
                    
                };
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_string__String_format(&((litaC_pathStr)), "%s/stdlib/%.*s.lita", litaC_lita->options->litaPath, litaC_moduleName.length, litaC_moduleName.buffer);
    if(litaC_system__FileExists(litaC_string__String_cStrConst(litaC_pathStr))) {
        {
            {
                litaC_bool ___result = litaC_true;
                {
                    litaC_system__GetAbsolutePath(litaC_system__CurrentWorkingPath(), litaC_string__String_cStr(litaC_pathStr), litaC_filename);
                    
                    
                };
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_string__String_clear(&((litaC_pathStr)));
    {
        litaC_bool ___result = litaC_false;
        {
            litaC_system__GetAbsolutePath(litaC_system__CurrentWorkingPath(), litaC_string__String_cStr(litaC_pathStr), litaC_filename);
            
            
        };
        return ___result;
        
    }
    
    {
        litaC_system__GetAbsolutePath(litaC_system__CurrentWorkingPath(), litaC_string__String_cStr(litaC_pathStr), litaC_filename);
        
        
    };
    
}

litaC_bool litaC_lita__ParseModule(litaC_lita__Lita* litaC_lita,litaC_module__Module* litaC_module,litaC_lex__SrcPos litaC_pos) {
    if(!(litaC_module)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_module->text)) {
        {
            litaC_io__FileStatus litaC_status = litaC_io__ReadFile(litaC_module->id.filename, &(litaC_module->text), litaC_lita->allocator);
            if(litaC_status == litaC_io__FileStatus_FileNotFoundError) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_lita->result)), litaC_pos, "Could not open file '%s'\n", litaC_module->id.filename);
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            if(litaC_status == litaC_io__FileStatus_IOError) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_lita->result)), litaC_pos, "Could not read file '%s'\n", litaC_module->id.filename);
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_parser__Parser litaC_parser = litaC_parser__ParserInit(litaC_module->id.filename, litaC_module->text, litaC_lita);
    litaC_ast__ModuleStmt* litaC_moduleStmt = litaC_parser__Parser_parseModule(&((litaC_parser)));
    litaC_module->ast = litaC_moduleStmt;
    litaC_lita->totalSourceLines += litaC_parser.totalLines;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_ImportDecl_ce_(&((litaC_module->ast->imports)));litaC_i += 1) {
        {
            litaC_ast__ImportDecl* litaC_importStmt = litaC_array__Array_get_cb__ptr_ImportDecl_ce_(&((litaC_module->ast->imports)), litaC_i);
            if(litaC_importStmt->decl.name.type == litaC_lex__TokenType_ERROR) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_lita->result)), litaC_importStmt->decl.stmt.node.startPos, "Could not parse import statement");
                    continue;
                    
                    
                }
                
            } 
            
            litaC_char litaC_filename[_MAX_PATH];
            if(!(litaC_lita__FindModulePath(litaC_lita, litaC_importStmt->decl.name.value.str, litaC_filename))) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_lita->result)), litaC_importStmt->decl.stmt.node.startPos, "Could not find module '%.*s'", litaC_importStmt->decl.name.value.str.length, litaC_importStmt->decl.name.value.str.buffer);
                    continue;
                    
                    
                }
                
            } 
            
            litaC_module__Module* litaC_importModule = litaC_map__Map_get_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_lita->modules)), litaC_filename);
            if(litaC_importModule) {
                {
                    litaC_importStmt->moduleId = &(litaC_importModule->id);
                    continue;
                    
                    
                }
                
            } 
            
            litaC_importModule = litaC_module__NewModule(litaC_lita, litaC_filename);
            litaC_importStmt->moduleId = &(litaC_importModule->id);
            litaC_lita__Lita_addModule(litaC_lita, litaC_importModule);
            litaC_lita__ParseModule(litaC_lita, litaC_importModule, litaC_importStmt->decl.stmt.node.startPos);
            
            
        }
    }
    return litaC_true;
    
    
}

litaC_void litaC_preprocessor__noOpFree(litaC_void* litaC_mem,litaC_void* litaC_freeArg) {
    
}

litaC_void* litaC_preprocessor__litaMalloc(litaC_u64 litaC_len,litaC_void* litaC_arg) {
    litaC_lita__Lita* litaC_lita = (litaC_lita__Lita*)litaC_arg;
    return litaC_mem__Allocator_alloc(litaC_lita->allocator, litaC_len);
    
    
}

litaC_preprocessor__Preprocessor litaC_preprocessor__PreprocessorInit(litaC_lita__Lita* litaC_lita) {
    litaC_preprocessor__Preprocessor litaC_pp =  {
        
    };
    litaC_preprocessor__Preprocessor_init(&((litaC_pp)), litaC_lita);
    return litaC_pp;
    
    
}

litaC_void litaC_preprocessor__Preprocessor_init(litaC_preprocessor__Preprocessor* litaC_this,litaC_lita__Lita* litaC_lita) {
    litaC_this->lita = litaC_lita;
    litaC_this->ape = ape_make();
    litaC_array__Array_init_cb__ptr_CompStmt_ce_(&((litaC_this->preCheckers)), 8, litaC_lita->allocator);
    litaC_this->callContext.pp = litaC_this;
    litaC_this->callContext.checker = NULL;
    litaC_this->callContext.comp = NULL;
    litaC_string_buffer__StringBuffer_init(&((litaC_this->callContext.buffer)), 1024, litaC_lita->allocator);
    ape_set_repl_mode(litaC_this->ape, litaC_true);
    ape_set_memory_functions((litaC_void*)litaC_lita, &(litaC_preprocessor__litaMalloc), (litaC_void*)litaC_lita, &(litaC_preprocessor__noOpFree));
    ape_set_global_constant(litaC_this->ape, "OS", ape_object_make_string(litaC_this->ape, litaC_system__OSAsStr(litaC_system__GetOS())));
    ape_set_global_constant(litaC_this->ape, "DEBUG", ape_object_make_bool(litaC_lita->options->isDebug));
    ape_set_global_constant(litaC_this->ape, "REFLECTION", ape_object_make_bool(litaC_lita->options->typeOption != litaC_lita__TypeInfoOption_NONE));
    ape_set_global_constant(litaC_this->ape, "TESTING", ape_object_make_bool(litaC_lita->options->testsOnly));
    ape_set_global_constant(litaC_this->ape, "INSTRUMENT", ape_object_make_bool(litaC_lita->options->instrument));
    ape_set_global_constant(litaC_this->ape, "OUTPUT_NAME", ape_object_make_string(litaC_this->ape, litaC_lita->options->outputFile));
    ape_set_global_constant(litaC_this->ape, "OUTPUT_PATH", ape_object_make_string(litaC_this->ape, litaC_lita->options->outputPath));
    ape_set_native_function(litaC_this->ape, "getTypeKind", litaC_preprocessor__ApeGetTypeKind, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->ape, "getSymbolsByNote", litaC_preprocessor__ApeGetSymbolsWithNote, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->ape, "getSymbolsToTest", litaC_preprocessor__ApeGetSymbolsToTest, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->ape, "addDeclaration", litaC_preprocessor__ApeAddDeclaration, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->ape, "replaceDeclaration", litaC_preprocessor__ApeReplaceDeclaration, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->ape, "addImport", litaC_preprocessor__ApeAddImport, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->ape, "getMainSymbol", litaC_preprocessor__ApeGetMainSymbol, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->ape, "setMainSymbol", litaC_preprocessor__ApeSetMainSymbol, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->ape, "getInputModuleFilename", litaC_preprocessor__ApeGetInputModuleFilename, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->ape, "getCurrentModuleFilename", litaC_preprocessor__ApeGetCurrentModuleFilename, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->ape, "astInsert", litaC_preprocessor__ApeAstInsert, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->ape, "emit", litaC_preprocessor__ApeEmit, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->ape, "emitClear", litaC_preprocessor__ApeEmitClear, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->ape, "emitStr", litaC_preprocessor__ApeEmitStr, &(litaC_this->callContext));
    
}


litaC_bool litaC_preprocessor__Preprocessor_eval(litaC_preprocessor__Preprocessor* litaC_this,litaC_ast__CompStmt* litaC_comp) {
    ape_object_t litaC_result = ape_execute(litaC_this->ape, litaC_comp->expr);
    if(ape_has_errors(litaC_this->ape)) {
        {
            const ape_error_t* litaC_error = ape_get_error(litaC_this->ape, 0);
            litaC_lex__SrcPos litaC_pos =  {
                .filename = litaC_comp->stmt.node.startPos.filename,
                .lineStart = litaC_comp->stmt.node.startPos.lineStart,
                .start = litaC_comp->stmt.node.startPos.start,
                .end = litaC_comp->stmt.node.startPos.end,
                .lineNumber = litaC_comp->stmt.node.startPos.lineNumber,
                .position = litaC_comp->stmt.node.startPos.position
            };
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_pos, "error evaluating preprocessor expression: '%s' for line: '%s'", ape_error_get_message(litaC_error), ape_error_get_line(litaC_error));
            return litaC_false;
            
            
            
        }
        
    } 
    
    return ape_object_get_bool(litaC_result);
    
    
}


litaC_void litaC_preprocessor__Preprocessor_evaluateForModule(litaC_preprocessor__Preprocessor* litaC_this,litaC_ast__ModuleStmt* litaC_moduleStmt,litaC_ast__CompStmt* litaC_comp) {
    assert(litaC_comp != NULL);
    litaC_this->callContext.comp = litaC_comp;
    if(strcmp(litaC_comp->type, "precheck") == 0) {
        {
            litaC_array__Array_add_cb__ptr_CompStmt_ce_(&((litaC_this->preCheckers)), litaC_comp);
            
            
        }
        
    } else {
        if(strcmp(litaC_comp->type, "postparse") == 0) {
            {
                litaC_preprocessor__CallContext_preprocessCall(&((litaC_this->callContext)), litaC_moduleStmt, litaC_comp);
                
                
            }
            
        } else {
            if(strcmp(litaC_comp->type, "if") == 0 || strcmp(litaC_comp->type, "elseif") == 0 || strcmp(litaC_comp->type, "else") == 0) {
                {
                    if(strcmp(litaC_comp->type, "else") == 0 || litaC_preprocessor__Preprocessor_eval(litaC_this, litaC_comp)) {
                        {
                            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Stmt_ce_(&((litaC_comp->body)));litaC_i += 1) {
                                {
                                    litaC_ast__Stmt* litaC_stmt = litaC_array__Array_get_cb__ptr_Stmt_ce_(&((litaC_comp->body)), litaC_i);
                                    switch(litaC_stmt->node.kind) {
                                        case litaC_ast__StmtKind_IMPORT_DECL: {
                                            {
                                                litaC_array__Array_add_cb__ptr_ImportDecl_ce_(&((litaC_moduleStmt->imports)), (litaC_ast__ImportDecl*)litaC_stmt);
                                                break;
                                                
                                                
                                            }
                                            
                                            
                                        }
                                        case litaC_ast__StmtKind_NOTE_STMT: {
                                            {
                                                litaC_array__Array_add_cb__ptr_NoteStmt_ce_(&((litaC_moduleStmt->notes)), (litaC_ast__NoteStmt*)litaC_stmt);
                                                break;
                                                
                                                
                                            }
                                            
                                            
                                        }
                                        case litaC_ast__StmtKind_NOTES_DECL: {
                                            {
                                                litaC_ast__NotesDecl* litaC_notes = (litaC_ast__NotesDecl*)litaC_stmt;
                                                litaC_array__Array_addAll_cb__ptr_NoteStmt_ce_(&((litaC_moduleStmt->notes)), &((litaC_notes->notes)));
                                                break;
                                                
                                                
                                            }
                                            
                                            
                                        }
                                        case litaC_ast__StmtKind_BLOCK_STMT: {
                                            {
                                                litaC_ast__BlockStmt* litaC_block = (litaC_ast__BlockStmt*)litaC_stmt;
                                                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Stmt_ce_(&((litaC_block->stmts)));litaC_i += 1) {
                                                    {
                                                        litaC_ast__Stmt* litaC_s = litaC_array__Array_get_cb__ptr_Stmt_ce_(&((litaC_block->stmts)), litaC_i);
                                                        if(litaC_s->node.kind == litaC_ast__StmtKind_NOTE_STMT) {
                                                            {
                                                                litaC_array__Array_add_cb__ptr_NoteStmt_ce_(&((litaC_moduleStmt->notes)), (litaC_ast__NoteStmt*)litaC_s);
                                                                
                                                                
                                                            }
                                                            
                                                        } 
                                                        
                                                        
                                                        
                                                    }
                                                }
                                                
                                                
                                            }
                                            
                                            
                                        }
                                        default: {
                                            {
                                                if(litaC_ast__IsDecl(&((litaC_stmt->node)))) {
                                                    {
                                                        litaC_array__Array_add_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), (litaC_ast__Decl*)litaC_stmt);
                                                        
                                                        
                                                    }
                                                    
                                                } 
                                                
                                                
                                                
                                            }
                                            
                                            
                                        }
                                    }
                                    
                                    
                                }
                            }
                            
                            
                        }
                        
                    } else {
                        if(litaC_comp->end) {
                            {
                                litaC_preprocessor__Preprocessor_evaluateForModule(litaC_this, litaC_moduleStmt, litaC_comp->end);
                                
                                
                            }
                            
                        } 
                        
                    } 
                    
                    
                    
                }
                
            } 
            
        } 
        
    } 
    
    
}


litaC_ast__Stmt* litaC_preprocessor__Preprocessor_evaluateForFunction(litaC_preprocessor__Preprocessor* litaC_this,litaC_checker__TypeChecker* litaC_checker,litaC_ast__CompStmt* litaC_comp) {
    assert(litaC_comp != NULL);
    if(litaC_comp->evaluatedStmt) {
        {
            return litaC_comp->evaluatedStmt;
            
            
            
        }
        
    } 
    
    litaC_this->callContext.checker = litaC_checker;
    litaC_this->callContext.comp = litaC_comp;
    if(strcmp(litaC_comp->type, "if") == 0 || strcmp(litaC_comp->type, "elseif") == 0 || strcmp(litaC_comp->type, "else") == 0) {
        {
            if(strcmp(litaC_comp->type, "else") == 0 || litaC_preprocessor__Preprocessor_eval(litaC_this, litaC_comp)) {
                {
                    litaC_comp->evaluatedStmt = litaC_ast_new__NewBlockStmt(litaC_comp->stmt.node.startPos, litaC_comp->stmt.node.endPos, litaC_comp->body, litaC_this->lita->allocator);
                    
                    
                }
                
            } else {
                if(litaC_comp->end) {
                    {
                        litaC_comp->evaluatedStmt = litaC_preprocessor__Preprocessor_evaluateForFunction(litaC_this, litaC_checker, litaC_comp->end);
                        
                        
                    }
                    
                } 
                
            } 
            
            
            
        }
        
    } 
    
    if(!(litaC_comp->evaluatedStmt)) {
        {
            litaC_comp->evaluatedStmt = litaC_ast_new__NewEmptyStmt(litaC_comp->stmt.node.startPos, litaC_comp->stmt.node.endPos, litaC_this->lita->allocator);
            
            
        }
        
    } 
    
    return litaC_comp->evaluatedStmt;
    
    
}

ape_object_t litaC_preprocessor__ApeGetTypeKind(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    if(!(APE_CHECK_ARGS(litaC_ape, litaC_true, litaC_argc, litaC_args, APE_OBJECT_STRING))) {
        {
            litaC_preprocessor__CallContext_logErrors(litaC_context);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_element = (const litaC_char*)ape_object_get_string(litaC_args[0]);
    if(!(litaC_element)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty symbol name");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_symbols__Symbol* litaC_symbol = litaC_symbols__Scope_lookup(litaC_context->checker->current->currentScope, litaC_element);
    if(!(litaC_symbol)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "no symbol found for '%s'", litaC_element);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    return ape_object_make_string(litaC_ape, litaC_types__TypeKindAsStr(litaC_symbol->type->kind));
    
    
}

litaC_bool litaC_preprocessor__CallContext_logErrors(litaC_preprocessor__CallContext* litaC_this) {
    if(!(ape_has_errors(litaC_this->pp->ape))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(1024, litaC_this->pp->lita->allocator);
    litaC_lex__SrcPos litaC_pos =  {
        
    };
    for(litaC_i32 litaC_i = 0;litaC_i < ape_errors_count(litaC_this->pp->ape);litaC_i += 1) {
        {
            const ape_error_t* litaC_err = ape_get_error(litaC_this->pp->ape, litaC_i);
            litaC_char* litaC_errStr = ape_error_serialize(litaC_err);
            
            litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->pp->lita->result)), litaC_pos, &((litaC_sb)));
            if(litaC_errStr) {
                free(litaC_errStr);
                
            } 
            ;
            
            
        }
    }
    return litaC_true;
    
    
}

litaC_void litaC_preprocessor__Preprocessor_preResolveSymbols(litaC_preprocessor__Preprocessor* litaC_this,litaC_checker__TypeChecker* litaC_checker) {
    litaC_this->callContext.checker = litaC_checker;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_CompStmt_ce_(&((litaC_this->preCheckers)));litaC_i += 1) {
        {
            litaC_ast__CompStmt* litaC_comp = litaC_array__Array_get_cb__ptr_CompStmt_ce_(&((litaC_this->preCheckers)), litaC_i);
            litaC_this->callContext.comp = litaC_comp;
            litaC_preprocessor__Preprocessor_eval(litaC_this, litaC_comp);
            
            
        }
    }
    
}

litaC_void litaC_preprocessor__Preprocessor_addNotes(litaC_preprocessor__Preprocessor* litaC_this,ape_object_t litaC_obj,litaC_ast__Attributes* litaC_attributes) {
    if(litaC_array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_attributes->notes)))) {
        {
            ape_object_t litaC_notesArray = ape_object_make_array(litaC_this->ape);
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_attributes->notes)));litaC_i += 1) {
                {
                    litaC_ast__NoteStmt* litaC_note = litaC_array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_attributes->notes)), litaC_i);
                    ape_object_t litaC_noteObj = ape_object_make_map(litaC_this->ape);
                    ape_object_t litaC_name = ape_object_make_stringf(litaC_this->ape, "%.*s", litaC_note->name.value.str.length, litaC_note->name.value.str.buffer);
                    ape_object_set_map_value(litaC_noteObj, "name", litaC_name);
                    if(litaC_array__Array_size_cb_Token_ce_(&((litaC_note->attributes)))) {
                        {
                            ape_object_t litaC_attributesArray = ape_object_make_array(litaC_this->ape);
                            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_Token_ce_(&((litaC_note->attributes)));litaC_i += 1) {
                                {
                                    litaC_lex__Token litaC_attr = litaC_array__Array_get_cb_Token_ce_(&((litaC_note->attributes)), litaC_i);
                                    ape_object_t litaC_attrObj = ape_object_make_map(litaC_this->ape);
                                    ape_object_t litaC_name = ape_object_make_stringf(litaC_this->ape, "%.*s", litaC_attr.value.str.length, litaC_attr.value.str.buffer);
                                    ape_object_set_map_value(litaC_attrObj, "name", litaC_name);
                                    ape_object_add_array_value(litaC_attributesArray, litaC_attrObj);
                                    
                                    
                                }
                            }
                            ape_object_set_map_value(litaC_noteObj, "attributes", litaC_attributesArray);
                            
                            
                        }
                        
                    } 
                    
                    ape_object_add_array_value(litaC_notesArray, litaC_noteObj);
                    
                    
                }
            }
            ape_object_set_map_value(litaC_obj, "notes", litaC_notesArray);
            
            
        }
        
    } 
    
    
}

ape_object_t litaC_preprocessor__Preprocessor_declToApe(litaC_preprocessor__Preprocessor* litaC_this,litaC_symbols__Symbol* litaC_sym) {
    ape_object_t litaC_declObj = ape_object_make_map(litaC_this->ape);
    ape_object_set_map_string(litaC_declObj, "name", litaC_sym->name);
    ape_object_set_map_string(litaC_declObj, "kind", litaC_ast__StmtKindAsStr(litaC_sym->decl->stmt.node.kind));
    ape_object_set_map_string(litaC_declObj, "moduleFilename", litaC_sym->declared->id.filename);
    ape_object_set_map_value(litaC_declObj, "moduleName", ape_object_make_stringf(litaC_this->ape, "%.*s", litaC_sym->declared->id.name.length, litaC_sym->declared->id.name.buffer));
    ape_object_set_map_value(litaC_declObj, "isPublic", ape_object_make_bool(litaC_sym->decl->attributes.isPublic));
    ape_object_set_map_value(litaC_declObj, "isGlobal", ape_object_make_bool(litaC_sym->decl->attributes.isGlobal));
    ape_object_set_map_value(litaC_declObj, "declPtr", ape_object_make_external(litaC_this->ape, litaC_sym->decl));
    litaC_preprocessor__Preprocessor_addNotes(litaC_this, litaC_declObj, &((litaC_sym->decl->attributes)));
    switch(litaC_sym->decl->stmt.node.kind) {
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TRAIT_DECL: 
        case litaC_ast__StmtKind_UNION_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: {
            {
                ape_object_t litaC_aggObj = ape_object_make_map(litaC_this->ape);
                if(litaC_ast__StmtKind_UNION_DECL == litaC_sym->decl->stmt.node.kind) {
                    {
                        ape_object_set_map_value(litaC_declObj, "unionDecl", litaC_aggObj);
                        
                        
                    }
                    
                } else {
                    if(litaC_ast__StmtKind_TRAIT_DECL == litaC_sym->decl->stmt.node.kind) {
                        {
                            ape_object_set_map_value(litaC_declObj, "traitDecl", litaC_aggObj);
                            
                            
                        }
                        
                    } else {
                        {
                            ape_object_set_map_value(litaC_declObj, "structDecl", litaC_aggObj);
                            
                            
                        }
                    } 
                    
                } 
                
                ape_object_t litaC_fieldsArray = ape_object_make_array(litaC_this->ape);
                litaC_ast__AggregateDecl* litaC_aggDecl = (litaC_ast__AggregateDecl*)litaC_sym->decl;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_aggDecl->fields)));litaC_i += 1) {
                    {
                        litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_aggDecl->fields)), litaC_i);
                        ape_object_t litaC_fieldObj = ape_object_make_map(litaC_this->ape);
                        switch(litaC_field.kind) {
                            case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                                {
                                    litaC_ast__TraitFieldDecl* litaC_varField = litaC_field.traitField;
                                    ape_object_t litaC_name = ape_object_make_stringf(litaC_this->ape, "%.*s", litaC_varField->decl.name.value.str.length, litaC_varField->decl.name.value.str.buffer);
                                    ape_object_set_map_value(litaC_fieldObj, "name", litaC_name);
                                    litaC_preprocessor__Preprocessor_addNotes(litaC_this, litaC_fieldObj, &((litaC_varField->decl.attributes)));
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                                {
                                    litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                                    ape_object_t litaC_name = ape_object_make_stringf(litaC_this->ape, "%.*s", litaC_varField->decl.name.value.str.length, litaC_varField->decl.name.value.str.buffer);
                                    ape_object_set_map_value(litaC_fieldObj, "name", litaC_name);
                                    litaC_preprocessor__Preprocessor_addNotes(litaC_this, litaC_fieldObj, &((litaC_varField->decl.attributes)));
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                                {
                                    litaC_ast__EnumDecl* litaC_enumField = litaC_field.enumField;
                                    ape_object_t litaC_name = ape_object_make_stringf(litaC_this->ape, "%.*s", litaC_enumField->decl.name.value.str.length, litaC_enumField->decl.name.value.str.buffer);
                                    ape_object_set_map_value(litaC_fieldObj, "name", litaC_name);
                                    litaC_preprocessor__Preprocessor_addNotes(litaC_this, litaC_fieldObj, &((litaC_enumField->decl.attributes)));
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                            case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                                {
                                    litaC_ast__AggregateDecl* litaC_aggregateField = litaC_field.aggregateField;
                                    ape_object_t litaC_name = ape_object_make_stringf(litaC_this->ape, "%.*s", litaC_aggregateField->decl.declaration.name.value.str.length, litaC_aggregateField->decl.declaration.name.value.str.buffer);
                                    ape_object_set_map_value(litaC_fieldObj, "name", litaC_name);
                                    litaC_preprocessor__Preprocessor_addNotes(litaC_this, litaC_fieldObj, &((litaC_aggregateField->decl.declaration.attributes)));
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            default: {
                                break;
                                
                                
                            }
                        }
                        ape_object_add_array_value(litaC_fieldsArray, litaC_fieldObj);
                        
                        
                    }
                }
                ape_object_set_map_value(litaC_aggObj, "fields", litaC_fieldsArray);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_DECL: {
            {
                ape_object_t litaC_enumObj = ape_object_make_map(litaC_this->ape);
                ape_object_set_map_value(litaC_declObj, "enumDecl", litaC_enumObj);
                ape_object_t litaC_fieldsArray = ape_object_make_array(litaC_this->ape);
                litaC_ast__EnumDecl* litaC_enumDecl = (litaC_ast__EnumDecl*)litaC_sym->decl;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_enumDecl->fields)));litaC_i += 1) {
                    {
                        litaC_ast__EnumFieldEntryDecl* litaC_field = litaC_array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_enumDecl->fields)), litaC_i);
                        ape_object_t litaC_fieldObj = ape_object_make_map(litaC_this->ape);
                        ape_object_t litaC_name = ape_object_make_stringf(litaC_this->ape, "%.*s", litaC_field->decl.name.value.str.length, litaC_field->decl.name.value.str.buffer);
                        ape_object_set_map_value(litaC_fieldObj, "name", litaC_name);
                        litaC_preprocessor__Preprocessor_addNotes(litaC_this, litaC_fieldObj, &((litaC_field->decl.attributes)));
                        ape_object_add_array_value(litaC_fieldsArray, litaC_fieldObj);
                        
                        
                    }
                }
                ape_object_set_map_value(litaC_enumObj, "fields", litaC_fieldsArray);
                break;
                
                
            }
            
            
        }
        default: {
            {
                break;
                
                
            }
            
            
        }
    }
    return litaC_declObj;
    
    
}


litaC_void litaC_preprocessor__CallContext_preprocessCall(litaC_preprocessor__CallContext* litaC_this,litaC_ast__ModuleStmt* litaC_moduleStmt,litaC_ast__CompStmt* litaC_comp) {
    litaC_preprocessor__Preprocessor_eval(litaC_this->pp, litaC_comp);
    litaC_string_view__StringView litaC_original = litaC_string_view__StringViewInit(litaC_this->buffer.buffer, litaC_this->buffer.length);
    litaC_string_view__StringView litaC_emitCode = litaC_string_view__StringView_copy(litaC_original, litaC_this->pp->lita->allocator);
    litaC_parser__Parser litaC_parser = litaC_parser__ParserInit(litaC_moduleStmt->stmt.node.startPos.filename, litaC_emitCode.buffer, litaC_this->pp->lita);
    litaC_ast__ModuleStmt* litaC_stmts = litaC_parser__Parser_parseModule(&((litaC_parser)));
    if(litaC_stmts) {
        {
            if(litaC_array__Array_size_cb__ptr_ImportDecl_ce_(&((litaC_stmts->imports)))) {
                {
                    litaC_array__Array_addAll_cb__ptr_ImportDecl_ce_(&((litaC_moduleStmt->imports)), &((litaC_stmts->imports)));
                    
                    
                }
                
            } 
            
            if(litaC_array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_stmts->notes)))) {
                {
                    litaC_array__Array_addAll_cb__ptr_NoteStmt_ce_(&((litaC_moduleStmt->notes)), &((litaC_stmts->notes)));
                    
                    
                }
                
            } 
            
            if(litaC_array__Array_size_cb__ptr_Decl_ce_(&((litaC_stmts->declarations)))) {
                {
                    litaC_array__Array_addAll_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), &((litaC_stmts->declarations)));
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    
}

ape_object_t litaC_preprocessor__ApeEmit(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    litaC_i32 litaC_argIndex = 1;
    const litaC_char* litaC_element = (const litaC_char*)ape_object_get_string(litaC_args[0]);
    if(litaC_element) {
        {
            const litaC_char* litaC_str = litaC_element;
            while(*(litaC_str)) {
                {
                    litaC_char litaC_c = *(litaC_str);
                    if(litaC_c == '%') {
                        {
                            if(litaC_str[1] == '%') {
                                {
                                    litaC_string_buffer__StringBuffer_append(&((litaC_context->buffer)), "%s", "%");
                                    
                                    
                                }
                                
                            } else {
                                {
                                    if(litaC_argIndex >= litaC_argc) {
                                        {
                                            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid argument index, there are more format parameters than supplied function arguments");
                                            return ape_object_make_null();
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    if(litaC_str[1] == 's') {
                                        {
                                            const litaC_char* litaC_arg = (const litaC_char*)ape_object_get_string(litaC_args[litaC_argIndex]);
                                            litaC_string_buffer__StringBuffer_append(&((litaC_context->buffer)), "%s", litaC_arg);
                                            
                                            
                                        }
                                        
                                    } else {
                                        if(litaC_str[1] == 'f') {
                                            {
                                                litaC_f64 litaC_arg = (litaC_f64)ape_object_get_number(litaC_args[litaC_argIndex]);
                                                litaC_string_buffer__StringBuffer_append(&((litaC_context->buffer)), "%f", litaC_arg);
                                                
                                                
                                            }
                                            
                                        } else {
                                            if(litaC_str[1] == 'd') {
                                                {
                                                    litaC_i64 litaC_arg = (litaC_i64)ape_object_get_number(litaC_args[litaC_argIndex]);
                                                    litaC_string_buffer__StringBuffer_append(&((litaC_context->buffer)), "%d", litaC_arg);
                                                    
                                                    
                                                }
                                                
                                            } else {
                                                if(litaC_str[1] == 'b') {
                                                    {
                                                        litaC_bool litaC_arg = (litaC_bool)ape_object_get_bool(litaC_args[litaC_argIndex]);
                                                        litaC_string_buffer__StringBuffer_append(&((litaC_context->buffer)), "%s", (litaC_arg) ? "true" : "false");
                                                        
                                                        
                                                    }
                                                    
                                                } else {
                                                    {
                                                        litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid format parameter: '%%%c'", litaC_str[1]);
                                                        return ape_object_make_null();
                                                        
                                                        
                                                        
                                                    }
                                                } 
                                                
                                            } 
                                            
                                        } 
                                        
                                    } 
                                    
                                    litaC_argIndex += 1;
                                    litaC_str += 2;
                                    continue;
                                    
                                    
                                }
                            } 
                            
                            
                            
                        }
                        
                    } else {
                        if(litaC_c == '\\') {
                            {
                                litaC_string_buffer__StringBuffer_append(&((litaC_context->buffer)), "\\\\");
                                
                                
                            }
                            
                        } 
                        
                    } 
                    
                    litaC_string_buffer__StringBuffer_append(&((litaC_context->buffer)), "%c", litaC_c);
                    litaC_str += 1;
                    
                    
                }
            }
            
            
        }
        
    } 
    
    return ape_object_make_null();
    
    
}

ape_object_t litaC_preprocessor__ApeEmitClear(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    litaC_string_buffer__StringBuffer_clear(&((litaC_context->buffer)));
    return ape_object_make_null();
    
    
}

ape_object_t litaC_preprocessor__ApeEmitStr(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    return ape_object_make_string(litaC_ape, litaC_string_buffer__StringBuffer_cStr(&((litaC_context->buffer))));
    
    
}

ape_object_t litaC_preprocessor__ApeGetSymbolsWithNote(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    if(!(APE_CHECK_ARGS(litaC_ape, litaC_true, litaC_argc, litaC_args, APE_OBJECT_STRING))) {
        {
            litaC_preprocessor__CallContext_logErrors(litaC_context);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_element = (const litaC_char*)ape_object_get_string(litaC_args[0]);
    if(!(litaC_element)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty note name");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    ape_object_t litaC_results = ape_object_make_array(litaC_ape);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_context->checker->symbolFuncs)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_context->checker->symbolFuncs)), litaC_i);
            if(litaC_ast__Decl_hasNote(litaC_sym->decl, litaC_element)) {
                {
                    ape_object_t litaC_declObj = litaC_preprocessor__Preprocessor_declToApe(litaC_context->pp, litaC_sym);
                    ape_object_add_array_value(litaC_results, litaC_declObj);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_context->checker->symbolTypes)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_context->checker->symbolTypes)), litaC_i);
            if(litaC_ast__Decl_hasNote(litaC_sym->decl, litaC_element)) {
                {
                    ape_object_t litaC_declObj = litaC_preprocessor__Preprocessor_declToApe(litaC_context->pp, litaC_sym);
                    ape_object_add_array_value(litaC_results, litaC_declObj);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_results;
    
    
}

ape_object_t litaC_preprocessor__ApeAddDeclaration(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    if(!(APE_CHECK_ARGS(litaC_ape, litaC_true, litaC_argc, litaC_args, APE_OBJECT_STRING, APE_OBJECT_STRING))) {
        {
            litaC_preprocessor__CallContext_logErrors(litaC_context);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_moduleName = (const litaC_char*)ape_object_get_string(litaC_args[0]);
    if(!(litaC_moduleName)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty module filename");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_code = (const litaC_char*)ape_object_get_string(litaC_args[1]);
    if(!(litaC_code)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty code buffer");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_module__Module* litaC_module = litaC_map__Map_get_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_context->pp->lita->modules)), litaC_moduleName);
    if(!(litaC_module)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid module: '%s'", litaC_moduleName);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_ast__ModuleStmt* litaC_moduleStmt = litaC_module->ast;
    litaC_string_view__StringView litaC_original = litaC_string_view__StringViewInit(litaC_code, -(1));
    litaC_string_view__StringView litaC_emitCode = litaC_string_view__StringView_copy(litaC_original, litaC_context->pp->lita->allocator);
    litaC_parser__Parser litaC_parser = litaC_parser__ParserInit(litaC_moduleStmt->stmt.node.startPos.filename, litaC_emitCode.buffer, litaC_context->pp->lita);
    litaC_ast__ModuleStmt* litaC_stmts = litaC_parser__Parser_parseModule(&((litaC_parser)));
    if(litaC_stmts) {
        {
            if(litaC_array__Array_size_cb__ptr_ImportDecl_ce_(&((litaC_stmts->imports)))) {
                {
                    litaC_array__Array_addAll_cb__ptr_ImportDecl_ce_(&((litaC_moduleStmt->imports)), &((litaC_stmts->imports)));
                    
                    
                }
                
            } 
            
            if(litaC_array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_stmts->notes)))) {
                {
                    litaC_array__Array_addAll_cb__ptr_NoteStmt_ce_(&((litaC_moduleStmt->notes)), &((litaC_stmts->notes)));
                    
                    
                }
                
            } 
            
            if(litaC_array__Array_size_cb__ptr_Decl_ce_(&((litaC_stmts->declarations)))) {
                {
                    litaC_array__Array_addAll_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), &((litaC_stmts->declarations)));
                    litaC_checker__TypeChecker_enterModule(litaC_context->checker, litaC_module);
                    
                    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Decl_ce_(&((litaC_stmts->declarations)));litaC_i += 1) {
                        {
                            litaC_ast__Decl* litaC_decl = litaC_array__Array_get_cb__ptr_Decl_ce_(&((litaC_stmts->declarations)), litaC_i);
                            litaC_symbols__Symbol* litaC_sym = litaC_checker__TypeChecker_createDeclSymbol(litaC_context->checker, litaC_decl);
                            if(litaC_sym) {
                                {
                                    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_ModuleImport_ce_(&((litaC_module->importedBy)));litaC_i += 1) {
                                        {
                                            litaC_module__ModuleImport litaC_imp = litaC_array__Array_get_cb_ModuleImport_ce_(&((litaC_module->importedBy)), litaC_i);
                                            litaC_module__Module_importModuleSymbol(litaC_imp.module, litaC_module, litaC_imp.alias, litaC_sym, litaC_sym->name, litaC_imp.isUsing);
                                            
                                            
                                        }
                                    }
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                    }
                    litaC_checker__TypeChecker_leaveModule(litaC_context->checker);
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    return ape_object_make_bool(litaC_true);
    
    
}

ape_object_t litaC_preprocessor__ApeReplaceDeclaration(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    if(!(APE_CHECK_ARGS(litaC_ape, litaC_true, litaC_argc, litaC_args, APE_OBJECT_STRING, APE_OBJECT_STRING))) {
        {
            litaC_preprocessor__CallContext_logErrors(litaC_context);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_moduleName = (const litaC_char*)ape_object_get_string(litaC_args[0]);
    if(!(litaC_moduleName)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty module filename");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_code = (const litaC_char*)ape_object_get_string(litaC_args[1]);
    if(!(litaC_code)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty code buffer");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_module__Module* litaC_module = litaC_map__Map_get_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_context->pp->lita->modules)), litaC_moduleName);
    if(!(litaC_module)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid module: '%s'", litaC_moduleName);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_ast__ModuleStmt* litaC_moduleStmt = litaC_module->ast;
    litaC_string_view__StringView litaC_original = litaC_string_view__StringViewInit(litaC_code, -(1));
    litaC_string_view__StringView litaC_emitCode = litaC_string_view__StringView_copy(litaC_original, litaC_context->pp->lita->allocator);
    litaC_parser__Parser litaC_parser = litaC_parser__ParserInit(litaC_moduleStmt->stmt.node.startPos.filename, litaC_emitCode.buffer, litaC_context->pp->lita);
    litaC_ast__ModuleStmt* litaC_stmts = litaC_parser__Parser_parseModule(&((litaC_parser)));
    if(litaC_stmts) {
        {
            if(litaC_array__Array_size_cb__ptr_Decl_ce_(&((litaC_stmts->declarations)))) {
                {
                    litaC_array__Array_addAll_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), &((litaC_stmts->declarations)));
                    litaC_checker__TypeChecker_enterModule(litaC_context->checker, litaC_module);
                    
                    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Decl_ce_(&((litaC_stmts->declarations)));litaC_i += 1) {
                        {
                            litaC_ast__Decl* litaC_decl = litaC_array__Array_get_cb__ptr_Decl_ce_(&((litaC_stmts->declarations)), litaC_i);
                            litaC_symbols__Symbol* litaC_sym = litaC_checker__TypeChecker_getTypeByName(litaC_context->checker, litaC_lex__Token_asString(&((litaC_decl->name))));
                            if(!(litaC_sym)) {
                                {
                                    litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "symbol '%s' not found for replacement", litaC_lex__Token_asString(&((litaC_decl->name))));
                                    {
                                        ape_object_t ___result = ape_object_make_null();
                                        litaC_checker__TypeChecker_leaveModule(litaC_context->checker);
                                        return ___result;
                                        
                                    }
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_sym->decl = litaC_decl;
                            litaC_decl->sym = litaC_sym;
                            
                            
                        }
                    }
                    litaC_checker__TypeChecker_leaveModule(litaC_context->checker);
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    return ape_object_make_bool(litaC_true);
    
    
}

ape_object_t litaC_preprocessor__ApeGetInputModuleFilename(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    litaC_char* litaC_moduleFilename = litaC_context->pp->lita->options->inputFile;
    litaC_module__Module* litaC_mainModule = litaC_map__Map_get_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_context->pp->lita->modules)), litaC_moduleFilename);
    if(!(litaC_mainModule)) {
        {
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    return ape_object_make_string(litaC_ape, litaC_moduleFilename);
    
    
}

ape_object_t litaC_preprocessor__ApeGetCurrentModuleFilename(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    const litaC_char* litaC_moduleFilename = litaC_context->comp->stmt.node.startPos.filename;
    litaC_module__Module* litaC_mainModule = litaC_map__Map_get_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_context->pp->lita->modules)), litaC_moduleFilename);
    if(!(litaC_mainModule)) {
        {
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    return ape_object_make_string(litaC_ape, litaC_moduleFilename);
    
    
}

ape_object_t litaC_preprocessor__ApeGetMainSymbol(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    litaC_symbols__Symbol* litaC_mainEntry = litaC_context->checker->mainEntry;
    if(!(litaC_mainEntry)) {
        {
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    return litaC_preprocessor__Preprocessor_declToApe(litaC_context->pp, litaC_mainEntry);
    
    
}

ape_object_t litaC_preprocessor__ApeAstInsert(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    if(!(APE_CHECK_ARGS(litaC_ape, litaC_true, litaC_argc, litaC_args, APE_OBJECT_EXTERNAL, APE_OBJECT_STRING, APE_OBJECT_NUMBER))) {
        {
            litaC_preprocessor__CallContext_logErrors(litaC_context);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_void* litaC_astPtr = ape_object_get_external(litaC_args[0]);
    if(!(litaC_astPtr)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty ast node");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_code = (const litaC_char*)ape_object_get_string(litaC_args[1]);
    if(!(litaC_code)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty code buffer");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_index = (litaC_i32)ape_object_get_number(litaC_args[2]);
    litaC_ast__Node* litaC_astNode = (litaC_ast__Node*)litaC_astPtr;
    litaC_parser__Parser litaC_parser = litaC_parser__ParserInit(litaC_astNode->startPos.filename, litaC_code, litaC_context->pp->lita);
    litaC_ast__Stmt* litaC_stmt = litaC_parser__Parser_statement(&((litaC_parser)));
    litaC_ast_copy__AstInsert(litaC_astNode, litaC_stmt, litaC_index, litaC_context->pp->lita->allocator);
    return ape_object_make_null();
    
    
}

ape_object_t litaC_preprocessor__ApeAddImport(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    if(!(APE_CHECK_ARGS(litaC_ape, litaC_true, litaC_argc, litaC_args, APE_OBJECT_STRING, APE_OBJECT_STRING))) {
        {
            litaC_preprocessor__CallContext_logErrors(litaC_context);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_moduleName = (const litaC_char*)ape_object_get_string(litaC_args[0]);
    if(!(litaC_moduleName)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty module filename");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_module__Module* litaC_module = litaC_map__Map_get_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_context->pp->lita->modules)), litaC_moduleName);
    if(!(litaC_module)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid module: '%s'", litaC_moduleName);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_moduleToImport = (const litaC_char*)ape_object_get_string(litaC_args[1]);
    if(!(litaC_moduleToImport)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty module to import name");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    if(strcmp(litaC_moduleName, litaC_moduleToImport) == 0) {
        {
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_module__Module* litaC_importModule = litaC_map__Map_get_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_context->pp->lita->modules)), litaC_moduleToImport);
    if(!(litaC_importModule)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid module: '%s'", litaC_moduleToImport);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_alias = litaC_ast_copy__AstAddImport(litaC_context->pp->lita, litaC_context->checker, litaC_module, litaC_importModule);
    if(!(litaC_alias)) {
        {
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    return ape_object_make_string(litaC_ape, litaC_alias);
    
    
}

ape_object_t litaC_preprocessor__ApeSetMainSymbol(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    if(!(APE_CHECK_ARGS(litaC_ape, litaC_true, litaC_argc, litaC_args, APE_OBJECT_STRING, APE_OBJECT_STRING))) {
        {
            litaC_preprocessor__CallContext_logErrors(litaC_context);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_moduleName = (const litaC_char*)ape_object_get_string(litaC_args[0]);
    if(!(litaC_moduleName)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty module filename");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_module__Module* litaC_module = litaC_map__Map_get_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_context->pp->lita->modules)), litaC_moduleName);
    if(!(litaC_module)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid module: '%s'", litaC_moduleName);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_symbolName = (const litaC_char*)ape_object_get_string(litaC_args[1]);
    if(!(litaC_symbolName)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty symbol name");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_symbols__Symbol* litaC_sym = litaC_module__Module_getType(litaC_module, litaC_symbolName);
    if(!(litaC_sym)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "can not find symbol '%s' in module: '%s'", litaC_symbolName, litaC_moduleName);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    if(litaC_sym->kind != litaC_symbols__SymbolKind_FUNC) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "can not make symbol '%s' a main entry point because it isn't a function", litaC_symbolName);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_context->checker->mainEntry = litaC_sym;
    return ape_object_make_bool(litaC_true);
    
    
}

ape_object_t litaC_preprocessor__ApeGetSymbolsToTest(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    ape_object_t litaC_results = ape_object_make_array(litaC_ape);
    if(!(litaC_context->pp->lita->options->testsOnly)) {
        {
            return litaC_results;
            
            
            
        }
        
    } 
    
    if(litaC_context->pp->lita->options->testsRegex) {
        {
            litaC_bool litaC_all = strcmp(litaC_context->pp->lita->options->testsRegex, ".*") == 0;
            litaC_regex__Regex litaC_pattern = litaC_regex__RegexCompile(litaC_context->pp->lita->options->testsRegex);
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_context->checker->symbolFuncs)));litaC_i += 1) {
                {
                    litaC_symbols__Symbol* litaC_sym = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_context->checker->symbolFuncs)), litaC_i);
                    if(litaC_sym->kind == litaC_symbols__SymbolKind_FUNC && litaC_ast__Decl_hasNote(litaC_sym->decl, "test")) {
                        {
                            if(litaC_all) {
                                {
                                    ape_object_t litaC_declObj = litaC_preprocessor__Preprocessor_declToApe(litaC_context->pp, litaC_sym);
                                    ape_object_add_array_value(litaC_results, litaC_declObj);
                                    
                                    
                                }
                                
                            } else {
                                {
                                    litaC_ast__NoteStmt* litaC_note = litaC_ast__Decl_getNote(litaC_sym->decl, "test");
                                    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_Token_ce_(&((litaC_note->attributes)));litaC_i += 1) {
                                        {
                                            litaC_lex__Token litaC_att = litaC_array__Array_get_cb_Token_ce_(&((litaC_note->attributes)), litaC_i);
                                            litaC_i32 litaC_matchlength = 0;
                                            if(litaC_regex__Regex_match(&((litaC_pattern)), litaC_lex__Token_asString(&((litaC_att))), &(litaC_matchlength)) > -(1)) {
                                                {
                                                    ape_object_t litaC_declObj = litaC_preprocessor__Preprocessor_declToApe(litaC_context->pp, litaC_sym);
                                                    ape_object_add_array_value(litaC_results, litaC_declObj);
                                                    break;
                                                    
                                                    
                                                }
                                                
                                            } 
                                            
                                            
                                            
                                        }
                                    }
                                    
                                    
                                }
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } else {
        {
            litaC_char* litaC_moduleName = litaC_context->pp->lita->options->inputFile;
            litaC_module__Module* litaC_mainModule = litaC_map__Map_get_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_context->pp->lita->modules)), litaC_moduleName);
            if(!(litaC_mainModule)) {
                {
                    return litaC_results;
                    
                    
                    
                }
                
            } 
            
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_context->checker->symbolFuncs)));litaC_i += 1) {
                {
                    litaC_symbols__Symbol* litaC_sym = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_context->checker->symbolFuncs)), litaC_i);
                    if(litaC_sym->declared == litaC_mainModule && litaC_sym->kind == litaC_symbols__SymbolKind_FUNC && litaC_ast__Decl_hasNote(litaC_sym->decl, "test")) {
                        {
                            ape_object_t litaC_declObj = litaC_preprocessor__Preprocessor_declToApe(litaC_context->pp, litaC_sym);
                            ape_object_add_array_value(litaC_results, litaC_declObj);
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
    } 
    
    return litaC_results;
    
    
}

litaC_regex__Regex litaC_regex__RegexCompile(const litaC_char* litaC_pattern) {
    litaC_regex__Regex litaC_result;
    {
        
        
    }
    litaC_result.reg = re_compile(litaC_pattern);
    return litaC_result;
    
    
}

litaC_i32 litaC_regex__Regex_match(litaC_regex__Regex* litaC_this,const litaC_char* litaC_text,litaC_i32* litaC_matchlength) {
    return re_matchp(litaC_this->reg, litaC_text, litaC_matchlength);
    
    
}

litaC_i32 litaC_regex__RegexMatch(const litaC_char* litaC_pattern,const litaC_char* litaC_text,litaC_i32* litaC_matchlength) {
    return re_match(litaC_pattern, litaC_text, litaC_matchlength);
    
    
}

const litaC_char* litaC_ast_copy__NewTokenName(litaC_lex__Token litaC_token,const litaC_mem__Allocator* litaC_allocator) {
    if(litaC_token.type != litaC_lex__TokenType_IDENTIFIER && litaC_token.type != litaC_lex__TokenType_STRING) {
        {
            return litaC_lex__tokenText[litaC_token.type];
            
            
            
        }
        
    } 
    
    litaC_char* litaC_bytes = (litaC_char*)litaC_mem__Allocator_alloc(litaC_allocator, litaC_token.value.str.length + 1);
    litaC_string_view__StringView_copyTo(litaC_token.value.str, litaC_bytes, litaC_token.value.str.length, litaC_true);
    return litaC_bytes;
    
    
}

litaC_array__Array_cb__ptr_TypeSpec_ce_ litaC_ast_copy__CopyTypeSpecs(litaC_array__Array_cb__ptr_TypeSpec_ce_ litaC_specs,const litaC_mem__Allocator* litaC_allocator) {
    if(litaC_array__Array_empty_cb__ptr_TypeSpec_ce_(&((litaC_specs)))) {
        {
            return (litaC_array__Array_cb__ptr_TypeSpec_ce_) {
                0
            };
            
            
            
        }
        
    } 
    
    litaC_array__Array_cb__ptr_TypeSpec_ce_ litaC_result =  {
        
    };
    litaC_array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_result)), litaC_array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_specs))), litaC_allocator);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_specs)));litaC_i += 1) {
        {
            litaC_ast__TypeSpec* litaC_spec = litaC_array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_specs)), litaC_i);
            litaC_array__Array_add_cb__ptr_TypeSpec_ce_(&((litaC_result)), litaC_ast_copy__CopyTypeSpec(litaC_spec, litaC_allocator));
            
            
        }
    }
    return litaC_result;
    
    
}

litaC_ast__TypeSpec* litaC_ast_copy__CopyTypeSpec(litaC_ast__TypeSpec* litaC_spec,const litaC_mem__Allocator* litaC_allocator) {
    if(litaC_spec == NULL) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_ast__TypeSpec* litaC_copy = litaC_ast_new__NewTypeSpec(litaC_spec->kind, litaC_spec->pos, litaC_allocator);
    litaC_copy->base = litaC_ast_copy__CopyTypeSpec(litaC_spec->base, litaC_allocator);
    switch(litaC_spec->kind) {
        case litaC_ast__TypeSpecKind_NONE: {
            {
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_ARRAY: {
            {
                litaC_ast__ArrayTypeSpec* litaC_originalArray = (litaC_ast__ArrayTypeSpec*)litaC_spec;
                litaC_ast__ArrayTypeSpec* litaC_copyArray = (litaC_ast__ArrayTypeSpec*)litaC_copy;
                if(litaC_originalArray->numElements) {
                    {
                        litaC_copyArray->numElements = litaC_ast_copy__CopyExpr(litaC_originalArray->numElements, litaC_allocator);
                        
                        
                    }
                    
                } 
                
                return (litaC_ast__TypeSpec*)litaC_copyArray;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_PTR: 
        case litaC_ast__TypeSpecKind_CONST: {
            {
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_NAME: {
            {
                litaC_ast__NameTypeSpec* litaC_originalName = (litaC_ast__NameTypeSpec*)litaC_spec;
                litaC_ast__NameTypeSpec* litaC_copyName = (litaC_ast__NameTypeSpec*)litaC_copy;
                litaC_copyName->name = litaC_originalName->name;
                litaC_copyName->genericArgs = litaC_ast_copy__CopyTypeSpecs(litaC_originalName->genericArgs, litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_FUNC_PTR: {
            {
                litaC_ast__FuncPtrTypeSpec* litaC_original = (litaC_ast__FuncPtrTypeSpec*)litaC_spec;
                litaC_ast__FuncPtrTypeSpec* litaC_copyFunc = (litaC_ast__FuncPtrTypeSpec*)litaC_copy;
                litaC_copyFunc->args = litaC_ast_copy__CopyTypeSpecs(litaC_original->args, litaC_allocator);
                litaC_copyFunc->ret = litaC_ast_copy__CopyTypeSpec(litaC_original->ret, litaC_allocator);
                litaC_copyFunc->hasVarargs = litaC_original->hasVarargs;
                litaC_array__Array_init_cb_GenericParam_ce_(&((litaC_copyFunc->genericParams)), litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_original->genericParams))), litaC_allocator);
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_original->genericParams)));litaC_i += 1) {
                    {
                        litaC_ast__GenericParam litaC_param = litaC_array__Array_get_cb_GenericParam_ce_(&((litaC_original->genericParams)), litaC_i);
                        litaC_array__Array_add_cb_GenericParam_ce_(&((litaC_copyFunc->genericParams)), litaC_param);
                        
                        
                    }
                }
                return litaC_copy;
                
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return NULL;
    
    
}

litaC_ast__Decl* litaC_ast_copy__CopyDecl(litaC_ast__Decl* litaC_decl,const litaC_mem__Allocator* litaC_allocator) {
    if(!(litaC_decl)) {
        return NULL;
        
        
    } 
    
    switch(litaC_decl->stmt.node.kind) {
        case litaC_ast__StmtKind_IMPORT_DECL: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONST_DECL: 
        case litaC_ast__StmtKind_VAR_DECL: {
            {
                litaC_ast__VarDecl* litaC_original = (litaC_ast__VarDecl*)litaC_decl;
                litaC_ast__Decl* litaC_copy = litaC_ast_new__NewVarDecl(litaC_original->decl.stmt.node.startPos, litaC_original->decl.stmt.node.endPos, litaC_original->decl.name, litaC_ast_copy__CopyTypeSpec(litaC_original->typeSpec, litaC_allocator), litaC_ast_copy__CopyExpr(litaC_original->expr, litaC_allocator), litaC_allocator);
                if(litaC_decl->stmt.node.kind == litaC_ast__StmtKind_CONST_DECL) {
                    {
                        litaC_copy->stmt.node.kind = litaC_ast__StmtKind_CONST_DECL;
                        
                        
                    }
                    
                } 
                
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_STRUCT_DECL: 
        case litaC_ast__StmtKind_UNION_DECL: 
        case litaC_ast__StmtKind_TRAIT_DECL: {
            {
                return (litaC_ast__Decl*)litaC_ast_copy__CopyAggregateDecl((litaC_ast__AggregateDecl*)litaC_decl, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_DECL: {
            assert(litaC_false);
            
            
        }
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                return (litaC_ast__Decl*)litaC_ast_copy__CopyFuncDecl((litaC_ast__FuncDecl*)litaC_decl, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            {
                return (litaC_ast__Decl*)litaC_ast_copy__CopyTypedefDecl((litaC_ast__TypedefDecl*)litaC_decl, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_PARAM_DECL: {
            {
                litaC_ast__ParameterDecl* litaC_original = (litaC_ast__ParameterDecl*)litaC_decl;
                litaC_ast__Decl* litaC_copy = litaC_ast_new__NewParameterDecl(litaC_original->decl.stmt.node.startPos, litaC_original->decl.stmt.node.endPos, litaC_original->decl.name, litaC_ast_copy__CopyTypeSpec(litaC_original->type, litaC_allocator), litaC_ast_copy__CopyExpr(litaC_original->defaultExpr, litaC_allocator), litaC_original->decl.attributes.isUsing, litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NATIVE_DECL: {
            {
                return litaC_decl;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_DECL: {
            return litaC_decl;
            
            
            
        }
        default: {
            assert(litaC_false);
            
            
        }
    }
    return NULL;
    
    
}

litaC_array__Array_cb_CallArg_ce_ litaC_ast_copy__CopyCallArgs(litaC_array__Array_cb_CallArg_ce_* litaC_args,const litaC_mem__Allocator* litaC_allocator) {
    if(litaC_array__Array_empty_cb_CallArg_ce_(litaC_args)) {
        {
            return (litaC_array__Array_cb_CallArg_ce_) {
                
            };
            
            
            
        }
        
    } 
    
    litaC_array__Array_cb_CallArg_ce_ litaC_result = litaC_array__ArrayInit_cb_CallArg_ce_(litaC_array__Array_size_cb_CallArg_ce_(litaC_args), litaC_allocator);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_CallArg_ce_(litaC_args);litaC_i += 1) {
        {
            litaC_ast__CallArg litaC_arg = litaC_array__Array_get_cb_CallArg_ce_(litaC_args, litaC_i);
            litaC_ast__Expr* litaC_argExpr = litaC_ast_copy__CopyExpr(litaC_arg.argExpr, litaC_allocator);
            litaC_array__Array_add_cb_CallArg_ce_(&((litaC_result)), (litaC_ast__CallArg) {
                .argExpr = litaC_argExpr,
                .argName = litaC_arg.argName
            });
            
            
        }
    }
    return litaC_result;
    
    
}

litaC_array__Array_cb__ptr_Expr_ce_ litaC_ast_copy__CopyExprs(litaC_array__Array_cb__ptr_Expr_ce_* litaC_exprs,const litaC_mem__Allocator* litaC_allocator) {
    if(litaC_array__Array_empty_cb__ptr_Expr_ce_(litaC_exprs)) {
        {
            return (litaC_array__Array_cb__ptr_Expr_ce_) {
                
            };
            
            
            
        }
        
    } 
    
    litaC_array__Array_cb__ptr_Expr_ce_ litaC_result = litaC_array__ArrayInit_cb__ptr_Expr_ce_(litaC_array__Array_size_cb__ptr_Expr_ce_(litaC_exprs), litaC_allocator);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Expr_ce_(litaC_exprs);litaC_i += 1) {
        {
            litaC_ast__Expr* litaC_copy = litaC_ast_copy__CopyExpr(litaC_array__Array_get_cb__ptr_Expr_ce_(litaC_exprs, litaC_i), litaC_allocator);
            litaC_array__Array_add_cb__ptr_Expr_ce_(&((litaC_result)), litaC_copy);
            
            
        }
    }
    return litaC_result;
    
    
}

litaC_array__Array_cb__ptr_Stmt_ce_ litaC_ast_copy__CopyStmts(litaC_array__Array_cb__ptr_Stmt_ce_* litaC_stmts,const litaC_mem__Allocator* litaC_allocator) {
    if(litaC_array__Array_empty_cb__ptr_Stmt_ce_(litaC_stmts)) {
        {
            return (litaC_array__Array_cb__ptr_Stmt_ce_) {
                
            };
            
            
            
        }
        
    } 
    
    litaC_array__Array_cb__ptr_Stmt_ce_ litaC_result = litaC_array__ArrayInit_cb__ptr_Stmt_ce_(litaC_array__Array_size_cb__ptr_Stmt_ce_(litaC_stmts), litaC_allocator);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Stmt_ce_(litaC_stmts);litaC_i += 1) {
        {
            litaC_ast__Stmt* litaC_copy = litaC_ast_copy__CopyStmt(litaC_array__Array_get_cb__ptr_Stmt_ce_(litaC_stmts, litaC_i), litaC_allocator);
            litaC_array__Array_add_cb__ptr_Stmt_ce_(&((litaC_result)), litaC_copy);
            
            
        }
    }
    return litaC_result;
    
    
}

litaC_ast__Expr* litaC_ast_copy__CopyExpr(litaC_ast__Expr* litaC_expr,const litaC_mem__Allocator* litaC_allocator) {
    if(!(litaC_expr)) {
        return NULL;
        
        
    } 
    
    switch(litaC_expr->stmt.node.kind) {
        case litaC_ast__StmtKind_ARRAY_DESIGNATION_EXPR: {
            {
                litaC_ast__ArrayDesignationExpr* litaC_original = (litaC_ast__ArrayDesignationExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewArrayDesignationExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->index, litaC_allocator), litaC_ast_copy__CopyExpr(litaC_original->value, litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ARRAY_INIT_EXPR: {
            {
                litaC_ast__ArrayInitExpr* litaC_original = (litaC_ast__ArrayInitExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewArrayInitExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyTypeSpec(litaC_original->type, litaC_allocator), litaC_ast_copy__CopyExprs(&((litaC_original->values)), litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BINARY_EXPR: {
            {
                litaC_ast__BinaryExpr* litaC_original = (litaC_ast__BinaryExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewBinaryExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->left, litaC_allocator), litaC_original->operator, litaC_ast_copy__CopyExpr(litaC_original->right, litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BOOLEAN_EXPR: {
            {
                return litaC_expr;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CAST_EXPR: {
            {
                litaC_ast__CastExpr* litaC_original = (litaC_ast__CastExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewCastExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->exprToCast, litaC_allocator), litaC_ast_copy__CopyTypeSpec(litaC_original->castTo, litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CHAR_EXPR: {
            {
                return litaC_expr;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_CALL_EXPR: {
            {
                litaC_ast__FuncCallExpr* litaC_original = (litaC_ast__FuncCallExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewFuncCallExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->object, litaC_allocator), litaC_ast_copy__CopyCallArgs(&((litaC_original->arguments)), litaC_allocator), litaC_ast_copy__CopyTypeSpecs(litaC_original->genericArgs, litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR: {
            {
                litaC_ast__IdentifierExpr* litaC_original = (litaC_ast__IdentifierExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewIdentifierExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, (litaC_ast__NameTypeSpec*)litaC_ast_copy__CopyTypeSpec(&((litaC_original->type->spec)), litaC_allocator), litaC_allocator);
                litaC_copy->stmt.node.kind = litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR;
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GET_EXPR: {
            {
                litaC_ast__GetExpr* litaC_original = (litaC_ast__GetExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewGetExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->object, litaC_allocator), (litaC_ast__IdentifierExpr*)litaC_ast_copy__CopyExpr(&((litaC_original->field->expr)), litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GROUP_EXPR: {
            {
                litaC_ast__GroupExpr* litaC_original = (litaC_ast__GroupExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewGroupExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->groupedExpr, litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: {
            {
                litaC_ast__IdentifierExpr* litaC_original = (litaC_ast__IdentifierExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewIdentifierExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, (litaC_ast__NameTypeSpec*)litaC_ast_copy__CopyTypeSpec(&((litaC_original->type->spec)), litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_INIT_ARG_EXPR: {
            {
                litaC_ast__InitArgExpr* litaC_original = (litaC_ast__InitArgExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewInitArgExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_original->fieldName, litaC_original->argPosition, litaC_ast_copy__CopyExpr(litaC_original->value, litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_INIT_EXPR: {
            {
                litaC_ast__InitExpr* litaC_original = (litaC_ast__InitExpr*)litaC_expr;
                litaC_array__Array_cb__ptr_InitArgExpr_ce_ litaC_arguments =  {
                    
                };
                if(!(litaC_array__Array_empty_cb__ptr_InitArgExpr_ce_(&((litaC_original->arguments))))) {
                    {
                        litaC_array__Array_init_cb__ptr_InitArgExpr_ce_(&((litaC_arguments)), litaC_array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_original->arguments))), litaC_allocator);
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_original->arguments)));litaC_i += 1) {
                    {
                        litaC_ast__InitArgExpr* litaC_copy = (litaC_ast__InitArgExpr*)litaC_ast_copy__CopyExpr(&((litaC_array__Array_get_cb__ptr_InitArgExpr_ce_(&((litaC_original->arguments)), litaC_i)->expr)), litaC_allocator);
                        litaC_array__Array_add_cb__ptr_InitArgExpr_ce_(&((litaC_arguments)), litaC_copy);
                        
                        
                    }
                }
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewInitExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, (litaC_ast__NameTypeSpec*)litaC_ast_copy__CopyTypeSpec(&((litaC_original->type->spec)), litaC_allocator), litaC_arguments, litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NULL_EXPR: {
            {
                return litaC_expr;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NUMBER_EXPR: {
            {
                return litaC_expr;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SET_EXPR: {
            {
                litaC_ast__SetExpr* litaC_original = (litaC_ast__SetExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewSetExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->object, litaC_allocator), (litaC_ast__IdentifierExpr*)litaC_ast_copy__CopyExpr(&((litaC_original->field->expr)), litaC_allocator), litaC_original->operator, litaC_ast_copy__CopyExpr(litaC_original->value, litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_OFFSET_OF_EXPR: {
            {
                litaC_ast__OffsetOfExpr* litaC_original = (litaC_ast__OffsetOfExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewOffsetOfExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyTypeSpec(litaC_original->type, litaC_allocator), litaC_original->field, litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SIZE_OF_EXPR: {
            {
                litaC_ast__SizeOfExpr* litaC_original = (litaC_ast__SizeOfExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewSizeOfExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->sizeOfExpr, litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_STRING_EXPR: {
            {
                return litaC_expr;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_GET_EXPR: {
            {
                litaC_ast__SubscriptGetExpr* litaC_original = (litaC_ast__SubscriptGetExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewSubscriptGetExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->object, litaC_allocator), litaC_ast_copy__CopyExpr(litaC_original->index, litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_SET_EXPR: {
            {
                litaC_ast__SubscriptSetExpr* litaC_original = (litaC_ast__SubscriptSetExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewSubscriptSetExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->object, litaC_allocator), litaC_ast_copy__CopyExpr(litaC_original->index, litaC_allocator), litaC_original->operator, litaC_ast_copy__CopyExpr(litaC_original->value, litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TERNARY_EXPR: {
            {
                litaC_ast__TernaryExpr* litaC_original = (litaC_ast__TernaryExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewTernaryExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->cond, litaC_allocator), litaC_ast_copy__CopyExpr(litaC_original->then, litaC_allocator), litaC_ast_copy__CopyExpr(litaC_original->other, litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPE_IDENTIFIER_EXPR: {
            {
                litaC_ast__TypeIdentifierExpr* litaC_original = (litaC_ast__TypeIdentifierExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewTypeIdentifierExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyTypeSpec(litaC_original->type, litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPE_OF_EXPR: {
            {
                litaC_ast__TypeOfExpr* litaC_original = (litaC_ast__TypeOfExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewTypeOfExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->typeOfExpr, litaC_allocator), litaC_ast_copy__CopyTypeSpec(litaC_original->type, litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNARY_EXPR: {
            {
                litaC_ast__UnaryExpr* litaC_original = (litaC_ast__UnaryExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewUnaryExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_original->operator, litaC_ast_copy__CopyExpr(litaC_original->unaryExpr, litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_EXPR: {
            {
                return litaC_expr;
                
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return NULL;
    
    
}

litaC_ast__Stmt* litaC_ast_copy__CopyStmt(litaC_ast__Stmt* litaC_stmt,const litaC_mem__Allocator* litaC_allocator) {
    if(!(litaC_stmt)) {
        return NULL;
        
        
    } 
    
    switch(litaC_stmt->node.kind) {
        case litaC_ast__StmtKind_BLOCK_STMT: {
            {
                litaC_ast__BlockStmt* litaC_original = (litaC_ast__BlockStmt*)litaC_stmt;
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewBlockStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_ast_copy__CopyStmts(&((litaC_original->stmts)), litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BREAK_STMT: {
            {
                return litaC_stmt;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_COMP_STMT: {
            {
                litaC_ast__CompStmt* litaC_original = (litaC_ast__CompStmt*)litaC_stmt;
                litaC_ast__Stmt* litaC_end = NULL;
                if(litaC_original->end != NULL) {
                    {
                        litaC_end = &(litaC_original->end->stmt);
                        
                        
                    }
                    
                } 
                
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewCompStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_original->type, litaC_original->expr, litaC_ast_copy__CopyStmts(&((litaC_original->body)), litaC_allocator), (litaC_ast__CompStmt*)litaC_ast_copy__CopyStmt(litaC_end, litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONTINUE_STMT: {
            {
                return litaC_stmt;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DEFER_STMT: {
            {
                litaC_ast__DeferStmt* litaC_original = (litaC_ast__DeferStmt*)litaC_stmt;
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewDeferStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_ast_copy__CopyStmt(litaC_original->deferedStmt, litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DO_WHILE_STMT: {
            {
                litaC_ast__DoWhileStmt* litaC_original = (litaC_ast__DoWhileStmt*)litaC_stmt;
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewDoWhileStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->cond, litaC_allocator), litaC_ast_copy__CopyStmt(litaC_original->body, litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_EMPTY_STMT: {
            {
                return litaC_stmt;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FOR_STMT: {
            {
                litaC_ast__ForStmt* litaC_original = (litaC_ast__ForStmt*)litaC_stmt;
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewForStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_ast_copy__CopyStmt(litaC_original->init, litaC_allocator), litaC_ast_copy__CopyExpr(litaC_original->cond, litaC_allocator), litaC_ast_copy__CopyStmt(litaC_original->post, litaC_allocator), litaC_ast_copy__CopyStmt(litaC_original->body, litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_BODY_STMT: {
            {
                litaC_ast__FuncBodyStmt* litaC_original = (litaC_ast__FuncBodyStmt*)litaC_stmt;
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewBlockStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_ast_copy__CopyStmts(&((litaC_original->stmts)), litaC_allocator), litaC_allocator);
                litaC_copy->node.kind = litaC_ast__StmtKind_FUNC_BODY_STMT;
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GOTO_STMT: {
            {
                return litaC_stmt;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IF_STMT: {
            {
                litaC_ast__IfStmt* litaC_original = (litaC_ast__IfStmt*)litaC_stmt;
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewIfStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->cond, litaC_allocator), litaC_ast_copy__CopyStmt(litaC_original->then, litaC_allocator), litaC_ast_copy__CopyStmt(litaC_original->elseStmt, litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_LABEL_STMT: {
            {
                return litaC_stmt;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_MODULE_STMT: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NOTE_STMT: {
            {
                return litaC_stmt;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_PARAMETERS_STMT: {
            {
                litaC_ast__ParametersStmt* litaC_original = (litaC_ast__ParametersStmt*)litaC_stmt;
                litaC_array__Array_cb__ptr_ParameterDecl_ce_ litaC_params =  {
                    
                };
                if(!(litaC_array__Array_empty_cb__ptr_ParameterDecl_ce_(&((litaC_original->params))))) {
                    {
                        litaC_array__Array_init_cb__ptr_ParameterDecl_ce_(&((litaC_params)), litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_original->params))), litaC_allocator);
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_original->params)));litaC_i += 1) {
                    {
                        litaC_ast__ParameterDecl* litaC_copy = (litaC_ast__ParameterDecl*)litaC_ast_copy__CopyStmt(&((litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_original->params)), litaC_i)->decl.stmt)), litaC_allocator);
                        litaC_array__Array_add_cb__ptr_ParameterDecl_ce_(&((litaC_params)), litaC_copy);
                        
                        
                    }
                }
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewParametersStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_params, litaC_original->isVararg, litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_RETURN_STMT: {
            {
                litaC_ast__ReturnStmt* litaC_original = (litaC_ast__ReturnStmt*)litaC_stmt;
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewReturnStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->expr, litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SWITCH_CASE_STMT: {
            {
                litaC_ast__SwitchCaseStmt* litaC_original = (litaC_ast__SwitchCaseStmt*)litaC_stmt;
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewSwitchCaseStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->cond, litaC_allocator), litaC_ast_copy__CopyStmt(litaC_original->body, litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SWITCH_STMT: {
            {
                litaC_ast__SwitchStmt* litaC_original = (litaC_ast__SwitchStmt*)litaC_stmt;
                litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_ litaC_cases =  {
                    
                };
                if(!(litaC_array__Array_empty_cb__ptr_SwitchCaseStmt_ce_(&((litaC_original->cases))))) {
                    {
                        litaC_array__Array_init_cb__ptr_SwitchCaseStmt_ce_(&((litaC_cases)), litaC_array__Array_size_cb__ptr_SwitchCaseStmt_ce_(&((litaC_original->cases))), litaC_allocator);
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_SwitchCaseStmt_ce_(&((litaC_original->cases)));litaC_i += 1) {
                    {
                        litaC_ast__SwitchCaseStmt* litaC_copy = (litaC_ast__SwitchCaseStmt*)litaC_ast_copy__CopyStmt(&((litaC_array__Array_get_cb__ptr_SwitchCaseStmt_ce_(&((litaC_original->cases)), litaC_i)->stmt)), litaC_allocator);
                        litaC_array__Array_add_cb__ptr_SwitchCaseStmt_ce_(&((litaC_cases)), litaC_copy);
                        
                        
                    }
                }
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewSwitchStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->cond, litaC_allocator), litaC_cases, litaC_ast_copy__CopyStmt(litaC_original->defaultStmt, litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_FIELD_DECL: 
        case litaC_ast__StmtKind_ENUM_FIELD_ENTRY_DECL: 
        case litaC_ast__StmtKind_STRUCT_FIELD_DECL: 
        case litaC_ast__StmtKind_UNION_FIELD_DECL: 
        case litaC_ast__StmtKind_TRAIT_FIELD_DECL: 
        case litaC_ast__StmtKind_VAR_FIELD_DECL: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_WHILE_STMT: {
            {
                litaC_ast__WhileStmt* litaC_original = (litaC_ast__WhileStmt*)litaC_stmt;
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewWhileStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->cond, litaC_allocator), litaC_ast_copy__CopyStmt(litaC_original->body, litaC_allocator), litaC_allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        default: {
            {
                if(litaC_ast__IsExpr(&((litaC_stmt->node)))) {
                    {
                        return (litaC_ast__Stmt*)litaC_ast_copy__CopyExpr((litaC_ast__Expr*)litaC_stmt, litaC_allocator);
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_ast__IsDecl(&((litaC_stmt->node)))) {
                    {
                        return (litaC_ast__Stmt*)litaC_ast_copy__CopyDecl((litaC_ast__Decl*)litaC_stmt, litaC_allocator);
                        
                        
                        
                    }
                    
                } 
                
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return NULL;
    
    
}

litaC_ast__AggregateDecl* litaC_ast_copy__CopyAggregateDecl(litaC_ast__AggregateDecl* litaC_decl,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__AggregateDecl* litaC_copy = (litaC_ast__AggregateDecl*)litaC_ast_new__NewAggregateDecl(litaC_decl->decl.declaration.stmt.node.startPos, litaC_decl->decl.declaration.stmt.node.endPos, litaC_decl->decl.declaration.stmt.node.kind, litaC_decl->decl.declaration.name, litaC_array__Array_copy_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams)), NULL), (litaC_array__Array_cb_FieldStmt_ce_) {
        
    }, litaC_decl->flags, litaC_allocator);
    litaC_copy->decl.declaration.attributes = litaC_decl->decl.declaration.attributes;
    litaC_copy->fields = litaC_array__ArrayInit_cb_FieldStmt_ce_(litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_decl->fields))), litaC_allocator);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_decl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_decl->fields)), litaC_i);
            switch(litaC_field.kind) {
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        litaC_ast__TraitFieldDecl* litaC_o = litaC_field.traitField;
                        litaC_ast__TraitFieldDecl* litaC_traitField = (litaC_ast__TraitFieldDecl*)litaC_ast_new__NewTraitFieldDecl(litaC_o->decl.stmt.node.startPos, litaC_o->decl.stmt.node.endPos, litaC_o->decl.name, litaC_ast_copy__CopyTypeSpec(litaC_o->type, litaC_allocator), litaC_o->decl.attributes, litaC_allocator);
                        litaC_ast__FieldStmt litaC_copyField =  {
                            .kind = litaC_ast__StmtKind_TRAIT_FIELD_DECL,
                            .traitField = litaC_traitField
                        };
                        litaC_array__Array_add_cb_FieldStmt_ce_(&((litaC_copy->fields)), litaC_copyField);
                        litaC_ast__Node_becomeParentOf_cb_TraitFieldDecl_ce_(&((litaC_copy->decl.declaration.stmt.node)), litaC_traitField);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_o = litaC_field.varField;
                        litaC_ast__VarFieldDecl* litaC_varField = (litaC_ast__VarFieldDecl*)litaC_ast_new__NewVarFieldDecl(litaC_o->decl.stmt.node.startPos, litaC_o->decl.stmt.node.endPos, litaC_o->decl.name, litaC_ast_copy__CopyTypeSpec(litaC_o->type, litaC_allocator), litaC_o->decl.attributes, litaC_ast_copy__CopyExpr(litaC_o->defaultExpr, litaC_allocator), litaC_allocator);
                        litaC_ast__FieldStmt litaC_copyField =  {
                            .kind = litaC_ast__StmtKind_VAR_FIELD_DECL,
                            .varField = litaC_varField
                        };
                        litaC_array__Array_add_cb_FieldStmt_ce_(&((litaC_copy->fields)), litaC_copyField);
                        litaC_ast__Node_becomeParentOf_cb_VarFieldDecl_ce_(&((litaC_copy->decl.declaration.stmt.node)), litaC_varField);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                    {
                        litaC_ast__FieldStmt litaC_copyField =  {
                            .kind = litaC_ast__StmtKind_ENUM_FIELD_DECL,
                            .enumField = litaC_field.enumField
                        };
                        litaC_array__Array_add_cb_FieldStmt_ce_(&((litaC_copy->fields)), litaC_copyField);
                        litaC_ast__Node_becomeParentOf_cb_EnumDecl_ce_(&((litaC_copy->decl.declaration.stmt.node)), litaC_field.enumField);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                    {
                        litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                        litaC_ast__FieldStmt litaC_copyField =  {
                            .kind = litaC_field.kind,
                            .aggregateField = litaC_ast_copy__CopyAggregateDecl(litaC_aggField, litaC_allocator)
                        };
                        litaC_array__Array_add_cb_FieldStmt_ce_(&((litaC_copy->fields)), litaC_copyField);
                        litaC_ast__Node_becomeParentOf_cb_AggregateDecl_ce_(&((litaC_copy->decl.declaration.stmt.node)), litaC_copyField.aggregateField);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_POISON_EXPR: {
                    {
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        assert(litaC_false);
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    return litaC_copy;
    
    
}

litaC_ast__FuncDecl* litaC_ast_copy__CopyFuncDecl(litaC_ast__FuncDecl* litaC_decl,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__Decl* litaC_copy = litaC_ast_new__NewFuncDecl(litaC_decl->decl.declaration.stmt.node.startPos, litaC_decl->decl.declaration.stmt.node.endPos, litaC_decl->decl.declaration.name, litaC_array__Array_copy_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams)), NULL), litaC_ast_copy__CopyParameters(*((litaC_decl->params)), litaC_allocator), litaC_ast_copy__CopyStmt(litaC_decl->body, litaC_allocator), litaC_ast_copy__CopyTypeSpec(litaC_decl->returnType, litaC_allocator), litaC_decl->flags, litaC_allocator);
    litaC_copy->attributes = litaC_decl->decl.declaration.attributes;
    return (litaC_ast__FuncDecl*)litaC_copy;
    
    
}

litaC_ast__ParametersStmt* litaC_ast_copy__CopyParameters(litaC_ast__ParametersStmt litaC_params,const litaC_mem__Allocator* litaC_allocator) {
    litaC_array__Array_cb__ptr_ParameterDecl_ce_ litaC_paramDecls =  {
        
    };
    litaC_array__Array_init_cb__ptr_ParameterDecl_ce_(&((litaC_paramDecls)), litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_params.params))), litaC_allocator);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_params.params)));litaC_i += 1) {
        {
            litaC_ast__ParameterDecl* litaC_decl = litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_params.params)), litaC_i);
            litaC_ast__ParameterDecl* litaC_copy = (litaC_ast__ParameterDecl*)litaC_ast_new__NewParameterDecl(litaC_decl->decl.stmt.node.startPos, litaC_decl->decl.stmt.node.endPos, litaC_decl->decl.name, litaC_ast_copy__CopyTypeSpec(litaC_decl->type, litaC_allocator), litaC_ast_copy__CopyExpr(litaC_decl->defaultExpr, litaC_allocator), litaC_decl->decl.attributes.isUsing, litaC_allocator);
            litaC_copy->decl.attributes = litaC_decl->decl.attributes;
            litaC_array__Array_add_cb__ptr_ParameterDecl_ce_(&((litaC_paramDecls)), litaC_copy);
            
            
        }
    }
    litaC_ast__Stmt* litaC_paramsCopy = litaC_ast_new__NewParametersStmt(litaC_params.stmt.node.startPos, litaC_params.stmt.node.endPos, litaC_paramDecls, litaC_params.isVararg, litaC_allocator);
    return (litaC_ast__ParametersStmt*)litaC_paramsCopy;
    
    
}

litaC_ast__TypedefDecl* litaC_ast_copy__CopyTypedefDecl(litaC_ast__TypedefDecl* litaC_decl,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__Decl* litaC_copy = litaC_ast_new__NewTypedefDecl(litaC_decl->decl.declaration.stmt.node.startPos, litaC_decl->decl.declaration.stmt.node.endPos, litaC_decl->decl.declaration.name, litaC_array__Array_copy_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams)), NULL), litaC_ast_copy__CopyTypeSpec(litaC_decl->type, litaC_allocator), litaC_allocator);
    litaC_copy->attributes = litaC_decl->decl.declaration.attributes;
    return (litaC_ast__TypedefDecl*)litaC_copy;
    
    
}

litaC_void litaC_ast_copy__AstInsertText(litaC_ast__Node* litaC_node,const litaC_char* litaC_text,litaC_i32 litaC_index,litaC_lita__Lita* litaC_lita) {
    litaC_parser__Parser litaC_parser = litaC_parser__ParserInit(litaC_node->startPos.filename, litaC_text, litaC_lita);
    litaC_ast__Stmt* litaC_stmt = litaC_parser__Parser_statement(&((litaC_parser)));
    litaC_ast_copy__AstInsert(litaC_node, litaC_stmt, litaC_index, litaC_lita->allocator);
    
}


litaC_void litaC_ast_copy__AstInsert(litaC_ast__Node* litaC_node,litaC_ast__Stmt* litaC_stmt,litaC_i32 litaC_index,const litaC_mem__Allocator* litaC_allocator) {
    switch(litaC_node->kind) {
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                litaC_ast__FuncDecl* litaC_funcDecl = (litaC_ast__FuncDecl*)litaC_node;
                if(!(litaC_funcDecl->body)) {
                    {
                        litaC_funcDecl->body = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_funcDecl->decl.declaration.stmt.node)), litaC_stmt);
                        
                        
                    }
                    
                } else {
                    {
                        if(litaC_funcDecl->body->node.kind == litaC_ast__StmtKind_FUNC_BODY_STMT) {
                            {
                                litaC_ast__FuncBodyStmt* litaC_body = (litaC_ast__FuncBodyStmt*)litaC_funcDecl->body;
                                litaC_array__Array_insertAt_cb__ptr_Stmt_ce_(&((litaC_body->stmts)), litaC_index, litaC_stmt);
                                litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_body->stmt.node)), litaC_stmt);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_array__Array_cb__ptr_Stmt_ce_ litaC_stmts = litaC_array__ArrayInit_cb__ptr_Stmt_ce_(8, litaC_allocator);
                                if(litaC_index) {
                                    {
                                        litaC_array__Array_add_cb__ptr_Stmt_ce_(&((litaC_stmts)), litaC_funcDecl->body);
                                        litaC_array__Array_add_cb__ptr_Stmt_ce_(&((litaC_stmts)), litaC_stmt);
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        litaC_array__Array_add_cb__ptr_Stmt_ce_(&((litaC_stmts)), litaC_stmt);
                                        litaC_array__Array_add_cb__ptr_Stmt_ce_(&((litaC_stmts)), litaC_funcDecl->body);
                                        
                                        
                                    }
                                } 
                                
                                litaC_funcDecl->body = litaC_ast_new__NewFuncBodyStmt((litaC_index) ? litaC_funcDecl->body->node.startPos : litaC_stmt->node.startPos, (litaC_index) ? litaC_stmt->node.endPos : litaC_funcDecl->body->node.endPos, litaC_stmts, litaC_allocator);
                                
                                
                            }
                        } 
                        
                        
                        
                    }
                } 
                
                break;
                
                
            }
            
            
        }
        default: {
            {
                printf("Assert AstInsert: %s\n", litaC_ast__StmtKindAsStr(litaC_node->kind));
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    
}

const litaC_char* litaC_ast_copy__AstAddImport(litaC_lita__Lita* litaC_lita,litaC_checker__TypeChecker* litaC_checker,litaC_module__Module* litaC_module,litaC_module__Module* litaC_importModule) {
    static 
    litaC_i32 litaC_moduleNameIndex;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_ImportDecl_ce_(&((litaC_module->ast->imports)));litaC_i += 1) {
        {
            litaC_ast__ImportDecl* litaC_importStmt = litaC_array__Array_get_cb__ptr_ImportDecl_ce_(&((litaC_module->ast->imports)), litaC_i);
            if(strncmp(litaC_importStmt->moduleId->filename, litaC_importModule->id.filename, _MAX_PATH) == 0) {
                {
                    if(litaC_importStmt->alias.type == litaC_lex__TokenType_IDENTIFIER) {
                        {
                            return litaC_lex__Token_asString(&((litaC_importStmt->alias)));
                            
                            
                            
                        }
                        
                    } else {
                        {
                            return NULL;
                            
                            
                            
                        }
                    } 
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_lex__Token litaC_name =  {
        .type = litaC_lex__TokenType_IDENTIFIER,
        .pos = litaC_module->ast->stmt.node.startPos,
        .value =  {
            .str = litaC_importModule->id.name
        }
    };
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(16, litaC_lita->allocator);
    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "____%d", litaC_moduleNameIndex += 1);
    litaC_lex__Token litaC_alias =  {
        .type = litaC_lex__TokenType_IDENTIFIER,
        .pos = litaC_module->ast->stmt.node.startPos,
        .value =  {
            .str = litaC_string_view__StringViewInit(litaC_string_buffer__StringBuffer_cStr(&((litaC_sb))), litaC_sb.length)
        }
    };
    litaC_ast__ImportDecl* litaC_importStmt = (litaC_ast__ImportDecl*)litaC_ast_new__NewImportDecl(litaC_module->ast->stmt.node.startPos, litaC_module->ast->stmt.node.startPos, litaC_name, litaC_alias, litaC_false, litaC_lita->allocator);
    litaC_importStmt->moduleId = &(litaC_importModule->id);
    litaC_array__Array_add_cb__ptr_ImportDecl_ce_(&((litaC_module->ast->imports)), litaC_importStmt);
    litaC_checker__TypeChecker_enterModule(litaC_checker, litaC_module);
    
    litaC_checker__TypeChecker_createImportSymbols(litaC_checker, litaC_importStmt);
    {
        const litaC_char* ___result = litaC_string_buffer__StringBuffer_cStr(&((litaC_sb)));
        litaC_checker__TypeChecker_leaveModule(litaC_checker);
        return ___result;
        
    }
    
    litaC_checker__TypeChecker_leaveModule(litaC_checker);
    
}

litaC_void litaC_checker__TypeChecker_init(litaC_checker__TypeChecker* litaC_this,litaC_lita__Lita* litaC_lita) {
    litaC_this->lita = litaC_lita;
    litaC_this->current = NULL;
    litaC_array__Array_init_cb__ptr_Module_ce_(&((litaC_this->moduleStack)), 64, litaC_lita->allocator);
    litaC_array__Array_init_cb__ptr_FuncTypeInfo_ce_(&((litaC_this->funcDeclStack)), 64, litaC_lita->allocator);
    litaC_array__Array_init_cb__ptr_Symbol_ce_(&((litaC_this->pendingValues)), 128, litaC_lita->allocator);
    litaC_array__Array_init_cb__ptr_Symbol_ce_(&((litaC_this->symbolTypes)), 256, litaC_lita->allocator);
    litaC_array__Array_init_cb__ptr_Symbol_ce_(&((litaC_this->symbolFuncs)), 256, litaC_lita->allocator);
    litaC_array__Array_init_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)), 128, litaC_lita->allocator);
    litaC_array__Array_init_cb__ptr_Symbol_ce_(&((litaC_this->genericTemplates)), 64, litaC_lita->allocator);
    litaC_this->genericContext.callsite = NULL;
    litaC_map__Map_init_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_this->interfaceImpls)), (litaC_array__Array_cb_i64_ce_) {
        
    }, 128, litaC_map__PtrHashFn_cb_i64_ce_, litaC_map__PtrEqualFn_cb_i64_ce_, litaC_lita->allocator, 0);
    litaC_this->bypassing = litaC_false;
    litaC_types_new__TypeCache_init(&((litaC_this->typeCache)), litaC_lita->allocator);
    litaC_this->mainEntry = NULL;
    memset(litaC_this->labels, 0, litaC_checker__MAX_LABELS * sizeof(litaC_checker__LabelInfo));
    litaC_this->numOfLabels = 0;
    
}


litaC_symbols__ProgramSymbols litaC_checker__TypeChecker_typeCheck(litaC_checker__TypeChecker* litaC_this,litaC_module__Module* litaC_root) {
    if(litaC_root->flags & litaC_module__ModuleFlags_TYPE_CHECKED) {
        {
            goto exit;
            
            
            
        }
        
    } 
    
    litaC_root->flags |= litaC_module__ModuleFlags_TYPE_CHECKED;
    litaC_checker__TypeChecker_createModuleSymbols(litaC_this, litaC_root);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Decl_ce_(&((litaC_root->ast->declarations)));litaC_i += 1) {
        {
            litaC_ast__Decl* litaC_decl = litaC_array__Array_get_cb__ptr_Decl_ce_(&((litaC_root->ast->declarations)), litaC_i);
            if(litaC_decl->sym && litaC_decl->stmt.node.kind == litaC_ast__StmtKind_FUNC_DECL && strcmp(litaC_decl->sym->name, "main") == 0) {
                {
                    litaC_this->mainEntry = litaC_decl->sym;
                    litaC_this->mainEntry->flags |= litaC_symbols__SymbolFlags_IS_MAIN;
                    break;
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_preprocessor__Preprocessor_preResolveSymbols(&((litaC_this->lita->preprocessor)), litaC_this);
    if(litaC_this->lita->options->instrument && !(litaC_phase_result__PhaseResult_hasErrors(&((litaC_this->lita->result))))) {
        {
            litaC_instrument__Instrument(litaC_this->lita, litaC_this);
            
            
        }
        
    } 
    
    litaC_checker__TypeChecker_resolveSymbols(litaC_this);
    litaC_checker__TypeChecker_enterModule(litaC_this, litaC_root);
    {
        litaC_array__Array_cb__ptr_Decl_ce_ litaC_traitDecls = litaC_traits__CreateTraitWrappers(litaC_this);
        litaC_this->bypassing = litaC_true;
        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Decl_ce_(&((litaC_traitDecls)));litaC_i += 1) {
            {
                litaC_ast__Decl* litaC_decl = litaC_array__Array_get_cb__ptr_Decl_ce_(&((litaC_traitDecls)), litaC_i);
                litaC_symbols__Symbol* litaC_sym = litaC_checker__TypeChecker_createDeclSymbol(litaC_this, litaC_decl);
                if(litaC_sym == NULL) {
                    {
                        continue;
                        
                        
                    }
                    
                } 
                
                litaC_checker__TypeChecker_resolveSymbol(litaC_this, litaC_sym);
                litaC_checker__TypeChecker_finishResolveSymbol(litaC_this, litaC_sym);
                
                
            }
        }
        litaC_this->bypassing = litaC_false;
        
        
    }
    litaC_checker__TypeChecker_leaveModule(litaC_this);
    if(!(litaC_phase_result__PhaseResult_hasErrors(&((litaC_this->lita->result))))) {
        {
            litaC_introspection__Introspect litaC_introspect =  {
                .lita = litaC_this->lita
            };
            litaC_introspection__Introspect_generate(&((litaC_introspect)), litaC_this);
            
            
        }
        
    } 
    
    exit:;
    
    return (litaC_symbols__ProgramSymbols) {
        .root = litaC_root,
        .values = litaC_this->pendingValues,
        .symbolTypes = litaC_this->symbolTypes,
        .symbolFuncs = litaC_this->symbolFuncs,
        .mainEntry = litaC_this->mainEntry,
        .interfaceImpls = litaC_this->interfaceImpls
    };
    
    
}

litaC_bool litaC_checker__TypeChecker_checkTrait(litaC_checker__TypeChecker* litaC_this,litaC_string_buffer__StringBuffer* litaC_sb,litaC_types__TypeInfo* litaC_a,litaC_types__TypeInfo* litaC_b,const litaC_char* litaC_description) {
    if(litaC_types__IsTraitLike(litaC_a)) {
        {
            litaC_types__TypeInfo* litaC_aTrait = litaC_types__TypeInfo_getBaseType(litaC_a);
            if(litaC_types__IsPtr(litaC_a)) {
                {
                    if(!(litaC_types__IsPtrTrait(litaC_b))) {
                        {
                            litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, "'", 1);
                            litaC_types__TypeInfo_toString(litaC_b, litaC_sb);
                            litaC_string_buffer__StringBuffer_appendStr(litaC_sb, litaC_description);
                            litaC_types__TypeInfo_toString(litaC_a, litaC_sb);
                            litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, "'", 1);
                            litaC_string_buffer__StringBuffer_appendStr(litaC_sb, "; assigned trait pointers can only be assigned from a trait type and not an implementation type");
                            return litaC_true;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            if(!(litaC_types__IsPtr(litaC_b)) && litaC_types__IsAggregate(litaC_b)) {
                {
                    litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_types__TypeInfo_getBaseType(litaC_b);
                    if(litaC_types__AggregateTypeInfo_implementsTrait(litaC_aggInfo, litaC_aTrait, litaC_this)) {
                        {
                            litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, "'", 1);
                            litaC_types__TypeInfo_toString(litaC_b, litaC_sb);
                            litaC_string_buffer__StringBuffer_appendStr(litaC_sb, litaC_description);
                            litaC_types__TypeInfo_toString(litaC_a, litaC_sb);
                            litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, "'", 1);
                            litaC_string_buffer__StringBuffer_appendStr(litaC_sb, "; assigned trait implementations must be pointers: e.g. '*");
                            litaC_types__TypeInfo_toString(litaC_b, litaC_sb);
                            litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, "'", 1);
                            return litaC_true;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } else {
                if(litaC_types__IsPtrAggregate(litaC_b)) {
                    {
                        litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_types__TypeInfo_getBaseType(litaC_b);
                        if(!(litaC_types__AggregateTypeInfo_implementsTrait(litaC_aggInfo, litaC_aTrait, litaC_this))) {
                            {
                                litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, "'", 1);
                                litaC_types__TypeInfo_toString(litaC_b, litaC_sb);
                                litaC_string_buffer__StringBuffer_appendStr(litaC_sb, litaC_description);
                                litaC_types__TypeInfo_toString(litaC_a, litaC_sb);
                                litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, "'; '", 4);
                                litaC_types__TypeInfo_toString(litaC_b, litaC_sb);
                                litaC_string_buffer__StringBuffer_appendStr(litaC_sb, "' doesn't implement all of '");
                                litaC_types__TypeInfo_toString(litaC_a, litaC_sb);
                                litaC_string_buffer__StringBuffer_appendStr(litaC_sb, "' trait methods");
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } else {
                    {
                        litaC_string_buffer__StringBuffer_appendStrn(litaC_sb, "'", 1);
                        litaC_types__TypeInfo_toString(litaC_b, litaC_sb);
                        litaC_string_buffer__StringBuffer_appendStr(litaC_sb, litaC_description);
                        litaC_types__TypeInfo_toString(litaC_a, litaC_sb);
                        litaC_string_buffer__StringBuffer_appendStr(litaC_sb, "'; only aggregate types can implement traits");
                        return litaC_true;
                        
                        
                        
                    }
                } 
                
            } 
            
            
            
        }
        
    } 
    
    return litaC_false;
    
    
}

litaC_bool litaC_checker__TypeChecker_checkCastability(litaC_checker__TypeChecker* litaC_this,litaC_lex__SrcPos litaC_src,litaC_types__TypeInfo* litaC_a,litaC_types__TypeInfo* litaC_b) {
    assert(litaC_a != NULL);
    assert(litaC_b != NULL);
    if(!(litaC_types__TypeInfo_canCastTo(litaC_a, litaC_b, litaC_this))) {
        {
            litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
            if(litaC_checker__TypeChecker_checkTrait(litaC_this, &((litaC_sb)), litaC_a, litaC_b, "' can't be casted to '")) {
                {
                    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_src, &((litaC_sb)));
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
            litaC_types__TypeInfo_toString(litaC_a, &((litaC_sb)));
            litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), "' can't be casted to '");
            litaC_types__TypeInfo_toString(litaC_b, &((litaC_sb)));
            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
            litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_src, &((litaC_sb)));
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_bool litaC_checker__TypeChecker_checkAssignability(litaC_checker__TypeChecker* litaC_this,litaC_lex__SrcPos litaC_src,litaC_types__TypeInfo* litaC_a,litaC_types__TypeInfo* litaC_b) {
    assert(litaC_a != NULL);
    assert(litaC_b != NULL);
    if(!(litaC_types__TypeInfo_isAssignable(litaC_a, litaC_b, litaC_this))) {
        {
            litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
            if(litaC_types__IsTraitLike(litaC_a)) {
                {
                    litaC_types__TypeInfo* litaC_aTrait = litaC_types__TypeInfo_getBaseType(litaC_a);
                    if(!(litaC_types__IsPtr(litaC_b)) && litaC_types__IsAggregate(litaC_b)) {
                        {
                            litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_types__TypeInfo_getBaseType(litaC_b);
                            if(litaC_types__AggregateTypeInfo_implementsTrait(litaC_aggInfo, litaC_aTrait, litaC_this)) {
                                {
                                    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
                                    litaC_types__TypeInfo_toString(litaC_b, &((litaC_sb)));
                                    litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), "' can't be assigned to '");
                                    litaC_types__TypeInfo_toString(litaC_a, &((litaC_sb)));
                                    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
                                    litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), "; assigned trait implementations must be pointers: e.g. '*");
                                    litaC_types__TypeInfo_toString(litaC_b, &((litaC_sb)));
                                    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
                                    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_src, &((litaC_sb)));
                                    return litaC_false;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
            litaC_types__TypeInfo_toString(litaC_b, &((litaC_sb)));
            litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), "' can't be assigned to '");
            litaC_types__TypeInfo_toString(litaC_a, &((litaC_sb)));
            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
            litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_src, &((litaC_sb)));
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_bool litaC_checker__TypeChecker_checkDeclarability(litaC_checker__TypeChecker* litaC_this,litaC_lex__SrcPos litaC_src,litaC_types__TypeInfo* litaC_a,litaC_types__TypeInfo* litaC_b) {
    assert(litaC_a != NULL);
    assert(litaC_b != NULL);
    if(!(litaC_types__TypeInfo_isDeclarable(litaC_a, litaC_b, litaC_this))) {
        {
            litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
            if(litaC_checker__TypeChecker_checkTrait(litaC_this, &((litaC_sb)), litaC_a, litaC_b, "' can't be assigned to '")) {
                {
                    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_src, &((litaC_sb)));
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
            litaC_types__TypeInfo_toString(litaC_b, &((litaC_sb)));
            litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), "' can't be assigned to '");
            litaC_types__TypeInfo_toString(litaC_a, &((litaC_sb)));
            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
            litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_src, &((litaC_sb)));
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_bool litaC_checker__TypeChecker_checkTypeCompatibility(litaC_checker__TypeChecker* litaC_this,litaC_lex__SrcPos litaC_src,litaC_types__TypeInfo* litaC_a,litaC_types__TypeInfo* litaC_b) {
    assert(litaC_a != NULL);
    assert(litaC_b != NULL);
    if(!(litaC_types__TypeInfo_isAssignable(litaC_a, litaC_b, litaC_this))) {
        {
            litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
            if(litaC_checker__TypeChecker_checkTrait(litaC_this, &((litaC_sb)), litaC_a, litaC_b, "' is not of type '")) {
                {
                    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_src, &((litaC_sb)));
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
            litaC_types__TypeInfo_toString(litaC_b, &((litaC_sb)));
            litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), "' is not of type '");
            litaC_types__TypeInfo_toString(litaC_a, &((litaC_sb)));
            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
            litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_src, &((litaC_sb)));
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_void litaC_checker__TypeChecker_createModuleSymbols(litaC_checker__TypeChecker* litaC_this,litaC_module__Module* litaC_module) {
    if(!(litaC_module->ast)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_checker__TypeChecker_enterModule(litaC_this, litaC_module);
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Decl_ce_(&((litaC_module->ast->declarations)));litaC_i += 1) {
        {
            litaC_ast__Decl* litaC_decl = litaC_array__Array_get_cb__ptr_Decl_ce_(&((litaC_module->ast->declarations)), litaC_i);
            litaC_checker__TypeChecker_createDeclSymbol(litaC_this, litaC_decl);
            
            
        }
    }
    if((litaC_module->flags & litaC_module__ModuleFlags_TYPE_IMPORTED)) {
        {
            litaC_checker__TypeChecker_leaveModule(litaC_this);
            return;
            
            
            
        }
        
    } 
    
    litaC_module->flags |= litaC_module__ModuleFlags_TYPE_IMPORTED;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_ImportDecl_ce_(&((litaC_module->ast->imports)));litaC_i += 1) {
        {
            litaC_ast__ImportDecl* litaC_imp = litaC_array__Array_get_cb__ptr_ImportDecl_ce_(&((litaC_module->ast->imports)), litaC_i);
            litaC_checker__TypeChecker_createImportSymbols(litaC_this, litaC_imp);
            
            
        }
    }
    litaC_checker__TypeChecker_leaveModule(litaC_this);
    
}

litaC_void litaC_checker__TypeChecker_enterModule(litaC_checker__TypeChecker* litaC_this,litaC_module__Module* litaC_module) {
    litaC_array__Array_push_cb__ptr_Module_ce_(&((litaC_this->moduleStack)), litaC_module);
    litaC_this->current = litaC_module;
    
}

litaC_void litaC_checker__TypeChecker_leaveModule(litaC_checker__TypeChecker* litaC_this) {
    litaC_module__Module* litaC_oldScope = litaC_this->current;
    if(litaC_array__Array_size_cb__ptr_Module_ce_(&((litaC_this->moduleStack)))) {
        {
            litaC_array__Array_pop_cb__ptr_Module_ce_(&((litaC_this->moduleStack)));
            if(litaC_array__Array_size_cb__ptr_Module_ce_(&((litaC_this->moduleStack)))) {
                {
                    litaC_this->current = litaC_array__Array_last_cb__ptr_Module_ce_(&((litaC_this->moduleStack)));
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    
}

litaC_symbols__Scope* litaC_checker__TypeChecker_currentScope(litaC_checker__TypeChecker* litaC_this) {
    return litaC_this->current->currentScope;
    
    
}

litaC_void litaC_checker__TypeChecker_pushScope(litaC_checker__TypeChecker* litaC_this,litaC_symbols__Scope* litaC_scope) {
    litaC_symbols__Scope_init(litaC_scope, litaC_symbols__ScopeKind_FUNC, litaC_checker__TypeChecker_currentScope(litaC_this), &((litaC_this->lita->result)), litaC_this->lita->allocator);
    litaC_scope->module = litaC_this->current;
    litaC_this->current->currentScope = litaC_scope;
    
}

litaC_void litaC_checker__TypeChecker_popScope(litaC_checker__TypeChecker* litaC_this) {
    if(litaC_checker__TypeChecker_currentScope(litaC_this)) {
        {
            litaC_this->current->currentScope = litaC_this->current->currentScope->parent;
            
            
        }
        
    } 
    
    
}

litaC_bool litaC_checker__TypeChecker_isGenericParamType(litaC_checker__TypeChecker* litaC_this,litaC_ast__NameTypeSpec* litaC_name) {
    for(litaC_i32 litaC_k = 0;litaC_k < litaC_array__Array_size_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));litaC_k += 1) {
        {
            litaC_array__Array_cb_GenericParam_ce_* litaC_params = &(litaC_this->genericParamStack.elements[litaC_k]);
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_GenericParam_ce_(litaC_params);litaC_i += 1) {
                {
                    litaC_ast__GenericParam litaC_param = litaC_array__Array_get_cb_GenericParam_ce_(litaC_params, litaC_i);
                    assert(litaC_param.name.type == litaC_lex__TokenType_IDENTIFIER);
                    if(litaC_string_view__StringView_equals(litaC_param.name.value.str, litaC_name->name, -(1))) {
                        {
                            return litaC_true;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_symbols__Symbol* litaC_checker__TypeChecker_createDeclSymbol(litaC_checker__TypeChecker* litaC_this,litaC_ast__Decl* litaC_decl) {
    assert(litaC_decl != NULL);
    if(litaC_decl->sym) {
        {
            return litaC_decl->sym;
            
            
            
        }
        
    } 
    
    litaC_char litaC_name[256];
    if(litaC_decl->name.type == litaC_lex__TokenType_IDENTIFIER) {
        {
            litaC_string_view__StringView_copyTo(litaC_decl->name.value.str, litaC_name, litaC_symbols__MAX_SYMBOL_NAME, litaC_true);
            
            
        }
        
    } else {
        {
            litaC_string__String litaC_nameStr = litaC_string__StringInit(litaC_name, litaC_symbols__MAX_SYMBOL_NAME, -(1));
            litaC_string__String_format(&((litaC_nameStr)), "anon_%d", litaC_this->randomNameIndex);
            litaC_this->randomNameIndex += 1;
            
            
        }
    } 
    
    litaC_symbols__Symbol* litaC_sym = NULL;
    if(litaC_decl->stmt.node.kind != litaC_ast__StmtKind_FUNC_DECL) {
        {
            litaC_sym = litaC_symbols__Scope_addSymbol(&((litaC_this->current->symbols)), (const litaC_char*)litaC_name, litaC_this->current, litaC_decl, litaC_symbols__SymbolFlags_IS_INCOMPLETE);
            if(!(litaC_sym)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    switch(litaC_decl->stmt.node.kind) {
        case litaC_ast__StmtKind_CONST_DECL: 
        case litaC_ast__StmtKind_VAR_DECL: {
            {
                litaC_ast__VarDecl* litaC_varDecl = (litaC_ast__VarDecl*)litaC_decl;
                litaC_bool litaC_isValid = litaC_false;
                if(litaC_ast__Expr_isConstExpr(litaC_varDecl->expr) || litaC_ast__Decl_hasNote(&((litaC_varDecl->decl)), "foreign")) {
                    {
                        litaC_this->lita->result.enabled = litaC_false;
                        litaC_isValid = litaC_checker_decl__TypeChecker_resolveValueDecl(litaC_this, litaC_varDecl) != NULL;
                        litaC_this->lita->result.enabled = litaC_true;
                        if(litaC_isValid) {
                            {
                                litaC_checker__TypeChecker_resolveSymbol(litaC_this, litaC_sym);
                                litaC_checker__TypeChecker_finishResolveSymbol(litaC_this, litaC_sym);
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_isValid)) {
                    {
                        litaC_array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->pendingValues)), litaC_sym);
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                litaC_ast__FuncDecl* litaC_funcDecl = (litaC_ast__FuncDecl*)litaC_decl;
                if(litaC_funcDecl->flags & litaC_ast__FuncFlags_IS_METHOD) {
                    {
                        if(!(litaC_ast__FuncDecl_getName(litaC_funcDecl, litaC_name))) {
                            {
                                litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_decl->stmt.node.startPos, "invalid function name");
                                goto err;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                litaC_sym = litaC_symbols__Scope_addSymbol(&((litaC_this->current->symbols)), (const litaC_char*)litaC_name, litaC_this->current, litaC_decl, litaC_symbols__SymbolFlags_IS_INCOMPLETE);
                if(!(litaC_sym)) {
                    {
                        goto err;
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_array__Array_empty_cb_GenericParam_ce_(&((litaC_funcDecl->decl.genericParams))))) {
                    {
                        litaC_sym->flags |= litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE;
                        litaC_array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->genericTemplates)), litaC_sym);
                        
                        
                    }
                    
                } 
                
                litaC_sym->type = (litaC_types__TypeInfo*)litaC_types_new__TypeCache_newFuncTypeInfo(&((litaC_this->typeCache)), litaC_sym, litaC_funcDecl);
                litaC_array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->symbolFuncs)), litaC_sym);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_DECL: {
            {
                litaC_array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->symbolTypes)), litaC_sym);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TRAIT_DECL: 
        case litaC_ast__StmtKind_UNION_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: {
            {
                litaC_ast__AggregateDecl* litaC_aggDecl = (litaC_ast__AggregateDecl*)litaC_decl;
                if(!(litaC_array__Array_empty_cb_GenericParam_ce_(&((litaC_aggDecl->decl.genericParams))))) {
                    {
                        litaC_sym->flags |= litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE;
                        litaC_array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->genericTemplates)), litaC_sym);
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_aggDecl->fields)));litaC_i += 1) {
                    {
                        litaC_ast__FieldStmt* litaC_field = &(litaC_aggDecl->fields.elements[litaC_i]);
                        switch(litaC_field->kind) {
                            case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                                {
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                                {
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                                {
                                    litaC_symbols__Symbol* litaC_sym = litaC_checker__TypeChecker_createDeclSymbol(litaC_this, &((litaC_field->enumField->decl)));
                                    litaC_field->enumField->decl.sym = litaC_sym;
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                            case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                                {
                                    if(!((litaC_aggDecl->decl.declaration.sym->flags & litaC_symbols__SymbolFlags_IS_FROM_GENERIC_TEMPLATE))) {
                                        {
                                            litaC_field->aggregateField->decl.declaration.sym = litaC_checker__TypeChecker_createDeclSymbol(litaC_this, &((litaC_field->aggregateField->decl.declaration)));
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_POISON_EXPR: {
                                {
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            default: {
                                {
                                    assert(litaC_false);
                                    
                                    
                                }
                                
                                
                            }
                        }
                        
                        
                    }
                }
                litaC_array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->symbolTypes)), litaC_sym);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            {
                litaC_ast__TypedefDecl* litaC_typedefDecl = (litaC_ast__TypedefDecl*)litaC_decl;
                if(!(litaC_array__Array_empty_cb_GenericParam_ce_(&((litaC_typedefDecl->decl.genericParams))))) {
                    {
                        litaC_sym->flags |= litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE;
                        
                        
                    }
                    
                } 
                
                litaC_array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->symbolTypes)), litaC_sym);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_DECL: {
            {
                break;
                
                
            }
            
            
        }
        default: {
            {
                litaC_ast_print__PrintStmt((litaC_ast__Stmt*)litaC_decl, 0);
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return litaC_sym;
    
    err:;
    
    return NULL;
    
    
}

litaC_void litaC_checker__TypeChecker_createImportSymbols(litaC_checker__TypeChecker* litaC_this,litaC_ast__ImportDecl* litaC_imp) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_ImportDecl_ce_(&((litaC_this->current->ast->imports)));litaC_i += 1) {
        {
            litaC_ast__ImportDecl* litaC_other = litaC_array__Array_get_cb__ptr_ImportDecl_ce_(&((litaC_this->current->ast->imports)), litaC_i);
            if(litaC_imp == litaC_other) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_string_view__StringView_equalsStringView(litaC_other->decl.name.value.str, litaC_imp->decl.name.value.str)) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_imp->decl.stmt.node.startPos, "duplicate import of module '%.*s'", litaC_imp->decl.name.value.str.length, litaC_imp->decl.name.value.str.buffer);
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    if(!(litaC_imp->moduleId)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_module__Module* litaC_module = litaC_map__Map_get_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_this->lita->modules)), litaC_imp->moduleId->filename);
    if(!(litaC_module)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_imp->decl.stmt.node.startPos, "could not find module '%s'", litaC_imp->moduleId->filename);
            goto err;
            
            
            
        }
        
    } 
    
    if(litaC_module == litaC_this->current) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(!((litaC_module->flags & litaC_module__ModuleFlags_TYPE_RESOLVED))) {
        {
            litaC_module->flags |= litaC_module__ModuleFlags_TYPE_RESOLVED;
            litaC_checker__TypeChecker_createModuleSymbols(litaC_this, litaC_module);
            
            
        }
        
    } 
    
    litaC_module__Module_importModule(litaC_this->current, litaC_imp, litaC_module);
    err:;
    
    return;
    
    
}

litaC_void litaC_checker__TypeChecker_resolveSymbols(litaC_checker__TypeChecker* litaC_this) {
    {
        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_this->symbolTypes)));litaC_i += 1) {
            {
                litaC_symbols__Symbol* litaC_symbol = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_this->symbolTypes)), litaC_i);
                litaC_checker__TypeChecker_resolveSymbol(litaC_this, litaC_symbol);
                
                
            }
        }
        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_this->symbolTypes)));litaC_i += 1) {
            {
                litaC_symbols__Symbol* litaC_symbol = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_this->symbolTypes)), litaC_i);
                litaC_checker__TypeChecker_finishResolveSymbol(litaC_this, litaC_symbol);
                
                
            }
        }
        
        
    }
    {
        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_this->symbolFuncs)));litaC_i += 1) {
            {
                litaC_symbols__Symbol* litaC_symbol = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_this->symbolFuncs)), litaC_i);
                litaC_checker__TypeChecker_resolveSymbol(litaC_this, litaC_symbol);
                
                
            }
        }
        
        
    }
    {
        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_this->pendingValues)));litaC_i += 1) {
            {
                litaC_symbols__Symbol* litaC_symbol = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_this->pendingValues)), litaC_i);
                litaC_checker__TypeChecker_finishResolveSymbol(litaC_this, litaC_symbol);
                
                
            }
        }
        
        
    }
    {
        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_this->symbolFuncs)));litaC_i += 1) {
            {
                litaC_symbols__Symbol* litaC_symbol = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_this->symbolFuncs)), litaC_i);
                litaC_checker__TypeChecker_finishResolveSymbol(litaC_this, litaC_symbol);
                
                
            }
        }
        
        
    }
    
}

litaC_void litaC_checker__TypeChecker_resolveSymbol(litaC_checker__TypeChecker* litaC_this,litaC_symbols__Symbol* litaC_sym) {
    if(litaC_sym->state == litaC_symbols__SymbolState_RESOLVED || litaC_sym->state == litaC_symbols__SymbolState_ERROR) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_sym->state == litaC_symbols__SymbolState_RESOLVING) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_sym->decl->stmt.node.startPos, "cyclic dependency found with '%s'", litaC_sym->name);
            goto err;
            
            
            
        }
        
    } 
    
    litaC_checker__TypeChecker_enterModule(litaC_this, litaC_sym->declared);
    
    litaC_sym->state = litaC_symbols__SymbolState_RESOLVING;
    switch(litaC_sym->kind) {
        case litaC_symbols__SymbolKind_TYPE: {
            {
                switch(litaC_sym->decl->stmt.node.kind) {
                    case litaC_ast__StmtKind_ENUM_DECL: {
                        {
                            litaC_ast__EnumDecl* litaC_enumDecl = (litaC_ast__EnumDecl*)litaC_sym->decl;
                            litaC_sym->type = (litaC_types__TypeInfo*)litaC_types_new__TypeCache_newEnumTypeInfo(&((litaC_this->typeCache)), litaC_sym, litaC_enumDecl);
                            break;
                            
                            
                        }
                        
                        
                    }
                    case litaC_ast__StmtKind_TYPEDEF_DECL: {
                        {
                            litaC_ast__TypedefDecl* litaC_typedefDecl = (litaC_ast__TypedefDecl*)litaC_sym->decl;
                            litaC_bool litaC_hasGenerics = !(litaC_array__Array_empty_cb_GenericParam_ce_(&((litaC_typedefDecl->decl.genericParams))));
                            if(litaC_hasGenerics) {
                                {
                                    litaC_array__Array_add_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)), litaC_typedefDecl->decl.genericParams);
                                    
                                    
                                }
                                
                            } 
                            
                            
                            litaC_types__TypeInfo* litaC_aliasedType = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_typedefDecl->type);
                            if(!(litaC_aliasedType)) {
                                {
                                    goto err;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            if(litaC_ast__Decl_hasNote(&((litaC_typedefDecl->decl.declaration)), "foreign") && litaC_aliasedType->kind == litaC_types__TypeKind_VOID) {
                                {
                                    litaC_aliasedType = litaC_types_new__TypeCache_newForeignTypeInfo(&((litaC_this->typeCache)), litaC_sym);
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_sym->type = litaC_aliasedType;
                            if(litaC_hasGenerics) {
                                {
                                    litaC_array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                    
                                    
                                }
                                
                            } 
                            ;
                            break;
                            if(litaC_hasGenerics) {
                                {
                                    litaC_array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                    
                                    
                                }
                                
                            } 
                            ;
                            
                            
                        }
                        
                        
                    }
                    case litaC_ast__StmtKind_TRAIT_DECL: 
                    case litaC_ast__StmtKind_STRUCT_DECL: 
                    case litaC_ast__StmtKind_UNION_DECL: {
                        {
                            litaC_ast__AggregateDecl* litaC_aggregateDecl = (litaC_ast__AggregateDecl*)litaC_sym->decl;
                            litaC_sym->type = (litaC_types__TypeInfo*)litaC_types_new__TypeCache_newAggregateTypeInfo(&((litaC_this->typeCache)), litaC_sym, litaC_aggregateDecl);
                            break;
                            
                            
                        }
                        
                        
                    }
                    default: {
                        {
                            assert(litaC_false);
                            
                            
                        }
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_symbols__SymbolKind_VAR: 
        case litaC_symbols__SymbolKind_CONST: {
            {
                if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_CONSTANT) {
                    {
                        litaC_ast__VarDecl* litaC_decl = (litaC_ast__VarDecl*)litaC_sym->decl;
                        if(litaC_decl && litaC_decl->expr && litaC_decl->expr->operand.isConst) {
                            {
                                litaC_sym->val = litaC_decl->expr->operand.val;
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                if(!((litaC_sym->flags & litaC_symbols__SymbolFlags_IS_LOCAL))) {
                    {
                        litaC_array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->pendingValues)), litaC_sym);
                        litaC_checker__TypeChecker_leaveModule(litaC_this);
                        return;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_symbols__SymbolKind_FUNC: {
            {
                litaC_ast__FuncDecl* litaC_funcDecl = (litaC_ast__FuncDecl*)litaC_sym->decl;
                litaC_types__FuncTypeInfo* litaC_funcInfo = (litaC_sym->type != NULL) ? (litaC_types__FuncTypeInfo*)litaC_sym->type : litaC_types_new__TypeCache_newFuncTypeInfo(&((litaC_this->typeCache)), litaC_sym, litaC_funcDecl);
                litaC_bool litaC_hasGenerics = !(litaC_array__Array_empty_cb_GenericParam_ce_(&((litaC_funcDecl->decl.genericParams))));
                if(litaC_hasGenerics) {
                    {
                        litaC_array__Array_add_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)), litaC_funcDecl->decl.genericParams);
                        
                        
                    }
                    
                } 
                
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcDecl->params->params)));litaC_i += 1) {
                    {
                        litaC_ast__ParameterDecl* litaC_param = litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcDecl->params->params)), litaC_i);
                        litaC_param->typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_param->type);
                        if(!(litaC_param->typeInfo)) {
                            {
                                goto err;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                litaC_types__TypeInfo* litaC_retType = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_funcDecl->returnType);
                if(!(litaC_retType)) {
                    {
                        goto err;
                        
                        
                        
                    }
                    
                } 
                
                litaC_funcInfo->returnType = litaC_types_new__TypeCache_typeDecay(&((litaC_this->typeCache)), litaC_retType);
                litaC_sym->type = (litaC_types__TypeInfo*)litaC_funcInfo;
                if(litaC_hasGenerics) {
                    {
                        litaC_array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                        
                        
                    }
                    
                } 
                ;
                break;
                if(litaC_hasGenerics) {
                    {
                        litaC_array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                        
                        
                    }
                    
                } 
                ;
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    litaC_sym->state = litaC_symbols__SymbolState_RESOLVED;
    litaC_checker__TypeChecker_leaveModule(litaC_this);
    return;
    
    err:;
    
    litaC_sym->state = litaC_symbols__SymbolState_ERROR;
    if(!(litaC_sym->type)) {
        {
            litaC_sym->type = &(litaC_types__POISON_TYPE);
            
            
        }
        
    } 
    
    litaC_checker__TypeChecker_leaveModule(litaC_this);
    return;
    
    litaC_checker__TypeChecker_leaveModule(litaC_this);
    
}

litaC_void litaC_checker__TypeChecker_finishResolveSymbol(litaC_checker__TypeChecker* litaC_this,litaC_symbols__Symbol* litaC_sym) {
    if(!((litaC_sym->flags & litaC_symbols__SymbolFlags_IS_INCOMPLETE))) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_checker__TypeChecker_enterModule(litaC_this, litaC_sym->declared);
    
    litaC_sym->flags &= ~(litaC_symbols__SymbolFlags_IS_INCOMPLETE);
    switch(litaC_sym->decl->stmt.node.kind) {
        case litaC_ast__StmtKind_TRAIT_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: 
        case litaC_ast__StmtKind_UNION_DECL: {
            {
                litaC_ast__AggregateDecl* litaC_aggDecl = (litaC_ast__AggregateDecl*)litaC_sym->decl;
                litaC_checker_decl__TypeChecker_resolveAggregateDecl(litaC_this, litaC_aggDecl);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_DECL: {
            {
                litaC_ast__EnumDecl* litaC_enumDecl = (litaC_ast__EnumDecl*)litaC_sym->decl;
                litaC_checker_decl__TypeChecker_resolveEnumDecl(litaC_this, litaC_enumDecl);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            {
                litaC_ast__TypedefDecl* litaC_typedefDecl = (litaC_ast__TypedefDecl*)litaC_sym->decl;
                litaC_checker_decl__TypeChecker_resolveTypedefDecl(litaC_this, litaC_typedefDecl);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                if((litaC_sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE)) {
                    {
                        litaC_checker__TypeChecker_leaveModule(litaC_this);
                        return;
                        
                        
                        
                    }
                    
                } 
                
                litaC_ast__FuncDecl* litaC_funcDecl = (litaC_ast__FuncDecl*)litaC_sym->decl;
                litaC_checker_decl__TypeChecker_resolveFuncDecl(litaC_this, litaC_funcDecl);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONST_DECL: 
        case litaC_ast__StmtKind_VAR_DECL: {
            {
                litaC_ast__VarDecl* litaC_varDecl = (litaC_ast__VarDecl*)litaC_sym->decl;
                litaC_sym->type = litaC_checker_decl__TypeChecker_resolveValueDecl(litaC_this, litaC_varDecl);
                litaC_sym->state = litaC_symbols__SymbolState_RESOLVED;
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_DECL: {
            {
                litaC_sym->state = litaC_symbols__SymbolState_RESOLVED;
                break;
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    litaC_checker__TypeChecker_leaveModule(litaC_this);
    
}

litaC_symbols__Symbol* litaC_checker__TypeChecker_getType(litaC_checker__TypeChecker* litaC_this,litaC_ast__NameTypeSpec* litaC_spec) {
    assert(litaC_spec != NULL);
    return litaC_checker__TypeChecker_getTypeByName(litaC_this, litaC_spec->name);
    
    
}

litaC_symbols__Symbol* litaC_checker__TypeChecker_getTypeByName(litaC_checker__TypeChecker* litaC_this,const litaC_char* litaC_typeName) {
    assert(litaC_typeName != NULL);
    litaC_symbols__Symbol* litaC_type = litaC_module__Module_getType(litaC_this->current, litaC_typeName);
    if(!(litaC_type)) {
        {
            if(litaC_this->genericContext.callsite) {
                {
                    litaC_type = litaC_module__Module_getType(litaC_this->genericContext.callsite, litaC_typeName);
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(!(litaC_type) && litaC_this->bypassing) {
        {
            litaC_string_view__StringView litaC_name = litaC_string_view__StringViewInit(litaC_typeName, -(1));
            litaC_i32 litaC_index = litaC_string_view__StringView_indexOf(litaC_name, "::", -(1));
            if(litaC_index < 0) {
                {
                    return NULL;
                    
                    
                    
                }
                
            } 
            
            litaC_string_view__StringView litaC_mod = litaC_string_view__StringView_substring(litaC_name, 0, litaC_index);
            litaC_char litaC_filename[_MAX_PATH] =  {
                0
            };
            if(!(litaC_lita__FindModulePath(litaC_this->lita, litaC_mod, litaC_filename))) {
                {
                    return NULL;
                    
                    
                    
                }
                
            } 
            
            litaC_module__Module* litaC_module = litaC_map__Map_get_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_this->lita->modules)), litaC_filename);
            assert(litaC_module != NULL);
            litaC_string_view__StringView litaC_namePart = litaC_string_view__StringView_substring(litaC_name, litaC_index + 2, -(1));
            return litaC_module__Module_getType(litaC_module, litaC_namePart.buffer);
            
            
            
        }
        
    } 
    
    return litaC_type;
    
    
}

litaC_bool litaC_checker__TypeChecker_implementsTrait(litaC_checker__TypeChecker* litaC_this,litaC_types__AggregateTypeInfo* litaC_agg,litaC_types__AggregateTypeInfo* litaC_iface) {
    assert(litaC_agg != NULL);
    assert(litaC_iface != NULL);
    if(litaC_agg->info.typeInfo.typeid == litaC_iface->info.typeInfo.typeid) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    if(litaC_map__Map_contains_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_this->interfaceImpls)), litaC_iface->info.typeInfo.typeid)) {
        {
            litaC_array__Array_cb_i64_ce_* litaC_impls = litaC_map__Map_getPtr_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_this->interfaceImpls)), litaC_iface->info.typeInfo.typeid);
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_i64_ce_(litaC_impls);litaC_i += 1) {
                {
                    if(litaC_array__Array_get_cb_i64_ce_(litaC_impls, litaC_i) == litaC_agg->info.typeInfo.typeid) {
                        {
                            return litaC_true;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } 
    
    litaC_symbols__Symbol* litaC_symbols[2048] =  {
        
    };
    litaC_i32 litaC_numOfMethods = litaC_module__Module_getMethodsForType(litaC_this->current, &((litaC_agg->info.typeInfo)), litaC_symbols);
    litaC_i32 litaC_numOfTraitFns = litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_iface->decl->fields)));
    if(litaC_numOfMethods < litaC_numOfTraitFns) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_matchedCount = 0;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_numOfTraitFns;litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_iface->decl->fields)), litaC_i);
            assert(litaC_field.typeInfo);
            assert(litaC_field.typeInfo->kind == litaC_types__TypeKind_FUNC_PTR);
            assert(litaC_field.kind == litaC_ast__StmtKind_TRAIT_FIELD_DECL);
            const litaC_char* litaC_functionName = litaC_lex__Token_asString(&((litaC_field.traitField->decl.name)));
            litaC_types__FuncPtrTypeInfo* litaC_traitFn = (litaC_types__FuncPtrTypeInfo*)litaC_field.typeInfo;
            for(litaC_i32 litaC_index = 0;litaC_index < litaC_numOfMethods;litaC_index += 1) {
                {
                    litaC_symbols__Symbol* litaC_sym = litaC_symbols[litaC_index];
                    litaC_string_view__StringView litaC_str = litaC_string_view__StringViewInit(litaC_sym->name, -(1));
                    litaC_i32 litaC_start = litaC_string_view__StringView_indexOf(litaC_str, "_", -(1));
                    if(litaC_start < 0) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    litaC_i32 litaC_end = litaC_string_view__StringView_indexOf(litaC_str, "<", -(1));
                    if(litaC_string_view__StringView_equals(litaC_string_view__StringView_substring(litaC_str, litaC_start + 1, litaC_end), litaC_functionName, -(1))) {
                        {
                            if(litaC_types__IsFuncImpl(litaC_traitFn, litaC_sym->type, litaC_this)) {
                                {
                                    litaC_matchedCount += 1;
                                    break;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
    }
    litaC_bool litaC_isImpl = litaC_matchedCount == litaC_numOfTraitFns;
    if(litaC_isImpl) {
        {
            if(!(litaC_map__Map_contains_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_this->interfaceImpls)), litaC_iface->info.typeInfo.typeid))) {
                {
                    litaC_array__Array_cb_i64_ce_ litaC_impls = litaC_array__ArrayInit_cb_i64_ce_(32, litaC_this->lita->allocator);
                    litaC_map__Map_put_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_this->interfaceImpls)), litaC_iface->info.typeInfo.typeid, litaC_impls);
                    
                    
                }
                
            } 
            
            litaC_array__Array_cb_i64_ce_* litaC_impls = litaC_map__Map_getPtr_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_this->interfaceImpls)), litaC_iface->info.typeInfo.typeid);
            litaC_array__Array_add_cb_i64_ce_(litaC_impls, litaC_agg->info.typeInfo.typeid);
            
            
        }
        
    } 
    
    return litaC_isImpl;
    
    
}

litaC_types__TypeInfo* litaC_checker__TypeChecker_resolveTypeSpec(litaC_checker__TypeChecker* litaC_this,litaC_ast__TypeSpec* litaC_spec) {
    if(!(litaC_spec)) {
        {
            return &(litaC_types__VOID_TYPE);
            
            
            
        }
        
    } 
    
    if(litaC_spec->typeInfo) {
        {
            return litaC_spec->typeInfo;
            
            
            
        }
        
    } 
    
    switch(litaC_spec->kind) {
        case litaC_ast__TypeSpecKind_NAME: {
            {
                litaC_ast__NameTypeSpec* litaC_nameSpec = (litaC_ast__NameTypeSpec*)litaC_spec;
                if(litaC_checker__TypeChecker_isGenericParamType(litaC_this, litaC_nameSpec)) {
                    {
                        litaC_nameSpec->spec.typeInfo = litaC_types_new__TypeCache_newGenericParamTypeInfo(&((litaC_this->typeCache)), litaC_nameSpec->name);
                        return litaC_nameSpec->spec.typeInfo;
                        
                        
                        
                    }
                    
                } 
                
                litaC_symbols__Symbol* litaC_sym = litaC_checker__TypeChecker_getType(litaC_this, litaC_nameSpec);
                if(!(litaC_sym)) {
                    {
                        litaC_sym = litaC_symbols__Scope_lookup(litaC_checker__TypeChecker_currentScope(litaC_this), litaC_nameSpec->name);
                        if(!(litaC_sym)) {
                            {
                                litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_spec->pos, "unknown type '%s'", litaC_nameSpec->name);
                                goto err;
                                
                                
                                
                            }
                            
                        } else {
                            if(litaC_sym->type && litaC_types__IsFuncLike(litaC_sym->type)) {
                                {
                                    litaC_spec->typeInfo = litaC_sym->type;
                                    return litaC_spec->typeInfo;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                if(!((litaC_sym->flags & litaC_symbols__SymbolFlags_IS_TYPE)) && !(litaC_types__IsFuncLike(litaC_sym->type))) {
                    {
                        litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_spec->pos, "'%s' must be a type", litaC_nameSpec->name);
                        goto err;
                        
                        
                        
                    }
                    
                } 
                
                litaC_checker__TypeChecker_resolveSymbol(litaC_this, litaC_sym);
                if(!(litaC_array__Array_empty_cb__ptr_TypeSpec_ce_(&((litaC_nameSpec->genericArgs))))) {
                    {
                        litaC_sym = litaC_generics__CreateTypeFromGenericTemplate(litaC_this, litaC_sym, litaC_nameSpec);
                        if(!(litaC_sym)) {
                            {
                                goto err;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                litaC_spec->typeInfo = litaC_sym->type;
                litaC_references__ReferenceDatabase_addTypeReference(&((litaC_this->lita->references)), litaC_spec);
                return litaC_spec->typeInfo;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_CONST: {
            {
                litaC_ast__ConstTypeSpec* litaC_constSpec = (litaC_ast__ConstTypeSpec*)litaC_spec;
                litaC_types__TypeInfo* litaC_constOf = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_constSpec->spec.base);
                litaC_spec->typeInfo = (litaC_types__TypeInfo*)litaC_types_new__TypeCache_newConstTypeInfo(&((litaC_this->typeCache)), litaC_constOf);
                return litaC_spec->typeInfo;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_PTR: {
            {
                litaC_ast__PtrTypeSpec* litaC_ptrSpec = (litaC_ast__PtrTypeSpec*)litaC_spec;
                litaC_types__TypeInfo* litaC_ptrOf = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_ptrSpec->spec.base);
                litaC_spec->typeInfo = (litaC_types__TypeInfo*)litaC_types_new__TypeCache_newPtrTypeInfo(&((litaC_this->typeCache)), litaC_ptrOf);
                return litaC_spec->typeInfo;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_ARRAY: {
            {
                litaC_ast__ArrayTypeSpec* litaC_arraySpec = (litaC_ast__ArrayTypeSpec*)litaC_spec;
                litaC_types__TypeInfo* litaC_arrayOf = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_arraySpec->spec.base);
                litaC_usize litaC_length = 0;
                litaC_bool litaC_isLengthDefined = litaC_false;
                if(litaC_arraySpec->numElements) {
                    {
                        litaC_ast__Expr* litaC_expr = litaC_arraySpec->numElements;
                        if(!(litaC_checker_expr__TypeChecker_resolveConstExpr(litaC_this, litaC_expr))) {
                            {
                                goto err;
                                
                                
                                
                            }
                            
                        } 
                        
                        if(!(litaC_types__IsInteger(litaC_expr->operand.typeInfo))) {
                            {
                                litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, "array size expression must be an integer type");
                                goto err;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_isLengthDefined = litaC_true;
                        if(litaC_expr->stmt.node.kind == litaC_ast__StmtKind_IDENTIFIER_EXPR) {
                            {
                                litaC_ast__IdentifierExpr* litaC_idExpr = (litaC_ast__IdentifierExpr*)litaC_expr;
                                if(litaC_idExpr->sym && (litaC_idExpr->sym->flags & litaC_symbols__SymbolFlags_IS_FOREIGN)) {
                                    {
                                        litaC_isLengthDefined = litaC_false;
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_isLengthDefined) {
                            {
                                litaC_length = litaC_expr->operand.val.intValue;
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                litaC_spec->typeInfo = (litaC_types__TypeInfo*)litaC_types_new__TypeCache_newArrayTypeInfo(&((litaC_this->typeCache)), litaC_arrayOf, litaC_length, litaC_arraySpec->numElements, litaC_isLengthDefined);
                return litaC_spec->typeInfo;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_FUNC_PTR: {
            {
                litaC_ast__FuncPtrTypeSpec* litaC_funcPtrSpec = (litaC_ast__FuncPtrTypeSpec*)litaC_spec;
                litaC_array__Array_cb__ptr_TypeInfo_ce_ litaC_paramDecls =  {
                    
                };
                if(!(litaC_array__Array_empty_cb__ptr_TypeSpec_ce_(&((litaC_funcPtrSpec->args))))) {
                    {
                        litaC_array__Array_init_cb__ptr_TypeInfo_ce_(&((litaC_paramDecls)), litaC_array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_funcPtrSpec->args))), litaC_this->lita->allocator);
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_funcPtrSpec->args)));litaC_i += 1) {
                            {
                                litaC_ast__TypeSpec* litaC_arg = litaC_array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_funcPtrSpec->args)), litaC_i);
                                litaC_types__TypeInfo* litaC_typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_arg);
                                litaC_array__Array_add_cb__ptr_TypeInfo_ce_(&((litaC_paramDecls)), litaC_typeInfo);
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                litaC_types__TypeInfo* litaC_returnType = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_funcPtrSpec->ret);
                litaC_spec->typeInfo = (litaC_types__TypeInfo*)litaC_types_new__TypeCache_newFuncPtrTypeInfo(&((litaC_this->typeCache)), litaC_funcPtrSpec->genericParams, litaC_returnType, litaC_paramDecls, litaC_funcPtrSpec->hasVarargs);
                return litaC_spec->typeInfo;
                
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    err:;
    
    if(!(litaC_spec->typeInfo)) {
        {
            litaC_spec->typeInfo = &(litaC_types__POISON_TYPE);
            
            
        }
        
    } 
    
    return &(litaC_types__POISON_TYPE);
    
    
}

litaC_symbols__Symbol* litaC_checker__TypeChecker_addSymbol(litaC_checker__TypeChecker* litaC_this,litaC_ast__Decl* litaC_decl,litaC_types__TypeInfo* litaC_typeInfo) {
    litaC_char litaC_name[256];
    assert(litaC_decl->name.type == litaC_lex__TokenType_IDENTIFIER);
    litaC_string_view__StringView_copyTo(litaC_decl->name.value.str, litaC_name, litaC_symbols__MAX_SYMBOL_NAME, litaC_true);
    litaC_symbols__Symbol* litaC_sym = litaC_symbols__Scope_addSymbol(litaC_this->current->currentScope, (const litaC_char*)litaC_name, litaC_this->current, litaC_decl, 0);
    if(litaC_sym) {
        {
            litaC_sym->type = litaC_typeInfo;
            litaC_checker__TypeChecker_resolveSymbol(litaC_this, litaC_sym);
            litaC_references__ReferenceDatabase_addSymbolReference(&((litaC_this->lita->references)), litaC_sym, litaC_decl->stmt.node.startPos);
            
            
        }
        
    } 
    
    return litaC_sym;
    
    
}

litaC_void litaC_checker__TypeChecker_addTypeToScope(litaC_checker__TypeChecker* litaC_this,litaC_ast__Decl* litaC_decl,litaC_symbols__Scope* litaC_scope,litaC_types__TypeInfo* litaC_baseType,litaC_types__AggregateTypeInfo* litaC_currentType) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_currentType->decl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_currentType->decl->fields)), litaC_i);
            switch(litaC_field.kind) {
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                        if(litaC_varField->decl.name.type != litaC_lex__TokenType_IDENTIFIER) {
                            {
                                break;
                                
                                
                            }
                            
                        } 
                        
                        litaC_ast__Decl* litaC_varDecl = litaC_ast_new__NewVarDecl(litaC_decl->stmt.node.startPos, litaC_decl->stmt.node.endPos, litaC_decl->name, litaC_varField->type, NULL, litaC_this->lita->allocator);
                        litaC_char litaC_name[256];
                        litaC_string_view__StringView_copyTo(litaC_varField->decl.name.value.str, litaC_name, litaC_symbols__MAX_SYMBOL_NAME, litaC_true);
                        litaC_varDecl->sym = litaC_symbols__Scope_addSymbol(litaC_scope, (const litaC_char*)litaC_name, litaC_this->current, litaC_varDecl, litaC_symbols__SymbolFlags_IS_USING);
                        litaC_varDecl->sym->type = litaC_field.typeInfo;
                        litaC_varDecl->sym->usingParent = litaC_decl->sym;
                        litaC_checker__TypeChecker_resolveSymbol(litaC_this, litaC_varDecl->sym);
                        if(litaC_varField->decl.attributes.isUsing) {
                            {
                                litaC_types__TypeInfo* litaC_fieldBaseType = litaC_types__TypeInfo_getBaseType(litaC_field.typeInfo);
                                assert(litaC_types__IsAggregate(litaC_fieldBaseType));
                                litaC_checker__TypeChecker_addTypeToScope(litaC_this, litaC_decl, litaC_scope, litaC_baseType, (litaC_types__AggregateTypeInfo*)litaC_fieldBaseType);
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: 
                case litaC_ast__StmtKind_ENUM_FIELD_DECL: 
                case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                case litaC_ast__StmtKind_STRUCT_FIELD_DECL: 
                case litaC_ast__StmtKind_POISON_EXPR: {
                    {
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        assert(litaC_false);
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    
}

litaC_bool litaC_checker__TypeChecker_resolveStmt(litaC_checker__TypeChecker* litaC_this,litaC_ast__Stmt* litaC_stmt) {
    if(!(litaC_stmt)) {
        return litaC_true;
        
        
    } 
    
    switch(litaC_stmt->node.kind) {
        case litaC_ast__StmtKind_IMPORT_DECL: 
        case litaC_ast__StmtKind_CONST_DECL: 
        case litaC_ast__StmtKind_VAR_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: 
        case litaC_ast__StmtKind_UNION_DECL: 
        case litaC_ast__StmtKind_TRAIT_DECL: 
        case litaC_ast__StmtKind_ENUM_DECL: 
        case litaC_ast__StmtKind_FUNC_DECL: 
        case litaC_ast__StmtKind_TYPEDEF_DECL: 
        case litaC_ast__StmtKind_PARAM_DECL: 
        case litaC_ast__StmtKind_NATIVE_DECL: 
        case litaC_ast__StmtKind_POISON_DECL: {
            {
                return litaC_checker_decl__TypeChecker_resolveDecl(litaC_this, (litaC_ast__Decl*)litaC_stmt);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BLOCK_STMT: {
            {
                litaC_ast__BlockStmt* litaC_body = (litaC_ast__BlockStmt*)litaC_stmt;
                litaC_checker__TypeChecker_pushScope(litaC_this, &((litaC_symbols__Scope) {
                    
                }));
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Stmt_ce_(&((litaC_body->stmts)));litaC_i += 1) {
                    {
                        litaC_ast__Stmt* litaC_s = litaC_array__Array_get_cb__ptr_Stmt_ce_(&((litaC_body->stmts)), litaC_i);
                        if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_s))) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    litaC_checker__TypeChecker_popScope(litaC_this);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                {
                    litaC_bool ___result = litaC_true;
                    litaC_checker__TypeChecker_popScope(litaC_this);
                    return ___result;
                    
                }
                
                litaC_checker__TypeChecker_popScope(litaC_this);
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BREAK_STMT: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_COMP_STMT: {
            {
                litaC_ast__CompStmt* litaC_compStmt = (litaC_ast__CompStmt*)litaC_stmt;
                litaC_ast__Stmt* litaC_stmt = litaC_preprocessor__Preprocessor_evaluateForFunction(&((litaC_this->lita->preprocessor)), litaC_this, litaC_compStmt);
                if(!(litaC_stmt)) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_stmt);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONTINUE_STMT: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DEFER_STMT: {
            {
                litaC_ast__DeferStmt* litaC_deferStmt = (litaC_ast__DeferStmt*)litaC_stmt;
                if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_deferStmt->deferedStmt))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DO_WHILE_STMT: {
            {
                litaC_ast__DoWhileStmt* litaC_whileStmt = (litaC_ast__DoWhileStmt*)litaC_stmt;
                {
                    litaC_checker__TypeChecker_pushScope(litaC_this, &((litaC_symbols__Scope) {
                        
                    }));
                    
                    if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_whileStmt->body))) {
                        {
                            {
                                litaC_bool ___result = litaC_false;
                                litaC_checker__TypeChecker_popScope(litaC_this);
                                return ___result;
                                
                            }
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_checker__TypeChecker_popScope(litaC_this);
                    
                    
                }
                if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_whileStmt->cond))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_EMPTY_STMT: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FOR_STMT: {
            {
                litaC_ast__ForStmt* litaC_forStmt = (litaC_ast__ForStmt*)litaC_stmt;
                litaC_checker__TypeChecker_pushScope(litaC_this, &((litaC_symbols__Scope) {
                    
                }));
                
                if(litaC_forStmt->init && !(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_forStmt->init))) {
                    {
                        {
                            litaC_bool ___result = litaC_false;
                            litaC_checker__TypeChecker_popScope(litaC_this);
                            return ___result;
                            
                        }
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_forStmt->cond && !(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_forStmt->cond))) {
                    {
                        {
                            litaC_bool ___result = litaC_false;
                            litaC_checker__TypeChecker_popScope(litaC_this);
                            return ___result;
                            
                        }
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_forStmt->post && !(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_forStmt->post))) {
                    {
                        {
                            litaC_bool ___result = litaC_false;
                            litaC_checker__TypeChecker_popScope(litaC_this);
                            return ___result;
                            
                        }
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_forStmt->body))) {
                    {
                        {
                            litaC_bool ___result = litaC_false;
                            litaC_checker__TypeChecker_popScope(litaC_this);
                            return ___result;
                            
                        }
                        
                        
                        
                    }
                    
                } 
                
                {
                    litaC_bool ___result = litaC_true;
                    litaC_checker__TypeChecker_popScope(litaC_this);
                    return ___result;
                    
                }
                
                litaC_checker__TypeChecker_popScope(litaC_this);
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_BODY_STMT: {
            {
                litaC_ast__FuncBodyStmt* litaC_body = (litaC_ast__FuncBodyStmt*)litaC_stmt;
                litaC_bool litaC_success = litaC_true;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Stmt_ce_(&((litaC_body->stmts)));litaC_i += 1) {
                    {
                        litaC_ast__Stmt* litaC_s = litaC_array__Array_get_cb__ptr_Stmt_ce_(&((litaC_body->stmts)), litaC_i);
                        if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_s))) {
                            {
                                litaC_success = litaC_false;
                                break;
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                return litaC_success;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GOTO_STMT: {
            {
                litaC_ast__GotoStmt* litaC_gotoStmt = (litaC_ast__GotoStmt*)litaC_stmt;
                if(litaC_gotoStmt->label.type != litaC_lex__TokenType_IDENTIFIER) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_this->numOfLabels;litaC_i += 1) {
                    {
                        litaC_checker__LabelInfo* litaC_label = &(litaC_this->labels[litaC_i]);
                        if(litaC_string_view__StringView_equalsStringView(litaC_gotoStmt->label.value.str, litaC_label->name)) {
                            {
                                litaC_label->stmt = litaC_stmt;
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                litaC_checker__LabelInfo* litaC_labelName = &(litaC_this->labels[litaC_this->numOfLabels]);
                litaC_labelName->name = litaC_gotoStmt->label.value.str;
                litaC_labelName->stmt = litaC_stmt;
                litaC_labelName->defined = litaC_false;
                litaC_this->numOfLabels += 1;
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IF_STMT: {
            {
                litaC_ast__IfStmt* litaC_ifStmt = (litaC_ast__IfStmt*)litaC_stmt;
                if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_ifStmt->cond))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                {
                    litaC_checker__TypeChecker_pushScope(litaC_this, &((litaC_symbols__Scope) {
                        
                    }));
                    
                    if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_ifStmt->then))) {
                        {
                            {
                                litaC_bool ___result = litaC_false;
                                litaC_checker__TypeChecker_popScope(litaC_this);
                                return ___result;
                                
                            }
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_checker__TypeChecker_popScope(litaC_this);
                    
                    
                }
                if(litaC_ifStmt->elseStmt) {
                    {
                        litaC_checker__TypeChecker_pushScope(litaC_this, &((litaC_symbols__Scope) {
                            
                        }));
                        
                        if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_ifStmt->elseStmt))) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    litaC_checker__TypeChecker_popScope(litaC_this);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_checker__TypeChecker_popScope(litaC_this);
                        
                        
                    }
                    
                } 
                
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_LABEL_STMT: {
            {
                litaC_ast__LabelStmt* litaC_labelStmt = (litaC_ast__LabelStmt*)litaC_stmt;
                if(litaC_labelStmt->label.type != litaC_lex__TokenType_IDENTIFIER) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_this->numOfLabels >= litaC_checker__MAX_LABELS) {
                    {
                        litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_labelStmt->stmt.node.startPos, "max number of labels reached");
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_this->numOfLabels;litaC_i += 1) {
                    {
                        litaC_checker__LabelInfo* litaC_label = &(litaC_this->labels[litaC_i]);
                        if(litaC_string_view__StringView_equalsStringView(litaC_labelStmt->label.value.str, litaC_label->name)) {
                            {
                                litaC_label->defined = litaC_true;
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                litaC_checker__LabelInfo* litaC_labelName = &(litaC_this->labels[litaC_this->numOfLabels]);
                litaC_labelName->name = litaC_labelStmt->label.value.str;
                litaC_labelName->defined = litaC_true;
                litaC_labelName->stmt = NULL;
                litaC_this->numOfLabels += 1;
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_MODULE_STMT: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NOTE_STMT: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_PARAMETERS_STMT: {
            {
                litaC_ast__ParametersStmt* litaC_params = (litaC_ast__ParametersStmt*)litaC_stmt;
                litaC_bool litaC_hasDefault = litaC_false;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_params->params)));litaC_i += 1) {
                    {
                        litaC_ast__ParameterDecl* litaC_param = litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_params->params)), litaC_i);
                        if(!(litaC_checker_decl__TypeChecker_resolveParamDecl(litaC_this, litaC_param))) {
                            {
                                return litaC_false;
                                
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_param->defaultExpr) {
                            {
                                litaC_hasDefault = litaC_true;
                                
                                
                            }
                            
                        } else {
                            if(litaC_hasDefault) {
                                {
                                    litaC_ast__FuncDecl* litaC_parentDecl = (litaC_ast__FuncDecl*)litaC_params->stmt.node.parent;
                                    assert(litaC_parentDecl != NULL);
                                    assert(litaC_parentDecl->decl.declaration.stmt.node.kind == litaC_ast__StmtKind_FUNC_DECL);
                                    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_parentDecl->decl.declaration.stmt.node.startPos, "'%.*s' must have default arguments defined last", litaC_parentDecl->decl.declaration.name.value.str.length, litaC_parentDecl->decl.declaration.name.value.str.buffer);
                                    return litaC_false;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                        } 
                        
                        
                        
                    }
                }
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_RETURN_STMT: {
            {
                litaC_ast__ReturnStmt* litaC_ret = (litaC_ast__ReturnStmt*)litaC_stmt;
                litaC_types__FuncTypeInfo* litaC_currentFuncDecl = litaC_array__Array_last_cb__ptr_FuncTypeInfo_ce_(&((litaC_this->funcDeclStack)));
                if(litaC_ret->expr) {
                    {
                        if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_ret->expr))) {
                            {
                                return litaC_false;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_ret->expr = litaC_checker_expr__TypeChecker_coerceTypeWithUsing(litaC_this, litaC_ret->expr, litaC_ret->expr->operand.typeInfo, litaC_currentFuncDecl->returnType);
                        litaC_checker__TypeChecker_checkTypeCompatibility(litaC_this, litaC_ret->expr->stmt.node.startPos, litaC_currentFuncDecl->returnType, litaC_ret->expr->operand.typeInfo);
                        litaC_ret->expr->expectedType = litaC_currentFuncDecl->returnType;
                        
                        
                    }
                    
                } else {
                    {
                        litaC_checker__TypeChecker_checkTypeCompatibility(litaC_this, litaC_ret->stmt.node.startPos, litaC_currentFuncDecl->returnType, &(litaC_types__VOID_TYPE));
                        
                        
                    }
                } 
                
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SWITCH_CASE_STMT: {
            {
                litaC_ast__SwitchCaseStmt* litaC_caseStmt = (litaC_ast__SwitchCaseStmt*)litaC_stmt;
                if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_caseStmt->cond))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_caseStmt->body))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SWITCH_STMT: {
            {
                litaC_ast__SwitchStmt* litaC_switchStmt = (litaC_ast__SwitchStmt*)litaC_stmt;
                if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_switchStmt->cond))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_SwitchCaseStmt_ce_(&((litaC_switchStmt->cases)));litaC_i += 1) {
                    {
                        litaC_ast__SwitchCaseStmt* litaC_caseStmt = litaC_array__Array_get_cb__ptr_SwitchCaseStmt_ce_(&((litaC_switchStmt->cases)), litaC_i);
                        if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, &((litaC_caseStmt->stmt))))) {
                            {
                                return litaC_false;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                if(litaC_switchStmt->defaultStmt) {
                    {
                        if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_switchStmt->defaultStmt))) {
                            {
                                return litaC_false;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_FIELD_DECL: 
        case litaC_ast__StmtKind_ENUM_FIELD_ENTRY_DECL: 
        case litaC_ast__StmtKind_STRUCT_FIELD_DECL: 
        case litaC_ast__StmtKind_UNION_FIELD_DECL: 
        case litaC_ast__StmtKind_TRAIT_FIELD_DECL: 
        case litaC_ast__StmtKind_VAR_FIELD_DECL: {
            {
                assert(litaC_false);
                return litaC_false;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_WHILE_STMT: {
            {
                litaC_ast__WhileStmt* litaC_whileStmt = (litaC_ast__WhileStmt*)litaC_stmt;
                if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_whileStmt->cond))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                litaC_checker__TypeChecker_pushScope(litaC_this, &((litaC_symbols__Scope) {
                    
                }));
                
                if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_whileStmt->body))) {
                    {
                        {
                            litaC_bool ___result = litaC_false;
                            litaC_checker__TypeChecker_popScope(litaC_this);
                            return ___result;
                            
                        }
                        
                        
                        
                    }
                    
                } 
                
                {
                    litaC_bool ___result = litaC_true;
                    litaC_checker__TypeChecker_popScope(litaC_this);
                    return ___result;
                    
                }
                
                litaC_checker__TypeChecker_popScope(litaC_this);
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ARRAY_DESIGNATION_EXPR: 
        case litaC_ast__StmtKind_ARRAY_INIT_EXPR: 
        case litaC_ast__StmtKind_BINARY_EXPR: 
        case litaC_ast__StmtKind_BOOLEAN_EXPR: 
        case litaC_ast__StmtKind_CAST_EXPR: 
        case litaC_ast__StmtKind_CHAR_EXPR: 
        case litaC_ast__StmtKind_FUNC_CALL_EXPR: 
        case litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR: 
        case litaC_ast__StmtKind_GET_EXPR: 
        case litaC_ast__StmtKind_GROUP_EXPR: 
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: 
        case litaC_ast__StmtKind_INIT_EXPR: 
        case litaC_ast__StmtKind_INIT_ARG_EXPR: 
        case litaC_ast__StmtKind_NULL_EXPR: 
        case litaC_ast__StmtKind_NUMBER_EXPR: 
        case litaC_ast__StmtKind_OFFSET_OF_EXPR: 
        case litaC_ast__StmtKind_SET_EXPR: 
        case litaC_ast__StmtKind_SIZE_OF_EXPR: 
        case litaC_ast__StmtKind_STRING_EXPR: 
        case litaC_ast__StmtKind_SUBSCRIPT_GET_EXPR: 
        case litaC_ast__StmtKind_SUBSCRIPT_SET_EXPR: 
        case litaC_ast__StmtKind_TERNARY_EXPR: 
        case litaC_ast__StmtKind_TYPE_IDENTIFIER_EXPR: 
        case litaC_ast__StmtKind_TYPE_OF_EXPR: 
        case litaC_ast__StmtKind_UNARY_EXPR: 
        case litaC_ast__StmtKind_POISON_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, (litaC_ast__Expr*)litaC_stmt);
                
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_u32 litaC_types_new__Hash(litaC_types_new__ArrayEntry litaC_a) {
    litaC_u32 litaC_add = 3;
    if(litaC_a.arrayOf) {
        {
            litaC_add += (litaC_u32)((litaC_usize)(litaC_a.arrayOf) >> 7);
            
            
        }
        
    } 
    
    litaC_add += (litaC_u32)litaC_a.length;
    return litaC_add;
    
    
}

litaC_bool litaC_types_new__Equals(litaC_types_new__ArrayEntry litaC_a,litaC_types_new__ArrayEntry litaC_b) {
    if(litaC_a.arrayOf && !(litaC_b.arrayOf)) {
        return litaC_false;
        
        
    } 
    
    if(!(litaC_a.arrayOf) && litaC_b.arrayOf) {
        return litaC_false;
        
        
    } 
    
    if(litaC_a.arrayOf && litaC_b.arrayOf) {
        {
            if(litaC_a.arrayOf->typeid != litaC_b.arrayOf->typeid) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    return litaC_a.length == litaC_b.length;
    
    
}

litaC_void litaC_types_new__TypeCache_init(litaC_types_new__TypeCache* litaC_this,const litaC_mem__Allocator* litaC_allocator) {
    litaC_this->allocator = litaC_allocator;
    litaC_map__Map_init_cb_i64_c__ptr_ConstTypeInfo_ce_(&((litaC_this->constCache)), NULL, 1024, litaC_map__PtrHashFn_cb_i64_ce_, litaC_map__PtrEqualFn_cb_i64_ce_, litaC_allocator, 0);
    litaC_map__Map_init_cb_i64_c__ptr_PtrTypeInfo_ce_(&((litaC_this->ptrCache)), NULL, 1024, litaC_map__PtrHashFn_cb_i64_ce_, litaC_map__PtrEqualFn_cb_i64_ce_, litaC_allocator, 0);
    litaC_map__Map_init_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(&((litaC_this->arrayCache)), NULL, 512, litaC_types_new__Hash, litaC_types_new__Equals, litaC_allocator, (litaC_types_new__ArrayEntry) {
        .expr = NULL,
        .arrayOf = NULL,
        .length = 0
    });
    litaC_map__Map_init_cb__ptr_const_char_c__ptr_TypeInfo_ce_(&((litaC_this->genericCache)), NULL, 128, litaC_map__StrHashFn, litaC_map__StrEqualFn, litaC_allocator, 0);
    
}

litaC_types__TypeInfo* litaC_types_new__TypeCache_newGenericParamTypeInfo(litaC_types_new__TypeCache* litaC_this,const litaC_char* litaC_name) {
    litaC_types__TypeInfo* litaC_type = litaC_map__Map_get_cb__ptr_const_char_c__ptr_TypeInfo_ce_(&((litaC_this->genericCache)), litaC_name);
    if(!(litaC_type)) {
        {
            litaC_type = litaC_mem__new_cb_TypeInfo_ce_(litaC_this->allocator);
            litaC_type->kind = litaC_types__TypeKind_GENERIC_PARAM;
            litaC_type->typeid = litaC_types__NextTypeId();
            litaC_type->name = litaC_name;
            litaC_type->sym = NULL;
            litaC_map__Map_put_cb__ptr_const_char_c__ptr_TypeInfo_ce_(&((litaC_this->genericCache)), litaC_name, litaC_type);
            
            
        }
        
    } 
    
    return litaC_type;
    
    
}

litaC_types__FuncTypeInfo* litaC_types_new__TypeCache_newFuncTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_symbols__Symbol* litaC_sym,litaC_ast__FuncDecl* litaC_funcDecl) {
    litaC_types__FuncTypeInfo* litaC_type = litaC_mem__new_cb_FuncTypeInfo_ce_(litaC_this->allocator);
    litaC_type->info.typeInfo.kind = litaC_types__TypeKind_FUNC;
    litaC_type->info.typeInfo.typeid = litaC_types__NextTypeId();
    litaC_type->info.typeInfo.name = litaC_sym->name;
    litaC_type->info.typeInfo.sym = litaC_sym;
    litaC_type->decl = litaC_funcDecl;
    litaC_type->returnType = NULL;
    return litaC_type;
    
    
}

litaC_types__ArrayTypeInfo* litaC_types_new__TypeCache_newArrayTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_types__TypeInfo* litaC_arrayOf,litaC_usize litaC_length,litaC_ast__Expr* litaC_numOfElements,litaC_bool litaC_isLengthDefined) {
    litaC_types_new__ArrayEntry litaC_entry =  {
        .arrayOf = litaC_arrayOf,
        .expr = litaC_numOfElements,
        .length = litaC_length
    };
    litaC_types__ArrayTypeInfo* litaC_type = litaC_map__Map_get_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(&((litaC_this->arrayCache)), litaC_entry);
    if(!(litaC_type) || litaC_type->length != litaC_length || litaC_type->isLengthDefined != litaC_isLengthDefined || litaC_type->numOfElements != litaC_numOfElements) {
        {
            litaC_type = litaC_mem__new_cb_ArrayTypeInfo_ce_(litaC_this->allocator);
            litaC_type->info.kind = litaC_types__TypeKind_ARRAY;
            litaC_type->info.typeid = litaC_types__NextTypeId();
            litaC_type->arrayOf = litaC_arrayOf;
            litaC_type->length = litaC_length;
            litaC_type->numOfElements = litaC_numOfElements;
            litaC_type->isLengthDefined = litaC_isLengthDefined;
            litaC_map__Map_put_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(&((litaC_this->arrayCache)), litaC_entry, litaC_type);
            
            
        }
        
    } 
    
    return litaC_type;
    
    
}

litaC_types__FuncPtrTypeInfo* litaC_types_new__TypeCache_newFuncPtrTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_types__TypeInfo* litaC_returnType,litaC_array__Array_cb__ptr_TypeInfo_ce_ litaC_paramDecls,litaC_bool litaC_hasVarargs) {
    litaC_types__FuncPtrTypeInfo* litaC_type = litaC_mem__new_cb_FuncPtrTypeInfo_ce_(litaC_this->allocator);
    litaC_type->info.typeInfo.kind = litaC_types__TypeKind_FUNC_PTR;
    litaC_type->info.typeInfo.typeid = litaC_types__NextTypeId();
    litaC_type->genericParams = litaC_genericParams;
    litaC_type->returnType = litaC_returnType;
    litaC_type->paramDecls = litaC_paramDecls;
    litaC_type->hasVarargs = litaC_hasVarargs;
    return litaC_type;
    
    
}

litaC_types__AggregateTypeInfo* litaC_types_new__TypeCache_newAggregateTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_symbols__Symbol* litaC_sym,litaC_ast__AggregateDecl* litaC_aggregateDecl) {
    litaC_types__AggregateTypeInfo* litaC_type = litaC_mem__new_cb_AggregateTypeInfo_ce_(litaC_this->allocator);
    switch(litaC_aggregateDecl->decl.declaration.stmt.node.kind) {
        case litaC_ast__StmtKind_TRAIT_DECL: {
            {
                litaC_type->info.typeInfo.kind = litaC_types__TypeKind_TRAIT;
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNION_DECL: {
            {
                litaC_type->info.typeInfo.kind = litaC_types__TypeKind_UNION;
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_STRUCT_DECL: {
            {
                litaC_type->info.typeInfo.kind = litaC_types__TypeKind_STRUCT;
                break;
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    litaC_type->info.typeInfo.typeid = litaC_types__NextTypeId();
    litaC_type->info.typeInfo.name = litaC_sym->name;
    litaC_type->decl = litaC_aggregateDecl;
    litaC_type->info.typeInfo.sym = litaC_sym;
    return litaC_type;
    
    
}

litaC_types__EnumTypeInfo* litaC_types_new__TypeCache_newEnumTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_symbols__Symbol* litaC_sym,litaC_ast__EnumDecl* litaC_enumDecl) {
    litaC_types__EnumTypeInfo* litaC_type = litaC_mem__new_cb_EnumTypeInfo_ce_(litaC_this->allocator);
    litaC_type->info.kind = litaC_types__TypeKind_ENUM;
    litaC_type->info.typeid = litaC_types__NextTypeId();
    litaC_type->info.name = litaC_sym->name;
    litaC_type->decl = litaC_enumDecl;
    litaC_type->info.sym = litaC_sym;
    return litaC_type;
    
    
}

litaC_types__TypeInfo* litaC_types_new__TypeCache_newForeignTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_symbols__Symbol* litaC_sym) {
    litaC_types__TypeInfo* litaC_type = litaC_mem__new_cb_TypeInfo_ce_(litaC_this->allocator);
    litaC_type->kind = litaC_types__TypeKind_I64;
    litaC_type->typeid = litaC_types__NextTypeId();
    litaC_type->name = litaC_sym->name;
    litaC_type->sym = litaC_sym;
    return litaC_type;
    
    
}

litaC_types__ConstTypeInfo* litaC_types_new__TypeCache_newConstTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_types__TypeInfo* litaC_base) {
    if(litaC_base->kind == litaC_types__TypeKind_CONST) {
        {
            return (litaC_types__ConstTypeInfo*)litaC_base;
            
            
            
        }
        
    } 
    
    litaC_types__ConstTypeInfo* litaC_type = litaC_map__Map_get_cb_i64_c__ptr_ConstTypeInfo_ce_(&((litaC_this->constCache)), litaC_base->typeid);
    if(!(litaC_type)) {
        {
            litaC_type = litaC_mem__new_cb_ConstTypeInfo_ce_(litaC_this->allocator);
            litaC_type->info.kind = litaC_types__TypeKind_CONST;
            litaC_type->info.typeid = litaC_types__NextTypeId();
            litaC_type->constOf = litaC_base;
            litaC_map__Map_put_cb_i64_c__ptr_ConstTypeInfo_ce_(&((litaC_this->constCache)), litaC_base->typeid, litaC_type);
            
            
        }
        
    } 
    
    return litaC_type;
    
    
}

litaC_types__PtrTypeInfo* litaC_types_new__TypeCache_newPtrTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_types__TypeInfo* litaC_base) {
    litaC_types__PtrTypeInfo* litaC_type = litaC_map__Map_get_cb_i64_c__ptr_PtrTypeInfo_ce_(&((litaC_this->ptrCache)), litaC_base->typeid);
    if(!(litaC_type)) {
        {
            litaC_type = litaC_mem__new_cb_PtrTypeInfo_ce_(litaC_this->allocator);
            litaC_type->info.kind = litaC_types__TypeKind_PTR;
            litaC_type->info.typeid = litaC_types__NextTypeId();
            litaC_type->ptrOf = litaC_base;
            litaC_map__Map_put_cb_i64_c__ptr_PtrTypeInfo_ce_(&((litaC_this->ptrCache)), litaC_base->typeid, litaC_type);
            
            
        }
        
    } 
    
    return litaC_type;
    
    
}

litaC_types__TypeInfo* litaC_types_new__TypeCache_typeDecay(litaC_types_new__TypeCache* litaC_this,litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        return NULL;
        
        
    } 
    
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__ArrayTypeInfo* litaC_arrayInfo = (litaC_types__ArrayTypeInfo*)litaC_type;
                return (litaC_types__TypeInfo*)litaC_types_new__TypeCache_newPtrTypeInfo(litaC_this, litaC_types_new__TypeCache_typeDecay(litaC_this, litaC_arrayInfo->arrayOf));
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC: {
            {
                litaC_types__FuncTypeInfo* litaC_funcInfo = (litaC_types__FuncTypeInfo*)litaC_type;
                return (litaC_types__TypeInfo*)litaC_types__FuncTypeInfo_asPtr(litaC_funcInfo, litaC_this);
                
                
                
            }
            
            
        }
        default: {
            {
                return litaC_type;
                
                
                
            }
            
            
        }
    }
    
}

litaC_void litaC_ast_print__PrintTypeSpec(litaC_ast__TypeSpec* litaC_spec) {
    if(litaC_spec == NULL) {
        {
            return;
            
            
            
        }
        
    } 
    
    switch(litaC_spec->kind) {
        case litaC_ast__TypeSpecKind_NONE: {
            {
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_ARRAY: {
            {
                litaC_ast__ArrayTypeSpec* litaC_array = (litaC_ast__ArrayTypeSpec*)litaC_spec;
                printf("[");
                if(litaC_array->numElements) {
                    {
                        litaC_ast_print__PrintStmt(&((litaC_array->numElements->stmt)), 0);
                        
                        
                    }
                    
                } 
                
                printf("]");
                litaC_ast_print__PrintTypeSpec(litaC_array->spec.base);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_PTR: {
            {
                litaC_ast__PtrTypeSpec* litaC_ptr = (litaC_ast__PtrTypeSpec*)litaC_spec;
                printf("*");
                litaC_ast_print__PrintTypeSpec(litaC_ptr->spec.base);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_CONST: {
            {
                litaC_ast__ConstTypeSpec* litaC_c = (litaC_ast__ConstTypeSpec*)litaC_spec;
                printf("const ");
                litaC_ast_print__PrintTypeSpec(litaC_c->spec.base);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_NAME: {
            {
                litaC_ast__NameTypeSpec* litaC_name = (litaC_ast__NameTypeSpec*)litaC_spec;
                printf("%s", litaC_name->name);
                if(!(litaC_array__Array_empty_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs))))) {
                    {
                        printf("<");
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    printf(",");
                                    
                                } 
                                
                                litaC_ast_print__PrintTypeSpec(litaC_array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)), litaC_i));
                                
                                
                            }
                        }
                        printf(">");
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_FUNC_PTR: {
            {
                litaC_ast__FuncPtrTypeSpec* litaC_fn = (litaC_ast__FuncPtrTypeSpec*)litaC_spec;
                printf("func");
                if(!(litaC_array__Array_empty_cb_GenericParam_ce_(&((litaC_fn->genericParams))))) {
                    {
                        printf("<");
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_fn->genericParams)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    {
                                        printf(",");
                                        
                                        
                                    }
                                    
                                } 
                                
                                litaC_ast_print__PrintName(litaC_array__Array_get_cb_GenericParam_ce_(&((litaC_fn->genericParams)), litaC_i).name);
                                
                                
                            }
                        }
                        printf(">");
                        
                        
                    }
                    
                } 
                
                printf("(");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_fn->args)));litaC_i += 1) {
                    {
                        if(litaC_i > 0) {
                            printf(",");
                            
                        } 
                        
                        litaC_ast_print__PrintTypeSpec(litaC_array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_fn->args)), litaC_i));
                        
                        
                    }
                }
                printf(") : ");
                litaC_ast_print__PrintTypeSpec(litaC_fn->ret);
                return;
                
                
                
            }
            
            
        }
        default: {
            {
                litaC_common__Panic("Invalid TypeSpecKind: '%d'\n", litaC_spec->kind);
                
                
            }
            
            
        }
    }
    
}

litaC_void litaC_ast_print__PrintName(litaC_lex__Token litaC_tok) {
    if(litaC_tok.type != litaC_lex__TokenType_ERROR) {
        {
            printf("%.*s", litaC_tok.value.str.length, litaC_tok.value.str.buffer);
            
            
        }
        
    } 
    
    
}

litaC_void litaC_ast_print__Printf(litaC_i32 litaC_indent,const litaC_char* litaC_format,...) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_indent;litaC_i += 1) {
        {
            printf("    ");
            
            
        }
    }
    va_list litaC_args;
    va_start(litaC_args, litaC_format);
    vprintf(litaC_format, litaC_args);
    va_end(litaC_args);
    
}

litaC_void litaC_ast_print__PrintStmt(litaC_ast__Stmt* litaC_s,litaC_i32 litaC_indent) {
    if(!(litaC_s)) {
        return;
        
        
    } 
    
    switch(litaC_s->node.kind) {
        case litaC_ast__StmtKind_IMPORT_DECL: {
            {
                litaC_ast__ImportDecl* litaC_decl = (litaC_ast__ImportDecl*)litaC_s;
                litaC_ast_print__Printf(0, "import '");
                litaC_ast_print__PrintName(litaC_decl->decl.name);
                printf("'");
                if(litaC_decl->alias.type == litaC_lex__TokenType_IDENTIFIER) {
                    {
                        litaC_ast_print__Printf(0, " as ");
                        litaC_ast_print__PrintName(litaC_decl->alias);
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONST_DECL: 
        case litaC_ast__StmtKind_VAR_DECL: {
            {
                litaC_ast__VarDecl* litaC_decl = (litaC_ast__VarDecl*)litaC_s;
                if(!(litaC_array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.attributes.notes))))) {
                    {
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.attributes.notes)));litaC_i += 1) {
                            {
                                litaC_ast_print__PrintStmt(&((litaC_array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.attributes.notes)), litaC_i)->stmt)), litaC_indent);
                                printf("\n");
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                if(litaC_decl->decl.stmt.node.kind == litaC_ast__StmtKind_CONST_DECL) {
                    {
                        litaC_ast_print__Printf(litaC_indent, "const ");
                        
                        
                    }
                    
                } else {
                    {
                        litaC_ast_print__Printf(litaC_indent, "var ");
                        
                        
                    }
                } 
                
                litaC_ast_print__PrintName(litaC_decl->decl.name);
                if(litaC_decl->typeSpec != NULL) {
                    {
                        printf(": ");
                        litaC_ast_print__PrintTypeSpec(litaC_decl->typeSpec);
                        
                        
                    }
                    
                } 
                
                if(litaC_decl->expr != NULL) {
                    {
                        printf(" = ");
                        litaC_ast_print__PrintStmt(&((litaC_decl->expr->stmt)), 0);
                        
                        
                    }
                    
                } 
                
                printf(";");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_STRUCT_DECL: {
            {
                litaC_ast__AggregateDecl* litaC_decl = (litaC_ast__AggregateDecl*)litaC_s;
                if(!(litaC_array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes))))) {
                    {
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes)));litaC_i += 1) {
                            {
                                litaC_ast_print__PrintStmt(&((litaC_array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes)), litaC_i)->stmt)), litaC_indent);
                                printf("\n");
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                litaC_ast_print__Printf(litaC_indent, "");
                if(litaC_decl->decl.declaration.attributes.isPublic) {
                    {
                        printf("public ");
                        
                        
                    }
                    
                } 
                
                printf("struct ");
                litaC_ast_print__PrintName(litaC_decl->decl.declaration.name);
                if(!(litaC_array__Array_empty_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams))))) {
                    {
                        printf("<");
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    litaC_ast_print__Printf(litaC_indent, ",");
                                    
                                } 
                                
                                litaC_lex__Token litaC_t = litaC_array__Array_get_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams)), litaC_i).name;
                                printf("%.*s", litaC_t.value.str.length, litaC_t.value.str.buffer);
                                
                                
                            }
                        }
                        printf(">");
                        
                        
                    }
                    
                } 
                
                printf(" {\n");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_decl->fields)));litaC_i += 1) {
                    {
                        litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_decl->fields)), litaC_i);
                        switch(litaC_field.kind) {
                            case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                                {
                                    litaC_ast_print__PrintStmt((litaC_ast__Stmt*)litaC_field.enumField, litaC_indent + 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_STRUCT_FIELD_DECL: 
                            case litaC_ast__StmtKind_UNION_FIELD_DECL: {
                                {
                                    litaC_ast_print__PrintStmt((litaC_ast__Stmt*)litaC_field.aggregateField, litaC_indent + 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                                {
                                    litaC_ast_print__PrintStmt(&((litaC_field.varField->decl.stmt)), litaC_indent + 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                                {
                                    litaC_ast_print__PrintStmt(&((litaC_field.traitField->decl.stmt)), litaC_indent + 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            default: {
                                {
                                    
                                    
                                }
                                
                                
                            }
                        }
                        printf("\n");
                        
                        
                    }
                }
                litaC_ast_print__Printf(litaC_indent, "}");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNION_DECL: {
            {
                litaC_ast__AggregateDecl* litaC_decl = (litaC_ast__AggregateDecl*)litaC_s;
                if(!(litaC_array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes))))) {
                    {
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes)));litaC_i += 1) {
                            {
                                litaC_ast_print__PrintStmt(&((litaC_array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes)), litaC_i)->stmt)), litaC_indent);
                                printf("\n");
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                litaC_ast_print__Printf(litaC_indent, "");
                if(litaC_decl->decl.declaration.attributes.isPublic) {
                    {
                        printf("public ");
                        
                        
                    }
                    
                } 
                
                printf("union ");
                litaC_ast_print__PrintName(litaC_decl->decl.declaration.name);
                if(!(litaC_array__Array_empty_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams))))) {
                    {
                        printf("<");
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    litaC_ast_print__Printf(litaC_indent, ",");
                                    
                                } 
                                
                                litaC_lex__Token litaC_t = litaC_array__Array_get_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams)), litaC_i).name;
                                printf("%.*s", litaC_t.value.str.length, litaC_t.value.str.buffer);
                                
                                
                            }
                        }
                        printf(">");
                        
                        
                    }
                    
                } 
                
                printf(" {\n");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_decl->fields)));litaC_i += 1) {
                    {
                        litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_decl->fields)), litaC_i);
                        switch(litaC_field.kind) {
                            case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                                {
                                    litaC_ast_print__PrintStmt((litaC_ast__Stmt*)litaC_field.enumField, litaC_indent + 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_STRUCT_FIELD_DECL: 
                            case litaC_ast__StmtKind_UNION_FIELD_DECL: {
                                {
                                    litaC_ast_print__PrintStmt((litaC_ast__Stmt*)litaC_field.aggregateField, litaC_indent + 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                                {
                                    litaC_ast_print__PrintStmt(&((litaC_field.varField->decl.stmt)), litaC_indent + 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                                {
                                    litaC_ast_print__PrintStmt(&((litaC_field.traitField->decl.stmt)), litaC_indent + 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            default: {
                                {
                                    
                                    
                                }
                                
                                
                            }
                        }
                        printf("\n");
                        
                        
                    }
                }
                litaC_ast_print__Printf(litaC_indent, "}");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TRAIT_DECL: {
            {
                litaC_ast__AggregateDecl* litaC_decl = (litaC_ast__AggregateDecl*)litaC_s;
                if(!(litaC_array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes))))) {
                    {
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes)));litaC_i += 1) {
                            {
                                litaC_ast_print__PrintStmt(&((litaC_array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes)), litaC_i)->stmt)), litaC_indent);
                                printf("\n");
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                litaC_ast_print__Printf(litaC_indent, "");
                if(litaC_decl->decl.declaration.attributes.isPublic) {
                    {
                        printf("public ");
                        
                        
                    }
                    
                } 
                
                printf("trait ");
                litaC_ast_print__PrintName(litaC_decl->decl.declaration.name);
                if(!(litaC_array__Array_empty_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams))))) {
                    {
                        printf("<");
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    litaC_ast_print__Printf(litaC_indent, ",");
                                    
                                } 
                                
                                litaC_lex__Token litaC_t = litaC_array__Array_get_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams)), litaC_i).name;
                                printf("%.*s", litaC_t.value.str.length, litaC_t.value.str.buffer);
                                
                                
                            }
                        }
                        printf(">");
                        
                        
                    }
                    
                } 
                
                printf(" {\n");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_decl->fields)));litaC_i += 1) {
                    {
                        litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_decl->fields)), litaC_i);
                        switch(litaC_field.kind) {
                            case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                                {
                                    litaC_ast_print__PrintStmt((litaC_ast__Stmt*)litaC_field.traitField, litaC_indent + 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            default: {
                                {
                                    
                                    
                                }
                                
                                
                            }
                        }
                        printf("\n");
                        
                        
                    }
                }
                litaC_ast_print__Printf(litaC_indent, "}");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_DECL: {
            {
                litaC_ast__EnumDecl* litaC_decl = (litaC_ast__EnumDecl*)litaC_s;
                if(!(litaC_array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.attributes.notes))))) {
                    {
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.attributes.notes)));litaC_i += 1) {
                            {
                                litaC_ast_print__PrintStmt(&((litaC_array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.attributes.notes)), litaC_i)->stmt)), litaC_indent);
                                printf("\n");
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                litaC_ast_print__Printf(litaC_indent, "");
                if(litaC_decl->decl.attributes.isPublic) {
                    {
                        printf("public ");
                        
                        
                    }
                    
                } 
                
                printf("enum ");
                litaC_ast_print__PrintName(litaC_decl->decl.name);
                printf(" {\n");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_decl->fields)));litaC_i += 1) {
                    {
                        litaC_ast__EnumFieldEntryDecl* litaC_field = litaC_array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_decl->fields)), litaC_i);
                        litaC_ast_print__PrintStmt(&((litaC_field->decl.stmt)), litaC_indent + 1);
                        printf(",\n");
                        
                        
                    }
                }
                litaC_ast_print__Printf(litaC_indent, "}");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                litaC_ast__FuncDecl* litaC_decl = (litaC_ast__FuncDecl*)litaC_s;
                if(!(litaC_array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes))))) {
                    {
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes)));litaC_i += 1) {
                            {
                                litaC_ast_print__PrintStmt(&((litaC_array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes)), litaC_i)->stmt)), litaC_indent);
                                printf("\n");
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                if(litaC_decl->decl.declaration.attributes.isPublic) {
                    {
                        litaC_ast_print__Printf(litaC_indent, "public ");
                        
                        
                    }
                    
                } 
                
                litaC_ast_print__Printf(litaC_indent, "func ");
                litaC_ast_print__PrintName(litaC_decl->decl.declaration.name);
                if(!(litaC_array__Array_empty_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams))))) {
                    {
                        litaC_ast_print__Printf(litaC_indent, "<");
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    litaC_ast_print__Printf(litaC_indent, ",");
                                    
                                } 
                                
                                litaC_lex__Token litaC_t = litaC_array__Array_get_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams)), litaC_i).name;
                                litaC_ast_print__Printf(litaC_indent, "%.*s", litaC_t.value.str.length, litaC_t.value.str.buffer);
                                
                                
                            }
                        }
                        litaC_ast_print__Printf(litaC_indent, ">");
                        
                        
                    }
                    
                } 
                
                litaC_ast_print__Printf(litaC_indent, "(");
                if(litaC_decl->params) {
                    {
                        litaC_ast_print__PrintStmt(&((litaC_decl->params->stmt)), 0);
                        
                        
                    }
                    
                } 
                
                litaC_ast_print__Printf(litaC_indent, ")");
                if(litaC_decl->returnType) {
                    {
                        litaC_ast_print__Printf(litaC_indent, " : ");
                        litaC_ast_print__PrintTypeSpec(litaC_decl->returnType);
                        
                        
                    }
                    
                } 
                
                if(litaC_decl->body) {
                    {
                        printf("\n");
                        litaC_ast_print__PrintStmt(litaC_decl->body, litaC_indent);
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            {
                litaC_ast__TypedefDecl* litaC_decl = (litaC_ast__TypedefDecl*)litaC_s;
                if(!(litaC_array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes))))) {
                    {
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes)));litaC_i += 1) {
                            {
                                litaC_ast_print__PrintStmt(&((litaC_array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes)), litaC_i)->stmt)), litaC_indent);
                                printf("\n");
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                if(litaC_decl->decl.declaration.attributes.isPublic) {
                    {
                        litaC_ast_print__Printf(litaC_indent, "public ");
                        
                        
                    }
                    
                } 
                
                litaC_ast_print__Printf(litaC_indent, "typedef ");
                litaC_ast_print__PrintTypeSpec(litaC_decl->type);
                printf(" as ");
                litaC_ast_print__PrintName(litaC_decl->decl.declaration.name);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_PARAM_DECL: {
            {
                litaC_ast__ParameterDecl* litaC_decl = (litaC_ast__ParameterDecl*)litaC_s;
                if(!(litaC_array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.attributes.notes))))) {
                    {
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.attributes.notes)));litaC_i += 1) {
                            {
                                litaC_ast_print__PrintStmt(&((litaC_array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.attributes.notes)), litaC_i)->stmt)), litaC_indent);
                                printf("\n");
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                litaC_ast_print__PrintName(litaC_decl->decl.name);
                litaC_ast_print__Printf(litaC_indent, ": ");
                litaC_ast_print__PrintTypeSpec(litaC_decl->type);
                if(litaC_decl->defaultExpr) {
                    {
                        litaC_ast_print__Printf(litaC_indent, " = ");
                        litaC_ast_print__PrintStmt(&((litaC_decl->defaultExpr->stmt)), 0);
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_DECL: {
            {
                litaC_ast_print__Printf(litaC_indent, "<poison_decl>");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BLOCK_STMT: {
            {
                litaC_ast__BlockStmt* litaC_stmt = (litaC_ast__BlockStmt*)litaC_s;
                litaC_ast_print__Printf(litaC_indent - 1, "{\n");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)));litaC_i += 1) {
                    {
                        litaC_ast__Stmt* litaC_n = litaC_array__Array_get_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)), litaC_i);
                        litaC_ast_print__PrintStmt(litaC_n, litaC_indent + 1);
                        if(litaC_ast__IsExpr(&((litaC_n->node)))) {
                            {
                                printf(";\n");
                                
                                
                            }
                            
                        } else {
                            {
                                printf("\n");
                                
                                
                            }
                        } 
                        
                        
                        
                    }
                }
                printf("\n");
                litaC_ast_print__Printf(litaC_indent - 1, "}");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BREAK_STMT: {
            {
                litaC_ast_print__Printf(litaC_indent, "break");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONTINUE_STMT: {
            {
                litaC_ast_print__Printf(litaC_indent, "continue");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DEFER_STMT: {
            {
                litaC_ast__DeferStmt* litaC_stmt = (litaC_ast__DeferStmt*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "defer ");
                litaC_ast_print__PrintStmt(litaC_stmt->deferedStmt, litaC_indent);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DO_WHILE_STMT: {
            {
                litaC_ast__DoWhileStmt* litaC_stmt = (litaC_ast__DoWhileStmt*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "do\n");
                litaC_ast_print__PrintStmt(litaC_stmt->body, litaC_indent + 1);
                litaC_ast_print__Printf(litaC_indent, "\nwhile(");
                litaC_ast_print__PrintStmt(&((litaC_stmt->cond->stmt)), 0);
                litaC_ast_print__Printf(0, ")");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_EMPTY_STMT: {
            {
                printf("\n");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_FIELD_ENTRY_DECL: {
            {
                litaC_ast__EnumFieldEntryDecl* litaC_stmt = (litaC_ast__EnumFieldEntryDecl*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "");
                litaC_ast_print__PrintName(litaC_stmt->decl.name);
                if(litaC_stmt->value) {
                    {
                        printf(" = ");
                        litaC_ast_print__PrintStmt(&((litaC_stmt->value->stmt)), 0);
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FOR_STMT: {
            {
                litaC_ast__ForStmt* litaC_stmt = (litaC_ast__ForStmt*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "for(");
                if(litaC_stmt->init) {
                    {
                        litaC_ast_print__PrintStmt(litaC_stmt->init, 0);
                        
                        
                    }
                    
                } 
                
                printf(";");
                if(litaC_stmt->cond) {
                    {
                        litaC_ast_print__PrintStmt(&((litaC_stmt->cond->stmt)), 0);
                        
                        
                    }
                    
                } 
                
                printf(";");
                if(litaC_stmt->post) {
                    {
                        litaC_ast_print__PrintStmt(litaC_stmt->post, 0);
                        
                        
                    }
                    
                } 
                
                printf(")\n");
                if(litaC_stmt->body) {
                    {
                        litaC_ast_print__PrintStmt(litaC_stmt->body, litaC_indent + 1);
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_BODY_STMT: {
            {
                litaC_ast__FuncBodyStmt* litaC_stmt = (litaC_ast__FuncBodyStmt*)litaC_s;
                litaC_ast_print__Printf(litaC_indent - 1, "{\n");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)));litaC_i += 1) {
                    {
                        litaC_ast__Stmt* litaC_n = litaC_array__Array_get_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)), litaC_i);
                        litaC_ast_print__PrintStmt(litaC_n, litaC_indent + 1);
                        if(litaC_ast__IsExpr(&((litaC_n->node)))) {
                            {
                                printf(";\n");
                                
                                
                            }
                            
                        } else {
                            {
                                printf("\n");
                                
                                
                            }
                        } 
                        
                        
                        
                    }
                }
                printf("\n");
                litaC_ast_print__Printf(litaC_indent - 1, "}");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GOTO_STMT: {
            {
                litaC_ast__GotoStmt* litaC_stmt = (litaC_ast__GotoStmt*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "goto ");
                litaC_ast_print__PrintName(litaC_stmt->label);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IF_STMT: {
            {
                litaC_ast__IfStmt* litaC_stmt = (litaC_ast__IfStmt*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "if(");
                litaC_ast_print__PrintStmt(&((litaC_stmt->cond->stmt)), 0);
                printf(") \n");
                litaC_ast_print__PrintStmt(litaC_stmt->then, litaC_indent + 1);
                printf("\n");
                if(litaC_stmt->elseStmt) {
                    {
                        litaC_ast_print__Printf(litaC_indent, "else \n");
                        litaC_ast_print__PrintStmt(litaC_stmt->elseStmt, litaC_indent + 1);
                        
                        
                    }
                    
                } 
                
                printf("\n");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_LABEL_STMT: {
            {
                litaC_ast__LabelStmt* litaC_stmt = (litaC_ast__LabelStmt*)litaC_s;
                printf(":");
                litaC_ast_print__PrintName(litaC_stmt->label);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_MODULE_STMT: {
            {
                litaC_ast__ModuleStmt* litaC_stmt = (litaC_ast__ModuleStmt*)litaC_s;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_ImportDecl_ce_(&((litaC_stmt->imports)));litaC_i += 1) {
                    {
                        litaC_ast_print__PrintStmt((litaC_ast__Stmt*)litaC_array__Array_get_cb__ptr_ImportDecl_ce_(&((litaC_stmt->imports)), litaC_i), 0);
                        litaC_ast_print__Printf(litaC_indent, "\n");
                        
                        
                    }
                }
                printf("\n");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_stmt->notes)));litaC_i += 1) {
                    {
                        litaC_ast_print__PrintStmt(&((litaC_array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_stmt->notes)), litaC_i)->stmt)), 0);
                        litaC_ast_print__Printf(litaC_indent, ";\n");
                        
                        
                    }
                }
                printf("\n");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Decl_ce_(&((litaC_stmt->declarations)));litaC_i += 1) {
                    {
                        litaC_ast_print__PrintStmt((litaC_ast__Stmt*)litaC_array__Array_get_cb__ptr_Decl_ce_(&((litaC_stmt->declarations)), litaC_i), 0);
                        litaC_ast_print__Printf(litaC_indent, "\n");
                        printf("\n");
                        
                        
                    }
                }
                printf("\n");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NOTE_STMT: {
            {
                litaC_ast__NoteStmt* litaC_stmt = (litaC_ast__NoteStmt*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "@");
                litaC_ast_print__PrintName(litaC_stmt->name);
                if(!(litaC_array__Array_empty_cb_Token_ce_(&((litaC_stmt->attributes))))) {
                    {
                        printf("(");
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_Token_ce_(&((litaC_stmt->attributes)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    printf(", ");
                                    
                                } 
                                
                                printf("'");
                                litaC_ast_print__PrintName(litaC_array__Array_get_cb_Token_ce_(&((litaC_stmt->attributes)), litaC_i));
                                printf("'");
                                
                                
                            }
                        }
                        printf(")");
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_PARAMETERS_STMT: {
            {
                litaC_ast__ParametersStmt* litaC_stmt = (litaC_ast__ParametersStmt*)litaC_s;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_stmt->params)));litaC_i += 1) {
                    {
                        if(litaC_i > 0) {
                            printf(", ");
                            
                        } 
                        
                        litaC_ast_print__PrintStmt((litaC_ast__Stmt*)litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_stmt->params)), litaC_i), 0);
                        
                        
                    }
                }
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_RETURN_STMT: {
            {
                litaC_ast__ReturnStmt* litaC_stmt = (litaC_ast__ReturnStmt*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "return");
                if(litaC_stmt->expr) {
                    {
                        printf(" ");
                        litaC_ast_print__PrintStmt(&((litaC_stmt->expr->stmt)), 0);
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
            {
                litaC_ast__TraitFieldDecl* litaC_stmt = (litaC_ast__TraitFieldDecl*)litaC_s;
                if(!(litaC_array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_stmt->decl.attributes.notes))))) {
                    {
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_stmt->decl.attributes.notes)));litaC_i += 1) {
                            {
                                litaC_ast_print__PrintStmt(&((litaC_array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_stmt->decl.attributes.notes)), litaC_i)->stmt)), litaC_indent);
                                printf("\n");
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                litaC_ast_print__Printf(litaC_indent, "");
                litaC_ast_print__PrintName(litaC_stmt->decl.name);
                printf(": ");
                litaC_ast_print__PrintTypeSpec(litaC_stmt->type);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_VAR_FIELD_DECL: {
            {
                litaC_ast__VarFieldDecl* litaC_stmt = (litaC_ast__VarFieldDecl*)litaC_s;
                if(!(litaC_array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_stmt->decl.attributes.notes))))) {
                    {
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_stmt->decl.attributes.notes)));litaC_i += 1) {
                            {
                                litaC_ast_print__PrintStmt(&((litaC_array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_stmt->decl.attributes.notes)), litaC_i)->stmt)), litaC_indent);
                                printf("\n");
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                litaC_ast_print__Printf(litaC_indent, "");
                litaC_ast_print__PrintName(litaC_stmt->decl.name);
                printf(": ");
                litaC_ast_print__PrintTypeSpec(litaC_stmt->type);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_WHILE_STMT: {
            {
                litaC_ast__WhileStmt* litaC_stmt = (litaC_ast__WhileStmt*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "while(");
                litaC_ast_print__PrintStmt(&((litaC_stmt->cond->stmt)), 0);
                litaC_ast_print__Printf(0, ")\n");
                litaC_ast_print__PrintStmt(litaC_stmt->body, litaC_indent);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ARRAY_DESIGNATION_EXPR: {
            {
                litaC_ast__ArrayDesignationExpr* litaC_expr = (litaC_ast__ArrayDesignationExpr*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "[");
                litaC_ast_print__PrintStmt(&((litaC_expr->index->stmt)), 0);
                litaC_ast_print__Printf(0, "] = ");
                litaC_ast_print__PrintStmt(&((litaC_expr->value->stmt)), 0);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ARRAY_INIT_EXPR: {
            {
                litaC_ast__ArrayInitExpr* litaC_expr = (litaC_ast__ArrayInitExpr*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "[]");
                litaC_ast_print__PrintTypeSpec(litaC_expr->type);
                litaC_ast_print__Printf(0, "{\n");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Expr_ce_(&((litaC_expr->values)));litaC_i += 1) {
                    {
                        litaC_ast__Expr* litaC_v = litaC_array__Array_get_cb__ptr_Expr_ce_(&((litaC_expr->values)), litaC_i);
                        if(litaC_i > 0) {
                            litaC_ast_print__Printf(0, ",\n");
                            
                        } 
                        
                        litaC_ast_print__PrintStmt(&((litaC_v->stmt)), litaC_indent + 1);
                        
                        
                    }
                }
                litaC_ast_print__Printf(litaC_indent, "}\n");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BINARY_EXPR: {
            {
                litaC_ast__BinaryExpr* litaC_expr = (litaC_ast__BinaryExpr*)litaC_s;
                litaC_ast_print__PrintStmt(&((litaC_expr->left->stmt)), litaC_indent);
                printf(" %s ", litaC_lex__tokenText[litaC_expr->operator]);
                litaC_ast_print__PrintStmt(&((litaC_expr->right->stmt)), 0);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BOOLEAN_EXPR: {
            {
                litaC_ast__BooleanExpr* litaC_expr = (litaC_ast__BooleanExpr*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "%s", (litaC_expr->boolean) ? "true" : "false");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CHAR_EXPR: {
            {
                litaC_ast__CharExpr* litaC_expr = (litaC_ast__CharExpr*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "'%c'", (litaC_char)litaC_expr->character.value.intValue);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GET_EXPR: {
            {
                litaC_ast__GetExpr* litaC_expr = (litaC_ast__GetExpr*)litaC_s;
                litaC_ast_print__PrintStmt(&((litaC_expr->object->stmt)), litaC_indent);
                printf(".");
                litaC_ast_print__PrintStmt(&((litaC_expr->field->expr.stmt)), 0);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GROUP_EXPR: {
            {
                litaC_ast__GroupExpr* litaC_expr = (litaC_ast__GroupExpr*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "(");
                litaC_ast_print__PrintStmt(&((litaC_expr->groupedExpr->stmt)), 0);
                litaC_ast_print__Printf(0, ")");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: {
            {
                litaC_ast__IdentifierExpr* litaC_expr = (litaC_ast__IdentifierExpr*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "%s", litaC_expr->type->name);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NULL_EXPR: {
            {
                printf("null");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NUMBER_EXPR: {
            {
                litaC_ast__NumberExpr* litaC_expr = (litaC_ast__NumberExpr*)litaC_s;
                switch(litaC_expr->number.type) {
                    case litaC_lex__TokenType_INT_NUMBER: {
                        {
                            litaC_ast_print__Printf(litaC_indent, "%llu", litaC_expr->number.value.intValue);
                            break;
                            
                            
                        }
                        
                        
                    }
                    case litaC_lex__TokenType_FLOAT_NUMBER: {
                        {
                            litaC_ast_print__Printf(litaC_indent, "%f", litaC_expr->number.value.floatValue);
                            break;
                            
                            
                        }
                        
                        
                    }
                    default: {
                        {
                            
                            
                        }
                        
                        
                    }
                }
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_STRING_EXPR: {
            {
                litaC_ast__StringExpr* litaC_expr = (litaC_ast__StringExpr*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "\"%.*s\"", litaC_expr->string.value.str.length, litaC_expr->string.value.str.buffer);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TERNARY_EXPR: {
            {
                litaC_ast__TernaryExpr* litaC_expr = (litaC_ast__TernaryExpr*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "(");
                litaC_ast_print__PrintStmt(&((litaC_expr->cond->stmt)), 0);
                printf(") ? ");
                litaC_ast_print__PrintStmt(&((litaC_expr->then->stmt)), 0);
                printf(" : ");
                litaC_ast_print__PrintStmt(&((litaC_expr->other->stmt)), 0);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_EXPR: {
            {
                litaC_ast_print__Printf(litaC_indent, "<poison_expr>");
                return;
                
                
                
            }
            
            
        }
        default: {
            {
                litaC_ast_print__Printf(litaC_indent, "<%s:%d Not Implemented>", litaC_ast__StmtKindAsStr(litaC_s->node.kind), litaC_s->node.kind);
                return;
                
                
                
            }
            
            
        }
    }
    
}

litaC_void litaC_generics__GetGenericName(litaC_checker__TypeChecker* litaC_checker,litaC_ast__TypeSpec* litaC_type,litaC_string__String* litaC_str) {
    switch(litaC_type->kind) {
        case litaC_ast__TypeSpecKind_ARRAY: {
            {
                litaC_string__String_append(litaC_str, "[]");
                litaC_generics__GetGenericName(litaC_checker, litaC_type->base, litaC_str);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_PTR: {
            {
                litaC_string__String_append(litaC_str, "*");
                litaC_generics__GetGenericName(litaC_checker, litaC_type->base, litaC_str);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_CONST: {
            {
                litaC_string__String_append(litaC_str, "const ");
                litaC_generics__GetGenericName(litaC_checker, litaC_type->base, litaC_str);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_NAME: {
            {
                litaC_ast__NameTypeSpec* litaC_name = (litaC_ast__NameTypeSpec*)litaC_type;
                litaC_bool litaC_nameSet = litaC_false;
                if(!(litaC_type->typeInfo)) {
                    {
                        litaC_symbols__Symbol* litaC_unaliasedType = litaC_checker__TypeChecker_getType(litaC_checker, litaC_name);
                        if(litaC_unaliasedType) {
                            {
                                litaC_types__TypeInfo* litaC_type = litaC_unaliasedType->type;
                                if(litaC_type && litaC_type->name) {
                                    {
                                        litaC_string__String_append(litaC_str, litaC_type->name);
                                        litaC_nameSet = litaC_true;
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } else {
                    {
                        litaC_string__String_append(litaC_str, "%s", litaC_type->typeInfo->name);
                        litaC_nameSet = litaC_true;
                        
                        
                    }
                } 
                
                if(!(litaC_nameSet)) {
                    {
                        litaC_string__String_append(litaC_str, litaC_name->name);
                        
                        
                    }
                    
                } 
                
                if(litaC_array__Array_empty_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)))) {
                    {
                        return;
                        
                        
                        
                    }
                    
                } 
                
                litaC_string__String_append(litaC_str, "<");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)));litaC_i += 1) {
                    {
                        if(litaC_i > 0) {
                            {
                                litaC_string__String_append(litaC_str, ",");
                                
                                
                            }
                            
                        } 
                        
                        litaC_ast__TypeSpec* litaC_arg = litaC_array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)), litaC_i);
                        litaC_generics__GetGenericName(litaC_checker, litaC_arg, litaC_str);
                        
                        
                    }
                }
                litaC_string__String_append(litaC_str, ">");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_FUNC_PTR: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_NONE: 
        default: {
            
            
        }
    }
    
}

litaC_symbols__Symbol* litaC_generics__CreateTypeFromGenericTemplate(litaC_checker__TypeChecker* litaC_checker,litaC_symbols__Symbol* litaC_sym,litaC_ast__NameTypeSpec* litaC_name) {
    assert(litaC_sym != NULL);
    litaC_bool litaC_isNewContext = litaC_checker->genericContext.callsite == NULL;
    if(litaC_isNewContext) {
        {
            litaC_checker->genericContext.callsite = litaC_checker->current;
            
            
        }
        
    } 
    
    
    litaC_char litaC_buffer[1024];
    litaC_string__String litaC_genericName = litaC_string__StringInit(litaC_buffer, litaC_generics__MAX_GENERIC_NAME, 0);
    litaC_generics__GetGenericName(litaC_checker, &((litaC_name->spec)), &((litaC_genericName)));
    const litaC_char* litaC_newName = litaC_string__String_cStrConst(litaC_genericName);
    litaC_symbols__Symbol* litaC_genericSym = litaC_map__Map_get_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_checker->current->genericSymbols, litaC_newName);
    if(!(litaC_genericSym)) {
        {
            litaC_char* litaC_newNameStr = litaC_string__String_copy(litaC_genericName, litaC_checker->lita->allocator).buffer;
            litaC_ast__GenericDecl* litaC_genericDecl = NULL;
            switch(litaC_sym->decl->stmt.node.kind) {
                case litaC_ast__StmtKind_FUNC_DECL: {
                    {
                        litaC_genericDecl = litaC_generics__CreateFuncDecl((litaC_ast__FuncDecl*)litaC_sym->decl, &((litaC_name->genericArgs)), litaC_checker->lita->allocator);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_TRAIT_DECL: 
                case litaC_ast__StmtKind_UNION_DECL: 
                case litaC_ast__StmtKind_STRUCT_DECL: {
                    {
                        litaC_genericDecl = litaC_generics__CreateAggregateDecl((litaC_ast__AggregateDecl*)litaC_sym->decl, &((litaC_name->genericArgs)), litaC_checker->lita->allocator);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_TYPEDEF_DECL: {
                    {
                        litaC_genericDecl = litaC_generics__CreateTypedefDecl((litaC_ast__TypedefDecl*)litaC_sym->decl, &((litaC_name->genericArgs)), litaC_checker->lita->allocator);
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        assert(litaC_false);
                        
                        
                    }
                    
                    
                }
            }
            if(!(litaC_genericDecl)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_genericSym = litaC_symbols__Scope_addSymbol(&((litaC_checker->current->symbols)), litaC_newNameStr, litaC_sym->declared, &((litaC_genericDecl->declaration)), litaC_symbols__SymbolFlags_IS_INCOMPLETE | litaC_symbols__SymbolFlags_IS_FROM_GENERIC_TEMPLATE);
            if(!(litaC_genericSym)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_genericSym->genericCallsiteModule = litaC_checker->current;
            litaC_genericSym->genericParams = litaC_array__Array_copy_cb_GenericParam_ce_(&((litaC_genericDecl->genericParams)), NULL);
            litaC_map__Map_put_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_checker->current->genericSymbols, litaC_newNameStr, litaC_genericSym);
            if(litaC_genericSym->decl->stmt.node.kind == litaC_ast__StmtKind_FUNC_DECL) {
                {
                    litaC_array__Array_add_cb__ptr_Symbol_ce_(&((litaC_checker->symbolFuncs)), litaC_genericSym);
                    
                    
                }
                
            } else {
                {
                    litaC_array__Array_add_cb__ptr_Symbol_ce_(&((litaC_checker->symbolTypes)), litaC_genericSym);
                    
                    
                }
            } 
            
            if(litaC_generics__HasGenericParam(litaC_checker, &((litaC_name->genericArgs)))) {
                {
                    litaC_genericSym->flags |= litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE;
                    litaC_ast__GenericDecl* litaC_originalDecl = (litaC_ast__GenericDecl*)litaC_sym->decl;
                    litaC_genericDecl->genericParams = litaC_array__Array_copy_cb_GenericParam_ce_(&((litaC_originalDecl->genericParams)), NULL);
                    
                    
                }
                
            } else {
                {
                    litaC_i32 litaC_removed = 0;
                    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)));litaC_i += 1) {
                        {
                            litaC_i32 litaC_index = litaC_i - litaC_removed;
                            if(litaC_index < litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_genericDecl->genericParams)))) {
                                {
                                    litaC_array__Array_removeAt_cb_GenericParam_ce_(&((litaC_genericDecl->genericParams)), litaC_index);
                                    litaC_removed += 1;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                    }
                    
                    
                }
            } 
            
            litaC_i32 litaC_numOfGenericArgs = litaC_array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)));
            litaC_array__Array_init_cb__ptr_TypeInfo_ce_(&((litaC_genericSym->genericArgs)), litaC_numOfGenericArgs, litaC_checker->lita->allocator);
            litaC_bool litaC_isValidArgs = litaC_true;
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_numOfGenericArgs;litaC_i += 1) {
                {
                    litaC_ast__TypeSpec* litaC_arg = litaC_array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)), litaC_i);
                    litaC_types__TypeInfo* litaC_typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_checker, litaC_arg);
                    if(!(litaC_typeInfo) || litaC_typeInfo->kind == litaC_types__TypeKind_POISON) {
                        {
                            litaC_isValidArgs = litaC_false;
                            
                            
                        }
                        
                    } 
                    
                    litaC_array__Array_add_cb__ptr_TypeInfo_ce_(&((litaC_genericSym->genericArgs)), litaC_arg->typeInfo);
                    
                    
                }
            }
            if(!(litaC_isValidArgs)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } else {
        {
            litaC_bool litaC_isValidArgs = litaC_true;
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)));litaC_i += 1) {
                {
                    litaC_ast__TypeSpec* litaC_arg = litaC_array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)), litaC_i);
                    litaC_types__TypeInfo* litaC_typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_checker, litaC_arg);
                    if(!(litaC_typeInfo) || litaC_typeInfo->kind == litaC_types__TypeKind_POISON) {
                        {
                            litaC_isValidArgs = litaC_false;
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            if(!(litaC_isValidArgs)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    } 
    
    assert(litaC_genericSym != NULL);
    litaC_checker__TypeChecker_resolveSymbol(litaC_checker, litaC_genericSym);
    litaC_checker__TypeChecker_finishResolveSymbol(litaC_checker, litaC_genericSym);
    litaC_name->spec.typeInfo = litaC_genericSym->type;
    if(litaC_types__IsGenericCapable(litaC_genericSym->type) && litaC_sym->type) {
        {
            litaC_types__GenericTypeInfo* litaC_genericType = (litaC_types__GenericTypeInfo*)litaC_genericSym->type;
            litaC_genericType->genericTypeid = litaC_sym->type->typeid;
            
            
        }
        
    } 
    
    {
        litaC_symbols__Symbol* ___result = litaC_genericSym;
        if(litaC_isNewContext) {
            litaC_checker->genericContext.callsite = NULL;
            
        } 
        ;
        return ___result;
        
    }
    
    err:;
    
    {
        litaC_symbols__Symbol* ___result = NULL;
        if(litaC_isNewContext) {
            litaC_checker->genericContext.callsite = NULL;
            
        } 
        ;
        return ___result;
        
    }
    
    if(litaC_isNewContext) {
        litaC_checker->genericContext.callsite = NULL;
        
    } 
    ;
    
}

litaC_ast__GenericDecl* litaC_generics__CreateAggregateDecl(litaC_ast__AggregateDecl* litaC_aggDecl,litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_genericArgs,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__AggregateDecl* litaC_copy = litaC_ast_copy__CopyAggregateDecl(litaC_aggDecl, litaC_allocator);
    litaC_generics__Template litaC_template =  {
        .genericParams = &(litaC_aggDecl->decl.genericParams),
        .genericArgs = litaC_genericArgs
    };
    litaC_generics__ReplaceTypes(&(litaC_template), &((litaC_copy->decl.declaration.stmt.node)));
    return (litaC_ast__GenericDecl*)litaC_copy;
    
    
}

litaC_ast__GenericDecl* litaC_generics__CreateFuncDecl(litaC_ast__FuncDecl* litaC_funcDecl,litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_genericArgs,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__FuncDecl* litaC_copy = litaC_ast_copy__CopyFuncDecl(litaC_funcDecl, litaC_allocator);
    litaC_generics__Template litaC_template =  {
        .genericParams = &(litaC_funcDecl->decl.genericParams),
        .genericArgs = litaC_genericArgs
    };
    litaC_generics__ReplaceTypes(&(litaC_template), &((litaC_copy->decl.declaration.stmt.node)));
    return (litaC_ast__GenericDecl*)litaC_copy;
    
    
}

litaC_ast__GenericDecl* litaC_generics__CreateTypedefDecl(litaC_ast__TypedefDecl* litaC_typedefDecl,litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_genericArgs,const litaC_mem__Allocator* litaC_allocator) {
    litaC_ast__TypedefDecl* litaC_copy = litaC_ast_copy__CopyTypedefDecl(litaC_typedefDecl, litaC_allocator);
    litaC_generics__Template litaC_template =  {
        .genericParams = &(litaC_typedefDecl->decl.genericParams),
        .genericArgs = litaC_genericArgs
    };
    litaC_generics__ReplaceTypes(&(litaC_template), &((litaC_copy->decl.declaration.stmt.node)));
    return (litaC_ast__GenericDecl*)litaC_copy;
    
    
}

litaC_ast__TypeSpec* litaC_generics__Template_replaceTypeSpec(litaC_generics__Template* litaC_this,litaC_ast__TypeSpec* litaC_type) {
    if(!(litaC_type)) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    switch(litaC_type->kind) {
        case litaC_ast__TypeSpecKind_NONE: {
            {
                return NULL;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_ARRAY: {
            {
                litaC_type->base = litaC_generics__Template_replaceTypeSpec(litaC_this, litaC_type->base);
                return litaC_type;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_CONST: {
            {
                litaC_type->base = litaC_generics__Template_replaceTypeSpec(litaC_this, litaC_type->base);
                return litaC_type;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_PTR: {
            {
                litaC_type->base = litaC_generics__Template_replaceTypeSpec(litaC_this, litaC_type->base);
                return litaC_type;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_FUNC_PTR: {
            {
                litaC_ast__FuncPtrTypeSpec* litaC_funcPtr = (litaC_ast__FuncPtrTypeSpec*)litaC_type;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_funcPtr->args)));litaC_i += 1) {
                    {
                        litaC_array__Array_set_cb__ptr_TypeSpec_ce_(&((litaC_funcPtr->args)), litaC_i, litaC_generics__Template_replaceTypeSpec(litaC_this, litaC_array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_funcPtr->args)), litaC_i)));
                        
                        
                    }
                }
                litaC_funcPtr->ret = litaC_generics__Template_replaceTypeSpec(litaC_this, litaC_funcPtr->ret);
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_funcPtr->genericParams)));) {
                    {
                        litaC_bool litaC_isRemoved = litaC_false;
                        litaC_ast__GenericParam litaC_genParam = litaC_array__Array_get_cb_GenericParam_ce_(&((litaC_funcPtr->genericParams)), litaC_i);
                        for(litaC_i32 litaC_j = 0;litaC_j < litaC_array__Array_size_cb_GenericParam_ce_(litaC_this->genericParams);litaC_j += 1) {
                            {
                                litaC_ast__GenericParam litaC_param = litaC_array__Array_get_cb_GenericParam_ce_(litaC_this->genericParams, litaC_j);
                                if(litaC_string_view__StringView_equalsStringView(litaC_param.name.value.str, litaC_genParam.name.value.str)) {
                                    {
                                        litaC_array__Array_removeAt_cb_GenericParam_ce_(&((litaC_funcPtr->genericParams)), litaC_i);
                                        litaC_isRemoved = litaC_true;
                                        break;
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                        }
                        if(!(litaC_isRemoved)) {
                            {
                                litaC_i += 1;
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                return litaC_type;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_NAME: {
            {
                litaC_ast__NameTypeSpec* litaC_name = (litaC_ast__NameTypeSpec*)litaC_type;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)));litaC_i += 1) {
                    {
                        litaC_array__Array_set_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)), litaC_i, litaC_generics__Template_replaceTypeSpec(litaC_this, litaC_array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)), litaC_i)));
                        
                        
                    }
                }
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_GenericParam_ce_(litaC_this->genericParams);litaC_i += 1) {
                    {
                        litaC_ast__GenericParam litaC_param = litaC_array__Array_get_cb_GenericParam_ce_(litaC_this->genericParams, litaC_i);
                        if(litaC_string_view__StringView_equals(litaC_param.name.value.str, litaC_name->name, -(1))) {
                            {
                                if(litaC_i < litaC_array__Array_size_cb__ptr_TypeSpec_ce_(litaC_this->genericArgs)) {
                                    {
                                        return litaC_array__Array_get_cb__ptr_TypeSpec_ce_(litaC_this->genericArgs, litaC_i);
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                return &(litaC_name->spec);
                
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return NULL;
    
    
}

litaC_bool litaC_generics__ReplaceTypes(litaC_generics__Template* litaC_template,litaC_ast__Node* litaC_ast) {
    if(!(litaC_ast)) {
        return litaC_true;
        
        
    } 
    
    switch(litaC_ast->kind) {
        case litaC_ast__StmtKind_TRAIT_DECL: 
        case litaC_ast__StmtKind_UNION_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: {
            {
                litaC_ast__AggregateDecl* litaC_aggDecl = (litaC_ast__AggregateDecl*)litaC_ast;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_aggDecl->fields)));litaC_i += 1) {
                    {
                        litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_aggDecl->fields)), litaC_i);
                        switch(litaC_field.kind) {
                            case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                                {
                                    litaC_ast__TraitFieldDecl* litaC_traitField = litaC_field.traitField;
                                    litaC_traitField->type = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_traitField->type);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                                {
                                    litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                                    litaC_varField->type = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_varField->type);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                                {
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                            case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                                {
                                    litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                                    litaC_generics__ReplaceTypes(litaC_template, &((litaC_aggField->decl.declaration.stmt.node)));
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_POISON_EXPR: {
                                {
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            default: {
                                {
                                    assert(litaC_false);
                                    
                                    
                                }
                                
                                
                            }
                        }
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                litaC_ast__FuncDecl* litaC_funcDecl = (litaC_ast__FuncDecl*)litaC_ast;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcDecl->params->params)));litaC_i += 1) {
                    {
                        litaC_ast__ParameterDecl* litaC_param = litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcDecl->params->params)), litaC_i);
                        litaC_param->type = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_param->type);
                        if(litaC_param->defaultExpr) {
                            {
                                litaC_generics__ReplaceTypes(litaC_template, &((litaC_param->defaultExpr->stmt.node)));
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                litaC_funcDecl->returnType = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_funcDecl->returnType);
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_funcDecl->body->node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IMPORT_DECL: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONST_DECL: 
        case litaC_ast__StmtKind_VAR_DECL: {
            {
                litaC_ast__VarDecl* litaC_decl = (litaC_ast__VarDecl*)litaC_ast;
                litaC_decl->typeSpec = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_decl->typeSpec);
                if(litaC_decl->expr) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_decl->expr->stmt.node)));
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            {
                litaC_ast__TypedefDecl* litaC_decl = (litaC_ast__TypedefDecl*)litaC_ast;
                litaC_decl->type = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_decl->type);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_DECL: 
        case litaC_ast__StmtKind_PARAM_DECL: 
        case litaC_ast__StmtKind_NATIVE_DECL: 
        case litaC_ast__StmtKind_POISON_DECL: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BLOCK_STMT: {
            {
                litaC_ast__BlockStmt* litaC_body = (litaC_ast__BlockStmt*)litaC_ast;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Stmt_ce_(&((litaC_body->stmts)));litaC_i += 1) {
                    {
                        litaC_ast__Stmt* litaC_s = litaC_array__Array_get_cb__ptr_Stmt_ce_(&((litaC_body->stmts)), litaC_i);
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_s->node)));
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BREAK_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_COMP_STMT: {
            {
                litaC_ast__CompStmt* litaC_comp = (litaC_ast__CompStmt*)litaC_ast;
                if(litaC_comp->evaluatedStmt) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_comp->evaluatedStmt->node)));
                        
                        
                    }
                    
                } 
                
                if(litaC_comp->end) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_comp->end->stmt.node)));
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Stmt_ce_(&((litaC_comp->body)));litaC_i += 1) {
                    {
                        litaC_ast__Stmt* litaC_s = litaC_array__Array_get_cb__ptr_Stmt_ce_(&((litaC_comp->body)), litaC_i);
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_s->node)));
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONTINUE_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DEFER_STMT: {
            {
                litaC_ast__DeferStmt* litaC_deferStmt = (litaC_ast__DeferStmt*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_deferStmt->deferedStmt->node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DO_WHILE_STMT: {
            {
                litaC_ast__DoWhileStmt* litaC_whileStmt = (litaC_ast__DoWhileStmt*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_whileStmt->body->node)));
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_whileStmt->cond->stmt.node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_EMPTY_STMT: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FOR_STMT: {
            {
                litaC_ast__ForStmt* litaC_forStmt = (litaC_ast__ForStmt*)litaC_ast;
                if(litaC_forStmt->init) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_forStmt->init->node)));
                        
                        
                    }
                    
                } 
                
                if(litaC_forStmt->cond) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_forStmt->cond->stmt.node)));
                        
                        
                    }
                    
                } 
                
                if(litaC_forStmt->post) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_forStmt->post->node)));
                        
                        
                    }
                    
                } 
                
                if(litaC_forStmt->body) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_forStmt->body->node)));
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_BODY_STMT: {
            {
                litaC_ast__FuncBodyStmt* litaC_body = (litaC_ast__FuncBodyStmt*)litaC_ast;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Stmt_ce_(&((litaC_body->stmts)));litaC_i += 1) {
                    {
                        litaC_ast__Stmt* litaC_s = litaC_array__Array_get_cb__ptr_Stmt_ce_(&((litaC_body->stmts)), litaC_i);
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_s->node)));
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GOTO_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IF_STMT: {
            {
                litaC_ast__IfStmt* litaC_ifStmt = (litaC_ast__IfStmt*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_ifStmt->cond->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_ifStmt->then->node)));
                if(litaC_ifStmt->elseStmt) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_ifStmt->elseStmt->node)));
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_LABEL_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_MODULE_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NOTE_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_PARAMETERS_STMT: {
            {
                litaC_ast__ParametersStmt* litaC_params = (litaC_ast__ParametersStmt*)litaC_ast;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_params->params)));litaC_i += 1) {
                    {
                        litaC_ast__ParameterDecl* litaC_param = litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_params->params)), litaC_i);
                        litaC_generics__ReplaceTypes(litaC_template, (litaC_ast__Node*)litaC_param);
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_RETURN_STMT: {
            {
                litaC_ast__ReturnStmt* litaC_stmt = (litaC_ast__ReturnStmt*)litaC_ast;
                if(litaC_stmt->expr) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_stmt->expr->stmt.node)));
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SWITCH_CASE_STMT: {
            {
                litaC_ast__SwitchCaseStmt* litaC_caseStmt = (litaC_ast__SwitchCaseStmt*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_caseStmt->cond->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_caseStmt->body->node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SWITCH_STMT: {
            {
                litaC_ast__SwitchStmt* litaC_switchStmt = (litaC_ast__SwitchStmt*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_switchStmt->cond->stmt.node)));
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_SwitchCaseStmt_ce_(&((litaC_switchStmt->cases)));litaC_i += 1) {
                    {
                        litaC_ast__SwitchCaseStmt* litaC_caseStmt = litaC_array__Array_get_cb__ptr_SwitchCaseStmt_ce_(&((litaC_switchStmt->cases)), litaC_i);
                        litaC_generics__ReplaceTypes(litaC_template, (litaC_ast__Node*)litaC_caseStmt);
                        
                        
                    }
                }
                if(litaC_switchStmt->defaultStmt) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_switchStmt->defaultStmt->node)));
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_FIELD_DECL: 
        case litaC_ast__StmtKind_ENUM_FIELD_ENTRY_DECL: 
        case litaC_ast__StmtKind_STRUCT_FIELD_DECL: 
        case litaC_ast__StmtKind_UNION_FIELD_DECL: 
        case litaC_ast__StmtKind_TRAIT_FIELD_DECL: 
        case litaC_ast__StmtKind_VAR_FIELD_DECL: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_WHILE_STMT: {
            {
                litaC_ast__WhileStmt* litaC_whileStmt = (litaC_ast__WhileStmt*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_whileStmt->cond->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_whileStmt->body->node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ARRAY_DESIGNATION_EXPR: {
            {
                litaC_ast__ArrayDesignationExpr* litaC_expr = (litaC_ast__ArrayDesignationExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->index->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->value->stmt.node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ARRAY_INIT_EXPR: {
            {
                litaC_ast__ArrayInitExpr* litaC_expr = (litaC_ast__ArrayInitExpr*)litaC_ast;
                litaC_expr->type = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_expr->type);
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Expr_ce_(&((litaC_expr->values)));litaC_i += 1) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_array__Array_get_cb__ptr_Expr_ce_(&((litaC_expr->values)), litaC_i)->stmt.node)));
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BINARY_EXPR: {
            {
                litaC_ast__BinaryExpr* litaC_expr = (litaC_ast__BinaryExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->left->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->right->stmt.node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BOOLEAN_EXPR: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CAST_EXPR: {
            {
                litaC_ast__CastExpr* litaC_expr = (litaC_ast__CastExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->exprToCast->stmt.node)));
                litaC_expr->castTo = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_expr->castTo);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CHAR_EXPR: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_CALL_EXPR: {
            {
                litaC_ast__FuncCallExpr* litaC_expr = (litaC_ast__FuncCallExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->object->stmt.node)));
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)));litaC_i += 1) {
                    {
                        litaC_ast__TypeSpec* litaC_arg = litaC_array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)), litaC_i);
                        litaC_arg = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_arg);
                        litaC_array__Array_set_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)), litaC_i, litaC_arg);
                        
                        
                    }
                }
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_CallArg_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_array__Array_get_cb_CallArg_ce_(&((litaC_expr->arguments)), litaC_i).argExpr->stmt.node)));
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR: {
            {
                litaC_ast__IdentifierExpr* litaC_expr = (litaC_ast__IdentifierExpr*)litaC_ast;
                litaC_expr->type = (litaC_ast__NameTypeSpec*)litaC_generics__Template_replaceTypeSpec(litaC_template, (litaC_ast__TypeSpec*)litaC_expr->type);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GET_EXPR: {
            {
                litaC_ast__GetExpr* litaC_expr = (litaC_ast__GetExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->object->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, (litaC_ast__Node*)litaC_expr->field);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GROUP_EXPR: {
            {
                litaC_ast__GroupExpr* litaC_expr = (litaC_ast__GroupExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->groupedExpr->stmt.node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: {
            {
                litaC_ast__IdentifierExpr* litaC_expr = (litaC_ast__IdentifierExpr*)litaC_ast;
                litaC_expr->type = (litaC_ast__NameTypeSpec*)litaC_generics__Template_replaceTypeSpec(litaC_template, (litaC_ast__TypeSpec*)litaC_expr->type);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_INIT_EXPR: {
            {
                litaC_ast__InitExpr* litaC_expr = (litaC_ast__InitExpr*)litaC_ast;
                litaC_expr->type = (litaC_ast__NameTypeSpec*)litaC_generics__Template_replaceTypeSpec(litaC_template, (litaC_ast__TypeSpec*)litaC_expr->type);
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)));litaC_i += 1) {
                    {
                        litaC_ast__TypeSpec* litaC_arg = litaC_array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)), litaC_i);
                        litaC_arg = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_arg);
                        litaC_array__Array_set_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)), litaC_i, litaC_arg);
                        
                        
                    }
                }
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, (litaC_ast__Node*)litaC_array__Array_get_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)), litaC_i));
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_INIT_ARG_EXPR: {
            {
                litaC_ast__InitArgExpr* litaC_expr = (litaC_ast__InitArgExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->value->stmt.node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NULL_EXPR: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NUMBER_EXPR: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_OFFSET_OF_EXPR: {
            {
                litaC_ast__OffsetOfExpr* litaC_expr = (litaC_ast__OffsetOfExpr*)litaC_ast;
                litaC_expr->type = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_expr->type);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SET_EXPR: {
            {
                litaC_ast__SetExpr* litaC_expr = (litaC_ast__SetExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->object->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, (litaC_ast__Node*)litaC_expr->field);
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->value->stmt.node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SIZE_OF_EXPR: {
            {
                litaC_ast__SizeOfExpr* litaC_expr = (litaC_ast__SizeOfExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->sizeOfExpr->stmt.node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_STRING_EXPR: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_GET_EXPR: {
            {
                litaC_ast__SubscriptGetExpr* litaC_expr = (litaC_ast__SubscriptGetExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->object->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->index->stmt.node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_SET_EXPR: {
            {
                litaC_ast__SubscriptSetExpr* litaC_expr = (litaC_ast__SubscriptSetExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->object->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->index->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->value->stmt.node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TERNARY_EXPR: {
            {
                litaC_ast__TernaryExpr* litaC_expr = (litaC_ast__TernaryExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->cond->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->then->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->other->stmt.node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPE_IDENTIFIER_EXPR: {
            {
                litaC_ast__TypeIdentifierExpr* litaC_expr = (litaC_ast__TypeIdentifierExpr*)litaC_ast;
                litaC_expr->type = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_expr->type);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPE_OF_EXPR: {
            {
                litaC_ast__TypeOfExpr* litaC_expr = (litaC_ast__TypeOfExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->typeOfExpr->stmt.node)));
                litaC_expr->type = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_expr->type);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNARY_EXPR: {
            {
                litaC_ast__UnaryExpr* litaC_expr = (litaC_ast__UnaryExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->unaryExpr->stmt.node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_EXPR: {
            {
                break;
                
                
            }
            
            
        }
        default: {
            {
                printf("Statement Kind: %s\n", litaC_ast__StmtKindAsStr(litaC_ast->kind));
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return litaC_true;
    
    
}

litaC_bool litaC_generics__HasGenericParam(litaC_checker__TypeChecker* litaC_checker,litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_genericArgs) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeSpec_ce_(litaC_genericArgs);litaC_i += 1) {
        {
            litaC_ast__TypeSpec* litaC_arg = litaC_array__Array_get_cb__ptr_TypeSpec_ce_(litaC_genericArgs, litaC_i);
            litaC_ast__TypeSpec* litaC_name = litaC_ast__TypeSpec_getBaseType(litaC_arg);
            if(litaC_name && litaC_name->kind == litaC_ast__TypeSpecKind_NAME) {
                {
                    if(litaC_checker__TypeChecker_isGenericParamType(litaC_checker, (litaC_ast__NameTypeSpec*)litaC_name)) {
                        {
                            return litaC_true;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_void litaC_introspection__Introspect_generate(litaC_introspection__Introspect* litaC_this,litaC_checker__TypeChecker* litaC_checker) {
    if(litaC_this->lita->options->typeOption == litaC_lita__TypeInfoOption_NONE) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_char litaC_filename[_MAX_PATH] =  {
        0
    };
    litaC_string_view__StringView litaC_moduleName = litaC_string_view__StringViewInit("type", -(1));
    if(!(litaC_lita__FindModulePath(litaC_this->lita, litaC_moduleName, litaC_filename))) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), (litaC_lex__SrcPos) {
                
            }, "could not find builtin module 'type' on the system path.");
            return;
            
            
            
        }
        
    } 
    
    litaC_module__Module* litaC_module = litaC_map__Map_get_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_this->lita->modules)), litaC_filename);
    if(!(litaC_module)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(2048 * 8, litaC_this->lita->allocator);
    litaC_string_buffer__StringBuffer litaC_scratch = litaC_string_buffer__StringBufferInit(1024, litaC_this->lita->allocator);
    litaC_bool litaC_onlyTagged = litaC_this->lita->options->typeOption == litaC_lita__TypeInfoOption_TAGGED;
    litaC_i64 litaC_maxTypes = litaC_types__NextTypeId();
    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "\n    public const numOfTypeInfos : usize = %llu_u64;\n    public const typeInfos: **TypeInfo = [%llu]*TypeInfo {\n    ", litaC_maxTypes, litaC_maxTypes);
    if(litaC_onlyTagged) {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_checker->symbolFuncs)));litaC_i += 1) {
                {
                    litaC_symbols__Symbol* litaC_sym = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_checker->symbolFuncs)), litaC_i);
                    if(litaC_ast__Decl_hasNote(litaC_sym->decl, "typeinfo")) {
                        {
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_checker->symbolTypes)));litaC_i += 1) {
                {
                    litaC_symbols__Symbol* litaC_sym = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_checker->symbolTypes)), litaC_i);
                    if(litaC_ast__Decl_hasNote(litaC_sym->decl, "typeinfo")) {
                        {
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } else {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_checker->symbolFuncs)));litaC_i += 1) {
                {
                    litaC_symbols__Symbol* litaC_sym = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_checker->symbolFuncs)), litaC_i);
                    litaC_types__TypeInfo* litaC_type = litaC_sym->type;
                    if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    if(!(litaC_type) || litaC_type->kind != litaC_types__TypeKind_FUNC) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    litaC_introspection__Introspect_emitFunc(litaC_this, &((litaC_sb)), &((litaC_scratch)), litaC_sym);
                    
                    
                }
            }
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_checker->symbolTypes)));litaC_i += 1) {
                {
                    litaC_symbols__Symbol* litaC_sym = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_checker->symbolTypes)), litaC_i);
                    if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_ALIAS) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    litaC_introspection__Introspect_emitType(litaC_this, &((litaC_sb)), &((litaC_scratch)), litaC_sym);
                    
                    
                }
            }
            
            
        }
    } 
    
    {
        for(litaC_map__MapIterator_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_ litaC_it = litaC_map__Map_iter_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(&((litaC_checker->typeCache.arrayCache)));litaC_map__MapIterator_hasNext_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(&((litaC_it)));) {
            {
                litaC_map__MapEntry_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_ litaC_entry = litaC_map__MapIterator_next_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(&((litaC_it)));
                litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), (litaC_types__TypeInfo*)litaC_entry.value);
                
                
            }
        }
        for(litaC_map__MapIterator_cb_i64_c__ptr_PtrTypeInfo_ce_ litaC_it = litaC_map__Map_iter_cb_i64_c__ptr_PtrTypeInfo_ce_(&((litaC_checker->typeCache.ptrCache)));litaC_map__MapIterator_hasNext_cb_i64_c__ptr_PtrTypeInfo_ce_(&((litaC_it)));) {
            {
                litaC_map__MapEntry_cb_i64_c__ptr_PtrTypeInfo_ce_ litaC_entry = litaC_map__MapIterator_next_cb_i64_c__ptr_PtrTypeInfo_ce_(&((litaC_it)));
                litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), (litaC_types__TypeInfo*)litaC_entry.value);
                
                
            }
        }
        for(litaC_map__MapIterator_cb_i64_c__ptr_ConstTypeInfo_ce_ litaC_it = litaC_map__Map_iter_cb_i64_c__ptr_ConstTypeInfo_ce_(&((litaC_checker->typeCache.constCache)));litaC_map__MapIterator_hasNext_cb_i64_c__ptr_ConstTypeInfo_ce_(&((litaC_it)));) {
            {
                litaC_map__MapEntry_cb_i64_c__ptr_ConstTypeInfo_ce_ litaC_entry = litaC_map__MapIterator_next_cb_i64_c__ptr_ConstTypeInfo_ce_(&((litaC_it)));
                litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), (litaC_types__TypeInfo*)litaC_entry.value);
                
                
            }
        }
        
        
    }
    {
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__BOOL_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__CHAR_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__I8_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__U8_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__I16_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__U16_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__I32_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__U32_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__I64_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__U64_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__F32_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__F64_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__USIZE_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__NULL_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__VOID_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__STR_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__POISON_TYPE)));
        
        
    }
    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "\n};");
    litaC_parser__Parser litaC_parser = litaC_parser__ParserInit(litaC_module->id.filename, litaC_string_buffer__StringBuffer_cStr(&((litaC_sb))), litaC_this->lita);
    litaC_ast__ModuleStmt* litaC_stmts = litaC_parser__Parser_parseModule(&((litaC_parser)));
    if(litaC_stmts) {
        {
            litaC_checker__TypeChecker_enterModule(litaC_checker, litaC_module);
            
            assert(litaC_array__Array_size_cb__ptr_Decl_ce_(&((litaC_stmts->declarations))) == 2);
            {
                litaC_ast__Decl* litaC_numDecl = litaC_array__Array_get_cb__ptr_Decl_ce_(&((litaC_stmts->declarations)), 0);
                assert(litaC_numDecl->stmt.node.kind == litaC_ast__StmtKind_CONST_DECL);
                litaC_types__TypeInfo* litaC_typeInfo = litaC_checker_decl__TypeChecker_resolveValueDecl(litaC_checker, (litaC_ast__VarDecl*)litaC_numDecl);
                assert(litaC_typeInfo != NULL);
                litaC_symbols__Symbol* litaC_existingDecl = litaC_module__Module_getType(litaC_module, "numOfTypeInfos");
                assert(litaC_existingDecl != NULL);
                litaC_numDecl->sym = litaC_existingDecl;
                litaC_existingDecl->decl = litaC_numDecl;
                
                
            }
            {
                litaC_ast__Decl* litaC_typesDecl = litaC_array__Array_get_cb__ptr_Decl_ce_(&((litaC_stmts->declarations)), 1);
                assert(litaC_typesDecl->stmt.node.kind == litaC_ast__StmtKind_CONST_DECL);
                litaC_checker->bypassing = litaC_true;
                litaC_types__TypeInfo* litaC_typeInfo = litaC_checker_decl__TypeChecker_resolveValueDecl(litaC_checker, (litaC_ast__VarDecl*)litaC_typesDecl);
                litaC_checker->bypassing = litaC_false;
                if(!(litaC_typeInfo)) {
                    {
                        if(litaC_phase_result__PhaseResult_hasErrors(&((litaC_checker->lita->result)))) {
                            {
                                litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(16, NULL);
                                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_PhaseError_ce_(&((litaC_checker->lita->result.errors)));litaC_i += 1) {
                                    {
                                        litaC_phase_result__PhaseError litaC_error = litaC_array__Array_get_cb_PhaseError_ce_(&((litaC_checker->lita->result.errors)), litaC_i);
                                        litaC_error_codes__PrintError(&((litaC_sb)), litaC_error);
                                        
                                        
                                    }
                                }
                                printf("ERRORS: \n%s\n", litaC_string_buffer__StringBuffer_cStr(&((litaC_sb))));
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                assert(litaC_typeInfo != NULL);
                litaC_symbols__Symbol* litaC_existingDecl = litaC_module__Module_getType(litaC_module, "typeInfos");
                assert(litaC_existingDecl != NULL);
                litaC_typesDecl->sym = litaC_existingDecl;
                litaC_existingDecl->decl = litaC_typesDecl;
                litaC_existingDecl->type = litaC_typeInfo;
                
                
            }
            litaC_checker__TypeChecker_leaveModule(litaC_checker);
            
            
        }
        
    } 
    
    
}

litaC_void litaC_introspection__Introspect_emitFunc(litaC_introspection__Introspect* litaC_this,litaC_string_buffer__StringBuffer* litaC_sb,litaC_string_buffer__StringBuffer* litaC_scratch,litaC_symbols__Symbol* litaC_sym) {
    litaC_types__TypeInfo* litaC_type = litaC_sym->type;
    assert(litaC_type->kind == litaC_types__TypeKind_FUNC);
    litaC_types__FuncTypeInfo* litaC_funcInfo = (litaC_types__FuncTypeInfo*)litaC_type;
    litaC_bool litaC_isVararg = litaC_funcInfo->decl->params->isVararg;
    litaC_i64 litaC_returnTypeid = litaC_funcInfo->returnType->typeid;
    litaC_i32 litaC_numOfParams = litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params)));
    {
        litaC_string_buffer__StringBuffer_clear(litaC_scratch);
        if(litaC_numOfParams) {
            {
                litaC_string_buffer__StringBuffer_append(litaC_scratch, "[]ParamInfo {");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_numOfParams;litaC_i += 1) {
                    {
                        litaC_ast__ParameterDecl* litaC_param = litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params)), litaC_i);
                        litaC_string_buffer__StringBuffer_append(litaC_scratch, "\n                    ParamInfo {\n                        .name = \"%s\",\n                        .type = %llu,\n                        .modifiers = Modifiers.%s,\n                    },\n                ", litaC_lex__Token_asString(&((litaC_param->decl.name))), litaC_param->type->typeInfo->typeid, ((litaC_param->decl.attributes.isUsing)) ? "Using" : "None");
                        
                        
                    }
                }
                litaC_string_buffer__StringBuffer_append(litaC_scratch, "}");
                
                
            }
            
        } else {
            {
                litaC_string_buffer__StringBuffer_append(litaC_scratch, "null");
                
                
            }
        } 
        
        
        
    }
    litaC_string_buffer__StringBuffer_append(litaC_sb, "\n        [%llu] = &TypeInfo {\n            .kind = TypeKind.FUNC,\n            .name = \"%s\",\n            .id = %llu,\n            .funcType = funcType {\n                .isVararg = %s,\n                .returnType = %llu,\n                .params = %s,\n                .numOfParams = %d\n            }\n        },\n    ", litaC_type->typeid, litaC_sym->name, litaC_type->typeid, (litaC_isVararg) ? "true" : "false", litaC_returnTypeid, litaC_string_buffer__StringBuffer_cStr(litaC_scratch), litaC_numOfParams);
    
}

litaC_void litaC_introspection__Introspect_emitType(litaC_introspection__Introspect* litaC_this,litaC_string_buffer__StringBuffer* litaC_sb,litaC_string_buffer__StringBuffer* litaC_scratch,litaC_symbols__Symbol* litaC_sym) {
    litaC_string_buffer__StringBuffer_clear(litaC_scratch);
    litaC_types__TypeInfo* litaC_type = litaC_sym->type;
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_ENUM: {
            {
                litaC_types__EnumTypeInfo* litaC_enumInfo = (litaC_types__EnumTypeInfo*)litaC_type;
                litaC_ast__EnumDecl* litaC_decl = litaC_enumInfo->decl;
                litaC_i32 litaC_numOfFields = litaC_array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_decl->fields)));
                if(litaC_numOfFields) {
                    {
                        litaC_string_buffer__StringBuffer_append(litaC_scratch, "[]EnumFieldInfo {");
                        litaC_i32 litaC_value = 0;
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_numOfFields;litaC_i += 1) {
                            {
                                litaC_ast__EnumFieldEntryDecl* litaC_field = litaC_array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_decl->fields)), litaC_i);
                                if(litaC_field->value) {
                                    {
                                        if(litaC_field->value->operand.isConst) {
                                            {
                                                litaC_value = (litaC_i32)litaC_field->value->operand.val.intValue;
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                litaC_string_buffer__StringBuffer_append(litaC_scratch, "\n                        EnumFieldInfo {\n                            .name = \"%s\",\n                            .value = %d,\n                        },\n                    ", litaC_lex__Token_asString(&((litaC_field->decl.name))), litaC_value);
                                litaC_value += 1;
                                
                                
                            }
                        }
                        litaC_string_buffer__StringBuffer_append(litaC_scratch, "}");
                        
                        
                    }
                    
                } else {
                    {
                        litaC_string_buffer__StringBuffer_append(litaC_scratch, "null");
                        
                        
                    }
                } 
                
                litaC_char* litaC_name = litaC_type->sym->name;
                litaC_string_buffer__StringBuffer_append(litaC_sb, "\n                [%llu] = &TypeInfo {\n                    .kind = TypeKind.%s,\n                    .name = \"%s\",\n                    .id = %llu,\n                    .enumType = enumType {\n                        .fields = %s,\n                        .numOfFields = %d\n                    }\n                },\n            ", litaC_type->typeid, litaC_types__TypeKindAsStr(litaC_type->kind), litaC_name, litaC_type->typeid, litaC_string_buffer__StringBuffer_cStr(litaC_scratch), litaC_numOfFields);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_TRAIT: 
        case litaC_types__TypeKind_UNION: 
        case litaC_types__TypeKind_STRUCT: {
            {
                litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_type;
                litaC_ast__AggregateDecl* litaC_decl = litaC_aggInfo->decl;
                litaC_i32 litaC_numOfFields = litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_decl->fields)));
                if(litaC_decl->flags & litaC_ast__AggregateFlags_IS_ANONYMOUS) {
                    {
                        return;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_numOfFields) {
                    {
                        litaC_string_buffer__StringBuffer_append(litaC_scratch, "[]FieldInfo {");
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_numOfFields;litaC_i += 1) {
                            {
                                litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_decl->fields)), litaC_i);
                                switch(litaC_field.kind) {
                                    case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                                        {
                                            litaC_ast__TraitFieldDecl* litaC_traitField = litaC_field.traitField;
                                            if(litaC_traitField->decl.name.type != litaC_lex__TokenType_IDENTIFIER) {
                                                {
                                                    break;
                                                    
                                                    
                                                }
                                                
                                            } 
                                            
                                            litaC_i64 litaC_typeid = ((litaC_field.typeInfo)) ? litaC_field.typeInfo->typeid : 0L;
                                            litaC_string_buffer__StringBuffer_append(litaC_scratch, "\n                                FieldInfo {\n                                    .kind = FieldInfoKind.VAR_FIELD,\n                                    .name = \"%s\",\n                                    .type = %llu,\n                                    .modifiers = Modifiers.%s,\n                                    .offset = offsetof(%.*s::%s, %s)\n                                },\n                            ", litaC_lex__Token_asString(&((litaC_traitField->decl.name))), litaC_typeid, "None", litaC_sym->declared->id.name.length, litaC_sym->declared->id.name.buffer, litaC_type->name, litaC_lex__Token_asString(&((litaC_traitField->decl.name))));
                                            break;
                                            
                                            
                                        }
                                        
                                        
                                    }
                                    case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                                        {
                                            litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                                            if(litaC_varField->decl.name.type != litaC_lex__TokenType_IDENTIFIER) {
                                                {
                                                    break;
                                                    
                                                    
                                                }
                                                
                                            } 
                                            
                                            litaC_i64 litaC_typeid = ((litaC_field.typeInfo)) ? litaC_field.typeInfo->typeid : 0L;
                                            litaC_string_buffer__StringBuffer_append(litaC_scratch, "\n                                FieldInfo {\n                                    .kind = FieldInfoKind.VAR_FIELD,\n                                    .name = \"%s\",\n                                    .type = %llu,\n                                    .modifiers = Modifiers.%s,\n                                    .offset = offsetof(%.*s::%s, %s)\n                                },\n                            ", litaC_lex__Token_asString(&((litaC_varField->decl.name))), litaC_typeid, ((litaC_varField->decl.attributes.isUsing)) ? "Using" : "None", litaC_sym->declared->id.name.length, litaC_sym->declared->id.name.buffer, litaC_type->name, litaC_lex__Token_asString(&((litaC_varField->decl.name))));
                                            break;
                                            
                                            
                                        }
                                        
                                        
                                    }
                                    case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                                        {
                                            litaC_ast__EnumDecl* litaC_enumField = litaC_field.enumField;
                                            if(litaC_enumField->decl.name.type != litaC_lex__TokenType_IDENTIFIER) {
                                                {
                                                    break;
                                                    
                                                    
                                                }
                                                
                                            } 
                                            
                                            litaC_string_buffer__StringBuffer_append(litaC_scratch, "\n                                FieldInfo {\n                                    .kind = FieldInfoKind.ENUM_FIELD,\n                                    .name = \"%s\",\n                                    .type = %llu,\n                                    .modifiers = Modifiers.%s,\n                                },\n                            ", litaC_lex__Token_asString(&((litaC_enumField->decl.name))), litaC_enumField->decl.sym->type->typeid, ((litaC_enumField->decl.attributes.isUsing)) ? "Using" : "None");
                                            break;
                                            
                                            
                                        }
                                        
                                        
                                    }
                                    case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                                    case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                                        {
                                            litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                                            const char* litaC_fieldType = (litaC_field.kind == litaC_ast__StmtKind_STRUCT_FIELD_DECL) ? "STRUCT_FIELD" : "UNION_FIELD";
                                            if(litaC_aggField->decl.declaration.name.type == litaC_lex__TokenType_IDENTIFIER) {
                                                {
                                                    litaC_string_buffer__StringBuffer_append(litaC_scratch, "\n                                    FieldInfo {\n                                        .kind = FieldInfoKind.%s,\n                                        .name = \"%s\",\n                                        .type = %llu,\n                                        .modifiers = Modifiers.%s,\n                                    },\n                                ", litaC_fieldType, litaC_lex__Token_asString(&((litaC_aggField->decl.declaration.name))), litaC_aggField->decl.declaration.sym->type->typeid, ((litaC_aggField->decl.declaration.attributes.isUsing)) ? "Using" : "None");
                                                    break;
                                                    
                                                    
                                                }
                                                
                                            } else {
                                                if(litaC_aggField->decl.declaration.name.type == litaC_lex__TokenType_VOID) {
                                                    {
                                                        litaC_string_buffer__StringBuffer_append(litaC_scratch, "\n                                    FieldInfo {\n                                        .kind = FieldInfoKind.%s,\n                                        .name = null,\n                                        .type = %llu,\n                                        .modifiers = Modifiers.%s,\n                                    },\n                                ", litaC_fieldType, litaC_aggField->decl.declaration.sym->type->typeid, ((litaC_aggField->decl.declaration.attributes.isUsing)) ? "Using" : "None");
                                                        
                                                        
                                                    }
                                                    
                                                } 
                                                
                                            } 
                                            
                                            break;
                                            
                                            
                                        }
                                        
                                        
                                    }
                                    case litaC_ast__StmtKind_POISON_EXPR: {
                                        {
                                            break;
                                            
                                            
                                        }
                                        
                                        
                                    }
                                    default: {
                                        {
                                            assert(litaC_false);
                                            
                                            
                                        }
                                        
                                        
                                    }
                                }
                                
                                
                            }
                        }
                        litaC_string_buffer__StringBuffer_append(litaC_scratch, "}");
                        
                        
                    }
                    
                } else {
                    {
                        litaC_string_buffer__StringBuffer_append(litaC_scratch, "null");
                        
                        
                    }
                } 
                
                litaC_char* litaC_name = litaC_type->sym->name;
                litaC_string_buffer__StringBuffer_append(litaC_sb, "\n                [%llu] = &TypeInfo {\n                    .kind = TypeKind.%s,\n                    .name = \"%s\",\n                    .id = %llu,\n                    .aggType = aggType {\n                        .fields = %s,\n                        .numOfFields = %d\n                    }\n                },\n            ", litaC_type->typeid, litaC_types__TypeKindAsStr(litaC_type->kind), litaC_name, litaC_type->typeid, litaC_string_buffer__StringBuffer_cStr(litaC_scratch), litaC_numOfFields);
                break;
                
                
            }
            
            
        }
        default: {
            {
                
                
            }
            
            
        }
    }
    
}

litaC_void litaC_introspection__Introspect_emitPrimitiveType(litaC_introspection__Introspect* litaC_this,litaC_string_buffer__StringBuffer* litaC_sb,litaC_types__TypeInfo* litaC_type) {
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_BOOL: 
        case litaC_types__TypeKind_CHAR: 
        case litaC_types__TypeKind_I8: 
        case litaC_types__TypeKind_U8: 
        case litaC_types__TypeKind_I16: 
        case litaC_types__TypeKind_U16: 
        case litaC_types__TypeKind_I32: 
        case litaC_types__TypeKind_U32: 
        case litaC_types__TypeKind_I64: 
        case litaC_types__TypeKind_U64: 
        case litaC_types__TypeKind_F32: 
        case litaC_types__TypeKind_F64: 
        case litaC_types__TypeKind_USIZE: 
        case litaC_types__TypeKind_NULL: 
        case litaC_types__TypeKind_STR: 
        case litaC_types__TypeKind_VOID: {
            {
                litaC_string_buffer__StringBuffer_append(litaC_sb, "\n                [%llu] = &TypeInfo {\n                    .kind = TypeKind.%s,\n                    .name = \"%s\",\n                    .id = %llu\n                },\n            ", litaC_type->typeid, litaC_types__TypeKindAsStr(litaC_type->kind), litaC_type->name, litaC_type->typeid);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__ArrayTypeInfo* litaC_arrayType = (litaC_types__ArrayTypeInfo*)litaC_type;
                litaC_string_buffer__StringBuffer_append(litaC_sb, "\n                [%llu] = &TypeInfo {\n                    .kind = TypeKind.%s,\n                    .name = null,\n                    .id = %llu,\n                    .arrayType = arrayType {\n                        .length = %llu,\n                        .arrayOfType: %llu\n                    }\n                },\n            ", litaC_type->typeid, litaC_types__TypeKindAsStr(litaC_type->kind), litaC_type->typeid, litaC_arrayType->length, litaC_arrayType->arrayOf->typeid);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__PtrTypeInfo* litaC_ptrType = (litaC_types__PtrTypeInfo*)litaC_type;
                litaC_string_buffer__StringBuffer_append(litaC_sb, "\n                [%llu] = &TypeInfo {\n                    .kind = TypeKind.%s,\n                    .name = null,\n                    .id = %llu,\n                    .ptrType = ptrType {\n                        .ptrOfType: %llu\n                    }\n                },\n            ", litaC_type->typeid, litaC_types__TypeKindAsStr(litaC_type->kind), litaC_type->typeid, litaC_ptrType->ptrOf->typeid);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__ConstTypeInfo* litaC_constType = (litaC_types__ConstTypeInfo*)litaC_type;
                litaC_string_buffer__StringBuffer_append(litaC_sb, "\n                [%llu] = &TypeInfo {\n                    .kind = TypeKind.%s,\n                    .name = null,\n                    .id = %llu,\n                    .constType = constType {\n                        .constOfType: %llu\n                    }\n                },\n            ", litaC_type->typeid, litaC_types__TypeKindAsStr(litaC_type->kind), litaC_type->typeid, litaC_constType->constOf->typeid);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC_PTR: {
            {
                break;
                
                
            }
            
            
        }
        default: {
            {
                
                
            }
            
            
        }
    }
    
}

litaC_bool litaC_checker_decl__TypeChecker_resolveDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__Decl* litaC_decl) {
    assert(litaC_decl != NULL);
    switch(litaC_decl->stmt.node.kind) {
        case litaC_ast__StmtKind_IMPORT_DECL: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONST_DECL: 
        case litaC_ast__StmtKind_VAR_DECL: {
            {
                litaC_types__TypeInfo* litaC_type = litaC_checker_decl__TypeChecker_resolveValueDecl(litaC_this, (litaC_ast__VarDecl*)litaC_decl);
                if(!(litaC_type)) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                litaC_checker__TypeChecker_addSymbol(litaC_this, litaC_decl, litaC_type);
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TRAIT_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: 
        case litaC_ast__StmtKind_UNION_DECL: {
            {
                litaC_ast__AggregateDecl* litaC_aggDecl = (litaC_ast__AggregateDecl*)litaC_decl;
                return litaC_checker_decl__TypeChecker_resolveAggregateDecl(litaC_this, litaC_aggDecl);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_DECL: {
            {
                litaC_ast__EnumDecl* litaC_enumDecl = (litaC_ast__EnumDecl*)litaC_decl;
                return litaC_checker_decl__TypeChecker_resolveEnumDecl(litaC_this, litaC_enumDecl);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                litaC_ast__FuncDecl* litaC_funcDecl = (litaC_ast__FuncDecl*)litaC_decl;
                return litaC_checker_decl__TypeChecker_resolveFuncDecl(litaC_this, litaC_funcDecl);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            {
                litaC_ast__TypedefDecl* litaC_typedefDecl = (litaC_ast__TypedefDecl*)litaC_decl;
                return litaC_checker_decl__TypeChecker_resolveTypedefDecl(litaC_this, litaC_typedefDecl);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_PARAM_DECL: {
            {
                litaC_ast__ParameterDecl* litaC_paramDecl = (litaC_ast__ParameterDecl*)litaC_decl;
                return litaC_checker_decl__TypeChecker_resolveParamDecl(litaC_this, litaC_paramDecl);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NATIVE_DECL: 
        case litaC_ast__StmtKind_POISON_DECL: {
            {
                break;
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_types__TypeInfo* litaC_checker_decl__TypeChecker_resolveValueDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__VarDecl* litaC_decl) {
    
    if(!(litaC_decl->expr) && litaC_decl->decl.stmt.node.kind == litaC_ast__StmtKind_CONST_DECL) {
        {
            if(!(litaC_ast__Decl_hasNote(&((litaC_decl->decl)), "foreign"))) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_decl->decl.stmt.node.startPos, "const declaration must have an assignment (unless it is '@foreign')");
                    {
                        litaC_types__TypeInfo* ___result = NULL;
                        litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_decl->decl.stmt.node.startPos, litaC_decl->decl.sym);
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_declaredType = NULL;
    litaC_types__TypeInfo* litaC_inferredType = NULL;
    if(litaC_decl->typeSpec) {
        {
            litaC_declaredType = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_decl->typeSpec);
            
            
        }
        
    } 
    
    if(litaC_decl->expr) {
        {
            if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_decl->expr))) {
                {
                    {
                        litaC_types__TypeInfo* ___result = NULL;
                        litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_decl->decl.stmt.node.startPos, litaC_decl->decl.sym);
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            litaC_ast__Operand litaC_op = litaC_decl->expr->operand;
            if(litaC_decl->expr->stmt.node.kind == litaC_ast__StmtKind_ARRAY_INIT_EXPR || litaC_decl->expr->stmt.node.kind == litaC_ast__StmtKind_INIT_EXPR) {
                {
                    litaC_inferredType = litaC_op.typeInfo;
                    
                    
                }
                
            } else {
                if(litaC_op.typeInfo->kind == litaC_types__TypeKind_NULL && litaC_declaredType == NULL) {
                    {
                        litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_decl->expr->stmt.node.startPos, "invalid variable declaration, can't infer type from 'null' for '%.*s' variable", litaC_decl->decl.name.value.str.length, litaC_decl->decl.name.value.str.buffer);
                        {
                            litaC_types__TypeInfo* ___result = NULL;
                            litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_decl->decl.stmt.node.startPos, litaC_decl->decl.sym);
                            return ___result;
                            
                        }
                        
                        
                        
                    }
                    
                } else {
                    {
                        litaC_inferredType = litaC_types_new__TypeCache_typeDecay(&((litaC_this->typeCache)), litaC_decl->expr->operand.typeInfo);
                        if(litaC_declaredType) {
                            {
                                litaC_decl->expr = litaC_checker_expr__TypeChecker_coerceTypeWithUsing(litaC_this, litaC_decl->expr, litaC_inferredType, litaC_declaredType);
                                litaC_inferredType = litaC_types_new__TypeCache_typeDecay(&((litaC_this->typeCache)), litaC_decl->expr->operand.typeInfo);
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                } 
                
            } 
            
            litaC_decl->expr->expectedType = (litaC_declaredType) ? litaC_declaredType : litaC_inferredType;
            
            
        }
        
    } 
    
    if(litaC_declaredType && litaC_inferredType) {
        {
            litaC_checker__TypeChecker_checkDeclarability(litaC_this, litaC_decl->expr->stmt.node.startPos, litaC_declaredType, litaC_inferredType);
            
            
        }
        
    } 
    
    {
        litaC_types__TypeInfo* ___result = (litaC_declaredType) ? litaC_declaredType : litaC_inferredType;
        litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_decl->decl.stmt.node.startPos, litaC_decl->decl.sym);
        return ___result;
        
    }
    
    litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_decl->decl.stmt.node.startPos, litaC_decl->decl.sym);
    
}

litaC_bool litaC_checker_decl__TypeChecker_checkAnonAggregateFieldDuplicate(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl,litaC_ast__FieldStmt litaC_field,litaC_i32 litaC_index) {
    switch(litaC_field.kind) {
        case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
            {
                litaC_ast__TraitFieldDecl* litaC_traitField = litaC_field.traitField;
                if(litaC_traitField->decl.name.type != litaC_lex__TokenType_IDENTIFIER) {
                    {
                        break;
                        
                        
                    }
                    
                } 
                
                litaC_checker_decl__TypeChecker_checkAggregateFieldDuplicate(litaC_this, litaC_aggDecl, litaC_traitField->decl.name.value.str, litaC_index);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_VAR_FIELD_DECL: {
            {
                litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                if(litaC_varField->decl.name.type != litaC_lex__TokenType_IDENTIFIER) {
                    {
                        break;
                        
                        
                    }
                    
                } 
                
                litaC_checker_decl__TypeChecker_checkAggregateFieldDuplicate(litaC_this, litaC_aggDecl, litaC_varField->decl.name.value.str, litaC_index);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
            {
                litaC_ast__EnumDecl* litaC_enumField = litaC_field.enumField;
                if(litaC_enumField->decl.name.type != litaC_lex__TokenType_IDENTIFIER) {
                    {
                        break;
                        
                        
                    }
                    
                } 
                
                litaC_checker_decl__TypeChecker_checkAggregateFieldDuplicate(litaC_this, litaC_aggDecl, litaC_enumField->decl.name.value.str, litaC_index);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNION_FIELD_DECL: 
        case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
            {
                litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                if(litaC_aggField->decl.declaration.name.type == litaC_lex__TokenType_IDENTIFIER) {
                    {
                        litaC_checker_decl__TypeChecker_checkAggregateFieldDuplicate(litaC_this, litaC_aggDecl, litaC_aggField->decl.declaration.name.value.str, litaC_index);
                        break;
                        
                        
                    }
                    
                } else {
                    if(litaC_aggField->decl.declaration.name.type == litaC_lex__TokenType_VOID) {
                        {
                            for(litaC_i32 litaC_j = 0;litaC_j < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_aggField->fields)));litaC_j += 1) {
                                {
                                    litaC_ast__FieldStmt litaC_anonymousField = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_aggField->fields)), litaC_j);
                                    litaC_checker_decl__TypeChecker_checkAnonAggregateFieldDuplicate(litaC_this, litaC_aggDecl, litaC_anonymousField, litaC_index);
                                    
                                    
                                }
                            }
                            
                            
                        }
                        
                    } 
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_EXPR: {
            {
                break;
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return litaC_true;
    
    
}

litaC_void litaC_checker_decl__TypeChecker_errorInvalidMemberForTrait(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl,litaC_string_view__StringView litaC_fieldName,litaC_lex__SrcPos litaC_pos) {
    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_pos, "invalid member '%.*s', only function pointers are allowed for traits", litaC_fieldName.length, litaC_fieldName.buffer);
    
}

litaC_void litaC_checker_decl__TypeChecker_errorUsingMember(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl,litaC_string_view__StringView litaC_fieldName,litaC_lex__SrcPos litaC_pos) {
    if(litaC_aggDecl->decl.declaration.name.value.str.length) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_pos, "invalid 'using' member '%.*s' in '%.*s', only aggregate types (or pointer to an aggregate) are allowed", litaC_fieldName.length, litaC_fieldName.buffer, litaC_aggDecl->decl.declaration.name.value.str.length, litaC_aggDecl->decl.declaration.name.value.str.buffer);
            
            
        }
        
    } else {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_pos, "invalid 'using' member '%.*s', only aggregate types (or pointer to an aggregate) are allowed", litaC_fieldName.length, litaC_fieldName.buffer);
            
            
        }
    } 
    
    
}

litaC_void litaC_checker_decl__TypeChecker_errorUsingParameter(litaC_checker__TypeChecker* litaC_this,litaC_ast__ParameterDecl* litaC_paramDecl) {
    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_paramDecl->decl.stmt.node.startPos, "invalid 'using' parameter '%.*s', only aggregate types (or pointer to an aggregate) are allowed", litaC_paramDecl->decl.name.value.str.length, litaC_paramDecl->decl.name.value.str.buffer);
    
}

litaC_void litaC_checker_decl__TypeChecker_errorDuplicateMember(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl,litaC_string_view__StringView litaC_fieldName,litaC_lex__SrcPos litaC_pos) {
    if(litaC_aggDecl->decl.declaration.name.value.str.length) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_pos, "duplicate member '%.*s' in '%.*s'", litaC_fieldName.length, litaC_fieldName.buffer, litaC_aggDecl->decl.declaration.name.value.str.length, litaC_aggDecl->decl.declaration.name.value.str.buffer);
            
            
        }
        
    } else {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_pos, "duplicate member '%.*s'", litaC_fieldName.length, litaC_fieldName.buffer);
            
            
        }
    } 
    
    
}

litaC_bool litaC_checker_decl__TypeChecker_checkAggregateFieldDuplicate(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl,litaC_string_view__StringView litaC_fieldName,litaC_i32 litaC_index) {
    litaC_bool litaC_isValid = litaC_true;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_aggDecl->fields)));litaC_i += 1) {
        {
            if(litaC_index == litaC_i) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_aggDecl->fields)), litaC_i);
            switch(litaC_field.kind) {
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        litaC_ast__TraitFieldDecl* litaC_traitField = litaC_field.traitField;
                        if(litaC_traitField->decl.name.type != litaC_lex__TokenType_IDENTIFIER) {
                            {
                                continue;
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_string_view__StringView_equalsStringView(litaC_traitField->decl.name.value.str, litaC_fieldName)) {
                            {
                                litaC_checker_decl__TypeChecker_errorDuplicateMember(litaC_this, litaC_aggDecl, litaC_fieldName, litaC_traitField->decl.stmt.node.startPos);
                                litaC_isValid = litaC_false;
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                        if(litaC_varField->decl.name.type != litaC_lex__TokenType_IDENTIFIER) {
                            {
                                continue;
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_string_view__StringView_equalsStringView(litaC_varField->decl.name.value.str, litaC_fieldName)) {
                            {
                                litaC_checker_decl__TypeChecker_errorDuplicateMember(litaC_this, litaC_aggDecl, litaC_fieldName, litaC_varField->decl.stmt.node.startPos);
                                litaC_isValid = litaC_false;
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                    {
                        litaC_ast__EnumDecl* litaC_enumField = litaC_field.enumField;
                        if(litaC_enumField->decl.name.type != litaC_lex__TokenType_IDENTIFIER) {
                            {
                                continue;
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_string_view__StringView_equalsStringView(litaC_enumField->decl.name.value.str, litaC_fieldName)) {
                            {
                                litaC_checker_decl__TypeChecker_errorDuplicateMember(litaC_this, litaC_aggDecl, litaC_fieldName, litaC_enumField->decl.stmt.node.startPos);
                                litaC_isValid = litaC_false;
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                    {
                        litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                        if(litaC_aggField->decl.declaration.name.type == litaC_lex__TokenType_IDENTIFIER) {
                            {
                                if(litaC_string_view__StringView_equalsStringView(litaC_aggField->decl.declaration.name.value.str, litaC_fieldName)) {
                                    {
                                        litaC_checker_decl__TypeChecker_errorDuplicateMember(litaC_this, litaC_aggDecl, litaC_fieldName, litaC_aggField->decl.declaration.stmt.node.startPos);
                                        litaC_isValid = litaC_false;
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } else {
                            if(litaC_aggField->decl.declaration.name.type == litaC_lex__TokenType_VOID) {
                                {
                                    litaC_checker_decl__TypeChecker_checkAggregateFieldDuplicate(litaC_this, litaC_aggField, litaC_fieldName, -(1));
                                    
                                    
                                }
                                
                            } 
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_POISON_EXPR: {
                    {
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        assert(litaC_false);
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    return litaC_isValid;
    
    
}

litaC_bool litaC_checker_decl__TypeChecker_resolveAggregateDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl) {
    
    litaC_i32 litaC_hasGenerics = litaC_aggDecl->decl.declaration.sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE;
    if(litaC_hasGenerics) {
        {
            litaC_array__Array_add_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)), litaC_aggDecl->decl.genericParams);
            
            
        }
        
    } 
    
    
    litaC_i32 litaC_isTrait = litaC_aggDecl->decl.declaration.sym->flags & litaC_symbols__SymbolFlags_IS_TRAIT;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_aggDecl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt* litaC_field = &(litaC_aggDecl->fields.elements[litaC_i]);
            switch(litaC_field->kind) {
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        assert(litaC_isTrait);
                        litaC_ast__TraitFieldDecl* litaC_traitField = litaC_field->traitField;
                        litaC_field->typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_traitField->type);
                        assert(litaC_field->typeInfo);
                        if(litaC_field->typeInfo->kind != litaC_types__TypeKind_FUNC_PTR) {
                            {
                                litaC_checker_decl__TypeChecker_errorInvalidMemberForTrait(litaC_this, litaC_aggDecl, litaC_traitField->decl.name.value.str, litaC_traitField->decl.stmt.node.startPos);
                                {
                                    litaC_bool ___result = litaC_false;
                                    if(litaC_hasGenerics) {
                                        {
                                            litaC_array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                            
                                            
                                        }
                                        
                                    } 
                                    ;
                                    litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_types__FuncPtrTypeInfo* litaC_traitFn = (litaC_types__FuncPtrTypeInfo*)litaC_field->typeInfo;
                        litaC_traitFn->isTrait = litaC_true;
                        litaC_checker_decl__TypeChecker_checkAggregateFieldDuplicate(litaC_this, litaC_aggDecl, litaC_traitField->decl.name.value.str, litaC_i);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_varField = litaC_field->varField;
                        litaC_field->typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_varField->type);
                        assert(litaC_field->typeInfo);
                        if(litaC_isTrait) {
                            {
                                litaC_checker_decl__TypeChecker_errorInvalidMemberForTrait(litaC_this, litaC_aggDecl, litaC_varField->decl.name.value.str, litaC_varField->decl.stmt.node.startPos);
                                {
                                    litaC_bool ___result = litaC_false;
                                    if(litaC_hasGenerics) {
                                        {
                                            litaC_array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                            
                                            
                                        }
                                        
                                    } 
                                    ;
                                    litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_varField->defaultExpr) {
                            {
                                if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_varField->defaultExpr))) {
                                    {
                                        {
                                            litaC_bool ___result = litaC_false;
                                            if(litaC_hasGenerics) {
                                                {
                                                    litaC_array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                                    
                                                    
                                                }
                                                
                                            } 
                                            ;
                                            litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                                            return ___result;
                                            
                                        }
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                litaC_checker__TypeChecker_checkDeclarability(litaC_this, litaC_varField->defaultExpr->stmt.node.startPos, litaC_varField->defaultExpr->operand.typeInfo, litaC_field->typeInfo);
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_varField->decl.attributes.isUsing) {
                            {
                                if(!(litaC_types__IsAggregate(litaC_field->typeInfo)) && !(litaC_types__IsPtrAggregate(litaC_field->typeInfo))) {
                                    {
                                        litaC_checker_decl__TypeChecker_errorUsingMember(litaC_this, litaC_aggDecl, litaC_varField->decl.name.value.str, litaC_varField->decl.stmt.node.startPos);
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_checker_decl__TypeChecker_checkAggregateFieldDuplicate(litaC_this, litaC_aggDecl, litaC_varField->decl.name.value.str, litaC_i);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                    {
                        if(litaC_isTrait) {
                            {
                                litaC_checker_decl__TypeChecker_errorInvalidMemberForTrait(litaC_this, litaC_aggDecl, litaC_field->enumField->decl.name.value.str, litaC_field->enumField->decl.stmt.node.startPos);
                                {
                                    litaC_bool ___result = litaC_false;
                                    if(litaC_hasGenerics) {
                                        {
                                            litaC_array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                            
                                            
                                        }
                                        
                                    } 
                                    ;
                                    litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_symbols__Symbol* litaC_sym = litaC_field->enumField->decl.sym;
                        if(!(litaC_sym)) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    if(litaC_hasGenerics) {
                                        {
                                            litaC_array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                            
                                            
                                        }
                                        
                                    } 
                                    ;
                                    litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_sym->flags |= litaC_symbols__SymbolFlags_IS_INCOMPLETE;
                        litaC_checker__TypeChecker_resolveSymbol(litaC_this, litaC_sym);
                        litaC_field->typeInfo = litaC_sym->type;
                        if(!(litaC_field->typeInfo)) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    if(litaC_hasGenerics) {
                                        {
                                            litaC_array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                            
                                            
                                        }
                                        
                                    } 
                                    ;
                                    litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_field->enumField->decl.name.type == litaC_lex__TokenType_IDENTIFIER) {
                            {
                                litaC_checker_decl__TypeChecker_checkAggregateFieldDuplicate(litaC_this, litaC_aggDecl, litaC_field->enumField->decl.name.value.str, litaC_i);
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                    {
                        if(litaC_isTrait) {
                            {
                                litaC_checker_decl__TypeChecker_errorInvalidMemberForTrait(litaC_this, litaC_aggDecl, litaC_field->aggregateField->decl.declaration.name.value.str, litaC_field->aggregateField->decl.declaration.stmt.node.startPos);
                                {
                                    litaC_bool ___result = litaC_false;
                                    if(litaC_hasGenerics) {
                                        {
                                            litaC_array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                            
                                            
                                        }
                                        
                                    } 
                                    ;
                                    litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_symbols__Symbol* litaC_sym = litaC_field->aggregateField->decl.declaration.sym;
                        if(litaC_aggDecl->decl.declaration.sym->flags & litaC_symbols__SymbolFlags_IS_FROM_GENERIC_TEMPLATE) {
                            {
                                litaC_char litaC_name[256] =  {
                                    
                                };
                                litaC_string__String litaC_nameStr = litaC_string__StringInit(litaC_name, litaC_symbols__MAX_SYMBOL_NAME, -(1));
                                litaC_string__String_format(&((litaC_nameStr)), "%.*s", litaC_field->aggregateField->decl.declaration.name.value.str.length, litaC_field->aggregateField->decl.declaration.name.value.str.buffer);
                                litaC_sym = litaC_checker__TypeChecker_getTypeByName(litaC_this, litaC_string__String_cStr(litaC_nameStr));
                                if(!(litaC_sym)) {
                                    {
                                        litaC_sym = litaC_checker__TypeChecker_createDeclSymbol(litaC_this, &((litaC_field->aggregateField->decl.declaration)));
                                        
                                        
                                    }
                                    
                                } 
                                
                                litaC_ast__NameTypeSpec* litaC_nameSpec = litaC_ast_new__NewNameTypeSpec(litaC_field->aggregateField->decl.declaration.stmt.node.startPos, litaC_string__String_cStr(litaC_nameStr), litaC_this->lita->allocator);
                                litaC_array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_nameSpec->genericArgs)), litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_field->aggregateField->decl.genericParams))), litaC_this->lita->allocator);
                                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_field->aggregateField->decl.genericParams)));litaC_i += 1) {
                                    {
                                        litaC_ast__GenericParam litaC_genericParam = litaC_array__Array_get_cb_GenericParam_ce_(&((litaC_field->aggregateField->decl.genericParams)), litaC_i);
                                        for(litaC_i32 litaC_j = 0;litaC_j < litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_aggDecl->decl.declaration.sym->genericParams)));litaC_j += 1) {
                                            {
                                                litaC_ast__GenericParam litaC_parentGenericParam = litaC_array__Array_get_cb_GenericParam_ce_(&((litaC_aggDecl->decl.declaration.sym->genericParams)), litaC_j);
                                                if(litaC_string_view__StringView_equalsStringView(litaC_parentGenericParam.name.value.str, litaC_genericParam.name.value.str)) {
                                                    {
                                                        litaC_array__Array_add_cb__ptr_TypeSpec_ce_(&((litaC_nameSpec->genericArgs)), litaC_types__TypeInfo_asTypeSpec(litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_aggDecl->decl.declaration.sym->genericArgs)), litaC_j), litaC_this->lita->allocator));
                                                        break;
                                                        
                                                        
                                                    }
                                                    
                                                } 
                                                
                                                
                                                
                                            }
                                        }
                                        
                                        
                                    }
                                }
                                litaC_sym = litaC_generics__CreateTypeFromGenericTemplate(litaC_this, litaC_sym, litaC_nameSpec);
                                litaC_sym->flags |= litaC_symbols__SymbolFlags_IS_INCOMPLETE;
                                
                                
                            }
                            
                        } 
                        
                        if(!(litaC_sym)) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    if(litaC_hasGenerics) {
                                        {
                                            litaC_array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                            
                                            
                                        }
                                        
                                    } 
                                    ;
                                    litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_field->aggregateField->decl.declaration.sym = litaC_sym;
                        litaC_checker__TypeChecker_resolveSymbol(litaC_this, litaC_sym);
                        litaC_checker__TypeChecker_finishResolveSymbol(litaC_this, litaC_sym);
                        litaC_field->typeInfo = litaC_sym->type;
                        if(!(litaC_field->typeInfo)) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    if(litaC_hasGenerics) {
                                        {
                                            litaC_array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                            
                                            
                                        }
                                        
                                    } 
                                    ;
                                    litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_field->aggregateField->decl.declaration.name.type == litaC_lex__TokenType_IDENTIFIER) {
                            {
                                litaC_checker_decl__TypeChecker_checkAggregateFieldDuplicate(litaC_this, litaC_aggDecl, litaC_field->aggregateField->decl.declaration.name.value.str, litaC_i);
                                
                                
                            }
                            
                        } else {
                            {
                                for(litaC_i32 litaC_j = 0;litaC_j < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_field->aggregateField->fields)));litaC_j += 1) {
                                    {
                                        litaC_ast__FieldStmt litaC_anonymousField = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_field->aggregateField->fields)), litaC_j);
                                        litaC_checker_decl__TypeChecker_checkAnonAggregateFieldDuplicate(litaC_this, litaC_aggDecl, litaC_anonymousField, litaC_i);
                                        
                                        
                                    }
                                }
                                
                                
                            }
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_POISON_EXPR: {
                    {
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        assert(litaC_false);
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    litaC_checker_decl__TypeChecker_addFieldReferences(litaC_this, litaC_aggDecl, litaC_aggDecl->decl.declaration.sym->type, 0);
    {
        litaC_bool ___result = litaC_true;
        if(litaC_hasGenerics) {
            {
                litaC_array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                
                
            }
            
        } 
        ;
        litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
        return ___result;
        
    }
    
    if(litaC_hasGenerics) {
        {
            litaC_array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
            
            
        }
        
    } 
    ;
    litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
    
}

litaC_i32 litaC_checker_decl__TypeChecker_addFieldReferences(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl,litaC_types__TypeInfo* litaC_parentTypeInfo,litaC_i32 litaC_position) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_aggDecl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt* litaC_field = &(litaC_aggDecl->fields.elements[litaC_i]);
            if(!(litaC_field->typeInfo)) {
                {
                    litaC_position += 1;
                    continue;
                    
                    
                }
                
            } 
            
            switch(litaC_field->kind) {
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        litaC_references__ReferenceDatabase_addFieldReference(&((litaC_this->lita->references)), litaC_field->traitField->decl.stmt.node.startPos, litaC_parentTypeInfo, litaC_position);
                        litaC_position += 1;
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_varField = litaC_field->varField;
                        litaC_references__ReferenceDatabase_addFieldReference(&((litaC_this->lita->references)), litaC_field->varField->decl.stmt.node.startPos, litaC_parentTypeInfo, litaC_position);
                        if(litaC_varField->decl.attributes.isUsing) {
                            {
                                if(litaC_types__IsAggregate(litaC_field->typeInfo) || litaC_types__IsPtrAggregate(litaC_field->typeInfo)) {
                                    {
                                        litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_types__TypeInfo_getBaseType(litaC_field->typeInfo);
                                        litaC_position += litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_aggInfo->decl->fields)));
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_position += 1;
                                
                                
                            }
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                    {
                        litaC_references__ReferenceDatabase_addFieldReference(&((litaC_this->lita->references)), litaC_field->enumField->decl.stmt.node.startPos, litaC_parentTypeInfo, litaC_position);
                        litaC_position += 1;
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                    {
                        if(litaC_field->aggregateField->decl.declaration.name.type == litaC_lex__TokenType_IDENTIFIER) {
                            {
                                litaC_references__ReferenceDatabase_addFieldReference(&((litaC_this->lita->references)), litaC_field->aggregateField->decl.declaration.stmt.node.startPos, litaC_parentTypeInfo, litaC_position);
                                litaC_position += 1;
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_position = litaC_checker_decl__TypeChecker_addFieldReferences(litaC_this, litaC_field->aggregateField, litaC_parentTypeInfo, litaC_position);
                                
                                
                            }
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_POISON_EXPR: {
                    {
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        assert(litaC_false);
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    return litaC_position;
    
    
}

litaC_bool litaC_checker_decl__TypeChecker_checkEnumFieldDuplicate(litaC_checker__TypeChecker* litaC_this,litaC_ast__EnumDecl* litaC_enumDecl,litaC_ast__EnumFieldEntryDecl* litaC_field,litaC_i32 litaC_index) {
    litaC_bool litaC_hasDuplicates = litaC_false;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_enumDecl->fields)));litaC_i += 1) {
        {
            if(litaC_i == litaC_index) {
                continue;
                
            } 
            
            litaC_ast__EnumFieldEntryDecl* litaC_other = litaC_array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_enumDecl->fields)), litaC_i);
            if(litaC_string_view__StringView_equalsStringView(litaC_other->decl.name.value.str, litaC_field->decl.name.value.str)) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_other->decl.stmt.node.startPos, "duplicate member '%.*s'", litaC_field->decl.name.value.str.length, litaC_field->decl.name.value.str.buffer);
                    litaC_hasDuplicates = litaC_true;
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return !(litaC_hasDuplicates);
    
    
}

litaC_bool litaC_checker_decl__TypeChecker_resolveEnumDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__EnumDecl* litaC_enumDecl) {
    
    litaC_types__TypeInfo* litaC_parentTypeInfo = litaC_enumDecl->decl.sym->type;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_enumDecl->fields)));litaC_i += 1) {
        {
            litaC_ast__EnumFieldEntryDecl* litaC_field = litaC_array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_enumDecl->fields)), litaC_i);
            if(litaC_field->value) {
                {
                    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_field->value))) {
                        {
                            {
                                litaC_bool ___result = litaC_false;
                                litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_enumDecl->decl.stmt.node.startPos, litaC_enumDecl->decl.sym);
                                return ___result;
                                
                            }
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_types__TypeInfo* litaC_typeInfo = litaC_field->value->operand.typeInfo;
                    litaC_checker__TypeChecker_checkTypeCompatibility(litaC_this, litaC_field->value->stmt.node.startPos, litaC_typeInfo, &(litaC_types__I32_TYPE));
                    
                    
                }
                
            } 
            
            litaC_checker_decl__TypeChecker_checkEnumFieldDuplicate(litaC_this, litaC_enumDecl, litaC_field, litaC_i);
            litaC_references__ReferenceDatabase_addFieldReference(&((litaC_this->lita->references)), litaC_field->decl.stmt.node.startPos, litaC_parentTypeInfo, litaC_i);
            
            
        }
    }
    {
        litaC_bool ___result = litaC_true;
        litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_enumDecl->decl.stmt.node.startPos, litaC_enumDecl->decl.sym);
        return ___result;
        
    }
    
    litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_enumDecl->decl.stmt.node.startPos, litaC_enumDecl->decl.sym);
    
}

litaC_void litaC_checker_decl__TypeChecker_checkLabels(litaC_checker__TypeChecker* litaC_this) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_this->numOfLabels;litaC_i += 1) {
        {
            litaC_checker__LabelInfo* litaC_label = &(litaC_this->labels[litaC_i]);
            if(!(litaC_label->defined)) {
                {
                    assert(litaC_label->stmt != NULL);
                    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_label->stmt->node.startPos, "'%.*s' label not found", litaC_label->name.length, litaC_label->name.buffer);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    
}

litaC_bool litaC_checker_decl__TypeChecker_resolveFuncDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncDecl* litaC_funcDecl) {
    
    litaC_checker__TypeChecker_enterModule(litaC_this, litaC_funcDecl->decl.declaration.sym->declared);
    
    litaC_checker__TypeChecker_pushScope(litaC_this, &(((litaC_symbols__Scope) {
        
    })));
    
    litaC_array__Array_add_cb__ptr_FuncTypeInfo_ce_(&((litaC_this->funcDeclStack)), (litaC_types__FuncTypeInfo*)litaC_funcDecl->decl.declaration.sym->type);
    
    litaC_i32 litaC_hasGenerics = litaC_funcDecl->decl.declaration.sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE;
    if(litaC_hasGenerics) {
        {
            litaC_array__Array_add_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)), litaC_funcDecl->decl.genericParams);
            
            
        }
        
    } 
    
    
    if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, &((litaC_funcDecl->params->stmt))))) {
        {
            {
                litaC_bool ___result = litaC_false;
                if(litaC_hasGenerics) {
                    {
                        litaC_array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                        
                        
                    }
                    
                } 
                ;
                litaC_array__Array_pop_cb__ptr_FuncTypeInfo_ce_(&((litaC_this->funcDeclStack)));
                litaC_checker__TypeChecker_popScope(litaC_this);
                litaC_checker__TypeChecker_leaveModule(litaC_this);
                litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_funcDecl->decl.declaration.stmt.node.startPos, litaC_funcDecl->decl.declaration.sym);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    if(litaC_funcDecl->body) {
        {
            litaC_this->numOfLabels = 0;
            if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_funcDecl->body))) {
                {
                    {
                        litaC_bool ___result = litaC_false;
                        if(litaC_hasGenerics) {
                            {
                                litaC_array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                
                                
                            }
                            
                        } 
                        ;
                        litaC_array__Array_pop_cb__ptr_FuncTypeInfo_ce_(&((litaC_this->funcDeclStack)));
                        litaC_checker__TypeChecker_popScope(litaC_this);
                        litaC_checker__TypeChecker_leaveModule(litaC_this);
                        litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_funcDecl->decl.declaration.stmt.node.startPos, litaC_funcDecl->decl.declaration.sym);
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            litaC_checker_decl__TypeChecker_checkLabels(litaC_this);
            
            
        }
        
    } 
    
    {
        litaC_bool ___result = litaC_true;
        if(litaC_hasGenerics) {
            {
                litaC_array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                
                
            }
            
        } 
        ;
        litaC_array__Array_pop_cb__ptr_FuncTypeInfo_ce_(&((litaC_this->funcDeclStack)));
        litaC_checker__TypeChecker_popScope(litaC_this);
        litaC_checker__TypeChecker_leaveModule(litaC_this);
        litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_funcDecl->decl.declaration.stmt.node.startPos, litaC_funcDecl->decl.declaration.sym);
        return ___result;
        
    }
    
    if(litaC_hasGenerics) {
        {
            litaC_array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
            
            
        }
        
    } 
    ;
    litaC_array__Array_pop_cb__ptr_FuncTypeInfo_ce_(&((litaC_this->funcDeclStack)));
    litaC_checker__TypeChecker_popScope(litaC_this);
    litaC_checker__TypeChecker_leaveModule(litaC_this);
    litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_funcDecl->decl.declaration.stmt.node.startPos, litaC_funcDecl->decl.declaration.sym);
    
}

litaC_bool litaC_checker_decl__TypeChecker_resolveParamDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__ParameterDecl* litaC_paramDecl) {
    assert(litaC_paramDecl != NULL);
    
    if(litaC_paramDecl->defaultExpr) {
        {
            if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_paramDecl->defaultExpr))) {
                {
                    {
                        litaC_bool ___result = litaC_false;
                        litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_paramDecl->decl.stmt.node.startPos, litaC_paramDecl->decl.sym);
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_paramDecl->type);
    if(!(litaC_typeInfo)) {
        {
            {
                litaC_bool ___result = litaC_false;
                litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_paramDecl->decl.stmt.node.startPos, litaC_paramDecl->decl.sym);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_paramDecl->decl.sym = litaC_checker__TypeChecker_addSymbol(litaC_this, &((litaC_paramDecl->decl)), litaC_typeInfo);
    if(litaC_paramDecl->decl.attributes.isUsing) {
        {
            if(!(litaC_types__IsAggregateLike(litaC_typeInfo))) {
                {
                    litaC_checker_decl__TypeChecker_errorUsingParameter(litaC_this, litaC_paramDecl);
                    
                    
                }
                
            } else {
                {
                    litaC_types__TypeInfo* litaC_baseType = litaC_types__TypeInfo_getBaseType(litaC_typeInfo);
                    litaC_types__AggregateTypeInfo* litaC_aggType = (litaC_types__AggregateTypeInfo*)litaC_baseType;
                    litaC_checker__TypeChecker_addTypeToScope(litaC_this, &((litaC_paramDecl->decl)), litaC_this->current->currentScope, &((litaC_aggType->info.typeInfo)), litaC_aggType);
                    
                    
                }
            } 
            
            
            
        }
        
    } 
    
    {
        litaC_bool ___result = litaC_true;
        litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_paramDecl->decl.stmt.node.startPos, litaC_paramDecl->decl.sym);
        return ___result;
        
    }
    
    litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_paramDecl->decl.stmt.node.startPos, litaC_paramDecl->decl.sym);
    
}

litaC_bool litaC_checker_decl__TypeChecker_resolveTypedefDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__TypedefDecl* litaC_typedefDecl) {
    
    {
        litaC_bool ___result = litaC_true;
        litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_typedefDecl->decl.declaration.stmt.node.startPos, litaC_typedefDecl->decl.declaration.sym);
        return ___result;
        
    }
    
    litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_typedefDecl->decl.declaration.stmt.node.startPos, litaC_typedefDecl->decl.declaration.sym);
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveConstExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr) {
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_expr->operand.isConst)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, "expected a constant expression");
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr) {
    if(!(litaC_expr)) {
        return litaC_false;
        
        
    } 
    
    switch(litaC_expr->stmt.node.kind) {
        case litaC_ast__StmtKind_ARRAY_DESIGNATION_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveArrayDesignationExpr(litaC_this, (litaC_ast__ArrayDesignationExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ARRAY_INIT_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveArrayInitExpr(litaC_this, (litaC_ast__ArrayInitExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BINARY_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveBinaryExpr(litaC_this, (litaC_ast__BinaryExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BOOLEAN_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveBooleanExpr(litaC_this, (litaC_ast__BooleanExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CAST_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveCastExpr(litaC_this, (litaC_ast__CastExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CHAR_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveCharExpr(litaC_this, (litaC_ast__CharExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_CALL_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveFuncCallExpr(litaC_this, (litaC_ast__FuncCallExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveFuncIdentifierExpr(litaC_this, (litaC_ast__IdentifierExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GET_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveGetExpr(litaC_this, (litaC_ast__GetExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GROUP_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveGroupExpr(litaC_this, (litaC_ast__GroupExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveIdentiferExpr(litaC_this, (litaC_ast__IdentifierExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_INIT_ARG_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveInitArgExpr(litaC_this, (litaC_ast__InitArgExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_INIT_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveInitExpr(litaC_this, (litaC_ast__InitExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NULL_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveNullExpr(litaC_this, (litaC_ast__NullExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NUMBER_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveNumberExpr(litaC_this, (litaC_ast__NumberExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SET_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveSetExpr(litaC_this, (litaC_ast__SetExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_OFFSET_OF_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveOffsetOfExpr(litaC_this, (litaC_ast__OffsetOfExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SIZE_OF_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveSizeOfExpr(litaC_this, (litaC_ast__SizeOfExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_STRING_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveStringExpr(litaC_this, (litaC_ast__StringExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_GET_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveSubscriptGetExpr(litaC_this, (litaC_ast__SubscriptGetExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_SET_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveSubscriptSetExpr(litaC_this, (litaC_ast__SubscriptSetExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TERNARY_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveTernaryExpr(litaC_this, (litaC_ast__TernaryExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPE_IDENTIFIER_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveTypeIdentifierExpr(litaC_this, (litaC_ast__TypeIdentifierExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPE_OF_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveTypeOfExpr(litaC_this, (litaC_ast__TypeOfExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNARY_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveUnaryExpr(litaC_this, (litaC_ast__UnaryExpr*)litaC_expr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_EXPR: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
        default: {
            {
                litaC_ast_print__PrintStmt((litaC_ast__Stmt*)litaC_expr, 0);
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveFuncIdentifierExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__IdentifierExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_types__TypeInfo* litaC_type = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, &((litaC_expr->type->spec)));
    if(!(litaC_type)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->expr.stmt.node.startPos, "unknown function '%s'", litaC_expr->type->name);
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_symbols__Symbol* litaC_sym = litaC_type->sym;
    if(litaC_type->kind == litaC_types__TypeKind_FUNC_PTR) {
        {
            litaC_symbols__Symbol* litaC_funcSym = litaC_symbols__Scope_lookup(litaC_checker__TypeChecker_currentScope(litaC_this), litaC_expr->type->name);
            if(litaC_funcSym && litaC_funcSym->type && litaC_funcSym->type->kind == litaC_types__TypeKind_FUNC_PTR) {
                {
                    litaC_sym = litaC_funcSym;
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(!(litaC_sym)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->expr.stmt.node.startPos, "unknown function '%s'", litaC_expr->type->name);
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_expr->expr.operand.typeInfo = litaC_sym->type;
    litaC_expr->expr.operand.isRightValue = litaC_true;
    litaC_expr->sym = litaC_sym;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_isMethodSyntax(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,litaC_array__Array_cb_CallArg_ce_* litaC_suppliedArgs) {
    assert(litaC_expr != NULL);
    if(litaC_expr->object->stmt.node.kind != litaC_ast__StmtKind_GET_EXPR) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_ast__GetExpr* litaC_getExpr = (litaC_ast__GetExpr*)litaC_expr->object;
    if(litaC_getExpr->field->expr.operand.typeInfo->kind != litaC_types__TypeKind_FUNC) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_getExpr->flags & litaC_ast__GetExprFlags_IS_METHOD_ARG) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    litaC_getExpr->flags |= litaC_ast__GetExprFlags_IS_METHOD_ARG;
    litaC_array__Array_insertAt_cb_CallArg_ce_(litaC_suppliedArgs, 0, (litaC_ast__CallArg) {
        .argExpr = litaC_getExpr->object
    });
    return litaC_true;
    
    
}

litaC_ast__Expr* litaC_checker_expr__TypeChecker_coerceTypeWithUsing(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_sourceType,litaC_types__TypeInfo* litaC_targetType) {
    if(!(litaC_types__IsAggregateLike(litaC_targetType))) {
        {
            return litaC_expr;
            
            
            
        }
        
    } 
    
    if(!(litaC_types__IsAggregateLike(litaC_sourceType))) {
        {
            return litaC_expr;
            
            
            
        }
        
    } 
    
    litaC_types__AggregateTypeInfo* litaC_source = (litaC_types__AggregateTypeInfo*)litaC_types__TypeInfo_getBaseType(litaC_sourceType);
    litaC_types__AggregateTypeInfo* litaC_target = (litaC_types__AggregateTypeInfo*)litaC_types__TypeInfo_getBaseType(litaC_targetType);
    if(litaC_targetType->sym && litaC_targetType->sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
        {
            if(litaC_source->info.genericTypeid == litaC_target->info.genericTypeid) {
                {
                    return litaC_expr;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(litaC_source->info.typeInfo.typeid == litaC_target->info.typeInfo.typeid) {
        {
            return litaC_expr;
            
            
            
        }
        
    } 
    
    litaC_types__FieldPath litaC_path =  {
        
    };
    if(!(litaC_types__AggregateTypeInfo_getFieldPathByType(litaC_source, litaC_target, &(litaC_path)))) {
        {
            return litaC_expr;
            
            
            
        }
        
    } 
    
    litaC_ast__Expr* litaC_originalExpr = litaC_expr;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_path.numOfFields;litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_path.fields[litaC_i];
            assert(litaC_field.kind == litaC_ast__StmtKind_VAR_FIELD_DECL);
            litaC_char* litaC_name = (litaC_char*)litaC_mem__Allocator_alloc(litaC_this->lita->allocator, (litaC_field.varField->decl.name.value.str.length + 1) * sizeof(litaC_char));
            litaC_string_view__StringView_copyTo(litaC_field.varField->decl.name.value.str, litaC_name, litaC_field.varField->decl.name.value.str.length, litaC_true);
            litaC_ast__NameTypeSpec* litaC_nameTypeSpec = litaC_ast_new__NewNameTypeSpec(litaC_expr->stmt.node.startPos, litaC_name, litaC_this->lita->allocator);
            litaC_ast__IdentifierExpr* litaC_idExpr = (litaC_ast__IdentifierExpr*)litaC_ast_new__NewIdentifierExpr(litaC_expr->stmt.node.startPos, litaC_expr->stmt.node.endPos, litaC_nameTypeSpec, litaC_this->lita->allocator);
            litaC_ast__Node* litaC_parentExpr = litaC_expr->stmt.node.parent;
            litaC_expr = litaC_ast_new__NewGetExpr(litaC_expr->stmt.node.startPos, litaC_expr->stmt.node.endPos, litaC_expr, litaC_idExpr, litaC_this->lita->allocator);
            if(litaC_parentExpr) {
                {
                    litaC_ast__Node_becomeParentOf_cb_Expr_ce_(litaC_parentExpr, litaC_expr);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr))) {
        {
            return litaC_originalExpr;
            
            
            
        }
        
    } 
    
    return litaC_expr;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_coerceFuncArgs(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,litaC_types__TypeInfo* litaC_funcType,litaC_array__Array_cb_CallArg_ce_* litaC_suppliedArgs) {
    assert(litaC_types__IsFuncLike(litaC_funcType));
    if(litaC_funcType->kind == litaC_types__TypeKind_FUNC_PTR) {
        {
            litaC_types__FuncPtrTypeInfo* litaC_funcPtr = (litaC_types__FuncPtrTypeInfo*)litaC_funcType;
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcPtr->paramDecls))) && litaC_i < litaC_array__Array_size_cb_CallArg_ce_(litaC_suppliedArgs);litaC_i += 1) {
                {
                    litaC_ast__Expr* litaC_argExpr = litaC_array__Array_get_cb_CallArg_ce_(litaC_suppliedArgs, litaC_i).argExpr;
                    litaC_types__TypeInfo* litaC_paramInfo = litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_funcPtr->paramDecls)), litaC_i);
                    if(!(litaC_checker_expr__TypeChecker_coerceFuncArg(litaC_this, litaC_expr, litaC_i, litaC_argExpr, litaC_paramInfo, litaC_suppliedArgs))) {
                        {
                            return litaC_false;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } else {
        {
            litaC_types__FuncTypeInfo* litaC_funcInfo = (litaC_types__FuncTypeInfo*)litaC_funcType;
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params))) && litaC_i < litaC_array__Array_size_cb_CallArg_ce_(litaC_suppliedArgs);litaC_i += 1) {
                {
                    litaC_ast__Expr* litaC_argExpr = litaC_array__Array_get_cb_CallArg_ce_(litaC_suppliedArgs, litaC_i).argExpr;
                    litaC_types__TypeInfo* litaC_paramInfo = litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params)), litaC_i)->typeInfo;
                    if(!(litaC_checker_expr__TypeChecker_coerceFuncArg(litaC_this, litaC_expr, litaC_i, litaC_argExpr, litaC_paramInfo, litaC_suppliedArgs))) {
                        {
                            return litaC_false;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
    } 
    
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_coerceFuncArg(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,litaC_i32 litaC_index,litaC_ast__Expr* litaC_argExpr,litaC_types__TypeInfo* litaC_paramInfo,litaC_array__Array_cb_CallArg_ce_* litaC_suppliedArgs) {
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_argExpr))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_argInfo = litaC_argExpr->operand.typeInfo;
    if(litaC_argInfo->kind == litaC_types__TypeKind_ARRAY) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    if(!(litaC_types__IsAggregateLike(litaC_argInfo))) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    if(!(litaC_types__IsAggregateLike(litaC_paramInfo)) || litaC_types__IsTraitLike(litaC_paramInfo)) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    litaC_argExpr = litaC_checker_expr__TypeChecker_coerceTypeWithUsing(litaC_this, litaC_argExpr, litaC_argInfo, litaC_paramInfo);
    litaC_argInfo = litaC_argExpr->operand.typeInfo;
    if(litaC_types__IsPtrAggregate(litaC_paramInfo) && (!(litaC_types__IsPtrAggregate(litaC_argInfo)) && litaC_argInfo->kind != litaC_types__TypeKind_NULL)) {
        {
            if(litaC_argExpr->operand.isRightValue) {
                {
                    return litaC_true;
                    
                    
                    
                }
                
            } 
            
            litaC_ast__Expr* litaC_groupExpr = litaC_ast_new__NewGroupExpr(litaC_argExpr->stmt.node.startPos, litaC_argExpr->stmt.node.endPos, litaC_argExpr, litaC_this->lita->allocator);
            litaC_argExpr = litaC_ast_new__NewUnaryExpr(litaC_argExpr->stmt.node.startPos, litaC_argExpr->stmt.node.endPos, litaC_lex__TokenType_BAND, litaC_groupExpr, litaC_this->lita->allocator);
            if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_argExpr))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } else {
        if(litaC_types__IsAggregate(litaC_paramInfo) && litaC_types__IsPtrAggregate(litaC_argInfo)) {
            {
                litaC_ast__Expr* litaC_groupExpr = litaC_ast_new__NewGroupExpr(litaC_argExpr->stmt.node.startPos, litaC_argExpr->stmt.node.endPos, litaC_argExpr, litaC_this->lita->allocator);
                litaC_argExpr = litaC_ast_new__NewUnaryExpr(litaC_argExpr->stmt.node.startPos, litaC_argExpr->stmt.node.endPos, litaC_lex__TokenType_STAR, litaC_groupExpr, litaC_this->lita->allocator);
                if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_argExpr))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                
                
            }
            
        } 
        
    } 
    
    litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_argExpr);
    litaC_array__Array_set_cb_CallArg_ce_(litaC_suppliedArgs, litaC_index, (litaC_ast__CallArg) {
        .argExpr = litaC_argExpr
    });
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_checkNumberOfArgs(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,const litaC_char* litaC_funcName,litaC_i32 litaC_maxNumOfArgs,litaC_bool litaC_hasVarargs,litaC_i32 litaC_numberOfSuppliedArgs,litaC_i32 litaC_numberOfDefaultArgs) {
    assert(litaC_expr != NULL);
    if(litaC_maxNumOfArgs == litaC_numberOfSuppliedArgs) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_minNumOfArgs = litaC_maxNumOfArgs - litaC_numberOfDefaultArgs;
    if(litaC_numberOfSuppliedArgs == litaC_minNumOfArgs) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    if(litaC_minNumOfArgs > litaC_numberOfSuppliedArgs) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->expr.stmt.node.startPos, "'%s' called with too few arguments", litaC_funcName);
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_hasVarargs) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    if(litaC_maxNumOfArgs < litaC_numberOfSuppliedArgs) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->expr.stmt.node.startPos, "'%s' called with too many arguments", litaC_funcName);
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_types__TypeInfo* litaC_checker_expr__TypeChecker_inferredType(litaC_checker__TypeChecker* litaC_this,litaC_lex__Token litaC_name,litaC_types__TypeInfo* litaC_paramType,litaC_types__TypeInfo* litaC_expectedType) {
    assert(litaC_paramType != NULL);
    assert(litaC_expectedType != NULL);
    if(litaC_string_view__StringView_equals(litaC_name.value.str, litaC_paramType->name, -(1))) {
        {
            return litaC_expectedType;
            
            
            
        }
        
    } 
    
    if(litaC_paramType->kind != litaC_expectedType->kind) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_index = 0;
    if(litaC_paramType->sym && (litaC_paramType->sym->flags & litaC_symbols__SymbolFlags_IS_FROM_GENERIC_TEMPLATE)) {
        {
            litaC_array__Array_cb__ptr_TypeInfo_ce_ litaC_genericArgs = litaC_paramType->sym->genericArgs;
            for(;litaC_index < litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_genericArgs)));litaC_index += 1) {
                {
                    litaC_types__TypeInfo* litaC_arg = litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_genericArgs)), litaC_index);
                    if(litaC_string_view__StringView_equals(litaC_name.value.str, litaC_arg->name, -(1))) {
                        {
                            break;
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } else {
        if(litaC_paramType->kind == litaC_types__TypeKind_FUNC_PTR) {
            {
                assert(litaC_false);
                
                
            }
            
        } 
        
    } 
    
    switch(litaC_paramType->kind) {
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__ArrayTypeInfo* litaC_arrayInfo = (litaC_types__ArrayTypeInfo*)litaC_paramType;
                litaC_types__ArrayTypeInfo* litaC_expectedArrayInfo = (litaC_types__ArrayTypeInfo*)litaC_expectedType;
                return litaC_checker_expr__TypeChecker_inferredType(litaC_this, litaC_name, litaC_arrayInfo->arrayOf, litaC_expectedArrayInfo->arrayOf);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__ConstTypeInfo* litaC_constInfo = (litaC_types__ConstTypeInfo*)litaC_paramType;
                litaC_types__ConstTypeInfo* litaC_expectedConstInfo = (litaC_types__ConstTypeInfo*)litaC_expectedType;
                return litaC_checker_expr__TypeChecker_inferredType(litaC_this, litaC_name, litaC_constInfo->constOf, litaC_expectedConstInfo->constOf);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__PtrTypeInfo* litaC_ptrInfo = (litaC_types__PtrTypeInfo*)litaC_paramType;
                litaC_types__PtrTypeInfo* litaC_expectedPtrInfo = (litaC_types__PtrTypeInfo*)litaC_expectedType;
                return litaC_checker_expr__TypeChecker_inferredType(litaC_this, litaC_name, litaC_ptrInfo->ptrOf, litaC_expectedPtrInfo->ptrOf);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_TRAIT: 
        case litaC_types__TypeKind_UNION: 
        case litaC_types__TypeKind_STRUCT: {
            {
                litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_paramType;
                litaC_i32 litaC_size = litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_aggInfo->decl->decl.genericParams)));
                if(litaC_size == 0 || litaC_size <= litaC_index) {
                    {
                        break;
                        
                        
                    }
                    
                } 
                
                litaC_lex__Token litaC_genericName = litaC_array__Array_get_cb_GenericParam_ce_(&((litaC_aggInfo->decl->decl.genericParams)), litaC_index).name;
                litaC_types__AggregateTypeInfo* litaC_expectedAggInfo = (litaC_types__AggregateTypeInfo*)litaC_expectedType;
                litaC_char litaC_aggBaseName[256];
                litaC_char litaC_expectedBaseName[256];
                litaC_types__AggregateTypeInfo_getBaseName(litaC_aggInfo, litaC_aggBaseName);
                litaC_types__AggregateTypeInfo_getBaseName(litaC_expectedAggInfo, litaC_expectedBaseName);
                if(strcmp(litaC_aggBaseName, litaC_expectedBaseName) == 0) {
                    {
                        litaC_symbols__Symbol* litaC_sym = litaC_expectedAggInfo->info.typeInfo.sym;
                        litaC_i32 litaC_pSize = litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_sym->genericParams)));
                        if(litaC_pSize) {
                            {
                                for(litaC_i32 litaC_i = 0;litaC_i < litaC_pSize;litaC_i += 1) {
                                    {
                                        litaC_ast__GenericParam litaC_param = litaC_array__Array_get_cb_GenericParam_ce_(&((litaC_sym->genericParams)), litaC_i);
                                        if(litaC_string_view__StringView_equalsStringView(litaC_param.name.value.str, litaC_genericName.value.str)) {
                                            {
                                                return litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_sym->genericArgs)), litaC_i);
                                                
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        
                                        
                                    }
                                }
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                litaC_char litaC_fieldName[256];
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_aggInfo->decl->fields)));litaC_i += 1) {
                    {
                        litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_aggInfo->decl->fields)), litaC_i);
                        switch(litaC_field.kind) {
                            case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                                {
                                    litaC_ast__TraitFieldDecl* litaC_traitField = litaC_field.traitField;
                                    litaC_string_view__StringView_copyTo(litaC_traitField->decl.name.value.str, litaC_fieldName, litaC_symbols__MAX_SYMBOL_NAME, litaC_true);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                                {
                                    litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                                    litaC_string_view__StringView_copyTo(litaC_varField->decl.name.value.str, litaC_fieldName, litaC_symbols__MAX_SYMBOL_NAME, litaC_true);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                                {
                                    litaC_ast__EnumDecl* litaC_enumField = litaC_field.enumField;
                                    litaC_string_view__StringView_copyTo(litaC_enumField->decl.name.value.str, litaC_fieldName, litaC_symbols__MAX_SYMBOL_NAME, litaC_true);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                            case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                                {
                                    litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                                    litaC_string_view__StringView_copyTo(litaC_aggField->decl.declaration.name.value.str, litaC_fieldName, litaC_symbols__MAX_SYMBOL_NAME, litaC_true);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            default: {
                                {
                                    continue;
                                    
                                    
                                }
                                
                                
                            }
                        }
                        litaC_ast__FieldStmt litaC_argumentField = litaC_types__AggregateTypeInfo_getField(litaC_expectedAggInfo, litaC_fieldName);
                        if(litaC_argumentField.kind != litaC_ast__StmtKind_POISON_EXPR) {
                            {
                                assert(litaC_field.typeInfo != NULL);
                                litaC_types__TypeInfo* litaC_fieldType = litaC_checker_expr__TypeChecker_inferredType(litaC_this, litaC_genericName, litaC_field.typeInfo, litaC_argumentField.typeInfo);
                                if(litaC_fieldType) {
                                    {
                                        return litaC_fieldType;
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC_PTR: {
            {
                litaC_types__FuncPtrTypeInfo* litaC_funcInfo = (litaC_types__FuncPtrTypeInfo*)litaC_paramType;
                if(litaC_array__Array_empty_cb_GenericParam_ce_(&((litaC_funcInfo->genericParams))) || litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_funcInfo->genericParams))) <= litaC_index) {
                    {
                        break;
                        
                        
                    }
                    
                } 
                
                litaC_lex__Token litaC_genericName = litaC_array__Array_get_cb_GenericParam_ce_(&((litaC_funcInfo->genericParams)), litaC_index).name;
                litaC_types__FuncPtrTypeInfo* litaC_argumentFuncInfo = (litaC_types__FuncPtrTypeInfo*)litaC_expectedType;
                litaC_types__TypeInfo* litaC_retType = litaC_checker_expr__TypeChecker_inferredType(litaC_this, litaC_genericName, litaC_funcInfo->returnType, litaC_argumentFuncInfo->returnType);
                if(litaC_retType) {
                    {
                        return litaC_retType;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcInfo->paramDecls)));litaC_i += 1) {
                    {
                        if(litaC_i < litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_argumentFuncInfo->paramDecls)))) {
                            {
                                litaC_types__TypeInfo* litaC_pType = litaC_checker_expr__TypeChecker_inferredType(litaC_this, litaC_genericName, litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_funcInfo->paramDecls)), litaC_i), litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_argumentFuncInfo->paramDecls)), litaC_i));
                                if(litaC_pType) {
                                    {
                                        return litaC_pType;
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        default: {
            {
                break;
                
                
            }
            
            
        }
    }
    return NULL;
    
    
}

litaC_types__TypeInfo* litaC_checker_expr__TypeChecker_inferFuncCallExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,litaC_types__TypeInfo* litaC_funcType,litaC_array__Array_cb_CallArg_ce_* litaC_suppliedArgs,litaC_bool litaC_isMethodCall) {
    assert(litaC_types__IsFuncLike(litaC_funcType));
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_CallArg_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
        {
            litaC_ast__CallArg litaC_arg = litaC_array__Array_get_cb_CallArg_ce_(&((litaC_expr->arguments)), litaC_i);
            if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_arg.argExpr))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_ast__Expr* litaC_objectExpr = litaC_expr->object;
    if(litaC_isMethodCall) {
        {
            litaC_ast__GetExpr* litaC_getExpr = (litaC_ast__GetExpr*)litaC_expr->object;
            litaC_objectExpr = &(litaC_getExpr->field->expr);
            
            
        }
        
    } 
    
    if(litaC_objectExpr->stmt.node.kind != litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR) {
        {
            return litaC_funcType;
            
            
            
        }
        
    } 
    
    litaC_ast__IdentifierExpr* litaC_funcExpr = (litaC_ast__IdentifierExpr*)litaC_objectExpr;
    litaC_ast__NameTypeSpec* litaC_nameSpec = litaC_funcExpr->type;
    litaC_nameSpec->spec.typeInfo = NULL;
    litaC_array__Array_cb_GenericParam_ce_ litaC_genericParams;
    if(litaC_funcType->kind == litaC_types__TypeKind_FUNC_PTR) {
        {
            litaC_types__FuncPtrTypeInfo* litaC_funcPtr = (litaC_types__FuncPtrTypeInfo*)litaC_funcType;
            litaC_genericParams = litaC_funcPtr->genericParams;
            litaC_i32 litaC_size = litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_genericParams)));
            litaC_array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_nameSpec->genericArgs)), litaC_size, litaC_this->lita->allocator);
            litaC_array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)), litaC_size, litaC_this->lita->allocator);
            litaC_i32 litaC_suppliedArgsSize = litaC_array__Array_size_cb_CallArg_ce_(litaC_suppliedArgs);
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_size;litaC_i += 1) {
                {
                    litaC_ast__GenericParam litaC_genericParam = litaC_array__Array_get_cb_GenericParam_ce_(&((litaC_genericParams)), litaC_i);
                    for(litaC_i32 litaC_j = 0;litaC_j < litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcPtr->paramDecls)));litaC_j += 1) {
                        {
                            litaC_types__TypeInfo* litaC_paramType = litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_funcPtr->paramDecls)), litaC_j);
                            if(litaC_j >= litaC_suppliedArgsSize) {
                                {
                                    break;
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_types__TypeInfo* litaC_argType = litaC_array__Array_get_cb_CallArg_ce_(litaC_suppliedArgs, litaC_j).argExpr->operand.typeInfo;
                            assert(litaC_argType != NULL);
                            assert(litaC_paramType != NULL);
                            litaC_types__TypeInfo* litaC_inferredType = litaC_checker_expr__TypeChecker_inferredType(litaC_this, litaC_genericParam.name, litaC_paramType, litaC_argType);
                            if(litaC_inferredType) {
                                {
                                    litaC_array__Array_add_cb__ptr_TypeSpec_ce_(&((litaC_nameSpec->genericArgs)), litaC_types__TypeInfo_asTypeSpec(litaC_inferredType, litaC_this->lita->allocator));
                                    break;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                    }
                    
                    
                }
            }
            
            
        }
        
    } else {
        {
            litaC_types__FuncTypeInfo* litaC_funcInfo = (litaC_types__FuncTypeInfo*)litaC_funcType;
            litaC_genericParams = litaC_funcInfo->decl->decl.genericParams;
            litaC_i32 litaC_size = litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_genericParams)));
            litaC_array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_nameSpec->genericArgs)), litaC_size, litaC_this->lita->allocator);
            litaC_array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)), litaC_size, litaC_this->lita->allocator);
            litaC_i32 litaC_suppliedArgsSize = litaC_array__Array_size_cb_CallArg_ce_(litaC_suppliedArgs);
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_size;litaC_i += 1) {
                {
                    litaC_ast__GenericParam litaC_genericParam = litaC_array__Array_get_cb_GenericParam_ce_(&((litaC_genericParams)), litaC_i);
                    for(litaC_i32 litaC_j = 0;litaC_j < litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params)));litaC_j += 1) {
                        {
                            litaC_types__TypeInfo* litaC_paramType = litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params)), litaC_j)->typeInfo;
                            if(litaC_j >= litaC_suppliedArgsSize) {
                                {
                                    break;
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_types__TypeInfo* litaC_argType = litaC_array__Array_get_cb_CallArg_ce_(litaC_suppliedArgs, litaC_j).argExpr->operand.typeInfo;
                            assert(litaC_argType != NULL);
                            assert(litaC_paramType != NULL);
                            litaC_types__TypeInfo* litaC_inferredType = litaC_checker_expr__TypeChecker_inferredType(litaC_this, litaC_genericParam.name, litaC_paramType, litaC_argType);
                            if(litaC_inferredType) {
                                {
                                    litaC_array__Array_add_cb__ptr_TypeSpec_ce_(&((litaC_nameSpec->genericArgs)), litaC_types__TypeInfo_asTypeSpec(litaC_inferredType, litaC_this->lita->allocator));
                                    break;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                    }
                    
                    
                }
            }
            
            
        }
    } 
    
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->object))) {
        {
            for(litaC_i32 litaC_i = litaC_array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)));litaC_i < litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_genericParams)));litaC_i += 1) {
                {
                    litaC_ast__GenericParam litaC_param = litaC_array__Array_get_cb_GenericParam_ce_(&((litaC_genericParams)), litaC_i);
                    litaC_checker_expr__TypeChecker_errorInferGenericParameter(litaC_this, &((litaC_expr->expr)), &(litaC_param));
                    
                    
                }
            }
            goto err;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_type = litaC_expr->object->operand.typeInfo;
    assert(litaC_types__IsFuncLike(litaC_type));
    if(litaC_type->sym && litaC_type->sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
        {
            litaC_ast__GenericDecl* litaC_decl = (litaC_ast__GenericDecl*)litaC_type->sym->decl;
            litaC_checker_expr__TypeChecker_errorMissingGenericArguments(litaC_this, &((litaC_funcExpr->expr)), litaC_nameSpec->name, &((litaC_decl->genericParams)));
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_type;
    
    err:;
    
    return NULL;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_checkFuncCallArgs(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,litaC_types__TypeInfo* litaC_funcType,litaC_array__Array_cb_CallArg_ce_* litaC_suppliedArgs) {
    assert(litaC_funcType != NULL);
    assert(litaC_types__IsFuncLike(litaC_funcType));
    litaC_i32 litaC_numberOfSuppliedArgs = litaC_array__Array_size_cb_CallArg_ce_(litaC_suppliedArgs);
    litaC_bool litaC_success = litaC_true;
    litaC_bool litaC_hasVarargs = litaC_false;
    litaC_i32 litaC_i = 0;
    if(litaC_funcType->kind == litaC_types__TypeKind_FUNC_PTR) {
        {
            litaC_types__FuncPtrTypeInfo* litaC_funcPtr = (litaC_types__FuncPtrTypeInfo*)litaC_funcType;
            litaC_hasVarargs = litaC_funcPtr->hasVarargs;
            for(;litaC_i < litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcPtr->paramDecls)));litaC_i += 1) {
                {
                    litaC_types__TypeInfo* litaC_p = litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_funcPtr->paramDecls)), litaC_i);
                    if(litaC_i < litaC_numberOfSuppliedArgs) {
                        {
                            litaC_ast__CallArg* litaC_callArg = litaC_array__Array_getPtr_cb_CallArg_ce_(litaC_suppliedArgs, litaC_i);
                            litaC_ast__Expr* litaC_arg = litaC_callArg->argExpr;
                            if(litaC_callArg->argName.type == litaC_lex__TokenType_IDENTIFIER) {
                                {
                                    litaC_checker_expr__TypeChecker_errorNamedArgumentsForFuncPtr(litaC_this, litaC_arg);
                                    litaC_success = litaC_false;
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_callArg->index = litaC_i;
                            litaC_checker__TypeChecker_checkTypeCompatibility(litaC_this, litaC_arg->stmt.node.startPos, litaC_p, litaC_arg->operand.typeInfo);
                            litaC_arg->expectedType = litaC_p;
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } else {
        {
            litaC_types__FuncTypeInfo* litaC_funcInfo = (litaC_types__FuncTypeInfo*)litaC_funcType;
            litaC_bool litaC_hasNamedArg = litaC_false;
            litaC_hasVarargs = litaC_funcInfo->decl->params->isVararg;
            for(;litaC_i < litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params)));litaC_i += 1) {
                {
                    litaC_ast__ParameterDecl* litaC_p = litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params)), litaC_i);
                    if(litaC_i < litaC_numberOfSuppliedArgs) {
                        {
                            litaC_ast__CallArg* litaC_callArg = litaC_array__Array_getPtr_cb_CallArg_ce_(litaC_suppliedArgs, litaC_i);
                            litaC_i32 litaC_paramIndex = litaC_i;
                            if(litaC_callArg->argName.type == litaC_lex__TokenType_IDENTIFIER) {
                                {
                                    litaC_hasNamedArg = litaC_true;
                                    litaC_paramIndex = -(1);
                                    for(litaC_i32 litaC_index = 0;litaC_index < litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params)));litaC_index += 1) {
                                        {
                                            litaC_ast__ParameterDecl* litaC_param = litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params)), litaC_index);
                                            if(litaC_string_view__StringView_equalsStringView(litaC_param->decl.name.value.str, litaC_callArg->argName.value.str)) {
                                                {
                                                    litaC_paramIndex = litaC_index;
                                                    break;
                                                    
                                                    
                                                }
                                                
                                            } 
                                            
                                            
                                            
                                        }
                                    }
                                    if(litaC_paramIndex < 0) {
                                        {
                                            litaC_checker_expr__TypeChecker_errorInvalidNamedArgument(litaC_this, litaC_callArg->argName.pos, &((litaC_callArg->argName.value.str)), litaC_funcInfo);
                                            litaC_success = litaC_false;
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    
                                    
                                }
                                
                            } else {
                                if(litaC_hasNamedArg) {
                                    {
                                        if(!(litaC_string_view__StringView_equalsStringView(litaC_p->decl.name.value.str, litaC_callArg->argName.value.str))) {
                                            {
                                                litaC_checker_expr__TypeChecker_errorFixedArgumentAfterNamed(litaC_this, litaC_callArg->argExpr);
                                                litaC_success = litaC_false;
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                            } 
                            
                            litaC_ast__Expr* litaC_arg = litaC_callArg->argExpr;
                            litaC_callArg->index = litaC_paramIndex;
                            litaC_checker__TypeChecker_checkTypeCompatibility(litaC_this, litaC_arg->stmt.node.startPos, litaC_p->typeInfo, litaC_arg->operand.typeInfo);
                            litaC_arg->expectedType = litaC_p->typeInfo;
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            for(litaC_i32 litaC_index = 0;litaC_index < litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params)));litaC_index += 1) {
                {
                    litaC_ast__ParameterDecl* litaC_param = litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params)), litaC_index);
                    if(litaC_param->defaultExpr) {
                        {
                            litaC_bool litaC_hasValue = litaC_false;
                            for(litaC_i32 litaC_j = 0;litaC_j < litaC_array__Array_size_cb_CallArg_ce_(litaC_suppliedArgs);litaC_j += 1) {
                                {
                                    litaC_ast__CallArg* litaC_callArg = litaC_array__Array_getPtr_cb_CallArg_ce_(litaC_suppliedArgs, litaC_j);
                                    if(litaC_callArg->index == litaC_index) {
                                        {
                                            litaC_hasValue = litaC_true;
                                            break;
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    
                                    
                                }
                            }
                            if(!(litaC_hasValue)) {
                                {
                                    litaC_array__Array_add_cb_CallArg_ce_(litaC_suppliedArgs, (litaC_ast__CallArg) {
                                        .argExpr = litaC_param->defaultExpr,
                                        .index = litaC_index
                                    });
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
    } 
    
    if(litaC_hasVarargs) {
        {
            for(;litaC_i < litaC_numberOfSuppliedArgs;litaC_i += 1) {
                {
                    litaC_ast__CallArg* litaC_arg = litaC_array__Array_getPtr_cb_CallArg_ce_(litaC_suppliedArgs, litaC_i);
                    litaC_arg->index = litaC_i;
                    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_arg->argExpr))) {
                        {
                            return litaC_false;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } 
    
    return litaC_success;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveFuncCallExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->object))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_objectType = litaC_expr->object->operand.typeInfo;
    if(!(litaC_types__IsFuncLike(litaC_objectType))) {
        {
            litaC_checker_expr__TypeChecker_errorNonFuncType(litaC_this, litaC_expr->object, litaC_objectType);
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_bool litaC_isMethod = litaC_false;
    litaC_i32 litaC_numberOfDefaultArgs = 0;
    litaC_array__Array_cb_CallArg_ce_ litaC_suppliedArgs = litaC_array__ArrayInit_cb_CallArg_ce_(litaC_array__Array_size_cb_CallArg_ce_(&((litaC_expr->arguments))) + 1, litaC_this->lita->allocator);
    litaC_array__Array_addAll_cb_CallArg_ce_(&((litaC_suppliedArgs)), &((litaC_expr->arguments)));
    litaC_bool litaC_hasVarargs = litaC_false;
    litaC_i32 litaC_maxNumOfArgs = 0;
    litaC_types__TypeInfo* litaC_returnType = NULL;
    litaC_array__Array_cb_GenericParam_ce_ litaC_genericParams;
    if(litaC_objectType->kind == litaC_types__TypeKind_FUNC) {
        {
            litaC_types__FuncTypeInfo* litaC_funcInfo = (litaC_types__FuncTypeInfo*)litaC_objectType;
            litaC_isMethod = (litaC_funcInfo->decl->flags & litaC_ast__FuncFlags_IS_METHOD);
            litaC_maxNumOfArgs = litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params)));
            litaC_hasVarargs = litaC_funcInfo->decl->params->isVararg;
            litaC_returnType = litaC_funcInfo->returnType;
            litaC_genericParams = litaC_funcInfo->decl->decl.genericParams;
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params)));litaC_i += 1) {
                {
                    litaC_ast__ParameterDecl* litaC_p = litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params)), litaC_i);
                    if(litaC_p->defaultExpr) {
                        {
                            litaC_numberOfDefaultArgs += 1;
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } else {
        {
            litaC_types__FuncPtrTypeInfo* litaC_funcPtr = (litaC_types__FuncPtrTypeInfo*)litaC_objectType;
            litaC_maxNumOfArgs = litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcPtr->paramDecls)));
            litaC_hasVarargs = litaC_funcPtr->hasVarargs;
            litaC_returnType = litaC_funcPtr->returnType;
            litaC_genericParams = litaC_funcPtr->genericParams;
            if(litaC_expr->object->stmt.node.kind == litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR) {
                {
                    litaC_ast__IdentifierExpr* litaC_idExpr = (litaC_ast__IdentifierExpr*)litaC_expr->object;
                    litaC_funcPtr->info.typeInfo.name = litaC_idExpr->type->name;
                    
                    
                }
                
            } else {
                if(litaC_expr->object->stmt.node.kind == litaC_ast__StmtKind_GET_EXPR) {
                    {
                        litaC_ast__GetExpr* litaC_getExpr = (litaC_ast__GetExpr*)litaC_expr->object;
                        litaC_funcPtr->info.typeInfo.name = litaC_getExpr->field->type->name;
                        
                        
                    }
                    
                } 
                
            } 
            
            
            
        }
    } 
    
    litaC_bool litaC_isMethodCall = litaC_isMethod && litaC_checker_expr__TypeChecker_isMethodSyntax(litaC_this, litaC_expr, &(litaC_suppliedArgs));
    litaC_i32 litaC_numberOfSuppliedArgs = litaC_array__Array_size_cb_CallArg_ce_(&((litaC_suppliedArgs)));
    litaC_checker_expr__TypeChecker_checkNumberOfArgs(litaC_this, litaC_expr, litaC_objectType->name, litaC_maxNumOfArgs, litaC_hasVarargs, litaC_numberOfSuppliedArgs, litaC_numberOfDefaultArgs);
    if(!(litaC_checker_expr__TypeChecker_coerceFuncArgs(litaC_this, litaC_expr, litaC_objectType, &((litaC_suppliedArgs))))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_array__Array_empty_cb_GenericParam_ce_(&((litaC_genericParams))))) {
        {
            if(litaC_array__Array_empty_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)))) {
                {
                    litaC_objectType = litaC_checker_expr__TypeChecker_inferFuncCallExpr(litaC_this, litaC_expr, litaC_objectType, &((litaC_suppliedArgs)), litaC_isMethodCall);
                    if(!(litaC_objectType)) {
                        {
                            return litaC_false;
                            
                            
                            
                        }
                        
                    } 
                    
                    assert(litaC_types__IsFuncLike(litaC_objectType));
                    if(litaC_objectType->kind == litaC_types__TypeKind_FUNC) {
                        {
                            litaC_types__FuncTypeInfo* litaC_funcInfo = (litaC_types__FuncTypeInfo*)litaC_objectType;
                            litaC_returnType = litaC_funcInfo->returnType;
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_types__FuncPtrTypeInfo* litaC_funcPtr = (litaC_types__FuncPtrTypeInfo*)litaC_objectType;
                            litaC_returnType = litaC_funcPtr->returnType;
                            
                            
                        }
                    } 
                    
                    
                    
                }
                
            } else {
                {
                    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)));litaC_i += 1) {
                        {
                            litaC_ast__TypeSpec* litaC_arg = litaC_array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)), litaC_i);
                            litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_arg);
                            
                            
                        }
                    }
                    
                    
                }
            } 
            
            
            
        }
        
    } 
    
    if(!(litaC_checker_expr__TypeChecker_checkFuncCallArgs(litaC_this, litaC_expr, litaC_objectType, &((litaC_suppliedArgs))))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    assert(litaC_returnType != NULL);
    litaC_array__Array_sort_cb_CallArg_ce_(&((litaC_suppliedArgs)), litaC_ast__CallArgSort);
    litaC_expr->arguments = *(litaC_ast__Node_becomeParentOfChildrenCallArgs(&((litaC_expr->expr.stmt.node)), &((litaC_suppliedArgs))));
    litaC_expr->expr.operand.typeInfo = litaC_returnType;
    litaC_expr->expr.operand.isRightValue = litaC_true;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveBooleanExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__BooleanExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_expr->expr.operand.typeInfo = &(litaC_types__BOOL_TYPE);
    litaC_expr->expr.operand.isConst = litaC_true;
    litaC_expr->expr.operand.isRightValue = litaC_true;
    litaC_expr->expr.operand.val.intValue = litaC_expr->boolean;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveCharExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__CharExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_expr->expr.operand.typeInfo = &(litaC_types__CHAR_TYPE);
    litaC_expr->expr.operand.isConst = litaC_true;
    litaC_expr->expr.operand.isRightValue = litaC_true;
    litaC_expr->expr.operand.val = litaC_expr->character.value;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveNullExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__NullExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_expr->expr.operand.typeInfo = &(litaC_types__NULL_TYPE);
    litaC_expr->expr.operand.isConst = litaC_true;
    litaC_expr->expr.operand.isRightValue = litaC_true;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveNumberExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__NumberExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_expr->expr.operand.typeInfo = litaC_expr->number.typeInfo;
    litaC_expr->expr.operand.isConst = litaC_true;
    litaC_expr->expr.operand.isRightValue = litaC_true;
    litaC_expr->expr.operand.val = litaC_expr->number.value;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveStringExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__StringExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_expr->expr.operand.typeInfo = &(litaC_types__STR_TYPE);
    litaC_expr->expr.operand.isConst = litaC_true;
    litaC_expr->expr.operand.isRightValue = litaC_true;
    litaC_expr->expr.operand.val = litaC_expr->string.value;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveSubscriptSetExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__SubscriptSetExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->object))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->index))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->value))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_baseObj = NULL;
    litaC_types__TypeInfo* litaC_objectType = litaC_expr->object->operand.typeInfo;
    switch(litaC_objectType->kind) {
        case litaC_types__TypeKind_STR: {
            {
                litaC_checker_expr__TypeChecker_errorSetIndexingConstType(litaC_this, litaC_expr->object, litaC_objectType);
                return litaC_false;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__PtrTypeInfo* litaC_ptrInfo = (litaC_types__PtrTypeInfo*)litaC_objectType;
                litaC_baseObj = litaC_ptrInfo->ptrOf;
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__ArrayTypeInfo* litaC_arrayInfo = (litaC_types__ArrayTypeInfo*)litaC_objectType;
                litaC_baseObj = litaC_arrayInfo->arrayOf;
                break;
                
                
            }
            
            
        }
        default: {
            {
                litaC_checker_expr__TypeChecker_errorNonIndexableType(litaC_this, litaC_expr->object, litaC_objectType);
                return litaC_false;
                
                
                
            }
            
            
        }
    }
    if(litaC_baseObj->kind == litaC_types__TypeKind_CONST) {
        {
            litaC_checker_expr__TypeChecker_errorSetIndexingConstType(litaC_this, litaC_expr->object, litaC_objectType);
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_indexType = litaC_expr->index->operand.typeInfo;
    if(!(litaC_types__IsInteger(litaC_indexType))) {
        {
            litaC_checker_expr__TypeChecker_errorIndexType(litaC_this, litaC_expr->index, litaC_indexType);
            
            
        }
        
    } 
    
    litaC_checker__TypeChecker_checkTypeCompatibility(litaC_this, litaC_expr->value->stmt.node.startPos, litaC_baseObj, litaC_expr->value->operand.typeInfo);
    litaC_expr->expr.operand.typeInfo = litaC_expr->value->operand.typeInfo;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveSubscriptGetExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__SubscriptGetExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->object))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->index))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_baseObj = NULL;
    litaC_types__TypeInfo* litaC_objectType = litaC_expr->object->operand.typeInfo;
    switch(litaC_objectType->kind) {
        case litaC_types__TypeKind_STR: {
            {
                litaC_baseObj = &(litaC_types__CHAR_TYPE);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__PtrTypeInfo* litaC_ptrInfo = (litaC_types__PtrTypeInfo*)litaC_objectType;
                litaC_baseObj = litaC_ptrInfo->ptrOf;
                if(litaC_baseObj->kind == litaC_types__TypeKind_CONST) {
                    {
                        litaC_types__ConstTypeInfo* litaC_constInfo = (litaC_types__ConstTypeInfo*)litaC_baseObj;
                        litaC_baseObj = litaC_constInfo->constOf;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__ArrayTypeInfo* litaC_arrayInfo = (litaC_types__ArrayTypeInfo*)litaC_objectType;
                litaC_baseObj = litaC_arrayInfo->arrayOf;
                if(litaC_baseObj->kind == litaC_types__TypeKind_CONST) {
                    {
                        litaC_types__ConstTypeInfo* litaC_constInfo = (litaC_types__ConstTypeInfo*)litaC_baseObj;
                        litaC_baseObj = litaC_constInfo->constOf;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        default: {
            {
                litaC_checker_expr__TypeChecker_errorNonIndexableType(litaC_this, litaC_expr->object, litaC_objectType);
                return litaC_false;
                
                
                
            }
            
            
        }
    }
    litaC_types__TypeInfo* litaC_indexType = litaC_expr->index->operand.typeInfo;
    if(!(litaC_types__IsInteger(litaC_indexType))) {
        {
            litaC_checker_expr__TypeChecker_errorIndexType(litaC_this, litaC_expr->index, litaC_indexType);
            
            
        }
        
    } 
    
    litaC_expr->expr.operand.typeInfo = litaC_baseObj;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveInitArgExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__InitArgExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_expr->expr.operand.typeInfo = &(litaC_types__NULL_TYPE);
    if(litaC_expr->value) {
        {
            if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->value))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_expr->expr.operand = litaC_expr->value->operand;
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_addDefaultArguments(litaC_checker__TypeChecker* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_ast__InitExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    assert(litaC_types__IsAggregate(litaC_type));
    litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_type;
    litaC_array__Array_cb__ptr_InitArgExpr_ce_ litaC_defaultArgs =  {
        
    };
    litaC_array__Array_init_cb__ptr_InitArgExpr_ce_(&((litaC_defaultArgs)), litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_aggInfo->decl->fields))), litaC_this->lita->allocator);
    for(litaC_i32 litaC_position = 0;litaC_position < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_aggInfo->decl->fields)));litaC_position += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_aggInfo->decl->fields)), litaC_position);
            if(litaC_field.kind != litaC_ast__StmtKind_VAR_FIELD_DECL) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(!(litaC_field.varField->defaultExpr)) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            litaC_bool litaC_byName = litaC_false;
            litaC_bool litaC_byPos = litaC_false;
            litaC_bool litaC_hasNamedArgs = litaC_false;
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
                {
                    litaC_ast__InitArgExpr* litaC_arg = litaC_array__Array_get_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)), litaC_i);
                    if(litaC_arg->fieldName.type == litaC_lex__TokenType_IDENTIFIER) {
                        {
                            litaC_hasNamedArgs = litaC_true;
                            if(litaC_string_view__StringView_equalsStringView(litaC_arg->fieldName.value.str, litaC_field.varField->decl.name.value.str)) {
                                {
                                    litaC_byName = litaC_true;
                                    break;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } else {
                        if(litaC_arg->argPosition == litaC_position) {
                            {
                                litaC_byPos = litaC_true;
                                break;
                                
                                
                            }
                            
                        } 
                        
                    } 
                    
                    
                    
                }
            }
            if(!(litaC_byName) && !((!(litaC_hasNamedArgs) && litaC_byPos))) {
                {
                    litaC_ast__InitArgExpr* litaC_arg = (litaC_ast__InitArgExpr*)litaC_ast_new__NewInitArgExpr(litaC_expr->expr.stmt.node.startPos, litaC_expr->expr.stmt.node.endPos, litaC_field.varField->decl.name, litaC_position, litaC_field.varField->defaultExpr, litaC_this->lita->allocator);
                    litaC_ast__Node_becomeParentOf_cb_InitArgExpr_ce_(&((litaC_expr->expr.stmt.node)), litaC_arg);
                    litaC_array__Array_add_cb__ptr_InitArgExpr_ce_(&((litaC_defaultArgs)), litaC_arg);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_defaultArgs)));litaC_i += 1) {
        {
            litaC_ast__InitArgExpr* litaC_arg = litaC_array__Array_get_cb__ptr_InitArgExpr_ce_(&((litaC_defaultArgs)), litaC_i);
            litaC_array__Array_add_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)), litaC_arg);
            
            
        }
    }
    return litaC_true;
    
    
}

litaC_void litaC_checker_expr__TypeChecker_addInitArgumentsReferences(litaC_checker__TypeChecker* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_ast__InitExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    if(litaC_types__IsAggregate(litaC_type)) {
        {
            litaC_char litaC_fieldName[256];
            litaC_string__String litaC_fieldNameStr = litaC_string__StringInit(litaC_fieldName, litaC_symbols__MAX_SYMBOL_NAME, -(1));
            litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_type;
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
                {
                    litaC_ast__InitArgExpr* litaC_arg = litaC_array__Array_get_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)), litaC_i);
                    litaC_ast__FieldStmt litaC_field;
                    if(litaC_arg->fieldName.type == litaC_lex__TokenType_IDENTIFIER) {
                        {
                            litaC_string__String_format(&((litaC_fieldNameStr)), "%.*s", litaC_arg->fieldName.value.str.length, litaC_arg->fieldName.value.str.buffer);
                            litaC_field = litaC_types__AggregateTypeInfo_getField(litaC_aggInfo, litaC_string__String_cStr(litaC_fieldNameStr));
                            litaC_types__FieldPositionResult litaC_fieldResult = litaC_types__AggregateTypeInfo_getFieldPosition(litaC_aggInfo, litaC_string__String_cStr(litaC_fieldNameStr));
                            if(litaC_fieldResult.aggInfo) {
                                {
                                    litaC_references__ReferenceDatabase_addFieldReference(&((litaC_this->lita->references)), litaC_arg->expr.stmt.node.startPos, &((litaC_fieldResult.aggInfo->info.typeInfo)), litaC_fieldResult.position);
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } 
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_checkInitArguments(litaC_checker__TypeChecker* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_ast__InitExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    litaC_bool litaC_isSuccessful = litaC_true;
    if(litaC_types__IsAggregate(litaC_type)) {
        {
            litaC_char litaC_fieldName[256];
            litaC_string__String litaC_fieldNameStr = litaC_string__StringInit(litaC_fieldName, litaC_symbols__MAX_SYMBOL_NAME, -(1));
            litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_type;
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
                {
                    litaC_ast__InitArgExpr* litaC_arg = litaC_array__Array_get_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)), litaC_i);
                    litaC_ast__FieldStmt litaC_field;
                    if(litaC_arg->fieldName.type == litaC_lex__TokenType_IDENTIFIER) {
                        {
                            litaC_string__String_format(&((litaC_fieldNameStr)), "%.*s", litaC_arg->fieldName.value.str.length, litaC_arg->fieldName.value.str.buffer);
                            litaC_field = litaC_types__AggregateTypeInfo_getField(litaC_aggInfo, litaC_string__String_cStr(litaC_fieldNameStr));
                            if(litaC_field.kind == litaC_ast__StmtKind_POISON_EXPR) {
                                {
                                    litaC_checker_expr__TypeChecker_errorNoField(litaC_this, &((litaC_arg->expr)), litaC_type, litaC_string__String_cStr(litaC_fieldNameStr));
                                    litaC_isSuccessful = litaC_false;
                                    continue;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_field = litaC_types__AggregateTypeInfo_getFieldByPosition(litaC_aggInfo, litaC_arg->argPosition);
                            if(litaC_field.kind == litaC_ast__StmtKind_POISON_EXPR) {
                                {
                                    litaC_checker_expr__TypeChecker_errorNoFieldAt(litaC_this, &((litaC_arg->expr)), litaC_type, litaC_arg->argPosition);
                                    litaC_isSuccessful = litaC_false;
                                    continue;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                    } 
                    
                    litaC_checker__TypeChecker_checkTypeCompatibility(litaC_this, litaC_arg->expr.stmt.node.startPos, litaC_field.typeInfo, litaC_arg->expr.operand.typeInfo);
                    litaC_arg->expr.expectedType = litaC_field.typeInfo;
                    litaC_arg->value->expectedType = litaC_field.typeInfo;
                    
                    
                }
            }
            
            
        }
        
    } else {
        if(litaC_type->kind == litaC_types__TypeKind_ARRAY) {
            {
                litaC_types__ArrayTypeInfo* litaC_arrayInfo = (litaC_types__ArrayTypeInfo*)litaC_type;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
                    {
                        litaC_ast__InitArgExpr* litaC_arg = litaC_array__Array_get_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)), litaC_i);
                        litaC_checker__TypeChecker_checkTypeCompatibility(litaC_this, litaC_arg->expr.stmt.node.startPos, litaC_arrayInfo->arrayOf, litaC_arg->expr.operand.typeInfo);
                        litaC_arg->expr.expectedType = litaC_arrayInfo->arrayOf;
                        litaC_arg->value->expectedType = litaC_arrayInfo->arrayOf;
                        
                        
                    }
                }
                
                
            }
            
        } 
        
    } 
    
    return litaC_isSuccessful;
    
    
}

litaC_types__TypeInfo* litaC_checker_expr__TypeChecker_inferInitExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__InitExpr* litaC_expr,litaC_types__AggregateTypeInfo* litaC_aggInfo) {
    litaC_i32 litaC_size = litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_aggInfo->decl->decl.genericParams)));
    litaC_array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)), litaC_size, litaC_this->lita->allocator);
    litaC_array__Array_cb__ptr_TypeInfo_ce_ litaC_suppliedArgs = litaC_array__ArrayInit_cb__ptr_TypeInfo_ce_(litaC_array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments))), litaC_this->lita->allocator);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
        {
            litaC_ast__InitArgExpr* litaC_arg = litaC_array__Array_get_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)), litaC_i);
            litaC_types__TypeInfo* litaC_type = litaC_arg->expr.operand.typeInfo;
            if(!(litaC_type)) {
                {
                    litaC_checker_expr__TypeChecker_errorInferGenericParameters(litaC_this, &((litaC_expr->expr)), &((litaC_aggInfo->decl->decl.genericParams)));
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_array__Array_add_cb__ptr_TypeInfo_ce_(&((litaC_suppliedArgs)), litaC_type);
            
            
        }
    }
    if(!(litaC_expr->type)) {
        {
            return (litaC_types__TypeInfo*)litaC_aggInfo;
            
            
            
        }
        
    } 
    
    litaC_array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_expr->type->genericArgs)), litaC_size, litaC_this->lita->allocator);
    litaC_expr->type->spec.typeInfo = NULL;
    for(litaC_i32 litaC_genericIndex = 0;litaC_genericIndex < litaC_size;litaC_genericIndex += 1) {
        {
            litaC_ast__GenericParam litaC_genericParam = litaC_array__Array_get_cb_GenericParam_ce_(&((litaC_aggInfo->decl->decl.genericParams)), litaC_genericIndex);
            for(litaC_i32 litaC_fieldIndex = 0;litaC_fieldIndex < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_aggInfo->decl->fields)));litaC_fieldIndex += 1) {
                {
                    litaC_types__TypeInfo* litaC_paramType = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_aggInfo->decl->fields)), litaC_fieldIndex).typeInfo;
                    if(!(litaC_paramType)) {
                        {
                            litaC_checker_expr__TypeChecker_errorInferGenericParameter(litaC_this, &((litaC_expr->expr)), &((litaC_genericParam)));
                            goto err;
                            
                            
                            
                        }
                        
                    } 
                    
                    if(litaC_fieldIndex >= litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_suppliedArgs)))) {
                        {
                            break;
                            
                            
                        }
                        
                    } 
                    
                    litaC_types__TypeInfo* litaC_inferredType = litaC_checker_expr__TypeChecker_inferredType(litaC_this, litaC_genericParam.name, litaC_paramType, litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_suppliedArgs)), litaC_fieldIndex));
                    if(litaC_inferredType) {
                        {
                            litaC_array__Array_add_cb__ptr_TypeSpec_ce_(&((litaC_expr->type->genericArgs)), litaC_types__TypeInfo_asTypeSpec(litaC_inferredType, litaC_this->lita->allocator));
                            break;
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
    }
    litaC_types__TypeInfo* litaC_type = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, &((litaC_expr->type->spec)));
    if(!(litaC_type)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(litaC_type->sym && (litaC_type->sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE)) {
        {
            litaC_ast__GenericDecl* litaC_decl = (litaC_ast__GenericDecl*)litaC_type->sym->decl;
            litaC_checker_expr__TypeChecker_errorMissingGenericArguments(litaC_this, &((litaC_expr->expr)), litaC_expr->type->name, &((litaC_decl->genericParams)));
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_type;
    
    err:;
    
    return &(litaC_types__POISON_TYPE);
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveInitExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__InitExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_types__TypeInfo* litaC_type = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, &((litaC_expr->type->spec)));
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_types__IsAggregate(litaC_type)) && litaC_type->kind != litaC_types__TypeKind_ARRAY) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->expr.stmt.node.startPos, "only struct, union or array can use initialization syntax");
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_types__IsAggregate(litaC_type)) {
        {
            if(!(litaC_checker_expr__TypeChecker_addDefaultArguments(litaC_this, litaC_type, litaC_expr))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
        {
            litaC_ast__InitArgExpr* litaC_arg = litaC_array__Array_get_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)), litaC_i);
            if(!(litaC_checker_expr__TypeChecker_resolveInitArgExpr(litaC_this, litaC_arg))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    if(litaC_types__IsAggregate(litaC_type)) {
        {
            litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_type;
            if(!(litaC_array__Array_empty_cb_GenericParam_ce_(&((litaC_aggInfo->decl->decl.genericParams)))) && litaC_array__Array_empty_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)))) {
                {
                    litaC_type = litaC_checker_expr__TypeChecker_inferInitExpr(litaC_this, litaC_expr, litaC_aggInfo);
                    if(litaC_type->kind == litaC_types__TypeKind_POISON) {
                        {
                            return litaC_false;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_checker_expr__TypeChecker_addInitArgumentsReferences(litaC_this, litaC_type, litaC_expr);
    litaC_expr->expr.operand.typeInfo = litaC_type;
    return litaC_checker_expr__TypeChecker_checkInitArguments(litaC_this, litaC_type, litaC_expr);
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveSetExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__SetExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->object))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->value))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_expr->field)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_objectTypeInfo = litaC_expr->object->operand.typeInfo;
    if(litaC_objectTypeInfo->kind == litaC_types__TypeKind_ENUM) {
        {
            litaC_checker_expr__TypeChecker_errorEnumFieldSet(litaC_this, litaC_expr->object, litaC_objectTypeInfo, litaC_expr->field->type->name);
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_types__IsFieldAccessible(litaC_objectTypeInfo))) {
        {
            litaC_checker_expr__TypeChecker_errorNoFieldAccess(litaC_this, litaC_expr->object, litaC_objectTypeInfo, litaC_expr->field->type->name);
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_info = litaC_types__TypeInfo_getBaseType(litaC_objectTypeInfo);
    assert(litaC_info != NULL);
    assert(litaC_info->kind == litaC_types__TypeKind_STRUCT || litaC_info->kind == litaC_types__TypeKind_UNION);
    litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_info;
    litaC_ast__FieldStmt litaC_field = litaC_types__AggregateTypeInfo_getField(litaC_aggInfo, litaC_expr->field->type->name);
    if(litaC_field.kind == litaC_ast__StmtKind_POISON_EXPR) {
        {
            litaC_field = litaC_types__AggregateTypeInfo_getFieldWithUsing(litaC_aggInfo, litaC_expr->field->type->name);
            if(litaC_field.kind == litaC_ast__StmtKind_POISON_EXPR) {
                {
                    litaC_checker_expr__TypeChecker_errorNoField(litaC_this, &((litaC_expr->field->expr)), litaC_objectTypeInfo, litaC_expr->field->type->name);
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_expr->flags |= litaC_ast__GetExprFlags_IS_USING;
            
            
        }
        
    } 
    
    litaC_types__FieldPositionResult litaC_fieldResult = litaC_types__AggregateTypeInfo_getFieldPosition(litaC_aggInfo, litaC_expr->field->type->name);
    if(litaC_fieldResult.aggInfo) {
        {
            litaC_references__ReferenceDatabase_addFieldReference(&((litaC_this->lita->references)), litaC_expr->field->type->spec.pos, &((litaC_fieldResult.aggInfo->info.typeInfo)), litaC_fieldResult.position);
            
            
        }
        
    } 
    
    litaC_expr->field->expr.operand.typeInfo = litaC_field.typeInfo;
    litaC_expr->expr.operand.typeInfo = litaC_field.typeInfo;
    litaC_checker__TypeChecker_checkTypeCompatibility(litaC_this, litaC_expr->expr.stmt.node.startPos, litaC_field.typeInfo, litaC_expr->value->operand.typeInfo);
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveTernaryExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__TernaryExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->cond))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_condType = litaC_expr->cond->operand.typeInfo;
    if(!(litaC_types__IsBooleanable(litaC_condType))) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->cond->stmt.node.startPos, "must be a boolean expression");
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->then))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->other))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_checker__TypeChecker_checkTypeCompatibility(litaC_this, litaC_expr->expr.stmt.node.startPos, litaC_expr->then->operand.typeInfo, litaC_expr->other->operand.typeInfo);
    litaC_expr->expr.operand.typeInfo = litaC_expr->then->operand.typeInfo;
    litaC_expr->expr.operand.isRightValue = litaC_true;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveTypeIdentifierExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__TypeIdentifierExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_types__TypeInfo* litaC_type = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_expr->type);
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_expr->sym = litaC_type->sym;
    litaC_expr->expr.operand.typeInfo = litaC_type;
    litaC_expr->expr.operand.isRightValue = litaC_true;
    litaC_expr->expr.operand.isConst = litaC_true;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveTypeOfExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__TypeOfExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(litaC_expr->typeOfExpr) {
        {
            if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->typeOfExpr))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_types__TypeInfo* litaC_type = litaC_expr->typeOfExpr->operand.typeInfo;
            litaC_expr->expr.operand.val.intValue = litaC_type->typeid;
            
            
        }
        
    } else {
        {
            litaC_types__TypeInfo* litaC_type = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_expr->type);
            if(!(litaC_type)) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_expr->expr.operand.val.intValue = litaC_type->typeid;
            
            
        }
    } 
    
    litaC_expr->expr.operand.typeInfo = &(litaC_types__U64_TYPE);
    litaC_expr->expr.operand.isRightValue = litaC_true;
    litaC_expr->expr.operand.isConst = litaC_true;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveOffsetOfExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__OffsetOfExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_types__TypeInfo* litaC_type = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_expr->type);
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_types__IsAggregate(litaC_type))) {
        {
            litaC_checker_expr__TypeChecker_errorNonAggregateType(litaC_this, &((litaC_expr->expr)), litaC_type);
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_expr->field.type != litaC_lex__TokenType_IDENTIFIER) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_char litaC_fieldName[256];
    litaC_string__String litaC_fieldNameStr = litaC_string__StringInit(litaC_fieldName, litaC_symbols__MAX_SYMBOL_NAME, -(1));
    litaC_string__String_format(&((litaC_fieldNameStr)), "%.*s", litaC_expr->field.value.str.length, litaC_expr->field.value.str.buffer);
    litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_type;
    litaC_ast__FieldStmt litaC_fieldStmt = litaC_types__AggregateTypeInfo_getField(litaC_aggInfo, litaC_string__String_cStr(litaC_fieldNameStr));
    if(litaC_fieldStmt.kind == litaC_ast__StmtKind_POISON_EXPR) {
        {
            litaC_checker_expr__TypeChecker_errorNoField(litaC_this, &((litaC_expr->expr)), litaC_type, litaC_string__String_cStr(litaC_fieldNameStr));
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_expr->expr.operand.typeInfo = &(litaC_types__USIZE_TYPE);
    litaC_expr->expr.operand.isRightValue = litaC_true;
    litaC_expr->expr.operand.isConst = litaC_true;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveSizeOfExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__SizeOfExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->sizeOfExpr))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_expr->expr.operand.typeInfo = &(litaC_types__USIZE_TYPE);
    litaC_expr->expr.operand.isRightValue = litaC_true;
    litaC_expr->expr.operand.isConst = litaC_true;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_checkMethodExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__GetExpr* litaC_expr,litaC_types__AggregateTypeInfo* litaC_aggInfo) {
    assert(litaC_expr != NULL);
    if(litaC_expr->flags & litaC_ast__GetExprFlags_IS_METHOD_CALL) {
        {
            litaC_symbols__Symbol* litaC_funcSym = litaC_checker__TypeChecker_getType(litaC_this, litaC_expr->field->type);
            if(!(litaC_funcSym)) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            if(litaC_funcSym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
                {
                    litaC_types__TypeInfo* litaC_typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, &((litaC_expr->field->type->spec)));
                    if(!(litaC_typeInfo)) {
                        {
                            return litaC_false;
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_expr->field->expr.operand.typeInfo = litaC_typeInfo;
                    litaC_expr->expr.operand.typeInfo = litaC_typeInfo;
                    
                    
                }
                
            } 
            
            return litaC_true;
            
            
            
        }
        
    } 
    
    litaC_symbols__Symbol* litaC_funcSym = litaC_types__AggregateTypeInfo_getMethod(litaC_aggInfo, litaC_this->current, litaC_expr->field->type->name);
    if(litaC_funcSym) {
        {
            litaC_ast__FuncDecl* litaC_decl = (litaC_ast__FuncDecl*)litaC_funcSym->decl;
            litaC_types__TypeInfo* litaC_typeInfo = litaC_funcSym->type;
            if(!((litaC_expr->flags & litaC_ast__GetExprFlags_IS_METHOD_CALL))) {
                {
                    litaC_expr->flags |= litaC_ast__GetExprFlags_IS_METHOD_CALL;
                    litaC_ast__NameTypeSpec* litaC_oldName = litaC_expr->field->type;
                    litaC_char* litaC_functionName = (litaC_char*)litaC_mem__Allocator_alloc(litaC_this->lita->allocator, litaC_symbols__MAX_SYMBOL_NAME * sizeof(litaC_char));
                    litaC_types__AggregateTypeInfo_getFunctionName(litaC_aggInfo, litaC_functionName, litaC_oldName->name);
                    litaC_expr->field->type->name = litaC_functionName;
                    
                    
                }
                
            } 
            
            if(litaC_funcSym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
                {
                    litaC_typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, &((litaC_expr->field->type->spec)));
                    if(!(litaC_typeInfo)) {
                        {
                            return litaC_false;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            litaC_references__ReferenceDatabase_addTypeReferenceByTypeInfo(&((litaC_this->lita->references)), litaC_expr->field->expr.stmt.node.startPos, litaC_typeInfo);
            litaC_expr->field->expr.operand.typeInfo = litaC_typeInfo;
            litaC_expr->expr.operand.typeInfo = litaC_typeInfo;
            return litaC_true;
            
            
            
        }
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_aggInfo->decl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_aggInfo->decl->fields)), litaC_i);
            if(litaC_field.kind == litaC_ast__StmtKind_VAR_FIELD_DECL) {
                {
                    litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                    if(litaC_varField->decl.attributes.isUsing) {
                        {
                            litaC_types__TypeInfo* litaC_baseType = litaC_types__TypeInfo_getBaseType(litaC_field.typeInfo);
                            if(litaC_checker_expr__TypeChecker_checkMethodExpr(litaC_this, litaC_expr, (litaC_types__AggregateTypeInfo*)litaC_baseType)) {
                                {
                                    return litaC_true;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveGetExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__GetExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->object))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_expr->field)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_objectTypeInfo = litaC_expr->object->operand.typeInfo;
    if(!(litaC_types__IsFieldAccessible(litaC_objectTypeInfo))) {
        {
            litaC_checker_expr__TypeChecker_errorNoFieldAccess(litaC_this, litaC_expr->object, litaC_objectTypeInfo, litaC_expr->field->type->name);
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_objectTypeInfo->kind == litaC_types__TypeKind_ENUM) {
        {
            litaC_types__EnumTypeInfo* litaC_enumInfo = (litaC_types__EnumTypeInfo*)litaC_objectTypeInfo;
            litaC_ast__EnumFieldEntryDecl* litaC_field = litaC_types__EnumTypeInfo_getField(litaC_enumInfo, litaC_expr->field->type->name);
            if(!(litaC_field)) {
                {
                    litaC_checker_expr__TypeChecker_errorNoField(litaC_this, &((litaC_expr->field->expr)), litaC_objectTypeInfo, litaC_expr->field->type->name);
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_references__ReferenceDatabase_addFieldReference(&((litaC_this->lita->references)), litaC_expr->field->type->spec.pos, &((litaC_enumInfo->info)), litaC_types__EnumTypeInfo_getFieldIndex(litaC_enumInfo, litaC_expr->field->type->name));
            litaC_expr->flags |= litaC_ast__GetExprFlags_IS_ENUM;
            litaC_expr->expr.operand.typeInfo = &(litaC_types__I32_TYPE);
            litaC_expr->expr.operand.isConst = litaC_true;
            litaC_expr->expr.operand.isRightValue = litaC_true;
            return litaC_true;
            
            
            
        }
        
    } else {
        {
            litaC_types__TypeInfo* litaC_info = litaC_types__TypeInfo_getBaseType(litaC_objectTypeInfo);
            assert(litaC_info != NULL);
            assert(litaC_types__IsAggregate(litaC_info));
            litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_info;
            litaC_ast__FieldStmt litaC_field = litaC_types__AggregateTypeInfo_getField(litaC_aggInfo, litaC_expr->field->type->name);
            if(litaC_field.kind != litaC_ast__StmtKind_POISON_EXPR) {
                {
                    litaC_references__ReferenceDatabase_addFieldReference(&((litaC_this->lita->references)), litaC_expr->field->type->spec.pos, &((litaC_aggInfo->info.typeInfo)), litaC_types__AggregateTypeInfo_getFieldIndex(litaC_aggInfo, litaC_expr->field->type->name));
                    litaC_expr->field->expr.operand.typeInfo = litaC_field.typeInfo;
                    litaC_expr->expr.operand.typeInfo = litaC_field.typeInfo;
                    if(litaC_aggInfo->info.typeInfo.kind == litaC_types__TypeKind_TRAIT && litaC_expr->field->expr.stmt.node.kind != litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR) {
                        {
                            litaC_types__TypeInfo* litaC_funcPtr = (litaC_types__TypeInfo*)litaC_types__AsTraitFuncPtr(litaC_field.typeInfo, litaC_expr->field->type->name, &((litaC_this->typeCache)));
                            litaC_expr->field->expr.operand.typeInfo = litaC_funcPtr;
                            litaC_expr->expr.operand.typeInfo = litaC_funcPtr;
                            
                            
                        }
                        
                    } 
                    
                    return litaC_true;
                    
                    
                    
                }
                
            } 
            
            litaC_field = litaC_types__AggregateTypeInfo_getFieldWithUsing(litaC_aggInfo, litaC_expr->field->type->name);
            if(litaC_field.kind != litaC_ast__StmtKind_POISON_EXPR) {
                {
                    litaC_types__FieldPositionResult litaC_fieldResult = litaC_types__AggregateTypeInfo_getFieldPosition(litaC_aggInfo, litaC_expr->field->type->name);
                    if(litaC_fieldResult.aggInfo) {
                        {
                            litaC_references__ReferenceDatabase_addFieldReference(&((litaC_this->lita->references)), litaC_expr->field->type->spec.pos, &((litaC_fieldResult.aggInfo->info.typeInfo)), litaC_fieldResult.position);
                            
                            
                        }
                        
                    } 
                    
                    litaC_expr->flags |= litaC_ast__GetExprFlags_IS_USING;
                    litaC_expr->field->expr.operand.typeInfo = litaC_field.typeInfo;
                    litaC_expr->expr.operand.typeInfo = litaC_field.typeInfo;
                    if(litaC_fieldResult.aggInfo->info.typeInfo.kind == litaC_types__TypeKind_TRAIT && litaC_expr->field->expr.stmt.node.kind != litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR) {
                        {
                            litaC_types__TypeInfo* litaC_funcPtr = (litaC_types__TypeInfo*)litaC_types__AsTraitFuncPtr(litaC_field.typeInfo, litaC_expr->field->type->name, &((litaC_this->typeCache)));
                            litaC_expr->field->expr.operand.typeInfo = litaC_funcPtr;
                            litaC_expr->expr.operand.typeInfo = litaC_funcPtr;
                            
                            
                        }
                        
                    } 
                    
                    return litaC_true;
                    
                    
                    
                }
                
            } 
            
            if(litaC_checker_expr__TypeChecker_checkMethodExpr(litaC_this, litaC_expr, litaC_aggInfo)) {
                {
                    return litaC_true;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    } 
    
    litaC_checker_expr__TypeChecker_errorNoField(litaC_this, &((litaC_expr->field->expr)), litaC_objectTypeInfo, litaC_expr->field->type->name);
    return litaC_false;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveGroupExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__GroupExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->groupedExpr))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_expr->expr.operand = litaC_expr->groupedExpr->operand;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveUnaryExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__UnaryExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->unaryExpr))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_type = litaC_expr->unaryExpr->operand.typeInfo;
    assert(litaC_type != NULL);
    switch(litaC_expr->operator) {
        case litaC_lex__TokenType_STAR: {
            {
                switch(litaC_type->kind) {
                    case litaC_types__TypeKind_PTR: {
                        {
                            litaC_types__PtrTypeInfo* litaC_info = (litaC_types__PtrTypeInfo*)litaC_type;
                            if(litaC_info->ptrOf->kind == litaC_types__TypeKind_CONST) {
                                {
                                    litaC_types__ConstTypeInfo* litaC_constInfo = (litaC_types__ConstTypeInfo*)litaC_info->ptrOf;
                                    litaC_expr->expr.operand.typeInfo = litaC_constInfo->constOf;
                                    
                                    
                                }
                                
                            } else {
                                {
                                    litaC_expr->expr.operand.typeInfo = litaC_info->ptrOf;
                                    
                                    
                                }
                            } 
                            
                            break;
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_STR: {
                        {
                            litaC_expr->expr.operand.typeInfo = &(litaC_types__CHAR_TYPE);
                            break;
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_ARRAY: {
                        {
                            litaC_types__ArrayTypeInfo* litaC_info = (litaC_types__ArrayTypeInfo*)litaC_type;
                            if(litaC_info->arrayOf->kind == litaC_types__TypeKind_CONST) {
                                {
                                    litaC_types__ConstTypeInfo* litaC_constInfo = (litaC_types__ConstTypeInfo*)litaC_info->arrayOf;
                                    litaC_expr->expr.operand.typeInfo = litaC_constInfo->constOf;
                                    
                                    
                                }
                                
                            } else {
                                {
                                    litaC_expr->expr.operand.typeInfo = litaC_info->arrayOf;
                                    
                                    
                                }
                            } 
                            
                            break;
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_CONST: {
                        {
                            litaC_types__ConstTypeInfo* litaC_constInfo = (litaC_types__ConstTypeInfo*)litaC_type;
                            if(litaC_types__IsPtrLike(litaC_constInfo->constOf)) {
                                {
                                    litaC_expr->expr.operand.typeInfo = litaC_constInfo->constOf;
                                    
                                    
                                }
                                
                            } 
                            
                            break;
                            
                            
                        }
                        
                        
                    }
                    default: {
                        {
                            litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
                            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
                            litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)));
                            litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), "' is not a pointer type");
                            litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->unaryExpr->stmt.node.startPos, &((litaC_sb)));
                            return litaC_false;
                            
                            
                            
                        }
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_lex__TokenType_BAND: {
            {
                if(litaC_type->kind == litaC_types__TypeKind_FUNC) {
                    {
                        litaC_expr->expr.operand.typeInfo = (litaC_types__TypeInfo*)litaC_types__FuncTypeInfo_asPtr(((litaC_types__FuncTypeInfo*)litaC_type), &((litaC_this->typeCache)));
                        litaC_expr->expr.operand.isRightValue = litaC_true;
                        
                        
                    }
                    
                } else {
                    if(litaC_expr->unaryExpr->operand.isRightValue) {
                        {
                            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->unaryExpr->stmt.node.startPos, "lvalue required as unary '&' operand");
                            return litaC_false;
                            
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_expr->expr.operand.typeInfo = (litaC_types__TypeInfo*)litaC_types_new__TypeCache_newPtrTypeInfo(&((litaC_this->typeCache)), litaC_type);
                            
                            
                        }
                    } 
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_lex__TokenType_NOT: {
            {
                if(!(litaC_checker_expr__TypeChecker_checkTruthyness(litaC_this, litaC_expr->unaryExpr, litaC_type))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                litaC_expr->expr.operand.typeInfo = &(litaC_types__BOOL_TYPE);
                break;
                
                
            }
            
            
        }
        default: {
            {
                litaC_expr->expr.operand = litaC_expr->unaryExpr->operand;
                break;
                
                
            }
            
            
        }
    }
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveCastExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__CastExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_types__TypeInfo* litaC_typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_expr->castTo);
    if(!(litaC_typeInfo)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->exprToCast))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_expr->expr.operand.typeInfo = litaC_typeInfo;
    if(!(litaC_checker__TypeChecker_checkCastability(litaC_this, litaC_expr->expr.stmt.node.startPos, litaC_expr->exprToCast->operand.typeInfo, litaC_typeInfo))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveArrayDesignationExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__ArrayDesignationExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->index))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->value))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_ast__Expr_isConstNumberExpr(litaC_expr->index))) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->index->stmt.node.startPos, "array designation must be indexed by a number");
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_expr->index->stmt.node.kind == litaC_ast__StmtKind_IDENTIFIER_EXPR) {
        {
            litaC_ast__IdentifierExpr* litaC_idExpr = (litaC_ast__IdentifierExpr*)litaC_expr->index;
            if(litaC_idExpr->sym != NULL && !((litaC_idExpr->sym->flags & litaC_symbols__SymbolFlags_IS_CONSTANT))) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->index->stmt.node.startPos, "'%s' must be a constant", litaC_idExpr->sym->name);
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(!(litaC_checker__TypeChecker_checkTypeCompatibility(litaC_this, litaC_expr->expr.stmt.node.startPos, &(litaC_types__USIZE_TYPE), litaC_expr->index->operand.typeInfo))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_expr->expr.operand = litaC_expr->value->operand;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveArrayInitExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__ArrayInitExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_types__TypeInfo* litaC_typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_expr->type);
    if(!(litaC_typeInfo) || litaC_typeInfo->kind == litaC_types__TypeKind_POISON) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_expr->expr.operand.typeInfo = litaC_typeInfo;
    litaC_expr->expr.operand.isRightValue = litaC_true;
    assert(litaC_typeInfo->kind == litaC_types__TypeKind_ARRAY);
    litaC_types__ArrayTypeInfo* litaC_arrayInfo = (litaC_types__ArrayTypeInfo*)litaC_typeInfo;
    litaC_types__TypeInfo* litaC_arrayOf = litaC_arrayInfo->arrayOf;
    if(!(litaC_array__Array_empty_cb__ptr_Expr_ce_(&((litaC_expr->values))))) {
        {
            if(!(litaC_arrayInfo->numOfElements) && litaC_arrayInfo->length < 1) {
                {
                    litaC_arrayInfo->length = litaC_array__Array_size_cb__ptr_Expr_ce_(&((litaC_expr->values)));
                    litaC_arrayInfo->isLengthDefined = litaC_true;
                    
                    
                }
                
            } 
            
            litaC_bool litaC_hasSucceed = litaC_true;
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Expr_ce_(&((litaC_expr->values)));litaC_i += 1) {
                {
                    litaC_ast__Expr* litaC_value = litaC_array__Array_get_cb__ptr_Expr_ce_(&((litaC_expr->values)), litaC_i);
                    litaC_value->expectedType = litaC_arrayOf;
                    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_value))) {
                        {
                            litaC_hasSucceed = litaC_false;
                            
                            
                        }
                        
                    } 
                    
                    if(litaC_value->operand.typeInfo) {
                        {
                            litaC_checker__TypeChecker_checkTypeCompatibility(litaC_this, litaC_value->stmt.node.startPos, litaC_arrayOf, litaC_value->operand.typeInfo);
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            return litaC_hasSucceed;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveBinaryExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__BinaryExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->left))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->right))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_leftType = litaC_expr->left->operand.typeInfo;
    litaC_types__TypeInfo* litaC_rightType = litaC_expr->right->operand.typeInfo;
    litaC_types__TypeInfo* litaC_targetType = ((litaC_leftType->typeid > litaC_rightType->typeid)) ? litaC_leftType : litaC_rightType;
    switch(litaC_expr->operator) {
        case litaC_lex__TokenType_EQUALS: {
            {
                litaC_expr->right = litaC_checker_expr__TypeChecker_coerceTypeWithUsing(litaC_this, litaC_expr->right, litaC_rightType, litaC_leftType);
                litaC_rightType = litaC_expr->right->operand.typeInfo;
                litaC_checker_expr__TypeChecker_checkConstant(litaC_this, litaC_expr->left);
                litaC_checker__TypeChecker_checkAssignability(litaC_this, litaC_expr->right->stmt.node.startPos, litaC_leftType, litaC_rightType);
                litaC_checker_expr__TypeChecker_checkRightValue(litaC_this, litaC_expr->left);
                break;
                
                
            }
            
            
        }
        case litaC_lex__TokenType_BAND_EQ: 
        case litaC_lex__TokenType_BNOT_EQ: 
        case litaC_lex__TokenType_BOR_EQ: 
        case litaC_lex__TokenType_XOR_EQ: 
        case litaC_lex__TokenType_LSHIFT_EQ: 
        case litaC_lex__TokenType_RSHIFT_EQ: {
            litaC_checker_expr__TypeChecker_checkConstant(litaC_this, litaC_expr->left);
            litaC_checker__TypeChecker_checkAssignability(litaC_this, litaC_expr->right->stmt.node.startPos, litaC_leftType, litaC_rightType);
            litaC_checker_expr__TypeChecker_checkRightValue(litaC_this, litaC_expr->left);
            
            
        }
        case litaC_lex__TokenType_BAND: 
        case litaC_lex__TokenType_BNOT: 
        case litaC_lex__TokenType_BOR: 
        case litaC_lex__TokenType_XOR: 
        case litaC_lex__TokenType_LSHIFT: 
        case litaC_lex__TokenType_RSHIFT: {
            {
                if(!(litaC_types__IsInteger(litaC_leftType))) {
                    {
                        litaC_checker_expr__TypeChecker_errorOperand(litaC_this, litaC_expr->left, litaC_leftType, "left");
                        
                        
                    }
                    
                } 
                
                if(!(litaC_types__IsInteger(litaC_rightType))) {
                    {
                        litaC_checker_expr__TypeChecker_errorOperand(litaC_this, litaC_expr->right, litaC_rightType, "right");
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_lex__TokenType_AND: 
        case litaC_lex__TokenType_OR: {
            {
                litaC_checker_expr__TypeChecker_checkTruthyness(litaC_this, litaC_expr->left, litaC_leftType);
                litaC_checker_expr__TypeChecker_checkTruthyness(litaC_this, litaC_expr->right, litaC_rightType);
                litaC_targetType = &(litaC_types__BOOL_TYPE);
                break;
                
                
            }
            
            
        }
        case litaC_lex__TokenType_EQUALS_EQUALS: 
        case litaC_lex__TokenType_NOT_EQUALS: {
            {
                litaC_checker_expr__TypeChecker_checkTruthyness(litaC_this, litaC_expr->left, litaC_leftType);
                litaC_checker_expr__TypeChecker_checkTruthyness(litaC_this, litaC_expr->right, litaC_rightType);
                litaC_targetType = &(litaC_types__BOOL_TYPE);
                break;
                
                
            }
            
            
        }
        case litaC_lex__TokenType_GREATER_EQUALS: 
        case litaC_lex__TokenType_GREATER_THAN: 
        case litaC_lex__TokenType_LESS_EQUALS: 
        case litaC_lex__TokenType_LESS_THAN: {
            {
                if(!(litaC_types__IsNumberLike(litaC_leftType))) {
                    {
                        litaC_checker_expr__TypeChecker_errorOperand(litaC_this, litaC_expr->left, litaC_leftType, "left");
                        
                        
                    }
                    
                } 
                
                if(!(litaC_types__IsNumberLike(litaC_rightType))) {
                    {
                        litaC_checker_expr__TypeChecker_errorOperand(litaC_this, litaC_expr->right, litaC_rightType, "right");
                        
                        
                    }
                    
                } 
                
                litaC_targetType = &(litaC_types__BOOL_TYPE);
                break;
                
                
            }
            
            
        }
        case litaC_lex__TokenType_MINUS_EQ: 
        case litaC_lex__TokenType_PLUS_EQ: 
        case litaC_lex__TokenType_MOD_EQ: 
        case litaC_lex__TokenType_MUL_EQ: 
        case litaC_lex__TokenType_DIV_EQ: {
            litaC_checker_expr__TypeChecker_checkConstant(litaC_this, litaC_expr->left);
            litaC_checker__TypeChecker_checkAssignability(litaC_this, litaC_expr->right->stmt.node.startPos, litaC_leftType, litaC_rightType);
            
            
        }
        case litaC_lex__TokenType_MINUS: 
        case litaC_lex__TokenType_PLUS: 
        case litaC_lex__TokenType_MOD: 
        case litaC_lex__TokenType_STAR: 
        case litaC_lex__TokenType_SLASH: {
            {
                if(!(litaC_types__IsNumberLike(litaC_leftType))) {
                    {
                        litaC_checker_expr__TypeChecker_errorOperand(litaC_this, litaC_expr->left, litaC_leftType, "left");
                        
                        
                    }
                    
                } 
                
                if(!(litaC_types__IsNumberLike(litaC_rightType))) {
                    {
                        litaC_checker_expr__TypeChecker_errorOperand(litaC_this, litaC_expr->right, litaC_rightType, "right");
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    litaC_expr->expr.operand.typeInfo = litaC_targetType;
    litaC_expr->expr.operand.isConst = litaC_expr->left->operand.isConst && litaC_expr->right->operand.isConst;
    return litaC_true;
    
    err:;
    
    return litaC_false;
    
    
}

litaC_void litaC_checker_expr__TypeChecker_errorNonIndexableType(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), "invalid index into '");
    litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)));
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorSetIndexingConstType(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), "invalid read-only assignment to '");
    litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)));
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorIndexType(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)));
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), " invalid index value");
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorNonAggregateType(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)));
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), " must be an aggregate type");
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorNonFuncType(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)));
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), " must be function type");
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorOperand(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type,const litaC_char* litaC_side) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "illegal, %s operand has type '", litaC_side);
    litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)));
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorEnumFieldSet(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type,const litaC_char* litaC_field) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), "can't reassign enum '");
    litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)));
    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "' field '%s'", litaC_field);
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorNoField(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type,const litaC_char* litaC_field) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)));
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), " does not have field '%s'", litaC_field);
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorNoFieldAt(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type,litaC_i32 litaC_position) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)));
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), " does not have a field at index '%d'", litaC_position);
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorNoFieldAccess(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type,const litaC_char* litaC_field) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)));
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), " can't be accessed with field '%s'", litaC_field);
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorInferGenericParameter(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_ast__GenericParam* litaC_param) {
    assert(litaC_expr != NULL);
    assert(litaC_param != NULL);
    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, "unable to infer generic parameter '%.*s'", litaC_param->name.value.str.length, litaC_param->name.value.str.buffer);
    
}

litaC_void litaC_checker_expr__TypeChecker_errorInferGenericParameters(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_array__Array_cb_GenericParam_ce_* litaC_params) {
    assert(litaC_expr != NULL);
    assert(litaC_params != NULL);
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), "unable to infer generic parameters [");
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_GenericParam_ce_(litaC_params);litaC_i += 1) {
        {
            if(litaC_i > 0) {
                {
                    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), ", ", 2);
                    
                    
                }
                
            } 
            
            litaC_ast__GenericParam litaC_p = litaC_array__Array_get_cb_GenericParam_ce_(litaC_params, litaC_i);
            litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "'%.*s'", litaC_p.name.value.str.length, litaC_p.name.value.str.buffer);
            
            
        }
    }
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "]", 1);
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorMissingGenericArguments(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,const litaC_char* litaC_typeName,litaC_array__Array_cb_GenericParam_ce_* litaC_genericParams) {
    assert(litaC_expr != NULL);
    assert(litaC_typeName != NULL);
    assert(litaC_genericParams != NULL);
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "'%s' is missing generic arguments [", litaC_typeName);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_GenericParam_ce_(litaC_genericParams);litaC_i += 1) {
        {
            litaC_ast__GenericParam litaC_param = litaC_array__Array_get_cb_GenericParam_ce_(litaC_genericParams, litaC_i);
            if(litaC_i > 0) {
                {
                    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), ", ", 1);
                    
                    
                }
                
            } 
            
            litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "'%.*s'", litaC_param.name.value.str.length, litaC_param.name.value.str.buffer);
            
            
        }
    }
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "]", 1);
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorFixedArgumentAfterNamed(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_arg) {
    assert(litaC_arg != NULL);
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(128, litaC_this->lita->allocator);
    litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), "Named argument specifications must appear after all fixed arguments have been specified");
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_arg->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorNamedArgumentsForFuncPtr(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(128, litaC_this->lita->allocator);
    litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), "Named arguments are not allowed on function pointers");
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorInvalidNamedArgument(litaC_checker__TypeChecker* litaC_this,litaC_lex__SrcPos litaC_pos,litaC_string_view__StringView* litaC_name,litaC_types__FuncTypeInfo* litaC_funcInfo) {
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "Invalid named parameter: '%.*s'; no parameter with that name found in 'func %s(", litaC_name->length, litaC_name->buffer, litaC_funcInfo->info.typeInfo.name);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params)));litaC_i += 1) {
        {
            litaC_ast__ParameterDecl* litaC_param = litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params)), litaC_i);
            if(litaC_i > 0) {
                {
                    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), ", ");
                    
                    
                }
                
            } 
            
            litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "%s: ", litaC_lex__Token_asString(&((litaC_param->decl.name))));
            if(litaC_param->typeInfo) {
                {
                    litaC_types__TypeInfo_toString(litaC_param->typeInfo, &((litaC_sb)));
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), ")'");
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_pos, &((litaC_sb)));
    
}

litaC_bool litaC_checker_expr__TypeChecker_checkConstant(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_symbols__Symbol* litaC_sym = NULL;
    if(litaC_expr->stmt.node.kind == litaC_ast__StmtKind_IDENTIFIER_EXPR) {
        {
            litaC_ast__IdentifierExpr* litaC_idExpr = (litaC_ast__IdentifierExpr*)litaC_expr;
            litaC_sym = litaC_idExpr->sym;
            if(litaC_sym && (litaC_sym->flags & litaC_symbols__SymbolFlags_IS_TYPE)) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, "can't reassign type '%s'", litaC_sym->name);
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(!(litaC_sym)) {
        {
            if(!(litaC_expr->operand.typeInfo)) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_sym = litaC_expr->operand.typeInfo->sym;
            if(!(litaC_sym)) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_CONSTANT) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, "can't reassign constant variable '%s'", litaC_sym->name);
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_checkTruthyness(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    if(!(litaC_types__IsBooleanable(litaC_type))) {
        {
            litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
            litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)));
            litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), "' can't be coerced to boolean");
            litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_checkRightValue(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(litaC_expr->operand.isRightValue) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, "rvalue can't be assigned to");
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveIdentiferExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__IdentifierExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_symbols__Symbol* litaC_sym = litaC_symbols__Scope_lookup(litaC_checker__TypeChecker_currentScope(litaC_this), litaC_expr->type->name);
    if(!(litaC_sym)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->expr.stmt.node.startPos, "unknown variable '%s'", litaC_expr->type->name);
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_typeInfo = litaC_sym->type;
    if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE && !(litaC_array__Array_empty_cb__ptr_TypeSpec_ce_(&((litaC_expr->type->genericArgs))))) {
        {
            litaC_typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, &((litaC_expr->type->spec)));
            if(!(litaC_typeInfo)) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->expr.stmt.node.startPos, "unknown type '%s'", litaC_expr->type->name);
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_sym = litaC_typeInfo->sym;
            
            
        }
        
    } 
    
    litaC_expr->sym = litaC_sym;
    litaC_expr->expr.operand.typeInfo = litaC_typeInfo;
    litaC_references__ReferenceDatabase_addSymbolReference(&((litaC_this->lita->references)), litaC_sym, litaC_expr->expr.stmt.node.startPos);
    if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_CONSTANT) {
        {
            litaC_expr->expr.operand.isConst = litaC_true;
            litaC_expr->expr.operand.val = litaC_sym->val;
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_void litaC_error_codes__PrintError(litaC_string_buffer__StringBuffer* litaC_sb,litaC_phase_result__PhaseError litaC_error) {
    if(!(litaC_error.pos.lineStart)) {
        {
            litaC_string_buffer__StringBuffer_append(litaC_sb, "%s\n", litaC_error.message);
            return;
            
            
            
        }
        
    } 
    
    litaC_string_buffer__StringBuffer_append(litaC_sb, "%s:%d:%d error: %s\n", litaC_error.pos.filename, litaC_error.pos.lineNumber, litaC_error.pos.position, litaC_error.message);
    litaC_string_buffer__StringBuffer_append(litaC_sb, "%.*s\n", litaC_lex__SrcPos_getLineLength(&((litaC_error.pos))), litaC_error.pos.lineStart);
    litaC_i32 litaC_spaceCount = 0;
    while(litaC_true) {
        {
            litaC_char litaC_c = litaC_error.pos.lineStart[litaC_spaceCount];
            if(litaC_c == '\0') {
                {
                    break;
                    
                    
                }
                
            } 
            
            if((litaC_error.pos.lineStart + litaC_spaceCount) == litaC_error.pos.start) {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_spaceCount += 1;
            
            
        }
    }
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_spaceCount;litaC_i += 1) {
        {
            litaC_string_buffer__StringBuffer_append(litaC_sb, " ");
            
            
        }
    }
    litaC_string_buffer__StringBuffer_append(litaC_sb, "^\n*** %s\n", litaC_error.message);
    
}

litaC_parser__Parser litaC_parser__ParserInit(const litaC_char* litaC_filename,const litaC_char* litaC_text,litaC_lita__Lita* litaC_lita) {
    litaC_parser__Parser litaC_parser =  {
        .allocator = litaC_lita->allocator,
        .result = &(litaC_lita->result),
        .lita = litaC_lita,
        .filename = litaC_filename,
        .current = 0,
        .breakLevel = 0,
        .loopLevel = 0,
        .switchLevel = 0,
        .funcLevel = 0,
        .aggregateLevel = 0,
        .tryLevel = 0,
        .tryErrorCounter = 0,
        .panicMode = litaC_false
    };
    litaC_lex__Lexer litaC_lex = litaC_lex__LexerInit(litaC_filename, litaC_text, litaC_lita->allocator);
    litaC_array__Array_init_cb_Token_ce_(&((litaC_parser.tokens)), 1024, litaC_lita->allocator);
    while(!(litaC_lex__Lexer_eof(&((litaC_lex))))) {
        {
            litaC_lex__Token litaC_token = litaC_lex__Lexer_nextToken(&((litaC_lex)));
            litaC_array__Array_add_cb_Token_ce_(&((litaC_parser.tokens)), litaC_token);
            
            
        }
    }
    litaC_parser.totalLines = litaC_lex.lineNumber;
    if(litaC_array__Array_empty_cb_Token_ce_(&((litaC_parser.tokens)))) {
        {
            litaC_array__Array_add_cb_Token_ce_(&((litaC_parser.tokens)), (litaC_lex__Token) {
                .type = litaC_lex__TokenType_END_OF_FILE
            });
            
            
        }
        
    } 
    
    return litaC_parser;
    
    
}

litaC_ast__ModuleStmt* litaC_parser__Parser_parseModule(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_array__Array_cb__ptr_ImportDecl_ce_ litaC_imports =  {
        
    };
    litaC_array__Array_init_cb__ptr_ImportDecl_ce_(&((litaC_imports)), 16, litaC_p->allocator);
    litaC_array__Array_cb__ptr_NoteStmt_ce_ litaC_notes =  {
        
    };
    litaC_array__Array_init_cb__ptr_NoteStmt_ce_(&((litaC_notes)), 2, litaC_p->allocator);
    litaC_array__Array_cb__ptr_Decl_ce_ litaC_declarations =  {
        
    };
    litaC_array__Array_init_cb__ptr_Decl_ce_(&((litaC_declarations)), 16, litaC_p->allocator);
    litaC_ast__ModuleStmt* litaC_moduleStmt = (litaC_ast__ModuleStmt*)litaC_ast_new__NewModuleStmt(litaC_pos, litaC_pos, litaC_imports, litaC_notes, litaC_declarations, litaC_p->allocator);
    if(litaC_parser__Parser_atEnd(litaC_p)) {
        {
            return litaC_moduleStmt;
            
            
            
        }
        
    } 
    
    while(!(litaC_parser__Parser_atEnd(litaC_p))) {
        {
            litaC_i32 litaC_errorCount = litaC_parser__Parser_numOfErrors(litaC_p);
            litaC_parser__Parser_parseModuleDeclaration(litaC_p, litaC_moduleStmt);
            if(litaC_parser__Parser_numOfErrors(litaC_p) > litaC_errorCount) {
                {
                    litaC_parser__Parser_adjust(litaC_p, litaC_parser__DECL_ADJUST_TOKENS, litaC_parser__DECL_ADJUST_TOKENS_COUNT);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_moduleStmt->stmt.node.endPos = litaC_parser__Parser_prevPos(litaC_p);
    return litaC_moduleStmt;
    
    
}

litaC_void litaC_parser__Parser_parseModuleDeclaration(litaC_parser__Parser* litaC_p,litaC_ast__ModuleStmt* litaC_moduleStmt) {
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_IMPORT)) {
        {
            litaC_ast__ImportDecl* litaC_importDecl = litaC_parser__Parser_importDeclaration(litaC_p);
            if(litaC_importDecl) {
                {
                    litaC_array__Array_add_cb__ptr_ImportDecl_ce_(&((litaC_moduleStmt->imports)), litaC_importDecl);
                    
                    
                }
                
            } 
            
            
            
        }
        
    } else {
        if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_HASH)) {
            {
                litaC_ast__Stmt* litaC_compStmt = litaC_parser__Parser_compStatement(litaC_p);
                assert(litaC_compStmt);
                if(!(litaC_compStmt) || litaC_compStmt->node.kind != litaC_ast__StmtKind_COMP_STMT) {
                    {
                        assert(litaC_false);
                        return;
                        
                        
                        
                    }
                    
                } 
                
                litaC_preprocessor__Preprocessor_evaluateForModule(&((litaC_p->lita->preprocessor)), litaC_moduleStmt, (litaC_ast__CompStmt*)litaC_compStmt);
                
                
            }
            
        } else {
            {
                litaC_array__Array_cb__ptr_NoteStmt_ce_ litaC_notes =  {
                    
                };
                if(!(litaC_parser__Parser_notes(litaC_p, &(litaC_notes)))) {
                    {
                        return;
                        
                        
                        
                    }
                    
                } 
                
                litaC_bool litaC_isPublic = litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_PUBLIC);
                if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_VAR)) {
                    {
                        litaC_ast__Decl* litaC_decl = litaC_parser__Parser_varDeclaration(litaC_p);
                        litaC_array__Array_add_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), litaC_decl);
                        
                        
                    }
                    
                } else {
                    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_CONST)) {
                        {
                            litaC_ast__Decl* litaC_decl = litaC_parser__Parser_constDeclaration(litaC_p);
                            litaC_array__Array_add_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), litaC_decl);
                            
                            
                        }
                        
                    } else {
                        if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_FUNC)) {
                            {
                                litaC_ast__Decl* litaC_decl = litaC_parser__Parser_funcDeclaration(litaC_p);
                                litaC_array__Array_add_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), litaC_decl);
                                
                                
                            }
                            
                        } else {
                            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_STRUCT)) {
                                {
                                    litaC_ast__Decl* litaC_decl = litaC_parser__Parser_structDeclaration(litaC_p);
                                    litaC_array__Array_add_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), litaC_decl);
                                    
                                    
                                }
                                
                            } else {
                                if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_UNION)) {
                                    {
                                        litaC_ast__Decl* litaC_decl = litaC_parser__Parser_unionDeclaration(litaC_p);
                                        litaC_array__Array_add_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), litaC_decl);
                                        
                                        
                                    }
                                    
                                } else {
                                    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_TRAIT)) {
                                        {
                                            litaC_ast__Decl* litaC_decl = litaC_parser__Parser_traitDeclaration(litaC_p);
                                            litaC_array__Array_add_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), litaC_decl);
                                            
                                            
                                        }
                                        
                                    } else {
                                        if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_ENUM)) {
                                            {
                                                litaC_ast__Decl* litaC_decl = litaC_parser__Parser_enumDeclaration(litaC_p);
                                                litaC_array__Array_add_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), litaC_decl);
                                                
                                                
                                            }
                                            
                                        } else {
                                            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_TYPEDEF)) {
                                                {
                                                    litaC_ast__Decl* litaC_decl = litaC_parser__Parser_typedefDeclaration(litaC_p);
                                                    litaC_array__Array_add_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), litaC_decl);
                                                    
                                                    
                                                }
                                                
                                            } else {
                                                if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_SEMICOLON)) {
                                                    {
                                                        if(!(litaC_array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_notes))))) {
                                                            {
                                                                litaC_array__Array_addAll_cb__ptr_NoteStmt_ce_(&((litaC_moduleStmt->notes)), &((litaC_notes)));
                                                                
                                                                
                                                            }
                                                            
                                                        } 
                                                        
                                                        return;
                                                        
                                                        
                                                        
                                                    }
                                                    
                                                } else {
                                                    {
                                                        litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_peek(litaC_p), litaC_error_codes__ErrorCode_UNEXPECTED_TOKEN);
                                                        return;
                                                        
                                                        
                                                        
                                                    }
                                                } 
                                                
                                            } 
                                            
                                        } 
                                        
                                    } 
                                    
                                } 
                                
                            } 
                            
                        } 
                        
                    } 
                    
                } 
                
                litaC_ast__Decl* litaC_decl = litaC_array__Array_last_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)));
                litaC_decl->attributes.notes = litaC_notes;
                litaC_decl->attributes.isPublic = litaC_isPublic;
                litaC_decl->attributes.isGlobal = litaC_true;
                
                
            }
        } 
        
    } 
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_parseCompileTimeBody(litaC_parser__Parser* litaC_p) {
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_IMPORT)) {
        {
            litaC_ast__ImportDecl* litaC_importDecl = litaC_parser__Parser_importDeclaration(litaC_p);
            if(!(litaC_importDecl)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            return (litaC_ast__Stmt*)litaC_importDecl;
            
            
            
        }
        
    } else {
        {
            litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
            litaC_array__Array_cb__ptr_NoteStmt_ce_ litaC_notes =  {
                
            };
            if(!(litaC_parser__Parser_notes(litaC_p, &(litaC_notes)))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_bool litaC_isPublic = litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_PUBLIC);
            litaC_ast__Decl* litaC_decl = NULL;
            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_VAR)) {
                {
                    litaC_decl = litaC_parser__Parser_varDeclaration(litaC_p);
                    
                    
                }
                
            } else {
                if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_CONST)) {
                    {
                        litaC_decl = litaC_parser__Parser_constDeclaration(litaC_p);
                        
                        
                    }
                    
                } else {
                    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_FUNC)) {
                        {
                            litaC_decl = litaC_parser__Parser_funcDeclaration(litaC_p);
                            
                            
                        }
                        
                    } else {
                        if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_STRUCT)) {
                            {
                                litaC_decl = litaC_parser__Parser_structDeclaration(litaC_p);
                                
                                
                            }
                            
                        } else {
                            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_UNION)) {
                                {
                                    litaC_decl = litaC_parser__Parser_unionDeclaration(litaC_p);
                                    
                                    
                                }
                                
                            } else {
                                if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_TRAIT)) {
                                    {
                                        litaC_decl = litaC_parser__Parser_traitDeclaration(litaC_p);
                                        
                                        
                                    }
                                    
                                } else {
                                    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_ENUM)) {
                                        {
                                            litaC_decl = litaC_parser__Parser_enumDeclaration(litaC_p);
                                            
                                            
                                        }
                                        
                                    } else {
                                        if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_TYPEDEF)) {
                                            {
                                                litaC_decl = litaC_parser__Parser_typedefDeclaration(litaC_p);
                                                
                                                
                                            }
                                            
                                        } else {
                                            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_SEMICOLON)) {
                                                {
                                                    if(!(litaC_array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_notes))))) {
                                                        {
                                                            return (litaC_ast__Stmt*)litaC_ast_new__NewNotesDecl(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_notes, litaC_p->allocator);
                                                            
                                                            
                                                            
                                                        }
                                                        
                                                    } 
                                                    
                                                    return NULL;
                                                    
                                                    
                                                    
                                                }
                                                
                                            } else {
                                                {
                                                    return litaC_parser__Parser_statement(litaC_p);
                                                    
                                                    
                                                    
                                                }
                                            } 
                                            
                                        } 
                                        
                                    } 
                                    
                                } 
                                
                            } 
                            
                        } 
                        
                    } 
                    
                } 
                
            } 
            
            litaC_decl->attributes.notes = litaC_notes;
            litaC_decl->attributes.isPublic = litaC_isPublic;
            litaC_decl->attributes.isGlobal = litaC_true;
            return (litaC_ast__Stmt*)litaC_decl;
            
            err:;
            
            return (litaC_ast__Stmt*)litaC_ast_new__NewPoisonDecl(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
            
            
            
        }
    } 
    
    
}

litaC_ast__ImportDecl* litaC_parser__Parser_importDeclaration(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_bool litaC_isUsing = litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_USING);
    litaC_lex__Token* litaC_moduleNameStr = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_STRING, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(!(litaC_moduleNameStr)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_lex__Token litaC_moduleName = *(litaC_moduleNameStr);
    litaC_lex__Token litaC_alias =  {
        .type = litaC_lex__TokenType_VOID
    };
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_AS)) {
        {
            litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
            if(!(litaC_identifier)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_alias = *(litaC_identifier);
            
            
        }
        
    } 
    
    return (litaC_ast__ImportDecl*)litaC_ast_new__NewImportDecl(litaC_pos, litaC_parser__Parser_prevPos(litaC_p), litaC_moduleName, litaC_alias, litaC_isUsing, litaC_p->allocator);
    
    err:;
    
    return NULL;
    
    
}

litaC_bool litaC_parser__Parser_notes(litaC_parser__Parser* litaC_p,litaC_array__Array_cb__ptr_NoteStmt_ce_* litaC_notes) {
    if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_AT))) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    litaC_array__Array_init_cb__ptr_NoteStmt_ce_(litaC_notes, 4, litaC_p->allocator);
    while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_AT)) {
        {
            litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
            litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
            if(!(litaC_identifier)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_lex__Token litaC_name = *(litaC_identifier);
            litaC_array__Array_cb_Token_ce_ litaC_attributes =  {
                
            };
            litaC_array__Array_init_cb_Token_ce_(&((litaC_attributes)), 2, litaC_p->allocator);
            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LEFT_PAREN)) {
                {
                    do {
                        {
                            if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_STRING)) {
                                {
                                    litaC_array__Array_add_cb_Token_ce_(&((litaC_attributes)), *(litaC_parser__Parser_advance(litaC_p)));
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                    }
                    while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COMMA));
                    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
                        {
                            goto err;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            litaC_ast__NoteStmt* litaC_note = (litaC_ast__NoteStmt*)litaC_ast_new__NewNoteStmt(litaC_pos, litaC_parser__Parser_prevPos(litaC_p), litaC_name, litaC_attributes, litaC_p->allocator);
            litaC_array__Array_add_cb__ptr_NoteStmt_ce_(litaC_notes, litaC_note);
            
            
        }
    }
    return litaC_true;
    
    err:;
    
    return litaC_false;
    
    
}

litaC_ast__Decl* litaC_parser__Parser_varDeclaration(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(!(litaC_identifier)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_lex__Token litaC_name = *(litaC_identifier);
    litaC_ast__TypeSpec* litaC_type = NULL;
    litaC_ast__Expr* litaC_expr = NULL;
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COLON)) {
        {
            litaC_type = litaC_parser__Parser_type(litaC_p, litaC_false);
            if(!(litaC_type)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_EQUALS)) {
                {
                    litaC_expr = litaC_parser__Parser_expression(litaC_p);
                    
                    
                }
                
            } 
            
            
            
        }
        
    } else {
        {
            if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_EQUALS, litaC_error_codes__ErrorCode_MISSING_EQUALS))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_expr = litaC_parser__Parser_expression(litaC_p);
            
            
        }
    } 
    
    return litaC_ast_new__NewVarDecl(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_name, litaC_type, litaC_expr, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonDecl(litaC_p, litaC_pos);
    
    
}

litaC_ast__Decl* litaC_parser__Parser_constDeclaration(litaC_parser__Parser* litaC_p) {
    litaC_ast__Decl* litaC_decl = litaC_parser__Parser_varDeclaration(litaC_p);
    if(litaC_decl->stmt.node.kind == litaC_ast__StmtKind_VAR_DECL) {
        {
            litaC_decl->stmt.node.kind = litaC_ast__StmtKind_CONST_DECL;
            
            
        }
        
    } 
    
    return litaC_decl;
    
    
}

litaC_ast__Decl* litaC_parser__Parser_funcDeclaration(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_p->funcLevel += 1;
    litaC_ast__ParameterDecl* litaC_objectParam = NULL;
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LEFT_PAREN)) {
        {
            litaC_objectParam = litaC_parser__Parser_paramDeclaration(litaC_p);
            if(!(litaC_objectParam)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(!(litaC_identifier)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_lex__Token litaC_name = *(litaC_identifier);
    litaC_array__Array_cb_GenericParam_ce_ litaC_genericParams =  {
        
    };
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LESS_THAN)) {
        {
            if(!(litaC_parser__Parser_genericParameters(litaC_p, &(litaC_genericParams)))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_ast__ParametersStmt* litaC_parameters = litaC_parser__Parser_parametersStatement(litaC_p);
    if(!(litaC_parameters)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(litaC_objectParam != NULL) {
        {
            if(litaC_array__Array_empty_cb__ptr_ParameterDecl_ce_(&((litaC_parameters->params)))) {
                {
                    litaC_array__Array_init_cb__ptr_ParameterDecl_ce_(&((litaC_parameters->params)), 1, litaC_p->allocator);
                    
                    
                }
                
            } 
            
            litaC_array__Array_insertAt_cb__ptr_ParameterDecl_ce_(&((litaC_parameters->params)), 0, litaC_objectParam);
            
            
        }
        
    } 
    
    litaC_ast__TypeSpec* litaC_returnType = NULL;
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COLON)) {
        {
            litaC_returnType = litaC_parser__Parser_type(litaC_p, litaC_false);
            if(!(litaC_returnType)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } else {
        {
            litaC_returnType = litaC_ast_new__NewVoidTypeSpec(litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
            
            
        }
    } 
    
    litaC_i32 litaC_flags = 0;
    if(litaC_parameters->isVararg) {
        {
            litaC_flags |= litaC_ast__FuncFlags_HAS_VARARGS;
            
            
        }
        
    } 
    
    if(litaC_objectParam != NULL) {
        {
            litaC_flags |= litaC_ast__FuncFlags_IS_METHOD;
            
            
        }
        
    } 
    
    litaC_ast__Stmt* litaC_body = NULL;
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_SEMICOLON)) {
        {
            litaC_body = litaC_ast_new__NewEmptyStmt(litaC_parser__Parser_prevPos(litaC_p), litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
            
            
        }
        
    } else {
        {
            litaC_body = litaC_parser__Parser_statement(litaC_p);
            if(litaC_body->node.kind == litaC_ast__StmtKind_BLOCK_STMT) {
                {
                    litaC_body->node.kind = litaC_ast__StmtKind_FUNC_BODY_STMT;
                    
                    
                }
                
            } 
            
            
            
        }
    } 
    
    litaC_p->funcLevel -= 1;
    return litaC_ast_new__NewFuncDecl(litaC_pos, litaC_parser__Parser_prevPos(litaC_p), litaC_name, litaC_genericParams, litaC_parameters, litaC_body, litaC_returnType, litaC_flags, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonDecl(litaC_p, litaC_pos);
    
    
}

litaC_ast__Decl* litaC_parser__Parser_structDeclaration(litaC_parser__Parser* litaC_p) {
    return litaC_parser__Parser_aggregateDeclaration(litaC_p, litaC_ast__StmtKind_STRUCT_DECL);
    
    
}

litaC_ast__Decl* litaC_parser__Parser_unionDeclaration(litaC_parser__Parser* litaC_p) {
    return litaC_parser__Parser_aggregateDeclaration(litaC_p, litaC_ast__StmtKind_UNION_DECL);
    
    
}

litaC_ast__Decl* litaC_parser__Parser_traitDeclaration(litaC_parser__Parser* litaC_p) {
    return litaC_parser__Parser_aggregateDeclaration(litaC_p, litaC_ast__StmtKind_TRAIT_DECL);
    
    
}

litaC_ast__Decl* litaC_parser__Parser_aggregateDeclaration(litaC_parser__Parser* litaC_p,litaC_ast__StmtKind litaC_kind) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_i32 litaC_flags = 0;
    if(litaC_p->aggregateLevel > 0) {
        {
            litaC_flags |= litaC_ast__AggregateFlags_IS_EMBEDDED;
            
            
        }
        
    } 
    
    litaC_lex__Token litaC_name =  {
        .type = litaC_lex__TokenType_VOID
    };
    if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_IDENTIFIER)) {
        {
            litaC_name = litaC_parser__Parser_identifier(litaC_p);
            
            
        }
        
    } else {
        {
            litaC_flags |= litaC_ast__AggregateFlags_IS_ANONYMOUS;
            
            
        }
    } 
    
    litaC_array__Array_cb_GenericParam_ce_ litaC_genericParams =  {
        
    };
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LESS_THAN)) {
        {
            if(!(litaC_parser__Parser_genericParameters(litaC_p, &(litaC_genericParams)))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_array__Array_cb_FieldStmt_ce_ litaC_fields =  {
        
    };
    litaC_p->aggregateLevel += 1;
    if(!(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_SEMICOLON))) {
        {
            if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_BRACE, litaC_error_codes__ErrorCode_MISSING_LEFT_BRACE))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_array__Array_init_cb_FieldStmt_ce_(&((litaC_fields)), 8, litaC_p->allocator);
            do {
                {
                    if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_BRACE)) {
                        {
                            break;
                            
                            
                        }
                        
                    } 
                    
                    litaC_ast__FieldStmt litaC_field = litaC_parser__Parser_fieldStatement(litaC_p, litaC_kind);
                    if(litaC_field.kind == litaC_ast__StmtKind_POISON_EXPR) {
                        {
                            goto err;
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_array__Array_add_cb_FieldStmt_ce_(&((litaC_fields)), litaC_field);
                    litaC_parser__Parser_eatSemicolon(litaC_p);
                    
                    
                }
            }
            while(!(litaC_parser__Parser_atEnd(litaC_p)));
            if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_BRACE, litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACE))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_p->aggregateLevel -= 1;
    return litaC_ast_new__NewAggregateDecl(litaC_pos, litaC_parser__Parser_prevPos(litaC_p), litaC_kind, litaC_name, litaC_genericParams, litaC_fields, litaC_flags, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonDecl(litaC_p, litaC_pos);
    
    
}

litaC_ast__Decl* litaC_parser__Parser_enumDeclaration(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(!(litaC_identifier)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_lex__Token litaC_name = *(litaC_identifier);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_BRACE, litaC_error_codes__ErrorCode_MISSING_LEFT_BRACE))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_array__Array_cb__ptr_EnumFieldEntryDecl_ce_ litaC_fields =  {
        
    };
    litaC_array__Array_init_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_fields)), 16, litaC_p->allocator);
    do {
        {
            if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_BRACE)) {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_ast__EnumFieldEntryDecl* litaC_field = litaC_parser__Parser_enumFieldEntryDecl(litaC_p);
            if(!(litaC_field)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_array__Array_add_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_fields)), litaC_field);
            
            
        }
    }
    while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COMMA));
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_BRACE, litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACE))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_ast_new__NewEnumDecl(litaC_pos, litaC_parser__Parser_prevPos(litaC_p), litaC_name, litaC_fields, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonDecl(litaC_p, litaC_pos);
    
    
}

litaC_ast__Decl* litaC_parser__Parser_typedefDeclaration(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_ast__TypeSpec* litaC_aliasedType = litaC_parser__Parser_type(litaC_p, litaC_false);
    if(!(litaC_aliasedType)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_AS);
    litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(!(litaC_identifier)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_lex__Token litaC_name = *(litaC_identifier);
    litaC_array__Array_cb_GenericParam_ce_ litaC_genericParams =  {
        
    };
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LESS_THAN)) {
        {
            if(!(litaC_parser__Parser_genericParameters(litaC_p, &(litaC_genericParams)))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    return litaC_ast_new__NewTypedefDecl(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_name, litaC_genericParams, litaC_aliasedType, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonDecl(litaC_p, litaC_pos);
    
    
}

litaC_ast__ParameterDecl* litaC_parser__Parser_paramDeclaration(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(!(litaC_identifier)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_lex__Token litaC_name = *(litaC_identifier);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_COLON, litaC_error_codes__ErrorCode_MISSING_COLON))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_bool litaC_isUsing = litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_USING);
    litaC_ast__TypeSpec* litaC_type = litaC_parser__Parser_type(litaC_p, litaC_false);
    if(!(litaC_type)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Expr* litaC_defaultExpr = NULL;
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_EQUALS)) {
        {
            litaC_defaultExpr = litaC_parser__Parser_constExpression(litaC_p);
            
            
        }
        
    } 
    
    return (litaC_ast__ParameterDecl*)litaC_ast_new__NewParameterDecl(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_name, litaC_type, litaC_defaultExpr, litaC_isUsing, litaC_p->allocator);
    
    err:;
    
    return NULL;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_expression(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_i32 litaC_errorCount = litaC_parser__Parser_numOfErrors(litaC_p);
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_assignment(litaC_p);
    if(litaC_parser__Parser_numOfErrors(litaC_p) > litaC_errorCount) {
        {
            litaC_parser__Parser_adjust(litaC_p, NULL, 0);
            if(litaC_expr) {
                {
                    if(litaC_expr->stmt.node.kind == litaC_ast__StmtKind_POISON_EXPR) {
                        {
                            return litaC_expr;
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_mem__Allocator_free(litaC_p->allocator, litaC_expr);
                    
                    
                }
                
            } 
            
            return litaC_ast_new__NewPoisonExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
            
            
            
        }
        
    } 
    
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_constExpression(litaC_parser__Parser* litaC_p) {
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_expression(litaC_p);
    litaC_parser__Parser_checkConstExpr(litaC_p, litaC_expr);
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_group(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_expression(litaC_p);
    litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN);
    return litaC_ast_new__NewGroupExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_p->allocator);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_arrayInit(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_ast__TypeSpec* litaC_type = litaC_parser__Parser_type(litaC_p, litaC_false);
    if(!(litaC_type)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(litaC_type->kind != litaC_ast__TypeSpecKind_ARRAY) {
        {
            litaC_parser__Parser_errorAtPos(litaC_p, litaC_type->pos, litaC_error_codes__ErrorCode_MISSING_LEFT_BRACE);
            goto err;
            
            
            
        }
        
    } 
    
    litaC_array__Array_cb__ptr_Expr_ce_ litaC_values =  {
        
    };
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LEFT_BRACE)) {
        {
            if(!(litaC_parser__Parser_arrayArguments(litaC_p, &(litaC_values)))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    return litaC_ast_new__NewArrayInitExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_type, litaC_values, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonExpr(litaC_p, litaC_pos);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_aggregateInit(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_array__Array_cb__ptr_InitArgExpr_ce_ litaC_arguments =  {
        
    };
    litaC_parser__Parser_structArguments(litaC_p, &(litaC_arguments));
    return litaC_ast_new__NewInitExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), NULL, litaC_arguments, litaC_p->allocator);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_sizeOf(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_PAREN, litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_bool litaC_isType = litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COLON);
    litaC_ast__Expr* litaC_expr = NULL;
    litaC_ast__TypeSpec* litaC_type = NULL;
    litaC_i32 litaC_backtrack = litaC_p->current;
    if(litaC_isType) {
        {
            litaC_type = litaC_parser__Parser_type(litaC_p, litaC_true);
            if(!(litaC_type)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_DOT)) {
                {
                    litaC_p->current = litaC_backtrack;
                    litaC_expr = litaC_parser__Parser_unary(litaC_p);
                    if(litaC_type) {
                        {
                            litaC_mem__Allocator_free(litaC_p->allocator, litaC_type);
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } else {
                {
                    litaC_expr = litaC_ast_new__NewTypeIdentifierExpr(litaC_type->pos, litaC_parser__Parser_pos(litaC_p), litaC_type, litaC_p->allocator);
                    
                    
                }
            } 
            
            
            
        }
        
    } else {
        {
            litaC_expr = litaC_parser__Parser_unary(litaC_p);
            
            
        }
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_ast_new__NewSizeOfExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonExpr(litaC_p, litaC_pos);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_typeOf(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_PAREN, litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_bool litaC_isType = litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COLON);
    litaC_ast__Expr* litaC_expr = NULL;
    litaC_ast__TypeSpec* litaC_type = NULL;
    litaC_i32 litaC_backtrack = litaC_p->current;
    if(litaC_isType) {
        {
            litaC_type = litaC_parser__Parser_type(litaC_p, litaC_true);
            if(!(litaC_type)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_DOT)) {
                {
                    litaC_p->current = litaC_backtrack;
                    litaC_expr = litaC_parser__Parser_unary(litaC_p);
                    if(litaC_type) {
                        {
                            litaC_mem__Allocator_free(litaC_p->allocator, litaC_type);
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } else {
                {
                    litaC_expr = litaC_ast_new__NewTypeIdentifierExpr(litaC_type->pos, litaC_parser__Parser_pos(litaC_p), litaC_type, litaC_p->allocator);
                    
                    
                }
            } 
            
            
            
        }
        
    } else {
        {
            litaC_expr = litaC_parser__Parser_unary(litaC_p);
            
            
        }
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_ast_new__NewTypeOfExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_type, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonExpr(litaC_p, litaC_pos);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_offsetOf(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_PAREN, litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__TypeSpec* litaC_type = litaC_parser__Parser_type(litaC_p, litaC_true);
    if(!(litaC_type)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_COMMA, litaC_error_codes__ErrorCode_MISSING_COMMA))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_lex__Token* litaC_fieldName = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(!(litaC_fieldName)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_ast_new__NewOffsetOfExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_type, *(litaC_fieldName), litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonExpr(litaC_p, litaC_pos);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_assignment(litaC_parser__Parser* litaC_p) {
    static 
    litaC_lex__TokenType litaC_checks[12] =  {
        litaC_lex__TokenType_EQUALS,
        litaC_lex__TokenType_PLUS_EQ,
        litaC_lex__TokenType_MINUS_EQ,
        litaC_lex__TokenType_DIV_EQ,
        litaC_lex__TokenType_MUL_EQ,
        litaC_lex__TokenType_MOD_EQ,
        litaC_lex__TokenType_LSHIFT_EQ,
        litaC_lex__TokenType_RSHIFT_EQ,
        litaC_lex__TokenType_BNOT_EQ,
        litaC_lex__TokenType_XOR_EQ,
        litaC_lex__TokenType_BAND_EQ,
        litaC_lex__TokenType_BOR_EQ
    };
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_ternary(litaC_p);
    if(!(litaC_expr)) {
        return NULL;
        
        
    } 
    
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    while(litaC_parser__Parser_matches(litaC_p, litaC_checks, 12)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_ternary(litaC_p);
            if(litaC_expr->stmt.node.kind == litaC_ast__StmtKind_GET_EXPR) {
                {
                    litaC_ast__GetExpr* litaC_getExpr = (litaC_ast__GetExpr*)litaC_expr;
                    litaC_expr = litaC_ast_new__NewSetExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_getExpr->object, litaC_getExpr->field, litaC_operator, litaC_right, litaC_p->allocator);
                    
                    
                }
                
            } else {
                if(litaC_expr->stmt.node.kind == litaC_ast__StmtKind_SUBSCRIPT_GET_EXPR) {
                    {
                        litaC_ast__SubscriptGetExpr* litaC_getExpr = (litaC_ast__SubscriptGetExpr*)litaC_expr;
                        litaC_expr = litaC_ast_new__NewSubscriptSetExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_getExpr->object, litaC_getExpr->index, litaC_operator, litaC_right, litaC_p->allocator);
                        
                        
                    }
                    
                } else {
                    {
                        litaC_expr = litaC_ast_new__NewBinaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_operator, litaC_right, litaC_p->allocator);
                        
                        
                    }
                } 
                
            } 
            
            litaC_pos = litaC_parser__Parser_pos(litaC_p);
            
            
        }
    }
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_ternary(litaC_parser__Parser* litaC_p) {
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_or(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_QUESTION_MARK)) {
        {
            litaC_ast__Expr* litaC_then = litaC_parser__Parser_expression(litaC_p);
            if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_COLON, litaC_error_codes__ErrorCode_MISSING_COLON))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_ast__Expr* litaC_other = litaC_parser__Parser_expression(litaC_p);
            litaC_expr = litaC_ast_new__NewTernaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_then, litaC_other, litaC_p->allocator);
            
            
        }
        
    } 
    
    return litaC_expr;
    
    err:;
    
    return litaC_parser__Parser_poisonExpr(litaC_p, litaC_pos);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_or(litaC_parser__Parser* litaC_p) {
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_and(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_OR)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_and(litaC_p);
            litaC_expr = litaC_ast_new__NewBinaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_operator, litaC_right, litaC_p->allocator);
            
            
        }
    }
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_and(litaC_parser__Parser* litaC_p) {
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_bitOr(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_AND)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_bitOr(litaC_p);
            litaC_expr = litaC_ast_new__NewBinaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_operator, litaC_right, litaC_p->allocator);
            
            
        }
    }
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_bitOr(litaC_parser__Parser* litaC_p) {
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_bitXor(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_BOR)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_bitXor(litaC_p);
            litaC_expr = litaC_ast_new__NewBinaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_operator, litaC_right, litaC_p->allocator);
            
            
        }
    }
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_bitXor(litaC_parser__Parser* litaC_p) {
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_bitAnd(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_XOR)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_bitAnd(litaC_p);
            litaC_expr = litaC_ast_new__NewBinaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_operator, litaC_right, litaC_p->allocator);
            
            
        }
    }
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_bitAnd(litaC_parser__Parser* litaC_p) {
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_equality(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_BAND)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_equality(litaC_p);
            litaC_expr = litaC_ast_new__NewBinaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_operator, litaC_right, litaC_p->allocator);
            
            
        }
    }
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_equality(litaC_parser__Parser* litaC_p) {
    static 
    litaC_lex__TokenType litaC_checks[2] =  {
        litaC_lex__TokenType_NOT_EQUALS,
        litaC_lex__TokenType_EQUALS_EQUALS
    };
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_comparison(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    while(litaC_parser__Parser_matches(litaC_p, litaC_checks, 2)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_comparison(litaC_p);
            litaC_expr = litaC_ast_new__NewBinaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_operator, litaC_right, litaC_p->allocator);
            
            
        }
    }
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_comparison(litaC_parser__Parser* litaC_p) {
    static 
    litaC_lex__TokenType litaC_checks[4] =  {
        litaC_lex__TokenType_GREATER_THAN,
        litaC_lex__TokenType_GREATER_EQUALS,
        litaC_lex__TokenType_LESS_THAN,
        litaC_lex__TokenType_LESS_EQUALS
    };
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_bitShift(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    while(litaC_parser__Parser_matches(litaC_p, litaC_checks, 4)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_bitShift(litaC_p);
            litaC_expr = litaC_ast_new__NewBinaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_operator, litaC_right, litaC_p->allocator);
            
            
        }
    }
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_bitShift(litaC_parser__Parser* litaC_p) {
    static 
    litaC_lex__TokenType litaC_checks[2] =  {
        litaC_lex__TokenType_LSHIFT,
        litaC_lex__TokenType_RSHIFT
    };
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_term(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_ast__Expr* litaC_bitExpr = litaC_parser__Parser_tryBitShiftRight(litaC_p, litaC_expr);
    if(litaC_bitExpr) {
        {
            return litaC_bitExpr;
            
            
            
        }
        
    } 
    
    while(litaC_parser__Parser_matches(litaC_p, litaC_checks, 2)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_term(litaC_p);
            litaC_expr = litaC_ast_new__NewBinaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_operator, litaC_right, litaC_p->allocator);
            
            
        }
    }
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_term(litaC_parser__Parser* litaC_p) {
    static 
    litaC_lex__TokenType litaC_checks[2] =  {
        litaC_lex__TokenType_MINUS,
        litaC_lex__TokenType_PLUS
    };
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_factor(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    while(litaC_parser__Parser_matches(litaC_p, litaC_checks, 2)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_factor(litaC_p);
            litaC_expr = litaC_ast_new__NewBinaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_operator, litaC_right, litaC_p->allocator);
            
            
        }
    }
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_factor(litaC_parser__Parser* litaC_p) {
    static 
    litaC_lex__TokenType litaC_checks[3] =  {
        litaC_lex__TokenType_SLASH,
        litaC_lex__TokenType_STAR,
        litaC_lex__TokenType_MOD
    };
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_unary(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    while(litaC_parser__Parser_matches(litaC_p, litaC_checks, 3)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_unary(litaC_p);
            litaC_expr = litaC_ast_new__NewBinaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_operator, litaC_right, litaC_p->allocator);
            
            
        }
    }
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_unary(litaC_parser__Parser* litaC_p) {
    static 
    litaC_lex__TokenType litaC_checks[6] =  {
        litaC_lex__TokenType_NOT,
        litaC_lex__TokenType_MINUS,
        litaC_lex__TokenType_PLUS,
        litaC_lex__TokenType_STAR,
        litaC_lex__TokenType_BAND,
        litaC_lex__TokenType_BNOT
    };
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    if(litaC_parser__Parser_matches(litaC_p, litaC_checks, 6)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_unary(litaC_p);
            return litaC_ast_new__NewUnaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_operator, litaC_right, litaC_p->allocator);
            
            
            
        }
        
    } 
    
    return litaC_parser__Parser_functionCall(litaC_p);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_functionCall(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_primary(litaC_p);
    litaC_expr->stmt.node.endPos = litaC_parser__Parser_pos(litaC_p);
    while(litaC_true) {
        {
            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LEFT_PAREN)) {
                {
                    litaC_expr = litaC_parser__Parser_finishFunctionCall(litaC_p, litaC_expr);
                    litaC_expr->stmt.node.endPos = litaC_parser__Parser_pos(litaC_p);
                    
                    
                }
                
            } else {
                if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_LEFT_BRACE)) {
                    {
                        if(!(litaC_ast__Expr_isIdentifier(litaC_expr))) {
                            {
                                return litaC_expr;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_parser__Parser_advance(litaC_p);
                        litaC_ast__IdentifierExpr* litaC_idExpr = (litaC_ast__IdentifierExpr*)litaC_expr;
                        litaC_array__Array_cb__ptr_InitArgExpr_ce_ litaC_arguments =  {
                            
                        };
                        if(!(litaC_parser__Parser_structArguments(litaC_p, &(litaC_arguments)))) {
                            {
                                goto err;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_expr = litaC_ast_new__NewInitExpr(litaC_expr->stmt.node.startPos, litaC_parser__Parser_pos(litaC_p), litaC_idExpr->type, litaC_arguments, litaC_p->allocator);
                        
                        
                    }
                    
                } else {
                    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LEFT_BRACKET)) {
                        {
                            litaC_ast__Expr* litaC_index = litaC_parser__Parser_expression(litaC_p);
                            if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_BRACKET, litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACKET))) {
                                {
                                    goto err;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_expr = litaC_ast_new__NewSubscriptGetExpr(litaC_expr->stmt.node.startPos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_index, litaC_p->allocator);
                            
                            
                        }
                        
                    } else {
                        if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_DOT)) {
                            {
                                litaC_ast__NameTypeSpec* litaC_identifier = litaC_parser__Parser_identifierType(litaC_p, litaC_true);
                                if(!(litaC_identifier)) {
                                    {
                                        goto err;
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                litaC_expr = litaC_ast_new__NewGetExpr(litaC_expr->stmt.node.startPos, litaC_parser__Parser_pos(litaC_p), litaC_expr, (litaC_ast__IdentifierExpr*)litaC_ast_new__NewIdentifierExpr(litaC_identifier->spec.pos, litaC_parser__Parser_pos(litaC_p), litaC_identifier, litaC_p->allocator), litaC_p->allocator);
                                
                                
                            }
                            
                        } else {
                            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_AS)) {
                                {
                                    litaC_expr = litaC_parser__Parser_cast(litaC_p, litaC_expr);
                                    
                                    
                                }
                                
                            } else {
                                {
                                    break;
                                    
                                    
                                }
                            } 
                            
                        } 
                        
                    } 
                    
                } 
                
            } 
            
            
            
        }
    }
    return litaC_expr;
    
    err:;
    
    return litaC_parser__Parser_poisonExpr(litaC_p, litaC_pos);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_primary(litaC_parser__Parser* litaC_p) {
    litaC_lex__Token* litaC_token = litaC_parser__Parser_peek(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_token->pos;
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_TRUE)) {
        {
            return litaC_ast_new__NewBooleanExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_true, litaC_p->allocator);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_FALSE)) {
        {
            return litaC_ast_new__NewBooleanExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_false, litaC_p->allocator);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_NULL)) {
        {
            return litaC_ast_new__NewNullExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_INT_NUMBER) || litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_FLOAT_NUMBER)) {
        {
            return litaC_ast_new__NewNumberExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), *((litaC_token)), litaC_p->allocator);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_STRING)) {
        {
            return litaC_ast_new__NewStringExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), *((litaC_token)), litaC_p->allocator);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_CHAR)) {
        {
            return litaC_ast_new__NewCharExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), *((litaC_token)), litaC_p->allocator);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LEFT_PAREN)) {
        {
            return litaC_parser__Parser_group(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_LEFT_BRACKET)) {
        {
            return litaC_parser__Parser_arrayInit(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LEFT_BRACE)) {
        {
            return litaC_parser__Parser_aggregateInit(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_SIZEOF)) {
        {
            return litaC_parser__Parser_sizeOf(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_TYPEOF)) {
        {
            return litaC_parser__Parser_typeOf(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_OFFSETOF)) {
        {
            return litaC_parser__Parser_offsetOf(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_IDENTIFIER)) {
        {
            litaC_ast__NameTypeSpec* litaC_name = litaC_parser__Parser_identifierType(litaC_p, litaC_true);
            if(!(litaC_name)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            return litaC_ast_new__NewIdentifierExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_name, litaC_p->allocator);
            
            
            
        }
        
    } 
    
    err:;
    
    litaC_parser__Parser_errorAtToken(litaC_p, litaC_token, litaC_error_codes__ErrorCode_UNEXPECTED_TOKEN);
    return litaC_parser__Parser_poisonExpr(litaC_p, litaC_pos);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_finishFunctionCall(litaC_parser__Parser* litaC_p,litaC_ast__Expr* litaC_expr) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_array__Array_cb_CallArg_ce_ litaC_arguments =  {
        
    };
    if(!(litaC_parser__Parser_arguments(litaC_p, &(litaC_arguments)))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_array__Array_cb__ptr_TypeSpec_ce_ litaC_genericArgs =  {
        
    };
    if(litaC_ast__Expr_isIdentifier(litaC_expr)) {
        {
            litaC_ast__IdentifierExpr* litaC_idExpr = (litaC_ast__IdentifierExpr*)litaC_expr;
            litaC_expr->stmt.node.kind = litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR;
            litaC_genericArgs = litaC_idExpr->type->genericArgs;
            
            
        }
        
    } else {
        if(litaC_expr->stmt.node.kind == litaC_ast__StmtKind_GET_EXPR) {
            {
                litaC_ast__GetExpr* litaC_getExpr = (litaC_ast__GetExpr*)litaC_expr;
                litaC_ast__IdentifierExpr* litaC_idExpr = litaC_getExpr->field;
                litaC_idExpr->expr.stmt.node.kind = litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR;
                litaC_genericArgs = litaC_idExpr->type->genericArgs;
                
                
            }
            
        } 
        
    } 
    
    return litaC_ast_new__NewFuncCallExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_arguments, litaC_genericArgs, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonExpr(litaC_p, litaC_pos);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_cast(litaC_parser__Parser* litaC_p,litaC_ast__Expr* litaC_expr) {
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_PAREN, litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__TypeSpec* litaC_castTo = litaC_parser__Parser_type(litaC_p, litaC_false);
    if(!(litaC_castTo)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_ast_new__NewCastExpr(litaC_expr->stmt.node.startPos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_castTo, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonExpr(litaC_p, litaC_expr->stmt.node.startPos);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_statement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_i32 litaC_errorCount = litaC_parser__Parser_numOfErrors(litaC_p);
    litaC_ast__Stmt* litaC_stmt = litaC_parser__Parser_tryStatement(litaC_p);
    if(litaC_parser__Parser_numOfErrors(litaC_p) > litaC_errorCount) {
        {
            litaC_parser__Parser_adjust(litaC_p, NULL, 0);
            if(litaC_stmt) {
                {
                    if(litaC_stmt->node.kind == litaC_ast__StmtKind_POISON_EXPR) {
                        {
                            return litaC_stmt;
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_mem__Allocator_free(litaC_p->allocator, litaC_stmt);
                    
                    
                }
                
            } 
            
            return (litaC_ast__Stmt*)litaC_ast_new__NewPoisonExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
            
            
            
        }
        
    } 
    
    return litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_tryStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_AT)) {
        {
            litaC_array__Array_cb__ptr_NoteStmt_ce_ litaC_notes =  {
                
            };
            if(!(litaC_parser__Parser_notes(litaC_p, &(litaC_notes)))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_ast__Decl* litaC_decl = NULL;
            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_VAR)) {
                {
                    litaC_decl = litaC_parser__Parser_varDeclaration(litaC_p);
                    
                    
                }
                
            } else {
                if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_CONST)) {
                    {
                        litaC_decl = litaC_parser__Parser_constDeclaration(litaC_p);
                        
                        
                    }
                    
                } else {
                    {
                        litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_peek(litaC_p), litaC_error_codes__ErrorCode_INVALID_NOTE_DECL);
                        goto err;
                        
                        
                        
                    }
                } 
                
            } 
            
            litaC_decl->attributes.notes = litaC_notes;
            litaC_decl->stmt.node.startPos = litaC_pos;
            return (litaC_ast__Stmt*)litaC_decl;
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_HASH)) {
        {
            return litaC_parser__Parser_compStatement(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LEFT_BRACE)) {
        {
            return litaC_parser__Parser_blockStatement(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_VAR)) {
        {
            return (litaC_ast__Stmt*)litaC_parser__Parser_varDeclaration(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_CONST)) {
        {
            return (litaC_ast__Stmt*)litaC_parser__Parser_constDeclaration(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_IF)) {
        {
            return litaC_parser__Parser_ifStatement(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_WHILE)) {
        {
            return litaC_parser__Parser_whileStatement(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_DO)) {
        {
            return litaC_parser__Parser_doWhileStatement(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_FOR)) {
        {
            return litaC_parser__Parser_forStatement(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_SWITCH)) {
        {
            return litaC_parser__Parser_switchStatement(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_BREAK)) {
        {
            return litaC_parser__Parser_breakStatement(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_CONTINUE)) {
        {
            return litaC_parser__Parser_continueStatement(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_RETURN)) {
        {
            return litaC_parser__Parser_returnStatement(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_DEFER)) {
        {
            return litaC_parser__Parser_deferStatement(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_GOTO)) {
        {
            return litaC_parser__Parser_gotoStatement(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_IDENTIFIER)) {
        {
            litaC_ast__Stmt* litaC_stmt = litaC_parser__Parser_tryLabelStatement(litaC_p);
            if(litaC_stmt) {
                {
                    return litaC_stmt;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    return (litaC_ast__Stmt*)litaC_parser__Parser_expression(litaC_p);
    
    err:;
    
    return litaC_parser__Parser_poisonStatement(litaC_p, litaC_pos);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_compStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    const litaC_char* litaC_type = NULL;
    const litaC_char* litaC_scriptExpr = NULL;
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_IF)) {
        {
            litaC_type = "if";
            
            
        }
        
    } else {
        if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_ELSE)) {
            {
                litaC_type = "else";
                
                
            }
            
        } else {
            {
                litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
                if(!(litaC_identifier)) {
                    {
                        goto err;
                        
                        
                        
                    }
                    
                } 
                
                litaC_type = litaC_ast_copy__NewTokenName(*(litaC_identifier), litaC_p->allocator);
                
                
            }
        } 
        
    } 
    
    if(strcmp(litaC_type, "if") == 0 || strcmp(litaC_type, "elseif") == 0) {
        {
            litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
            litaC_i32 litaC_currentLine = litaC_pos.lineNumber;
            litaC_string_buffer__StringBuffer litaC_script = litaC_string_buffer__StringBufferInit(128, litaC_p->allocator);
            const litaC_char* litaC_stream = litaC_pos.start;
            while(*(litaC_stream)) {
                {
                    litaC_char litaC_c = *(litaC_stream);
                    if(litaC_c == '\n') {
                        {
                            break;
                            
                            
                        }
                        
                    } 
                    
                    if(litaC_c == '\\') {
                        {
                            if(litaC_stream[1] == '\n') {
                                {
                                    litaC_stream += 2;
                                    litaC_currentLine += 1;
                                    continue;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_string_buffer__StringBuffer_appendChar(&((litaC_script)), litaC_c);
                    litaC_stream += 1;
                    
                    
                }
            }
            while(!(litaC_parser__Parser_atEnd(litaC_p))) {
                {
                    litaC_lex__Token* litaC_token = litaC_parser__Parser_peek(litaC_p);
                    litaC_i32 litaC_nextLine = litaC_token->pos.lineNumber;
                    if(litaC_nextLine > litaC_currentLine) {
                        {
                            break;
                            
                            
                        }
                        
                    } 
                    
                    litaC_parser__Parser_advance(litaC_p);
                    
                    
                }
            }
            litaC_scriptExpr = litaC_string_buffer__StringBuffer_cStr(&((litaC_script)));
            litaC_array__Array_cb__ptr_Stmt_ce_ litaC_body = litaC_array__ArrayInit_cb__ptr_Stmt_ce_(32, litaC_p->allocator);
            while(!(litaC_parser__Parser_atEnd(litaC_p))) {
                {
                    if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_HASH)) {
                        {
                            break;
                            
                            
                        }
                        
                    } 
                    
                    litaC_ast__Stmt* litaC_stmt = litaC_parser__Parser_parseCompileTimeBody(litaC_p);
                    if(litaC_stmt) {
                        {
                            litaC_array__Array_add_cb__ptr_Stmt_ce_(&((litaC_body)), litaC_stmt);
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_HASH, litaC_error_codes__ErrorCode_MISSING_COMP_STMT_END))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_ast__Stmt* litaC_end = litaC_parser__Parser_compStatement(litaC_p);
            if(litaC_end && litaC_end->node.kind != litaC_ast__StmtKind_COMP_STMT) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            return litaC_ast_new__NewCompStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_type, litaC_scriptExpr, litaC_body, (litaC_ast__CompStmt*)litaC_end, litaC_p->allocator);
            
            
            
        }
        
    } else {
        if(strcmp(litaC_type, "precheck") == 0 || strcmp(litaC_type, "postparse") == 0) {
            {
                litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
                litaC_string_buffer__StringBuffer litaC_script = litaC_string_buffer__StringBufferInit(512, litaC_p->allocator);
                const litaC_char* litaC_stream = litaC_pos.start;
                while(*(litaC_stream)) {
                    {
                        litaC_char litaC_c = *(litaC_stream);
                        if(litaC_c == '#') {
                            {
                                break;
                                
                                
                            }
                            
                        } 
                        
                        litaC_string_buffer__StringBuffer_appendChar(&((litaC_script)), litaC_c);
                        litaC_stream += 1;
                        
                        
                    }
                }
                while(!(litaC_parser__Parser_atEnd(litaC_p))) {
                    {
                        litaC_lex__Token* litaC_token = litaC_parser__Parser_peek(litaC_p);
                        if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_HASH)) {
                            {
                                break;
                                
                                
                            }
                            
                        } 
                        
                        litaC_parser__Parser_advance(litaC_p);
                        
                        
                    }
                }
                litaC_scriptExpr = litaC_string_buffer__StringBuffer_cStr(&((litaC_script)));
                if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_HASH, litaC_error_codes__ErrorCode_MISSING_COMP_STMT_END))) {
                    {
                        goto err;
                        
                        
                        
                    }
                    
                } 
                
                litaC_ast__Stmt* litaC_end = litaC_parser__Parser_compStatement(litaC_p);
                if(litaC_end && litaC_end->node.kind != litaC_ast__StmtKind_COMP_STMT) {
                    {
                        goto err;
                        
                        
                        
                    }
                    
                } 
                
                litaC_array__Array_cb__ptr_Stmt_ce_ litaC_body =  {
                    
                };
                return litaC_ast_new__NewCompStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_type, litaC_scriptExpr, litaC_body, (litaC_ast__CompStmt*)litaC_end, litaC_p->allocator);
                
                
                
            }
            
        } else {
            if(strcmp(litaC_type, "else") == 0) {
                {
                    litaC_array__Array_cb__ptr_Stmt_ce_ litaC_body = litaC_array__ArrayInit_cb__ptr_Stmt_ce_(32, litaC_p->allocator);
                    while(!(litaC_parser__Parser_atEnd(litaC_p))) {
                        {
                            if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_HASH)) {
                                {
                                    break;
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_ast__Stmt* litaC_stmt = litaC_parser__Parser_parseCompileTimeBody(litaC_p);
                            if(litaC_stmt) {
                                {
                                    litaC_array__Array_add_cb__ptr_Stmt_ce_(&((litaC_body)), litaC_stmt);
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                    }
                    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_HASH, litaC_error_codes__ErrorCode_MISSING_COMP_STMT_END))) {
                        {
                            goto err;
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_ast__Stmt* litaC_end = litaC_parser__Parser_compStatement(litaC_p);
                    if(litaC_end && litaC_end->node.kind != litaC_ast__StmtKind_COMP_STMT) {
                        {
                            goto err;
                            
                            
                            
                        }
                        
                    } 
                    
                    return litaC_ast_new__NewCompStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_type, litaC_scriptExpr, litaC_body, (litaC_ast__CompStmt*)litaC_end, litaC_p->allocator);
                    
                    
                    
                }
                
            } else {
                if(strcmp(litaC_type, "end") == 0) {
                    {
                        return litaC_ast_new__NewCompStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_type, NULL, (litaC_array__Array_cb__ptr_Stmt_ce_) {
                            
                        }, NULL, litaC_p->allocator);
                        
                        
                        
                    }
                    
                } else {
                    {
                        litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_peek(litaC_p), litaC_error_codes__ErrorCode_INVALID_COMP_STMT);
                        goto err;
                        
                        
                        
                    }
                } 
                
            } 
            
        } 
        
    } 
    
    err:;
    
    return (litaC_ast__Stmt*)litaC_ast_new__NewPoisonExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_blockStatement(litaC_parser__Parser* litaC_p) {
    if(litaC_p->breakLevel > 0) {
        {
            litaC_p->breakLevel -= 1;
            
            
        }
        
    } 
    
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_array__Array_cb__ptr_Stmt_ce_ litaC_stmts =  {
        
    };
    litaC_array__Array_init_cb__ptr_Stmt_ce_(&((litaC_stmts)), 16, litaC_p->allocator);
    do {
        {
            if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_BRACE)) {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_ast__Stmt* litaC_stmt = litaC_parser__Parser_statement(litaC_p);
            litaC_array__Array_add_cb__ptr_Stmt_ce_(&((litaC_stmts)), litaC_stmt);
            litaC_parser__Parser_eatSemicolon(litaC_p);
            
            
        }
    }
    while(!(litaC_parser__Parser_atEnd(litaC_p)));
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_BRACE, litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACE))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_ast_new__NewBlockStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_stmts, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonStatement(litaC_p, litaC_pos);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_ifStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_PAREN, litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Expr* litaC_cond = litaC_parser__Parser_expression(litaC_p);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Stmt* litaC_then = litaC_parser__Parser_statement(litaC_p);
    litaC_ast__Stmt* litaC_elseStmt = NULL;
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_ELSE)) {
        {
            litaC_elseStmt = litaC_parser__Parser_statement(litaC_p);
            
            
        }
        
    } 
    
    return litaC_ast_new__NewIfStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_cond, litaC_then, litaC_elseStmt, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonStatement(litaC_p, litaC_pos);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_whileStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_p->loopLevel += 1;
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_PAREN, litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Expr* litaC_cond = litaC_parser__Parser_expression(litaC_p);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Stmt* litaC_body = litaC_parser__Parser_statement(litaC_p);
    litaC_p->loopLevel -= 1;
    return litaC_ast_new__NewWhileStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_cond, litaC_body, litaC_p->allocator);
    
    err:;
    
    litaC_p->loopLevel -= 1;
    return litaC_parser__Parser_poisonStatement(litaC_p, litaC_pos);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_doWhileStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_p->loopLevel += 1;
    litaC_ast__Stmt* litaC_body = litaC_parser__Parser_statement(litaC_p);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_WHILE, litaC_error_codes__ErrorCode_MISSING_WHILE))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_PAREN, litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Expr* litaC_cond = litaC_parser__Parser_expression(litaC_p);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_p->loopLevel -= 1;
    return litaC_ast_new__NewDoWhileStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_cond, litaC_body, litaC_p->allocator);
    
    err:;
    
    litaC_p->loopLevel -= 1;
    return litaC_parser__Parser_poisonStatement(litaC_p, litaC_pos);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_forStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_PAREN, litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Stmt* litaC_init = (!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_SEMICOLON))) ? litaC_parser__Parser_statement(litaC_p) : NULL;
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_SEMICOLON, litaC_error_codes__ErrorCode_MISSING_SEMICOLON))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Expr* litaC_cond = (!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_SEMICOLON))) ? litaC_parser__Parser_expression(litaC_p) : NULL;
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_SEMICOLON, litaC_error_codes__ErrorCode_MISSING_SEMICOLON))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Stmt* litaC_post = (!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_PAREN))) ? litaC_parser__Parser_statement(litaC_p) : NULL;
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_p->loopLevel += 1;
    litaC_ast__Stmt* litaC_body = litaC_parser__Parser_statement(litaC_p);
    litaC_p->loopLevel -= 1;
    return litaC_ast_new__NewForStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_init, litaC_cond, litaC_post, litaC_body, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonStatement(litaC_p, litaC_pos);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_switchCaseStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_ast__Expr* litaC_cond = litaC_parser__Parser_constExpression(litaC_p);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_COLON, litaC_error_codes__ErrorCode_MISSING_COLON))) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_lex__SrcPos litaC_bodyPos = litaC_parser__Parser_pos(litaC_p);
    litaC_array__Array_cb__ptr_Stmt_ce_ litaC_stmts =  {
        
    };
    litaC_array__Array_init_cb__ptr_Stmt_ce_(&((litaC_stmts)), 8, litaC_p->allocator);
    while(!(litaC_parser__Parser_atEnd(litaC_p))) {
        {
            if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_BRACE) || litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_CASE) || litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_DEFAULT)) {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_ast__Stmt* litaC_stmt = litaC_parser__Parser_statement(litaC_p);
            litaC_parser__Parser_eatSemicolon(litaC_p);
            litaC_array__Array_add_cb__ptr_Stmt_ce_(&((litaC_stmts)), litaC_stmt);
            
            
        }
    }
    litaC_ast__Stmt* litaC_body = NULL;
    if(litaC_array__Array_empty_cb__ptr_Stmt_ce_(&((litaC_stmts)))) {
        {
            litaC_body = litaC_ast_new__NewEmptyStmt(litaC_bodyPos, litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
            
            
        }
        
    } else {
        {
            litaC_body = litaC_ast_new__NewBlockStmt(litaC_bodyPos, litaC_parser__Parser_pos(litaC_p), litaC_stmts, litaC_p->allocator);
            
            
        }
    } 
    
    return litaC_ast_new__NewSwitchCaseStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_cond, litaC_body, litaC_p->allocator);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_switchDefaultStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_i32 litaC_breakCount = litaC_p->breakLevel;
    litaC_array__Array_cb__ptr_Stmt_ce_ litaC_stmts =  {
        
    };
    litaC_array__Array_init_cb__ptr_Stmt_ce_(&((litaC_stmts)), 8, litaC_p->allocator);
    while(!(litaC_parser__Parser_atEnd(litaC_p))) {
        {
            if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_BRACE) || litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_CASE)) {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_ast__Stmt* litaC_stmt = litaC_parser__Parser_statement(litaC_p);
            litaC_parser__Parser_eatSemicolon(litaC_p);
            litaC_array__Array_add_cb__ptr_Stmt_ce_(&((litaC_stmts)), litaC_stmt);
            if(litaC_breakCount != litaC_p->breakLevel) {
                {
                    litaC_p->breakLevel -= 1;
                    break;
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_ast_new__NewBlockStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_stmts, litaC_p->allocator);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_switchStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_p->switchLevel += 1;
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_PAREN, litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Expr* litaC_cond = litaC_parser__Parser_expression(litaC_p);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_bool litaC_startBrace = litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LEFT_BRACE);
    litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_ litaC_cases =  {
        
    };
    litaC_array__Array_init_cb__ptr_SwitchCaseStmt_ce_(&((litaC_cases)), 8, litaC_p->allocator);
    litaC_ast__Stmt* litaC_defaultStmt = NULL;
    while(!(litaC_parser__Parser_atEnd(litaC_p))) {
        {
            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_CASE)) {
                {
                    litaC_ast__SwitchCaseStmt* litaC_caseStmt = (litaC_ast__SwitchCaseStmt*)litaC_parser__Parser_switchCaseStatement(litaC_p);
                    if(!(litaC_caseStmt)) {
                        {
                            goto err;
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_array__Array_add_cb__ptr_SwitchCaseStmt_ce_(&((litaC_cases)), litaC_caseStmt);
                    litaC_parser__Parser_eatSemicolon(litaC_p);
                    
                    
                }
                
            } else {
                if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_DEFAULT)) {
                    {
                        if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_COLON, litaC_error_codes__ErrorCode_MISSING_COLON))) {
                            {
                                goto err;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_defaultStmt = litaC_parser__Parser_switchDefaultStatement(litaC_p);
                        litaC_parser__Parser_eatSemicolon(litaC_p);
                        
                        
                    }
                    
                } else {
                    {
                        break;
                        
                        
                    }
                } 
                
            } 
            
            
            
        }
    }
    if(litaC_startBrace) {
        {
            litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_BRACE, litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACE);
            
            
        }
        
    } 
    
    {
        litaC_ast__Stmt* ___result = litaC_ast_new__NewSwitchStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_cond, litaC_cases, litaC_defaultStmt, litaC_p->allocator);
        litaC_p->switchLevel -= 1;
        return ___result;
        
    }
    
    err:;
    
    {
        litaC_ast__Stmt* ___result = litaC_parser__Parser_poisonStatement(litaC_p, litaC_pos);
        litaC_p->switchLevel -= 1;
        return ___result;
        
    }
    
    litaC_p->switchLevel -= 1;
    
}

litaC_ast__Stmt* litaC_parser__Parser_breakStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    if(litaC_p->loopLevel < 1 && litaC_p->switchLevel < 1) {
        {
            litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_previous(litaC_p), litaC_error_codes__ErrorCode_INVALID_BREAK);
            goto err;
            
            
            
        }
        
    } 
    
    if(litaC_p->switchLevel > 0 && litaC_p->loopLevel < 1) {
        {
            litaC_p->breakLevel += 1;
            
            
        }
        
    } 
    
    return litaC_ast_new__NewBreakStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonStatement(litaC_p, litaC_pos);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_continueStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    if(litaC_p->loopLevel < 1) {
        {
            litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_previous(litaC_p), litaC_error_codes__ErrorCode_INVALID_CONTINUE);
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_ast_new__NewContinueStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonStatement(litaC_p, litaC_pos);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_returnStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_ast__Expr* litaC_expr = NULL;
    if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_SEMICOLON))) {
        {
            litaC_expr = litaC_parser__Parser_expression(litaC_p);
            
            
        }
        
    } 
    
    return litaC_ast_new__NewReturnStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_p->allocator);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_deferStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_ast__Stmt* litaC_defered = litaC_parser__Parser_statement(litaC_p);
    return litaC_ast_new__NewDeferStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_defered, litaC_p->allocator);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_gotoStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_lex__Token* litaC_label = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(!(litaC_label)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_ast_new__NewGotoStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), *((litaC_label)), litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonStatement(litaC_p, litaC_pos);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_tryLabelStatement(litaC_parser__Parser* litaC_p) {
    litaC_i32 litaC_backtrack = litaC_p->current;
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_lex__Token* litaC_label = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(!(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COLON))) {
        {
            litaC_p->current = litaC_backtrack;
            return NULL;
            
            
            
        }
        
    } 
    
    if(litaC_p->funcLevel < 1) {
        {
            litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_peek(litaC_p), litaC_error_codes__ErrorCode_INVALID_LABEL_STMT);
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_ast_new__NewLabelStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), *((litaC_label)), litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonStatement(litaC_p, litaC_pos);
    
    
}

litaC_ast__TypeSpec* litaC_parser__Parser_type(litaC_parser__Parser* litaC_p,litaC_bool litaC_disambiguate) {
    litaC_lex__Token* litaC_token = litaC_parser__Parser_peek(litaC_p);
    switch(litaC_token->type) {
        case litaC_lex__TokenType_BOOL: 
        case litaC_lex__TokenType_CHAR: 
        case litaC_lex__TokenType_I8: 
        case litaC_lex__TokenType_U8: 
        case litaC_lex__TokenType_I16: 
        case litaC_lex__TokenType_U16: 
        case litaC_lex__TokenType_I32: 
        case litaC_lex__TokenType_U32: 
        case litaC_lex__TokenType_I64: 
        case litaC_lex__TokenType_U64: 
        case litaC_lex__TokenType_F32: 
        case litaC_lex__TokenType_F64: 
        case litaC_lex__TokenType_USIZE: 
        case litaC_lex__TokenType_VOID: {
            {
                litaC_parser__Parser_advance(litaC_p);
                litaC_ast__NameTypeSpec* litaC_spec = (litaC_ast__NameTypeSpec*)litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind_NAME, litaC_token->pos, litaC_p->allocator);
                litaC_spec->name = litaC_ast_copy__NewTokenName(*((litaC_token)), litaC_p->allocator);
                return (litaC_ast__TypeSpec*)litaC_spec;
                
                
                
            }
            
            
        }
        case litaC_lex__TokenType_STAR: {
            {
                litaC_parser__Parser_advance(litaC_p);
                litaC_ast__TypeSpec* litaC_base = litaC_parser__Parser_type(litaC_p, litaC_disambiguate);
                if(!(litaC_base)) {
                    return NULL;
                    
                    
                } 
                
                litaC_ast__TypeSpec* litaC_spec = litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind_PTR, litaC_token->pos, litaC_p->allocator);
                litaC_spec->base = litaC_base;
                return (litaC_ast__TypeSpec*)litaC_spec;
                
                
                
            }
            
            
        }
        case litaC_lex__TokenType_CONST: {
            {
                litaC_parser__Parser_advance(litaC_p);
                litaC_ast__TypeSpec* litaC_base = litaC_parser__Parser_type(litaC_p, litaC_disambiguate);
                if(!(litaC_base)) {
                    return NULL;
                    
                    
                } 
                
                litaC_ast__TypeSpec* litaC_spec = litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind_CONST, litaC_token->pos, litaC_p->allocator);
                litaC_spec->base = litaC_base;
                return (litaC_ast__TypeSpec*)litaC_spec;
                
                
                
            }
            
            
        }
        case litaC_lex__TokenType_IDENTIFIER: {
            {
                return (litaC_ast__TypeSpec*)litaC_parser__Parser_identifierType(litaC_p, litaC_disambiguate);
                
                
                
            }
            
            
        }
        case litaC_lex__TokenType_LEFT_BRACKET: {
            {
                litaC_ast__ArrayTypeSpec* litaC_spec = litaC_parser__Parser_arrayType(litaC_p);
                litaC_parser__Parser_advance(litaC_p);
                if(!(litaC_spec)) {
                    return NULL;
                    
                    
                } 
                
                litaC_spec->spec.base = litaC_parser__Parser_type(litaC_p, litaC_disambiguate);
                return (litaC_ast__TypeSpec*)litaC_spec;
                
                
                
            }
            
            
        }
        case litaC_lex__TokenType_FUNC: {
            {
                litaC_parser__Parser_advance(litaC_p);
                return (litaC_ast__TypeSpec*)litaC_parser__Parser_funcPtrType(litaC_p);
                
                
                
            }
            
            
        }
        default: {
            {
                litaC_parser__Parser_errorAtToken(litaC_p, litaC_token, litaC_error_codes__ErrorCode_UNEXPECTED_TOKEN);
                break;
                
                
            }
            
            
        }
    }
    return NULL;
    
    
}

litaC_ast__NameTypeSpec* litaC_parser__Parser_identifierType(litaC_parser__Parser* litaC_p,litaC_bool litaC_disambiguate) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_lex__Token litaC_name = litaC_parser__Parser_identifier(litaC_p);
    if(litaC_name.type != litaC_lex__TokenType_IDENTIFIER) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(litaC_symbols__MAX_SYMBOL_NAME, litaC_p->allocator);
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), litaC_name.value.str.buffer, litaC_name.value.str.length);
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COLON_COLON)) {
        {
            litaC_lex__Token litaC_identifier = litaC_parser__Parser_identifier(litaC_p);
            if(litaC_identifier.type != litaC_lex__TokenType_IDENTIFIER) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "::", 2);
            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), litaC_identifier.value.str.buffer, litaC_identifier.value.str.length);
            
            
        }
        
    } 
    
    litaC_ast__NameTypeSpec* litaC_spec = (litaC_ast__NameTypeSpec*)litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind_NAME, litaC_pos, litaC_p->allocator);
    litaC_spec->name = litaC_string_buffer__StringBuffer_cStr(&((litaC_sb)));
    if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_LESS_THAN)) {
        {
            litaC_spec->genericArgs = litaC_parser__Parser_tryGenericArguments(litaC_p, litaC_disambiguate);
            
            
        }
        
    } 
    
    return litaC_spec;
    
    err:;
    
    litaC_string_buffer__StringBuffer_free(&((litaC_sb)));
    return NULL;
    
    
}

litaC_ast__ArrayTypeSpec* litaC_parser__Parser_arrayType(litaC_parser__Parser* litaC_p) {
    litaC_ast__ArrayTypeSpec* litaC_spec = (litaC_ast__ArrayTypeSpec*)litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind_ARRAY, litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
    litaC_parser__Parser_advance(litaC_p);
    if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_BRACKET))) {
        {
            litaC_ast__Expr* litaC_expr = litaC_parser__Parser_expression(litaC_p);
            if(!(litaC_ast__Expr_isConstNumberExpr(litaC_expr))) {
                {
                    litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_peek(litaC_p), litaC_error_codes__ErrorCode_INVALID_ARRAY_DIMENSION_EXPR);
                    goto err;
                    
                    
                    
                }
                
            } else {
                {
                    litaC_spec->numElements = litaC_expr;
                    
                    
                }
            } 
            
            
            
        }
        
    } 
    
    return litaC_spec;
    
    err:;
    
    return NULL;
    
    
}

litaC_ast__FuncPtrTypeSpec* litaC_parser__Parser_funcPtrType(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_ast__FuncPtrTypeSpec* litaC_spec = (litaC_ast__FuncPtrTypeSpec*)litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind_FUNC_PTR, litaC_pos, litaC_p->allocator);
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LESS_THAN)) {
        {
            if(!(litaC_parser__Parser_genericParameters(litaC_p, &(litaC_spec->genericParams)))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_PAREN, litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_PAREN))) {
        {
            do {
                {
                    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_VAR_ARGS)) {
                        {
                            litaC_spec->hasVarargs = litaC_true;
                            if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_PAREN))) {
                                {
                                    litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_peek(litaC_p), litaC_error_codes__ErrorCode_INVALID_VARARG_POSITION);
                                    goto err;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_ast__TypeSpec* litaC_arg = litaC_parser__Parser_type(litaC_p, litaC_false);
                            if(!(litaC_arg)) {
                                {
                                    goto err;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_array__Array_add_cb__ptr_TypeSpec_ce_(&((litaC_spec->args)), litaC_arg);
                            
                            
                        }
                    } 
                    
                    
                    
                }
            }
            while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COMMA));
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_COLON, litaC_error_codes__ErrorCode_MISSING_COLON))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_spec->ret = litaC_parser__Parser_type(litaC_p, litaC_false);
    if(!(litaC_spec->ret)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_spec;
    
    err:;
    
    return NULL;
    
    
}

litaC_ast__ParametersStmt* litaC_parser__Parser_parametersStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_array__Array_cb__ptr_ParameterDecl_ce_ litaC_params =  {
        
    };
    litaC_bool litaC_isVarargs = litaC_false;
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_PAREN, litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_PAREN))) {
        {
            litaC_array__Array_init_cb__ptr_ParameterDecl_ce_(&((litaC_params)), 8, litaC_p->allocator);
            do {
                {
                    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_VAR_ARGS)) {
                        {
                            litaC_isVarargs = litaC_true;
                            if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_PAREN))) {
                                {
                                    litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_peek(litaC_p), litaC_error_codes__ErrorCode_INVALID_VARARG_POSITION);
                                    goto err;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_ast__ParameterDecl* litaC_param = litaC_parser__Parser_paramDeclaration(litaC_p);
                            if(!(litaC_param)) {
                                {
                                    goto err;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_array__Array_add_cb__ptr_ParameterDecl_ce_(&((litaC_params)), litaC_param);
                            
                            
                        }
                    } 
                    
                    
                    
                }
            }
            while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COMMA));
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return (litaC_ast__ParametersStmt*)litaC_ast_new__NewParametersStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_params, litaC_isVarargs, litaC_p->allocator);
    
    err:;
    
    return NULL;
    
    
}

litaC_bool litaC_parser__Parser_structArguments(litaC_parser__Parser* litaC_p,litaC_array__Array_cb__ptr_InitArgExpr_ce_* litaC_arguments) {
    litaC_array__Array_init_cb__ptr_InitArgExpr_ce_(litaC_arguments, 16, litaC_p->allocator);
    litaC_i32 litaC_argPosition = 0;
    do {
        {
            if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_BRACE)) {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
            litaC_lex__Token litaC_fieldName =  {
                .type = litaC_lex__TokenType_VOID
            };
            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_DOT)) {
                {
                    litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
                    if(!(litaC_identifier)) {
                        {
                            goto err;
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_fieldName = *(litaC_identifier);
                    if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_COLON)) {
                        {
                            litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_COLON, litaC_error_codes__ErrorCode_MISSING_COLON);
                            
                            
                        }
                        
                    } else {
                        if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_EQUALS)) {
                            {
                                litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_EQUALS, litaC_error_codes__ErrorCode_MISSING_EQUALS);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_peek(litaC_p), litaC_error_codes__ErrorCode_MISSING_COLON);
                                goto err;
                                
                                
                                
                            }
                        } 
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            litaC_ast__Expr* litaC_value = litaC_parser__Parser_expression(litaC_p);
            litaC_ast__InitArgExpr* litaC_arg = (litaC_ast__InitArgExpr*)litaC_ast_new__NewInitArgExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_fieldName, litaC_argPosition, litaC_value, litaC_p->allocator);
            litaC_array__Array_add_cb__ptr_InitArgExpr_ce_(litaC_arguments, litaC_arg);
            litaC_argPosition += 1;
            
            
        }
    }
    while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COMMA));
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_BRACE, litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACE))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    err:;
    
    return litaC_false;
    
    
}

litaC_bool litaC_parser__Parser_arguments(litaC_parser__Parser* litaC_p,litaC_array__Array_cb_CallArg_ce_* litaC_arguments) {
    if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_PAREN))) {
        {
            litaC_array__Array_init_cb_CallArg_ce_(litaC_arguments, 8, litaC_p->allocator);
            do {
                {
                    litaC_ast__CallArg litaC_arg =  {
                        
                    };
                    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_DOT)) {
                        {
                            litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
                            if(!(litaC_identifier)) {
                                {
                                    goto err;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_arg.argName = *(litaC_identifier);
                            if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_COLON)) {
                                {
                                    litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_COLON, litaC_error_codes__ErrorCode_MISSING_COLON);
                                    
                                    
                                }
                                
                            } else {
                                if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_EQUALS)) {
                                    {
                                        litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_EQUALS, litaC_error_codes__ErrorCode_MISSING_EQUALS);
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_peek(litaC_p), litaC_error_codes__ErrorCode_MISSING_COLON);
                                        goto err;
                                        
                                        
                                        
                                    }
                                } 
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_arg.argExpr = litaC_parser__Parser_expression(litaC_p);
                    litaC_array__Array_add_cb_CallArg_ce_(litaC_arguments, litaC_arg);
                    
                    
                }
            }
            while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COMMA));
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    err:;
    
    return litaC_false;
    
    
}

litaC_bool litaC_parser__Parser_genericParameters(litaC_parser__Parser* litaC_p,litaC_array__Array_cb_GenericParam_ce_* litaC_arguments) {
    if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_GREATER_THAN))) {
        {
            litaC_array__Array_init_cb_GenericParam_ce_(litaC_arguments, 2, litaC_p->allocator);
            do {
                {
                    litaC_lex__Token* litaC_typeName = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
                    if(!(litaC_typeName)) {
                        {
                            goto err;
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_array__Array_add_cb_GenericParam_ce_(litaC_arguments, (litaC_ast__GenericParam) {
                        .name = *(litaC_typeName)
                    });
                    
                    
                }
            }
            while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COMMA));
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_GREATER_THAN, litaC_error_codes__ErrorCode_MISSING_GENERIC_END))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    err:;
    
    return litaC_false;
    
    
}

litaC_array__Array_cb__ptr_TypeSpec_ce_ litaC_parser__Parser_genericArguments(litaC_parser__Parser* litaC_p) {
    litaC_array__Array_cb__ptr_TypeSpec_ce_ litaC_arguments =  {
        
    };
    if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_GREATER_THAN))) {
        {
            litaC_array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_arguments)), 2, litaC_p->allocator);
            do {
                {
                    litaC_ast__TypeSpec* litaC_type = litaC_parser__Parser_type(litaC_p, litaC_false);
                    if(!(litaC_type)) {
                        {
                            return litaC_arguments;
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_array__Array_add_cb__ptr_TypeSpec_ce_(&((litaC_arguments)), litaC_type);
                    
                    
                }
            }
            while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COMMA));
            
            
        }
        
    } 
    
    litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_GREATER_THAN, litaC_error_codes__ErrorCode_MISSING_GENERIC_END);
    return litaC_arguments;
    
    
}

litaC_array__Array_cb__ptr_TypeSpec_ce_ litaC_parser__Parser_tryGenericArguments(litaC_parser__Parser* litaC_p,litaC_bool litaC_disambiguate) {
    litaC_p->tryLevel += 1;
    
    litaC_i32 litaC_backtrack = litaC_p->current;
    litaC_u64 litaC_numOfErrors = litaC_p->tryErrorCounter;
    litaC_parser__Parser_advance(litaC_p);
    litaC_array__Array_cb__ptr_TypeSpec_ce_ litaC_arguments = litaC_parser__Parser_genericArguments(litaC_p);
    litaC_bool litaC_isFailed = litaC_false;
    if(litaC_p->tryErrorCounter == litaC_numOfErrors) {
        {
            if(litaC_disambiguate) {
                {
                    litaC_lex__Token* litaC_token = litaC_parser__Parser_peek(litaC_p);
                    switch(litaC_token->type) {
                        case litaC_lex__TokenType_LEFT_PAREN: 
                        case litaC_lex__TokenType_RIGHT_PAREN: 
                        case litaC_lex__TokenType_RIGHT_BRACKET: 
                        case litaC_lex__TokenType_LEFT_BRACE: 
                        case litaC_lex__TokenType_RIGHT_BRACE: 
                        case litaC_lex__TokenType_COLON: 
                        case litaC_lex__TokenType_SEMICOLON: 
                        case litaC_lex__TokenType_COMMA: 
                        case litaC_lex__TokenType_DOT: 
                        case litaC_lex__TokenType_QUESTION_MARK: 
                        case litaC_lex__TokenType_EQUALS_EQUALS: 
                        case litaC_lex__TokenType_NOT_EQUALS: 
                        case litaC_lex__TokenType_OR: 
                        case litaC_lex__TokenType_XOR: 
                        case litaC_lex__TokenType_STAR: {
                            {
                                litaC_array__Array_cb__ptr_TypeSpec_ce_ ___result = litaC_arguments;
                                litaC_p->tryLevel -= 1;
                                return ___result;
                                
                            }
                            
                            
                            
                        }
                        default: {
                            {
                                litaC_isFailed = litaC_true;
                                break;
                                
                                
                            }
                            
                            
                        }
                    }
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(litaC_p->tryErrorCounter > litaC_numOfErrors || litaC_isFailed) {
        {
            litaC_parser__Parser_rewindTo(litaC_p, litaC_backtrack, litaC_numOfErrors);
            litaC_isFailed = litaC_true;
            
            
        }
        
    } 
    
    if(litaC_isFailed) {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_arguments)));litaC_i += 1) {
                {
                    litaC_ast__TypeSpec* litaC_type = litaC_array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_arguments)), litaC_i);
                    litaC_mem__Allocator_free(litaC_p->allocator, litaC_type);
                    
                    
                }
            }
            litaC_array__Array_free_cb__ptr_TypeSpec_ce_(&((litaC_arguments)));
            litaC_array__Array_clear_cb__ptr_TypeSpec_ce_(&((litaC_arguments)));
            
            
        }
        
    } 
    
    {
        litaC_array__Array_cb__ptr_TypeSpec_ce_ ___result = litaC_arguments;
        litaC_p->tryLevel -= 1;
        return ___result;
        
    }
    
    litaC_p->tryLevel -= 1;
    
}

litaC_bool litaC_parser__Parser_arrayArguments(litaC_parser__Parser* litaC_p,litaC_array__Array_cb__ptr_Expr_ce_* litaC_arguments) {
    litaC_array__Array_init_cb__ptr_Expr_ce_(litaC_arguments, 16, litaC_p->allocator);
    do {
        {
            if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_BRACE)) {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_ast__Expr* litaC_expr = NULL;
            if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_LEFT_BRACKET)) {
                {
                    litaC_expr = litaC_parser__Parser_tryArrayDesignationExpr(litaC_p);
                    
                    
                }
                
            } 
            
            if(!(litaC_expr)) {
                {
                    litaC_expr = litaC_parser__Parser_expression(litaC_p);
                    
                    
                }
                
            } 
            
            litaC_array__Array_add_cb__ptr_Expr_ce_(litaC_arguments, litaC_expr);
            
            
        }
    }
    while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COMMA));
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_BRACE, litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACE))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    err:;
    
    return litaC_false;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_tryArrayDesignationExpr(litaC_parser__Parser* litaC_p) {
    litaC_p->tryLevel += 1;
    
    litaC_i32 litaC_backtrack = litaC_p->current;
    litaC_u64 litaC_numOfErrors = litaC_p->tryErrorCounter;
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_ast__Expr* litaC_designatorExpr = NULL;
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LEFT_BRACKET)) {
        {
            litaC_ast__Expr* litaC_index = litaC_parser__Parser_expression(litaC_p);
            litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_BRACKET, litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACKET);
            litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_EQUALS, litaC_error_codes__ErrorCode_MISSING_EQUALS);
            litaC_ast__Expr* litaC_value = litaC_parser__Parser_expression(litaC_p);
            if(litaC_p->tryErrorCounter == litaC_numOfErrors) {
                {
                    litaC_designatorExpr = litaC_ast_new__NewArrayDesignationExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_index, litaC_value, litaC_p->allocator);
                    
                    
                }
                
            } else {
                {
                    litaC_mem__Allocator_free(litaC_p->allocator, litaC_index);
                    litaC_mem__Allocator_free(litaC_p->allocator, litaC_value);
                    
                    
                }
            } 
            
            
            
        }
        
    } 
    
    if(litaC_p->tryErrorCounter > litaC_numOfErrors) {
        {
            litaC_parser__Parser_rewindTo(litaC_p, litaC_backtrack, litaC_numOfErrors);
            
            
        }
        
    } 
    
    {
        litaC_ast__Expr* ___result = litaC_designatorExpr;
        litaC_p->tryLevel -= 1;
        return ___result;
        
    }
    
    litaC_p->tryLevel -= 1;
    
}

litaC_ast__FieldStmt litaC_parser__Parser_fieldStatement(litaC_parser__Parser* litaC_p,litaC_ast__StmtKind litaC_aggKind) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_array__Array_cb__ptr_NoteStmt_ce_ litaC_notes =  {
        
    };
    if(!(litaC_parser__Parser_notes(litaC_p, &(litaC_notes)))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_bool litaC_isTrait = litaC_aggKind == litaC_ast__StmtKind_TRAIT_DECL;
    if(litaC_isTrait) {
        {
            litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
            if(!(litaC_identifier)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_lex__Token litaC_fieldName = *(litaC_identifier);
            if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_COLON, litaC_error_codes__ErrorCode_MISSING_COLON))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_ast__Attributes litaC_attributes =  {
                
            };
            litaC_attributes.notes = litaC_notes;
            litaC_ast__TypeSpec* litaC_type = litaC_parser__Parser_type(litaC_p, litaC_false);
            if(!(litaC_type)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            if(litaC_type->kind != litaC_ast__TypeSpecKind_FUNC_PTR) {
                {
                    litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_previous(litaC_p), litaC_error_codes__ErrorCode_INVALID_TRAIT_MEMBER);
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_ast__Stmt* litaC_traitField = litaC_ast_new__NewTraitFieldDecl(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_fieldName, litaC_type, litaC_attributes, litaC_p->allocator);
            return (litaC_ast__FieldStmt) {
                .kind = litaC_ast__StmtKind_TRAIT_FIELD_DECL,
                .traitField = (litaC_ast__TraitFieldDecl*)litaC_traitField
            };
            
            
            
        }
        
    } else {
        {
            litaC_bool litaC_isStruct = litaC_aggKind == litaC_ast__StmtKind_STRUCT_DECL;
            switch(litaC_parser__Parser_peek(litaC_p)->type) {
                case litaC_lex__TokenType_IDENTIFIER: {
                    {
                        litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
                        if(!(litaC_identifier)) {
                            {
                                goto err;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_lex__Token litaC_fieldName = *(litaC_identifier);
                        if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_COLON, litaC_error_codes__ErrorCode_MISSING_COLON))) {
                            {
                                goto err;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_ast__Attributes litaC_attributes =  {
                            
                        };
                        litaC_attributes.isUsing = litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_USING);
                        litaC_attributes.notes = litaC_notes;
                        litaC_ast__Expr* litaC_defaultExpr = NULL;
                        litaC_ast__TypeSpec* litaC_type = litaC_parser__Parser_type(litaC_p, litaC_false);
                        if(!(litaC_type)) {
                            {
                                goto err;
                                
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_EQUALS)) {
                            {
                                if(!(litaC_isStruct)) {
                                    {
                                        litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_previous(litaC_p), litaC_error_codes__ErrorCode_INVALID_DEFAULT_ASSIGNMENT);
                                        goto err;
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                litaC_defaultExpr = litaC_parser__Parser_constExpression(litaC_p);
                                
                                
                            }
                            
                        } 
                        
                        litaC_ast__Stmt* litaC_varField = litaC_ast_new__NewVarFieldDecl(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_fieldName, litaC_type, litaC_attributes, litaC_defaultExpr, litaC_p->allocator);
                        return (litaC_ast__FieldStmt) {
                            .kind = litaC_ast__StmtKind_VAR_FIELD_DECL,
                            .varField = (litaC_ast__VarFieldDecl*)litaC_varField
                        };
                        
                        
                        
                    }
                    
                    
                }
                case litaC_lex__TokenType_STRUCT: {
                    {
                        litaC_parser__Parser_advance(litaC_p);
                        litaC_ast__Decl* litaC_structField = litaC_parser__Parser_structDeclaration(litaC_p);
                        litaC_structField->stmt.node.startPos = litaC_pos;
                        litaC_structField->attributes.notes = litaC_notes;
                        return (litaC_ast__FieldStmt) {
                            .kind = litaC_ast__StmtKind_STRUCT_FIELD_DECL,
                            .aggregateField = (litaC_ast__AggregateDecl*)litaC_structField
                        };
                        
                        
                        
                    }
                    
                    
                }
                case litaC_lex__TokenType_UNION: {
                    {
                        litaC_parser__Parser_advance(litaC_p);
                        litaC_ast__Decl* litaC_unionField = litaC_parser__Parser_unionDeclaration(litaC_p);
                        litaC_unionField->stmt.node.startPos = litaC_pos;
                        litaC_unionField->attributes.notes = litaC_notes;
                        return (litaC_ast__FieldStmt) {
                            .kind = litaC_ast__StmtKind_UNION_FIELD_DECL,
                            .aggregateField = (litaC_ast__AggregateDecl*)litaC_unionField
                        };
                        
                        
                        
                    }
                    
                    
                }
                case litaC_lex__TokenType_ENUM: {
                    {
                        litaC_parser__Parser_advance(litaC_p);
                        litaC_ast__Decl* litaC_enumField = litaC_parser__Parser_enumDeclaration(litaC_p);
                        litaC_enumField->stmt.node.startPos = litaC_pos;
                        litaC_enumField->attributes.notes = litaC_notes;
                        return (litaC_ast__FieldStmt) {
                            .kind = litaC_ast__StmtKind_ENUM_FIELD_DECL,
                            .enumField = (litaC_ast__EnumDecl*)litaC_enumField
                        };
                        
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_peek(litaC_p), litaC_error_codes__ErrorCode_INVALID_FIELD);
                        litaC_parser__Parser_advance(litaC_p);
                        goto err;
                        
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    } 
    
    err:;
    
    return (litaC_ast__FieldStmt) {
        .kind = litaC_ast__StmtKind_POISON_EXPR
    };
    
    
}

litaC_ast__EnumFieldEntryDecl* litaC_parser__Parser_enumFieldEntryDecl(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_array__Array_cb__ptr_NoteStmt_ce_ litaC_notes =  {
        
    };
    if(!(litaC_parser__Parser_notes(litaC_p, &(litaC_notes)))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(!(litaC_identifier)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_lex__Token litaC_fieldName = *(litaC_identifier);
    litaC_ast__Expr* litaC_value = NULL;
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_EQUALS)) {
        {
            litaC_value = litaC_parser__Parser_constExpression(litaC_p);
            
            
        }
        
    } 
    
    litaC_ast__Attributes litaC_attributes =  {
        .notes = litaC_notes
    };
    return (litaC_ast__EnumFieldEntryDecl*)litaC_ast_new__NewEnumFieldEntryDecl(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_fieldName, litaC_value, litaC_attributes, litaC_p->allocator);
    
    err:;
    
    return NULL;
    
    
}

litaC_void litaC_parser__Parser_rewindTo(litaC_parser__Parser* litaC_p,litaC_i32 litaC_backtrack,litaC_u64 litaC_numOfErrors) {
    assert(litaC_p->tryErrorCounter >= litaC_numOfErrors);
    {
        litaC_p->current = litaC_backtrack;
        litaC_p->tryErrorCounter = litaC_numOfErrors;
        
        
    }
    
}

litaC_ast__Expr* litaC_parser__Parser_tryBitShiftRight(litaC_parser__Parser* litaC_p,litaC_ast__Expr* litaC_expr) {
    if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_GREATER_THAN))) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_lex__Token* litaC_prevToken = litaC_parser__Parser_advance(litaC_p);
    if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_GREATER_THAN))) {
        {
            litaC_parser__Parser_rewind(litaC_p);
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_lex__Token* litaC_nextToken = litaC_parser__Parser_advance(litaC_p);
    if((litaC_nextToken->pos.position - litaC_prevToken->pos.position) == 1) {
        {
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_term(litaC_p);
            return litaC_ast_new__NewBinaryExpr(litaC_expr->stmt.node.startPos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_lex__TokenType_RSHIFT, litaC_right, litaC_p->allocator);
            
            
            
        }
        
    } 
    
    litaC_parser__Parser_rewind(litaC_p);
    litaC_parser__Parser_rewind(litaC_p);
    return NULL;
    
    
}

litaC_void litaC_parser__Parser_eatSemicolon(litaC_parser__Parser* litaC_p) {
    litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_SEMICOLON);
    
}

litaC_lex__Token litaC_parser__Parser_identifier(litaC_parser__Parser* litaC_p) {
    litaC_lex__Token litaC_name =  {
        .type = litaC_lex__TokenType_ERROR
    };
    litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(litaC_identifier) {
        {
            litaC_name = *(litaC_identifier);
            
            
        }
        
    } 
    
    return litaC_name;
    
    
}

litaC_bool litaC_parser__Parser_checkConstExpr(litaC_parser__Parser* litaC_p,litaC_ast__Expr* litaC_expr) {
    if(!(litaC_expr)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_expr->stmt.node.kind) {
        case litaC_ast__StmtKind_NUMBER_EXPR: 
        case litaC_ast__StmtKind_BOOLEAN_EXPR: 
        case litaC_ast__StmtKind_STRING_EXPR: 
        case litaC_ast__StmtKind_CHAR_EXPR: 
        case litaC_ast__StmtKind_NULL_EXPR: 
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: 
        case litaC_ast__StmtKind_GET_EXPR: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GROUP_EXPR: {
            {
                litaC_ast__GroupExpr* litaC_groupExpr = (litaC_ast__GroupExpr*)litaC_expr;
                return litaC_parser__Parser_checkConstExpr(litaC_p, litaC_groupExpr->groupedExpr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BINARY_EXPR: {
            {
                litaC_ast__BinaryExpr* litaC_binExpr = (litaC_ast__BinaryExpr*)litaC_expr;
                return litaC_parser__Parser_checkConstExpr(litaC_p, litaC_binExpr->left) && litaC_parser__Parser_checkConstExpr(litaC_p, litaC_binExpr->right);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNARY_EXPR: {
            {
                litaC_ast__UnaryExpr* litaC_unaryExpr = (litaC_ast__UnaryExpr*)litaC_expr;
                return litaC_parser__Parser_checkConstExpr(litaC_p, litaC_unaryExpr->unaryExpr);
                
                
                
            }
            
            
        }
        default: {
            {
                litaC_parser__Parser_errorAtPos(litaC_p, litaC_expr->stmt.node.startPos, litaC_error_codes__ErrorCode_INVALID_CONST_EXPR);
                
                
            }
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_poisonStatement(litaC_parser__Parser* litaC_p,litaC_lex__SrcPos litaC_pos) {
    return (litaC_ast__Stmt*)litaC_ast_new__NewPoisonExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_poisonExpr(litaC_parser__Parser* litaC_p,litaC_lex__SrcPos litaC_pos) {
    return litaC_ast_new__NewPoisonExpr(litaC_parser__Parser_prevPos(litaC_p), litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
    
    
}

litaC_ast__Decl* litaC_parser__Parser_poisonDecl(litaC_parser__Parser* litaC_p,litaC_lex__SrcPos litaC_pos) {
    return litaC_ast_new__NewPoisonDecl(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
    
    
}

litaC_lex__SrcPos litaC_parser__Parser_pos(litaC_parser__Parser* litaC_p) {
    if(!(litaC_parser__Parser_atEnd(litaC_p))) {
        {
            return litaC_parser__Parser_peek(litaC_p)->pos;
            
            
            
        }
        
    } 
    
    if(litaC_array__Array_empty_cb_Token_ce_(&((litaC_p->tokens)))) {
        {
            return (litaC_lex__SrcPos) {
                
            };
            
            
            
        }
        
    } 
    
    return litaC_array__Array_last_cb_Token_ce_(&((litaC_p->tokens))).pos;
    
    
}

litaC_lex__SrcPos litaC_parser__Parser_prevPos(litaC_parser__Parser* litaC_p) {
    return litaC_parser__Parser_previous(litaC_p)->pos;
    
    
}

litaC_lex__Token* litaC_parser__Parser_peek(litaC_parser__Parser* litaC_p) {
    assert(litaC_p->current >= 0 && litaC_p->current <= litaC_array__Array_size_cb_Token_ce_(&((litaC_p->tokens))));
    if(litaC_p->current >= litaC_array__Array_size_cb_Token_ce_(&((litaC_p->tokens)))) {
        {
            return &(litaC_p->tokens.elements[litaC_array__Array_size_cb_Token_ce_(&((litaC_p->tokens))) - 1]);
            
            
            
        }
        
    } 
    
    return &(litaC_p->tokens.elements[litaC_p->current]);
    
    
}

litaC_void litaC_parser__Parser_rewind(litaC_parser__Parser* litaC_p) {
    litaC_p->current -= 1;
    if(litaC_p->current < 0) {
        {
            litaC_p->current = 0;
            
            
        }
        
    } 
    
    
}

litaC_lex__Token* litaC_parser__Parser_previous(litaC_parser__Parser* litaC_p) {
    litaC_i32 litaC_index = litaC_p->current - 1;
    assert(litaC_index < litaC_array__Array_size_cb_Token_ce_(&((litaC_p->tokens))) && litaC_index >= 0);
    return &(litaC_p->tokens.elements[litaC_index]);
    
    
}

litaC_bool litaC_parser__Parser_atEnd(litaC_parser__Parser* litaC_p) {
    if(litaC_p->current < litaC_array__Array_size_cb_Token_ce_(&((litaC_p->tokens))) - 1) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    assert(!(litaC_array__Array_empty_cb_Token_ce_(&((litaC_p->tokens)))));
    return litaC_p->current >= litaC_array__Array_size_cb_Token_ce_(&((litaC_p->tokens))) || litaC_parser__Parser_peek(litaC_p)->type == litaC_lex__TokenType_END_OF_FILE;
    
    
}

litaC_lex__Token* litaC_parser__Parser_advance(litaC_parser__Parser* litaC_p) {
    if(!(litaC_parser__Parser_atEnd(litaC_p))) {
        {
            litaC_p->current += 1;
            
            
        }
        
    } 
    
    return litaC_parser__Parser_previous(litaC_p);
    
    
}

LITAC_INLINE 
litaC_bool litaC_parser__Parser_check(litaC_parser__Parser* litaC_p,litaC_lex__TokenType litaC_type) {
    litaC_lex__Token* litaC_token = litaC_parser__Parser_peek(litaC_p);
    assert(litaC_token != NULL);
    return litaC_token->type == litaC_type;
    
    
}

litaC_bool litaC_parser__Parser_match(litaC_parser__Parser* litaC_p,litaC_lex__TokenType litaC_type) {
    if(litaC_parser__Parser_check(litaC_p, litaC_type)) {
        {
            litaC_parser__Parser_advance(litaC_p);
            return litaC_true;
            
            
            
        }
        
    } 
    
    return litaC_false;
    
    
}

litaC_bool litaC_parser__Parser_matches(litaC_parser__Parser* litaC_p,litaC_lex__TokenType* litaC_types,litaC_i32 litaC_len) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_len;litaC_i += 1) {
        {
            litaC_lex__TokenType litaC_type = litaC_types[litaC_i];
            if(litaC_parser__Parser_check(litaC_p, litaC_type)) {
                {
                    litaC_parser__Parser_advance(litaC_p);
                    return litaC_true;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_lex__Token* litaC_parser__Parser_consume(litaC_parser__Parser* litaC_p,litaC_lex__TokenType litaC_type,litaC_error_codes__ErrorCode litaC_errorCode) {
    if(litaC_parser__Parser_check(litaC_p, litaC_type)) {
        {
            return litaC_parser__Parser_advance(litaC_p);
            
            
            
        }
        
    } 
    
    litaC_parser__Parser_errorUnexpectedToken(litaC_p, litaC_parser__Parser_peek(litaC_p), litaC_errorCode);
    return NULL;
    
    
}

litaC_void litaC_parser__Parser_adjust(litaC_parser__Parser* litaC_p,litaC_lex__TokenType* litaC_types,litaC_i32 litaC_len) {
    litaC_p->panicMode = litaC_false;
    if(!(litaC_types) || litaC_len < 1) {
        {
            litaC_parser__Parser_advance(litaC_p);
            return;
            
            
            
        }
        
    } 
    
    while(!(litaC_parser__Parser_atEnd(litaC_p))) {
        {
            litaC_lex__TokenType litaC_type = litaC_parser__Parser_peek(litaC_p)->type;
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_len;litaC_i += 1) {
                {
                    if(litaC_types[litaC_i] == litaC_type) {
                        {
                            return;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            litaC_parser__Parser_advance(litaC_p);
            
            
        }
    }
    
}

litaC_void litaC_parser__Parser_errorAtToken(litaC_parser__Parser* litaC_p,litaC_lex__Token* litaC_token,litaC_error_codes__ErrorCode litaC_errorCode) {
    if(!(litaC_token)) {
        {
            litaC_parser__Parser_errorAtPos(litaC_p, litaC_parser__Parser_pos(litaC_p), litaC_errorCode);
            
            
        }
        
    } else {
        {
            litaC_parser__Parser_errorAtPos(litaC_p, litaC_token->pos, litaC_errorCode);
            
            
        }
    } 
    
    
}

litaC_void litaC_parser__Parser_errorAtPos(litaC_parser__Parser* litaC_p,litaC_lex__SrcPos litaC_pos,litaC_error_codes__ErrorCode litaC_errorCode) {
    
    if(litaC_p->tryLevel > 0) {
        {
            litaC_p->tryErrorCounter += 1;
            litaC_parser__Parser_advance(litaC_p);
            return;
            
            
            
        }
        
    } 
    
    if(litaC_p->panicMode) {
        {
            litaC_parser__Parser_advance(litaC_p);
            return;
            
            
            
        }
        
    } 
    
    litaC_p->panicMode = litaC_true;
    litaC_phase_result__PhaseResult_addError(litaC_p->result, litaC_pos, "%s", litaC_error_codes__errorCodeText[litaC_errorCode]);
    litaC_parser__Parser_advance(litaC_p);
    
}

litaC_void litaC_parser__Parser_errorUnexpectedToken(litaC_parser__Parser* litaC_p,litaC_lex__Token* litaC_token,litaC_error_codes__ErrorCode litaC_errorCode) {
    if(litaC_token) {
        {
            
            if(litaC_p->tryLevel > 0) {
                {
                    litaC_p->tryErrorCounter += 1;
                    litaC_parser__Parser_advance(litaC_p);
                    return;
                    
                    
                    
                }
                
            } 
            
            if(litaC_p->panicMode) {
                {
                    litaC_parser__Parser_advance(litaC_p);
                    return;
                    
                    
                    
                }
                
            } 
            
            litaC_p->panicMode = litaC_true;
            litaC_common__Error("Current index: %d out of %d\n", litaC_p->current, litaC_array__Array_size_cb_Token_ce_(&((litaC_p->tokens))));
            litaC_phase_result__PhaseResult_addError(litaC_p->result, litaC_parser__Parser_pos(litaC_p), "Unexpected token: '%s' - %s", litaC_lex__tokenText[litaC_token->type], litaC_error_codes__errorCodeText[litaC_errorCode]);
            litaC_parser__Parser_advance(litaC_p);
            
            
        }
        
    } else {
        {
            litaC_parser__Parser_errorAtPos(litaC_p, litaC_parser__Parser_pos(litaC_p), litaC_errorCode);
            
            
        }
    } 
    
    
}

litaC_i32 litaC_parser__Parser_numOfErrors(litaC_parser__Parser* litaC_p) {
    return litaC_array__Array_size_cb_PhaseError_ce_(&((litaC_p->result->errors)));
    
    
}

litaC_void litaC_instrument__Instrument(litaC_lita__Lita* litaC_lita,litaC_checker__TypeChecker* litaC_checker) {
    litaC_char litaC_filename[_MAX_PATH] =  {
        0
    };
    litaC_string_view__StringView litaC_moduleName = litaC_string_view__StringViewInit("profile", -(1));
    if(!(litaC_lita__FindModulePath(litaC_lita, litaC_moduleName, litaC_filename))) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_lita->result)), (litaC_lex__SrcPos) {
                
            }, "could not find module 'profile' on the system path.");
            return;
            
            
            
        }
        
    } 
    
    litaC_module__Module* litaC_module = litaC_map__Map_get_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_lita->modules)), litaC_filename);
    if(!(litaC_module)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(2048 * 2, litaC_lita->allocator);
    litaC_bool litaC_profileAll = litaC_true;
    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "@generated public enum ProfileTag {\n");
    litaC_i32 litaC_numOfProfiled = 0;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_checker->symbolFuncs)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_checker->symbolFuncs)), litaC_i);
            if(litaC_sym->declared == litaC_module) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_sym->flags & (litaC_symbols__SymbolFlags_IS_FOREIGN | litaC_symbols__SymbolFlags_IS_MAIN | litaC_symbols__SymbolFlags_IS_TEST)) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_ast__Decl_hasNote(litaC_sym->decl, "no_profile")) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_profileAll || litaC_ast__Decl_hasNote(litaC_sym->decl, "profile")) {
                {
                    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "    %.*s__%s,\n", litaC_sym->declared->id.name.length, litaC_sym->declared->id.name.buffer, litaC_sym->name);
                    litaC_numOfProfiled += 1;
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "    MAX_PROFILE_TAGS\n");
    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "\n}\n");
    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "@generated const profileEntries = [%d]ProfileEntry {\n", litaC_numOfProfiled);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_checker->symbolFuncs)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_checker->symbolFuncs)), litaC_i);
            if(litaC_sym->declared == litaC_module) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_sym->flags & (litaC_symbols__SymbolFlags_IS_FOREIGN | litaC_symbols__SymbolFlags_IS_MAIN | litaC_symbols__SymbolFlags_IS_TEST)) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_ast__Decl_hasNote(litaC_sym->decl, "no_profile")) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_profileAll || litaC_ast__Decl_hasNote(litaC_sym->decl, "profile")) {
                {
                    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "\n                ProfileEntry {\n                    .functionName = \"%.*s::%s\",\n                    .count = 0_u64,\n                    .startTime = 0_f64,\n                    .totalTime = 0_f64,\n                },\n            ", litaC_sym->declared->id.name.length, litaC_sym->declared->id.name.buffer, litaC_sym->name);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "\n}\n");
    litaC_parser__Parser litaC_parser = litaC_parser__ParserInit(litaC_module->id.filename, litaC_string_buffer__StringBuffer_cStr(&((litaC_sb))), litaC_lita);
    litaC_ast__ModuleStmt* litaC_stmts = litaC_parser__Parser_parseModule(&((litaC_parser)));
    if(litaC_stmts) {
        {
            litaC_checker__TypeChecker_enterModule(litaC_checker, litaC_module);
            
            {
                litaC_ast__Decl* litaC_tagDecl = litaC_array__Array_get_cb__ptr_Decl_ce_(&((litaC_stmts->declarations)), 0);
                assert(litaC_tagDecl->stmt.node.kind == litaC_ast__StmtKind_ENUM_DECL);
                litaC_symbols__Symbol* litaC_existingDecl = litaC_module__Module_getType(litaC_module, "ProfileTag");
                assert(litaC_existingDecl != NULL);
                litaC_tagDecl->sym = litaC_existingDecl;
                litaC_existingDecl->decl = litaC_tagDecl;
                
                
            }
            {
                litaC_ast__Decl* litaC_entriesDecl = litaC_array__Array_get_cb__ptr_Decl_ce_(&((litaC_stmts->declarations)), 1);
                assert(litaC_entriesDecl->stmt.node.kind == litaC_ast__StmtKind_CONST_DECL);
                litaC_symbols__Symbol* litaC_existingDecl = litaC_module__Module_getType(litaC_module, "profileEntries");
                assert(litaC_existingDecl != NULL);
                litaC_entriesDecl->sym = litaC_existingDecl;
                litaC_existingDecl->decl = litaC_entriesDecl;
                
                
            }
            litaC_checker__TypeChecker_leaveModule(litaC_checker);
            
            
        }
        
    } 
    
    litaC_sb = litaC_string_buffer__StringBufferInit(2048, litaC_lita->allocator);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_checker->symbolFuncs)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_checker->symbolFuncs)), litaC_i);
            if(litaC_sym->declared == litaC_module) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_sym->flags & (litaC_symbols__SymbolFlags_IS_FOREIGN | litaC_symbols__SymbolFlags_IS_MAIN | litaC_symbols__SymbolFlags_IS_TEST)) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_ast__Decl_hasNote(litaC_sym->decl, "no_profile")) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_profileAll || litaC_ast__Decl_hasNote(litaC_sym->decl, "profile")) {
                {
                    const litaC_char* litaC_alias = litaC_ast_copy__AstAddImport(litaC_lita, litaC_checker, litaC_sym->declared, litaC_module);
                    if(litaC_alias) {
                        {
                            litaC_string_buffer__StringBuffer_clear(&((litaC_sb)));
                            litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "defer %s::StopWatch(%s::ProfileTag.%.*s__%s)\n", litaC_alias, litaC_alias, litaC_sym->declared->id.name.length, litaC_sym->declared->id.name.buffer, litaC_sym->name);
                            litaC_ast_copy__AstInsertText(&((litaC_sym->decl->stmt.node)), litaC_string__StringCopy(litaC_string_buffer__StringBuffer_cStr(&((litaC_sb))), litaC_sb.length, litaC_lita->allocator), 0, litaC_lita);
                            litaC_string_buffer__StringBuffer_clear(&((litaC_sb)));
                            litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "%s::StartWatch(%s::ProfileTag.%.*s__%s)\n", litaC_alias, litaC_alias, litaC_sym->declared->id.name.length, litaC_sym->declared->id.name.buffer, litaC_sym->name);
                            litaC_ast_copy__AstInsertText(&((litaC_sym->decl->stmt.node)), litaC_string__StringCopy(litaC_string_buffer__StringBuffer_cStr(&((litaC_sb))), litaC_sb.length, litaC_lita->allocator), 0, litaC_lita);
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_string_buffer__StringBuffer_clear(&((litaC_sb)));
                            litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "defer StopWatch(ProfileTag.%.*s__%s)\n", litaC_sym->declared->id.name.length, litaC_sym->declared->id.name.buffer, litaC_sym->name);
                            litaC_ast_copy__AstInsertText(&((litaC_sym->decl->stmt.node)), litaC_string__StringCopy(litaC_string_buffer__StringBuffer_cStr(&((litaC_sb))), litaC_sb.length, litaC_lita->allocator), 0, litaC_lita);
                            litaC_string_buffer__StringBuffer_clear(&((litaC_sb)));
                            litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "StartWatch(ProfileTag.%.*s__%s)\n", litaC_sym->declared->id.name.length, litaC_sym->declared->id.name.buffer, litaC_sym->name);
                            litaC_ast_copy__AstInsertText(&((litaC_sym->decl->stmt.node)), litaC_string__StringCopy(litaC_string_buffer__StringBuffer_cStr(&((litaC_sb))), litaC_sb.length, litaC_lita->allocator), 0, litaC_lita);
                            
                            
                        }
                    } 
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    
}

litaC_array__Array_cb__ptr_Decl_ce_ litaC_traits__CreateTraitWrappers(litaC_checker__TypeChecker* litaC_checker) {
    litaC_array__Array_cb__ptr_Decl_ce_ litaC_decls = litaC_array__ArrayInit_cb__ptr_Decl_ce_(512, litaC_checker->lita->allocator);
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(2048, litaC_checker->lita->allocator);
    litaC_string_buffer__StringBuffer litaC_traitBuffer = litaC_string_buffer__StringBufferInit(litaC_symbols__MAX_SYMBOL_NAME, litaC_checker->lita->allocator);
    litaC_string_buffer__StringBuffer litaC_traitFieldBuffer = litaC_string_buffer__StringBufferInit(litaC_symbols__MAX_SYMBOL_NAME, litaC_checker->lita->allocator);
    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "// %d number of traits found.\n", litaC_map__Map_size_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_checker->interfaceImpls))));
    for(litaC_map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_ litaC_it = litaC_map__Map_iter_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_checker->interfaceImpls)));litaC_map__MapIterator_hasNext_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_it)));) {
        {
            litaC_map__MapEntry_cb_i64_c_Array_cb_i64_ce__ce_ litaC_entry = litaC_map__MapIterator_next_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_it)));
            litaC_symbols__Symbol* litaC_traitSym = litaC_traits__FindSymbolByTypeid(litaC_checker->symbolTypes, litaC_entry.key);
            assert(litaC_traitSym);
            assert(litaC_traitSym->decl && litaC_traitSym->decl->stmt.node.kind == litaC_ast__StmtKind_TRAIT_DECL);
            litaC_ast__AggregateDecl* litaC_traitDecl = (litaC_ast__AggregateDecl*)litaC_traitSym->decl;
            const litaC_char* litaC_traitName = litaC_traits__GetTraitName(litaC_traitSym, &((litaC_traitBuffer)));
            litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "// Trait: '%.*s' has %d impls\n", litaC_traitDecl->decl.declaration.name.value.str.length, litaC_traitDecl->decl.declaration.name.value.str.buffer, litaC_array__Array_size_cb_i64_ce_(&((litaC_entry.value))));
            {
                litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "struct %s__VirtualTable", litaC_traitName);
                litaC_string_buffer__StringBuffer_append(&((litaC_sb)), " {\n");
                for(litaC_i32 litaC_j = 0;litaC_j < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_traitDecl->fields)));litaC_j += 1) {
                    {
                        litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_traitDecl->fields)), litaC_j);
                        assert(litaC_field.kind == litaC_ast__StmtKind_TRAIT_FIELD_DECL);
                        assert(litaC_field.typeInfo != NULL && litaC_field.typeInfo->kind == litaC_types__TypeKind_FUNC_PTR);
                        litaC_types__FuncPtrTypeInfo* litaC_fn = (litaC_types__FuncPtrTypeInfo*)litaC_field.typeInfo;
                        litaC_ast__TraitFieldDecl* litaC_traitField = litaC_field.traitField;
                        litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "    %s: func", litaC_lex__Token_asString(&((litaC_traitField->decl.name))));
                        litaC_traits__PrintGenerics(&((litaC_fn->genericParams)), &((litaC_sb)));
                        litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "(*void");
                        for(litaC_i32 litaC_p = 0;litaC_p < litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_fn->paramDecls)));litaC_p += 1) {
                            {
                                litaC_types__TypeInfo* litaC_param = litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_fn->paramDecls)), litaC_p);
                                litaC_string_buffer__StringBuffer_append(&((litaC_sb)), ", ");
                                litaC_types__TypeInfo_toString(litaC_param, &((litaC_sb)));
                                
                                
                            }
                        }
                        litaC_string_buffer__StringBuffer_append(&((litaC_sb)), ") : ");
                        litaC_types__TypeInfo_toString(litaC_fn->returnType, &((litaC_sb)));
                        litaC_string_buffer__StringBuffer_append(&((litaC_sb)), ";\n");
                        
                        
                    }
                }
                litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "}\n");
                
                
            }
            {
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_i64_ce_(&((litaC_entry.value)));litaC_i += 1) {
                    {
                        litaC_symbols__Symbol* litaC_implSym = litaC_traits__FindSymbolByTypeid(litaC_checker->symbolTypes, litaC_array__Array_get_cb_i64_ce_(&((litaC_entry.value)), litaC_i));
                        assert(litaC_implSym);
                        const litaC_char* litaC_implEscapedName = litaC_traits__GetTraitName(litaC_implSym, &((litaC_traitFieldBuffer)));
                        litaC_char* litaC_implName = litaC_implSym->name;
                        if(litaC_implSym->flags & litaC_symbols__SymbolFlags_IS_FROM_GENERIC_TEMPLATE) {
                            {
                                litaC_i64 litaC_genericTypeid = ((litaC_types__GenericTypeInfo*)litaC_implSym->type)->genericTypeid;
                                litaC_symbols__Symbol* litaC_genSym = litaC_traits__FindSymbolByTypeid(litaC_checker->symbolTypes, litaC_genericTypeid);
                                litaC_implName = litaC_genSym->name;
                                
                                
                            }
                            
                        } 
                        
                        for(litaC_i32 litaC_j = 0;litaC_j < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_traitDecl->fields)));litaC_j += 1) {
                            {
                                litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_traitDecl->fields)), litaC_j);
                                assert(litaC_field.kind == litaC_ast__StmtKind_TRAIT_FIELD_DECL);
                                assert(litaC_field.typeInfo && litaC_field.typeInfo->kind == litaC_types__TypeKind_FUNC_PTR);
                                litaC_types__FuncPtrTypeInfo* litaC_fn = (litaC_types__FuncPtrTypeInfo*)litaC_field.typeInfo;
                                litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "func __%s_%s_wrapper", litaC_implEscapedName, litaC_lex__Token_asString(&((litaC_field.traitField->decl.name))));
                                litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "(this: *void");
                                for(litaC_i32 litaC_p = 0;litaC_p < litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_fn->paramDecls)));litaC_p += 1) {
                                    {
                                        litaC_types__TypeInfo* litaC_param = litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_fn->paramDecls)), litaC_p);
                                        litaC_string_buffer__StringBuffer_append(&((litaC_sb)), ", _%d: ", litaC_p);
                                        litaC_types__TypeInfo_toString(litaC_param, &((litaC_sb)));
                                        
                                        
                                    }
                                }
                                if(litaC_fn->hasVarargs) {
                                    {
                                        litaC_string_buffer__StringBuffer_append(&((litaC_sb)), ", ...");
                                        
                                        
                                    }
                                    
                                } 
                                
                                litaC_string_buffer__StringBuffer_append(&((litaC_sb)), ") : ");
                                litaC_types__TypeInfo_toString(litaC_fn->returnType, &((litaC_sb)));
                                litaC_string_buffer__StringBuffer_append(&((litaC_sb)), " {\n");
                                {
                                    litaC_string_view__StringView litaC_moduleName = litaC_implSym->declared->id.name;
                                    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "    var __this = this as (*%.*s::%s", litaC_moduleName.length, litaC_moduleName.buffer, litaC_implName);
                                    litaC_traits__PrintGenericArgs(&((litaC_implSym->genericArgs)), &((litaC_sb)));
                                    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), ")\n");
                                    if(litaC_fn->returnType->kind != litaC_types__TypeKind_VOID) {
                                        {
                                            litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "    return ");
                                            
                                            
                                        }
                                        
                                    } else {
                                        {
                                            litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "    ");
                                            
                                            
                                        }
                                    } 
                                    
                                    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "__this.%s", litaC_lex__Token_asString(&((litaC_field.traitField->decl.name))));
                                    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "(");
                                    for(litaC_i32 litaC_p = 0;litaC_p < litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_fn->paramDecls)));litaC_p += 1) {
                                        {
                                            litaC_types__TypeInfo* litaC_param = litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_fn->paramDecls)), litaC_p);
                                            if(litaC_p > 0) {
                                                {
                                                    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), ", ");
                                                    
                                                    
                                                }
                                                
                                            } 
                                            
                                            litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "_%d", litaC_p);
                                            
                                            
                                        }
                                    }
                                    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), ")");
                                    
                                    
                                }
                                litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "\n}\n");
                                
                                
                            }
                        }
                        
                        
                    }
                }
                
                
            }
            {
                litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "const %s__vtables = []*%s__VirtualTable {\n", litaC_traitName, litaC_traitName);
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_i64_ce_(&((litaC_entry.value)));litaC_i += 1) {
                    {
                        litaC_symbols__Symbol* litaC_implSym = litaC_traits__FindSymbolByTypeid(litaC_checker->symbolTypes, litaC_array__Array_get_cb_i64_ce_(&((litaC_entry.value)), litaC_i));
                        assert(litaC_implSym);
                        const litaC_char* litaC_implEscapedName = litaC_traits__GetTraitName(litaC_implSym, &((litaC_traitFieldBuffer)));
                        litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "    [%d] = &%s__VirtualTable {\n", litaC_i, litaC_traitName);
                        {
                            for(litaC_i32 litaC_j = 0;litaC_j < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_traitDecl->fields)));litaC_j += 1) {
                                {
                                    litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_traitDecl->fields)), litaC_j);
                                    assert(litaC_field.kind == litaC_ast__StmtKind_TRAIT_FIELD_DECL);
                                    const litaC_char* litaC_fieldName = litaC_lex__Token_asString(&((litaC_field.traitField->decl.name)));
                                    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "        .%s = __%s_%s_wrapper", litaC_fieldName, litaC_implEscapedName, litaC_fieldName);
                                    litaC_string_buffer__StringBuffer_append(&((litaC_sb)), ",\n");
                                    
                                    
                                }
                            }
                            
                            
                        }
                        litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "    },\n");
                        
                        
                    }
                }
                litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "}\n");
                
                
            }
            
            
        }
    }
    {
        litaC_parser__Parser litaC_parser = litaC_parser__ParserInit("generated", litaC_string_buffer__StringBuffer_cStr(&((litaC_sb))), litaC_checker->lita);
        litaC_ast__ModuleStmt* litaC_stmts = litaC_parser__Parser_parseModule(&((litaC_parser)));
        litaC_array__Array_addAll_cb__ptr_Decl_ce_(&((litaC_decls)), &((litaC_stmts->declarations)));
        
        
    }
    return litaC_decls;
    
    
}

litaC_void litaC_traits__PrintGenerics(litaC_array__Array_cb_GenericParam_ce_* litaC_genericParams,litaC_string_buffer__StringBuffer* litaC_sb) {
    for(litaC_i32 litaC_x = 0;litaC_x < litaC_array__Array_size_cb_GenericParam_ce_(litaC_genericParams);litaC_x += 1) {
        {
            if(litaC_x == 0) {
                {
                    litaC_string_buffer__StringBuffer_append(litaC_sb, "<");
                    
                    
                }
                
            } 
            
            if(litaC_x > 0) {
                {
                    litaC_string_buffer__StringBuffer_append(litaC_sb, ", ");
                    
                    
                }
                
            } 
            
            litaC_lex__Token litaC_name = litaC_array__Array_get_cb_GenericParam_ce_(litaC_genericParams, litaC_x).name;
            litaC_string_buffer__StringBuffer_append(litaC_sb, "%s", litaC_lex__Token_asString(&((litaC_name))));
            
            
        }
    }
    if(litaC_array__Array_size_cb_GenericParam_ce_(litaC_genericParams) > 0) {
        {
            litaC_string_buffer__StringBuffer_append(litaC_sb, ">");
            
            
        }
        
    } 
    
    
}

litaC_void litaC_traits__PrintGenericArgs(litaC_array__Array_cb__ptr_TypeInfo_ce_* litaC_genericArgs,litaC_string_buffer__StringBuffer* litaC_sb) {
    for(litaC_i32 litaC_x = 0;litaC_x < litaC_array__Array_size_cb__ptr_TypeInfo_ce_(litaC_genericArgs);litaC_x += 1) {
        {
            if(litaC_x == 0) {
                {
                    litaC_string_buffer__StringBuffer_append(litaC_sb, "<");
                    
                    
                }
                
            } 
            
            if(litaC_x > 0) {
                {
                    litaC_string_buffer__StringBuffer_append(litaC_sb, ", ");
                    
                    
                }
                
            } 
            
            litaC_types__TypeInfo* litaC_type = litaC_array__Array_get_cb__ptr_TypeInfo_ce_(litaC_genericArgs, litaC_x);
            assert(litaC_type);
            litaC_types__TypeInfo_toString(litaC_type, litaC_sb);
            
            
        }
    }
    if(litaC_array__Array_size_cb__ptr_TypeInfo_ce_(litaC_genericArgs) > 0) {
        {
            litaC_string_buffer__StringBuffer_append(litaC_sb, ">");
            
            
        }
        
    } 
    
    
}

litaC_symbols__Symbol* litaC_traits__FindSymbolByTypeid(litaC_array__Array_cb__ptr_Symbol_ce_ litaC_symbols,litaC_i64 litaC_id) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_symbols)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_symbols)), litaC_i);
            if(litaC_sym->type && litaC_sym->type->typeid == litaC_id) {
                {
                    return litaC_sym;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return NULL;
    
    
}

const litaC_char* litaC_traits__GetTraitName(litaC_symbols__Symbol* litaC_traitSym,litaC_string_buffer__StringBuffer* litaC_sb) {
    if(!((litaC_traitSym->flags & litaC_symbols__SymbolFlags_IS_FROM_GENERIC_TEMPLATE))) {
        {
            return litaC_traitSym->name;
            
            
            
        }
        
    } 
    
    litaC_string_buffer__StringBuffer_clear(litaC_sb);
    return litaC_common__EscapeName(litaC_traitSym->name, litaC_sb);
    
    
}

litaC_void litaC_traits__Parse(litaC_string_buffer__StringBuffer* litaC_sb,litaC_checker__TypeChecker* litaC_checker,litaC_array__Array_cb__ptr_Decl_ce_* litaC_decls) {
    litaC_parser__Parser litaC_parser = litaC_parser__ParserInit("generated", litaC_string_buffer__StringBuffer_cStr(litaC_sb), litaC_checker->lita);
    litaC_ast__ModuleStmt* litaC_stmts = litaC_parser__Parser_parseModule(&((litaC_parser)));
    litaC_array__Array_addAll_cb__ptr_Decl_ce_(litaC_decls, &((litaC_stmts->declarations)));
    
}

litaC_void litaC_cgen__CGen_init(litaC_cgen__CGen* litaC_this,litaC_lita__Lita* litaC_lita,FILE* litaC_output) {
    litaC_this->lita = litaC_lita;
    litaC_string_buffer__StringBuffer_init(&((litaC_this->buf)), 1024 * 2, litaC_lita->allocator);
    litaC_string_buffer__StringBuffer_init(&((litaC_this->line)), 1024 * 2, litaC_lita->allocator);
    litaC_this->aggregateLevel = 0;
    litaC_this->currentFunc = NULL;
    litaC_this->currentScope = NULL;
    litaC_this->bufferFlush = litaC_false;
    litaC_this->format = litaC_lita->options->cFormat;
    litaC_this->output = litaC_output;
    
}

litaC_void litaC_cgen__CGen_emitProgram(litaC_cgen__CGen* litaC_this,litaC_module__Module* litaC_module) {
    assert(litaC_module != NULL);
    assert(litaC_module->ast != NULL);
    litaC_this->bufferFlush = litaC_true;
    litaC_string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), "#ifndef _LITAC_HEADER_H\n");
    litaC_string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), "#define _LITAC_HEADER_H\n");
    litaC_cgen__CGen_emitForward(litaC_this);
    litaC_cgen__CGen_emitPrimitiveConstDecls(litaC_this);
    litaC_cgen__CGen_emitModuleNotes(litaC_this);
    litaC_cgen__CGen_emitForwardDecls(litaC_this);
    litaC_cgen__CGen_emitTraitForwardDecls(litaC_this);
    litaC_string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), "\n#endif /* _LITAC_HEADER_H */\n");
    litaC_string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), "\n\n");
    litaC_string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), "// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    litaC_string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), "// translated code begins\n");
    litaC_string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), "// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    litaC_string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), "\n\n");
    litaC_this->bufferFlush = litaC_false;
    litaC_dependency_graph__DependencyGraph litaC_graph =  {
        
    };
    litaC_dependency_graph__DependencyGraph_init(&((litaC_graph)), litaC_this->lita);
    litaC_array__Array_cb__ptr_Symbol_ce_ litaC_declarations = litaC_dependency_graph__DependencyGraph_sort(&((litaC_graph)));
    litaC_bool litaC_isTesting = litaC_this->lita->options->testsOnly;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_declarations)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_declarations)), litaC_i);
            assert(litaC_sym->decl);
            if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_EMITTED) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_FOREIGN) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_sym == litaC_this->lita->programSymbols.mainEntry) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(!(litaC_isTesting) && litaC_sym->flags & litaC_symbols__SymbolFlags_IS_TEST) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_sym->decl->stmt)));
            litaC_cgen__CGen_emitln(litaC_this);
            litaC_cgen__CGen_flush(litaC_this);
            
            
        }
    }
    litaC_cgen__CGen_emitTraitDecls(litaC_this);
    litaC_cgen__CGen_emitln(litaC_this);
    if(litaC_this->lita->programSymbols.mainEntry) {
        {
            litaC_cgen__CGen_emitMain(litaC_this, litaC_this->lita->programSymbols.mainEntry);
            
            
        }
        
    } 
    
    litaC_cgen__CGen_flush(litaC_this);
    
}

litaC_void litaC_cgen__CGen_emitMain(litaC_cgen__CGen* litaC_this,litaC_symbols__Symbol* litaC_sym) {
    litaC_ast__FuncDecl* litaC_decl = (litaC_ast__FuncDecl*)litaC_sym->decl;
    litaC_cgen_decl__CGen_emitFuncDeclSignature(litaC_this, litaC_decl, "main");
    litaC_this->currentFunc = (litaC_types__FuncTypeInfo*)litaC_sym->type;
    
    litaC_cgen__CGen_emitStrn(litaC_this, " {", 2);
    litaC_this->funcIndex = litaC_this->buf.length;
    litaC_cgen__CGen_emitStmt(litaC_this, litaC_decl->body);
    litaC_cgen__CGen_emitStrn(litaC_this, "}", 1);
    litaC_this->currentFunc = NULL;
    
}

litaC_void litaC_cgen__CGen_emitForward(litaC_cgen__CGen* litaC_this) {
    litaC_string_buffer__StringBuffer_append(&((litaC_this->buf)), "\n// Generated on %s\n#include <stdint.h>\n#include <stddef.h>\ntypedef int8_t    %s%s;\ntypedef int16_t   %s%s;\ntypedef int32_t   %s%s;\ntypedef int64_t   %s%s;\ntypedef uint8_t   %s%s;\ntypedef uint16_t  %s%s;\ntypedef uint32_t  %s%s;\ntypedef uint64_t  %s%s;\ntypedef float     %s%s;\ntypedef double    %s%s;\n//typedef int8_t    %s%s;\ntypedef size_t    %s%s;\n\n#if _MSC_VER\n#define LITAC_THREADLOCAL __declspec(thread)\n#define LITAC_INLINE static inline __forceinline\n#define LITAC_NOINLINE __declspec(noinline)\n#define LITAC_PACKED __pragma(pack(push, 1))\n#define LITAC_PACKED_POP __pragma(pack(pop))\n#define LITAC_EXPORT __declspec(dllexport)\n#endif\n\n#if __GNUC__\n#define LITAC_THREADLOCAL __thread\n#define LITAC_INLINE static inline __attribute__((always_inline))\n#define LITAC_NOINLINE __attribute__((noinline))\n#define LITAC_PACKED __attribute__((packed))\n#define LITAC_PACKED_POP\n#define LITAC_EXPORT __attribute__((visibility(\"default\")))\n#endif\n\n#if __TINYC__\n#define LITAC_THREADLOCAL\n#define LITAC_INLINE\n#define LITAC_NOINLINE\n#define LITAC_PACKED __attribute__((packed))\n#define LITAC_PACKED_POP\n#define LITAC_EXPORT __attribute__((dllexport))\n#endif\n\n", litaC_system__CurrentDateTime(), litaC_this->lita->options->cPrefix, "i8", litaC_this->lita->options->cPrefix, "i16", litaC_this->lita->options->cPrefix, "i32", litaC_this->lita->options->cPrefix, "i64", litaC_this->lita->options->cPrefix, "u8", litaC_this->lita->options->cPrefix, "u16", litaC_this->lita->options->cPrefix, "u32", litaC_this->lita->options->cPrefix, "u64", litaC_this->lita->options->cPrefix, "f32", litaC_this->lita->options->cPrefix, "f64", litaC_this->lita->options->cPrefix, "bool", litaC_this->lita->options->cPrefix, "usize");
    if(strlen(litaC_this->lita->options->cPrefix) > 0) {
        {
            litaC_string_buffer__StringBuffer_append(&((litaC_this->buf)), "typedef int8_t %s%s;\n", litaC_this->lita->options->cPrefix, "bool");
            litaC_string_buffer__StringBuffer_append(&((litaC_this->buf)), "#define %s%s (1)\n", litaC_this->lita->options->cPrefix, "true");
            litaC_string_buffer__StringBuffer_append(&((litaC_this->buf)), "#define %s%s (0)\n", litaC_this->lita->options->cPrefix, "false");
            litaC_string_buffer__StringBuffer_append(&((litaC_this->buf)), "#define %s%s void\n", litaC_this->lita->options->cPrefix, "void");
            litaC_string_buffer__StringBuffer_append(&((litaC_this->buf)), "typedef char   %s%s;\n", litaC_this->lita->options->cPrefix, "char");
            
            
        }
        
    } else {
        {
            litaC_string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), "\n// Boolean type\n#if defined(__STDC__) && __STDC_VERSION__ >= 199901L\n    #include <stdbool.h>\n#elif !defined(__cplusplus) && !defined(bool)\n    typedef enum { false, true } bool;\n#endif\n        ");
            
            
        }
    } 
    
    
}

litaC_void litaC_cgen__CGen_emitPrimitiveConstDecls(litaC_cgen__CGen* litaC_this) {
    litaC_symbols__ProgramSymbols* litaC_program = &(litaC_this->lita->programSymbols);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_program->values)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_program->values)), litaC_i);
            if(!((litaC_sym->flags & litaC_symbols__SymbolFlags_IS_CONSTANT))) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_FOREIGN) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(!(litaC_types__IsPrimitive(litaC_sym->type))) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            litaC_cgen_decl__CGen_emitVarDecl(litaC_this, (litaC_ast__VarDecl*)litaC_sym->decl);
            litaC_cgen__CGen_emitln(litaC_this);
            
            
        }
    }
    
}

litaC_void litaC_cgen__CGen_emitModuleNotes(litaC_cgen__CGen* litaC_this) {
    for(litaC_map__MapIterator_cb__ptr_const_char_c__ptr_Module_ce_ litaC_it = litaC_map__Map_iter_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_this->lita->modules)));litaC_map__MapIterator_hasNext_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_it)));) {
        {
            litaC_map__MapEntry_cb__ptr_const_char_c__ptr_Module_ce_ litaC_m = litaC_map__MapIterator_next_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_it)));
            litaC_module__Module* litaC_module = litaC_m.value;
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_module->ast->notes)));litaC_i += 1) {
                {
                    litaC_ast__NoteStmt* litaC_note = litaC_array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_module->ast->notes)), litaC_i);
                    litaC_cgen__CGen_emitPreludeNote(litaC_this, litaC_note);
                    litaC_cgen__CGen_emitStrn(litaC_this, "\n", 1);
                    
                    
                }
            }
            
            
        }
    }
    
}

litaC_symbols__Symbol* litaC_cgen__CGen_findSymbolByTypeid(litaC_cgen__CGen* litaC_this,litaC_i64 litaC_id) {
    litaC_array__Array_cb__ptr_Symbol_ce_ litaC_symbols = litaC_this->lita->programSymbols.symbolTypes;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_symbols)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_symbols)), litaC_i);
            if(litaC_sym->type && litaC_sym->type->typeid == litaC_id) {
                {
                    return litaC_sym;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return NULL;
    
    
}

litaC_void litaC_cgen__CGen_emitTraitForwardDecls(litaC_cgen__CGen* litaC_this) {
    litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_ litaC_interfaceImpls = litaC_this->lita->programSymbols.interfaceImpls;
    litaC_cgen__CGen_emit(litaC_this, "\n\n// Generated code for interfaces\n");
    for(litaC_map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_ litaC_it = litaC_map__Map_iter_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_interfaceImpls)));litaC_map__MapIterator_hasNext_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_it)));) {
        {
            litaC_map__MapEntry_cb_i64_c_Array_cb_i64_ce__ce_ litaC_entry = litaC_map__MapIterator_next_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_it)));
            litaC_symbols__Symbol* litaC_traitSym = litaC_cgen__CGen_findSymbolByTypeid(litaC_this, litaC_entry.key);
            assert(litaC_traitSym);
            assert(litaC_traitSym->decl && litaC_traitSym->decl->stmt.node.kind == litaC_ast__StmtKind_TRAIT_DECL);
            litaC_ast__AggregateDecl* litaC_traitDecl = (litaC_ast__AggregateDecl*)litaC_traitSym->decl;
            const litaC_char* litaC_traitName = litaC_cgen__CGen_cTypeName(litaC_this, litaC_traitSym->type);
            litaC_cgen__CGen_emit(litaC_this, "// Generated code %s\n", litaC_traitName);
            {
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_i64_ce_(&((litaC_entry.value)));litaC_i += 1) {
                    {
                        litaC_symbols__Symbol* litaC_implSym = litaC_cgen__CGen_findSymbolByTypeid(litaC_this, litaC_array__Array_get_cb_i64_ce_(&((litaC_entry.value)), litaC_i));
                        assert(litaC_implSym);
                        const litaC_char* litaC_implName = litaC_cgen__CGen_cTypeName(litaC_this, litaC_implSym->type);
                        litaC_cgen__CGen_emit(litaC_this, "%s %s__to__%s(%s* x);\n", litaC_traitName, litaC_implName, litaC_traitName, litaC_implName);
                        
                        
                    }
                }
                
                
            }
            litaC_cgen__CGen_emitStrn(litaC_this, "\n", 1);
            
            
        }
    }
    
}

litaC_void litaC_cgen__CGen_emitTraitDecls(litaC_cgen__CGen* litaC_this) {
    litaC_module__Module* litaC_root = litaC_this->lita->programSymbols.root;
    assert(litaC_root != NULL);
    litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_ litaC_interfaceImpls = litaC_this->lita->programSymbols.interfaceImpls;
    for(litaC_map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_ litaC_it = litaC_map__Map_iter_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_interfaceImpls)));litaC_map__MapIterator_hasNext_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_it)));) {
        {
            litaC_map__MapEntry_cb_i64_c_Array_cb_i64_ce__ce_ litaC_entry = litaC_map__MapIterator_next_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_it)));
            litaC_symbols__Symbol* litaC_traitSym = litaC_cgen__CGen_findSymbolByTypeid(litaC_this, litaC_entry.key);
            assert(litaC_traitSym);
            assert(litaC_traitSym->decl && litaC_traitSym->decl->stmt.node.kind == litaC_ast__StmtKind_TRAIT_DECL);
            litaC_ast__AggregateDecl* litaC_traitDecl = (litaC_ast__AggregateDecl*)litaC_traitSym->decl;
            const litaC_char* litaC_traitName = litaC_cgen__CGen_cTypeName(litaC_this, litaC_traitSym->type);
            litaC_char litaC_vtableName[256] =  {
                
            };
            litaC_string__String litaC_vtableNameStr = litaC_string__StringInit(litaC_vtableName, litaC_symbols__MAX_SYMBOL_NAME, -(1));
            litaC_string__String_format(&((litaC_vtableNameStr)), "%s%.*s__%s", litaC_this->lita->options->cPrefix, litaC_root->id.name.length, litaC_root->id.name.buffer, litaC_cgen__CGen_escapeNameStr(litaC_this, litaC_traitSym->name));
            {
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_i64_ce_(&((litaC_entry.value)));litaC_i += 1) {
                    {
                        litaC_symbols__Symbol* litaC_implSym = litaC_cgen__CGen_findSymbolByTypeid(litaC_this, litaC_array__Array_get_cb_i64_ce_(&((litaC_entry.value)), litaC_i));
                        assert(litaC_implSym);
                        const litaC_char* litaC_implName = litaC_cgen__CGen_cTypeName(litaC_this, litaC_implSym->type);
                        litaC_cgen__CGen_emit(litaC_this, "%s %s__to__%s(%s* x) {", litaC_traitName, litaC_implName, litaC_traitName, litaC_implName);
                        litaC_cgen__CGen_emit(litaC_this, "return (%s) {", litaC_traitName);
                        litaC_cgen__CGen_emit(litaC_this, ".__vtable = %s__vtables[%d],\n", litaC_string__String_cStr(litaC_vtableNameStr), litaC_i);
                        litaC_cgen__CGen_emit(litaC_this, ".__this = x");
                        litaC_cgen__CGen_emitStrn(litaC_this, "}", 1);
                        litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                        litaC_cgen__CGen_emitStrn(litaC_this, "}\n", 2);
                        
                        
                    }
                }
                
                
            }
            
            
        }
    }
    
}

litaC_bool litaC_cgen__CGen_emitTraitCast(litaC_cgen__CGen* litaC_this,litaC_ast__Expr* litaC_expr) {
    if(!(litaC_expr)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_types__IsTraitLike(litaC_expr->expectedType)) {
        {
            if(litaC_expr->operand.typeInfo != NULL && !(litaC_types__IsTraitLike(litaC_expr->operand.typeInfo))) {
                {
                    const litaC_char* litaC_traitName = litaC_cgen__CGen_cTypeName(litaC_this, litaC_types__TypeInfo_getBaseType(litaC_expr->expectedType));
                    const litaC_char* litaC_implName = litaC_cgen__CGen_cTypeName(litaC_this, litaC_types__TypeInfo_getBaseType(litaC_expr->operand.typeInfo));
                    if(litaC_types__IsPtr(litaC_expr->expectedType)) {
                        {
                            litaC_cgen__CGen_emitStrn(litaC_this, "&", 1);
                            
                            
                        }
                        
                    } 
                    
                    litaC_cgen__CGen_emit(litaC_this, "%s__to__%s(", litaC_implName, litaC_traitName);
                    if(!(litaC_types__IsPtr(litaC_expr->operand.typeInfo))) {
                        {
                            litaC_cgen__CGen_emitStrn(litaC_this, "&", 1);
                            
                            
                        }
                        
                    } 
                    
                    litaC_cgen__CGen_emitStrn(litaC_this, "(", 1);
                    litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->stmt)));
                    litaC_cgen__CGen_emitStrn(litaC_this, "))", 2);
                    return litaC_true;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    return litaC_false;
    
    
}

litaC_void litaC_cgen__CGen_emitForwardDecls(litaC_cgen__CGen* litaC_this) {
    litaC_symbols__ProgramSymbols* litaC_program = &(litaC_this->lita->programSymbols);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_program->symbolTypes)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_program->symbolTypes)), litaC_i);
            litaC_cgen__CGen_emitTypeForwardDecl(litaC_this, litaC_sym);
            
            
        }
    }
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_program->symbolFuncs)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_program->symbolFuncs)), litaC_i);
            litaC_cgen__CGen_emitTypeForwardDecl(litaC_this, litaC_sym);
            
            
        }
    }
    
}

litaC_void litaC_cgen__CGen_emitTypeForwardDecl(litaC_cgen__CGen* litaC_this,litaC_symbols__Symbol* litaC_sym) {
    litaC_ast__Decl* litaC_decl = litaC_sym->decl;
    if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_FOREIGN || litaC_sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(!(litaC_this->lita->options->testsOnly) && litaC_sym->flags & litaC_symbols__SymbolFlags_IS_TEST) {
        {
            return;
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_name = litaC_cgen__CGen_cName(litaC_this, litaC_decl->sym);
    switch(litaC_decl->stmt.node.kind) {
        case litaC_ast__StmtKind_VAR_DECL: 
        case litaC_ast__StmtKind_CONST_DECL: {
            break;
            
            
        }
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                litaC_cgen_decl__CGen_emitFuncDeclSignature(litaC_this, (litaC_ast__FuncDecl*)litaC_decl, litaC_name);
                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ";\n", 2);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNION_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: 
        case litaC_ast__StmtKind_TRAIT_DECL: {
            {
                litaC_ast__AggregateDecl* litaC_aggDecl = (litaC_ast__AggregateDecl*)litaC_decl;
                {
                    litaC_string_buffer__StringBuffer_append(&((litaC_this->buf)), "typedef %s %s %s;\n", (litaC_aggDecl->decl.declaration.stmt.node.kind == litaC_ast__StmtKind_UNION_DECL) ? "union" : "struct", litaC_name, litaC_name);
                    
                    
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_DECL: {
            {
                litaC_cgen_decl__CGen_emitEnumDecl(litaC_this, (litaC_ast__EnumDecl*)litaC_decl);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            {
                break;
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    
}

const litaC_char* litaC_cgen__CGen_allocTemp(litaC_cgen__CGen* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_char* litaC_buffer) {
    litaC_string__String litaC_name = litaC_string__StringInit(litaC_buffer, litaC_symbols__MAX_SYMBOL_NAME, -(1));
    litaC_string__String_format(&((litaC_name)), "__tmp%d", litaC_this->tmpVar);
    litaC_this->tmpVar += 1;
    const litaC_char* litaC_decl = litaC_cgen__CGen_cTypeDecl(litaC_this, litaC_type, litaC_string__String_cStr(litaC_name), litaC_false);
    litaC_string_buffer__StringBuffer_insert(&((litaC_this->buf)), litaC_this->funcIndex, "    %s;\n", litaC_decl);
    return litaC_string__String_cStr(litaC_name);
    
    
}

litaC_char* litaC_cgen__CGen_escapeNameStr(litaC_cgen__CGen* litaC_this,const litaC_char* litaC_name) {
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    return litaC_common__EscapeName(litaC_name, &((litaC_sb)));
    
    
}

const litaC_char* litaC_cgen__CGen_escapeName(litaC_cgen__CGen* litaC_this,litaC_types__TypeInfo* litaC_type) {
    if(litaC_types__IsAggregate(litaC_type)) {
        {
            return litaC_cgen__CGen_escapeNameStr(litaC_this, litaC_type->name);
            
            
            
        }
        
    } 
    
    if(litaC_types__IsFuncLike(litaC_type)) {
        {
            if(litaC_type->kind == litaC_types__TypeKind_FUNC) {
                {
                    litaC_types__FuncTypeInfo* litaC_funcInfo = (litaC_types__FuncTypeInfo*)litaC_type;
                    if(litaC_funcInfo->decl->flags & litaC_ast__FuncFlags_IS_METHOD) {
                        {
                            litaC_char litaC_methodName[256];
                            if(!(litaC_ast__FuncDecl_getName(litaC_funcInfo->decl, litaC_methodName))) {
                                {
                                    assert(litaC_false);
                                    
                                    
                                }
                                
                            } 
                            
                            return litaC_cgen__CGen_escapeNameStr(litaC_this, litaC_methodName);
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            return "_";
            
            
            
        }
        
    } 
    
    return litaC_type->name;
    
    
}

litaC_string_view__StringView litaC_cgen__CGen_baseTypeName(litaC_cgen__CGen* litaC_this,litaC_string_view__StringView litaC_name) {
    litaC_i32 litaC_index = litaC_string_view__StringView_indexOf(litaC_name, "::", -(1));
    if(litaC_index >= 0) {
        {
            litaC_name = litaC_string_view__StringView_substring(litaC_name, litaC_index + 2, -(1));
            
            
        }
        
    } 
    
    litaC_index = litaC_string_view__StringView_indexOf(litaC_name, "<", -(1));
    if(litaC_index >= 0) {
        {
            litaC_name = litaC_string_view__StringView_substring(litaC_name, 0, litaC_index);
            
            
        }
        
    } 
    
    return litaC_name;
    
    
}

litaC_void litaC_cgen__CGen_pushScope(litaC_cgen__CGen* litaC_this,litaC_cgen__CGenScope* litaC_scope) {
    litaC_scope->parent = litaC_this->currentScope;
    litaC_this->currentScope = litaC_scope;
    
}

litaC_cgen__CGenScope* litaC_cgen__CGen_popScope(litaC_cgen__CGen* litaC_this) {
    litaC_cgen__CGenScope* litaC_scope = litaC_this->currentScope;
    if(!(litaC_scope)) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_this->currentScope = litaC_scope->parent;
    litaC_cgen__CGen_leaveScope(litaC_this, litaC_scope);
    return litaC_scope;
    
    
}

litaC_void litaC_cgen__CGen_popLoopScope(litaC_cgen__CGen* litaC_this,litaC_bool litaC_checkSwitch) {
    litaC_cgen__CGenScope* litaC_scope = litaC_this->currentScope;
    while(litaC_scope) {
        {
            if(litaC_checkSwitch && litaC_scope->isSwitch) {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_cgen__CGen_leaveScope(litaC_this, litaC_scope);
            if(!(litaC_scope) || litaC_scope->isLoop) {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_scope = litaC_scope->parent;
            
            
        }
    }
    
}

litaC_void litaC_cgen__CGen_leaveScope(litaC_cgen__CGen* litaC_this,litaC_cgen__CGenScope* litaC_scope) {
    if(!(litaC_scope)) {
        {
            return;
            
            
            
        }
        
    } 
    
    for(litaC_i32 litaC_i = litaC_array__Array_size_cb__ptr_Stmt_ce_(&((litaC_scope->defers))) - 1;litaC_i >= 0;litaC_i -= 1) {
        {
            litaC_ast__Stmt* litaC_deferStmt = litaC_array__Array_get_cb__ptr_Stmt_ce_(&((litaC_scope->defers)), litaC_i);
            litaC_cgen__CGen_emitStmt(litaC_this, litaC_deferStmt);
            litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
            
            
        }
    }
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_const_char_ce_(&((litaC_scope->constDefs)));litaC_i += 1) {
        {
            const litaC_char* litaC_name = litaC_array__Array_get_cb__ptr_const_char_ce_(&((litaC_scope->constDefs)), litaC_i);
            litaC_cgen__CGen_emit(litaC_this, "#undef %s\n", litaC_name);
            
            
        }
    }
    
}

litaC_bool litaC_cgen__CGen_hasPendingDefers(litaC_cgen__CGen* litaC_this) {
    litaC_cgen__CGenScope* litaC_scope = litaC_this->currentScope;
    while(litaC_scope) {
        {
            if(!(litaC_array__Array_empty_cb__ptr_Stmt_ce_(&((litaC_scope->defers))))) {
                {
                    return litaC_true;
                    
                    
                    
                }
                
            } 
            
            litaC_scope = litaC_scope->parent;
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_void litaC_cgen__CGen_emitDefers(litaC_cgen__CGen* litaC_this) {
    litaC_cgen__CGenScope* litaC_scope = litaC_this->currentScope;
    while(litaC_scope) {
        {
            litaC_cgen__CGen_leaveScope(litaC_this, litaC_scope);
            litaC_scope = litaC_scope->parent;
            
            
        }
    }
    
}

litaC_void litaC_cgen__CGen_emitLineInfo(litaC_cgen__CGen* litaC_this,litaC_ast__Stmt* litaC_stmt) {
    
}

const litaC_char* litaC_cgen__CGen_cType(litaC_cgen__CGen* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_bool litaC_isCast,litaC_bool litaC_decay) {
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__PtrTypeInfo* litaC_ptrInfo = (litaC_types__PtrTypeInfo*)litaC_type;
                litaC_types__TypeInfo* litaC_ptrOf = litaC_ptrInfo->ptrOf;
                if(litaC_ptrOf->kind == litaC_types__TypeKind_ARRAY && !(litaC_decay)) {
                    {
                        litaC_types__ArrayTypeInfo* litaC_arrayInfo = (litaC_types__ArrayTypeInfo*)litaC_ptrOf;
                        if(litaC_arrayInfo->isLengthDefined) {
                            {
                                litaC_types__TypeInfo* litaC_baseInfo = litaC_types__TypeInfo_getBaseType(&((litaC_arrayInfo->info)));
                                const litaC_char* litaC_cType = litaC_cgen__CGen_cType(litaC_this, litaC_baseInfo, litaC_isCast, litaC_false);
                                litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "%s (*)[%zu]", litaC_cType, litaC_arrayInfo->length);
                                return litaC_string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                const litaC_char* litaC_cType = litaC_cgen__CGen_cType(litaC_this, litaC_ptrInfo->ptrOf, litaC_isCast, litaC_decay);
                litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_cType);
                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "*", 1);
                return litaC_string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__ConstTypeInfo* litaC_constInfo = (litaC_types__ConstTypeInfo*)litaC_type;
                if(litaC_types__IsPtrLike(litaC_constInfo->constOf)) {
                    {
                        const litaC_char* litaC_cType = litaC_cgen__CGen_cType(litaC_this, litaC_constInfo->constOf, litaC_isCast, litaC_decay);
                        litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_cType);
                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), " const", 6);
                        return litaC_string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                        
                        
                        
                    }
                    
                } 
                
                const litaC_char* litaC_cType = litaC_cgen__CGen_cType(litaC_this, litaC_constInfo->constOf, litaC_isCast, litaC_decay);
                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "const ", 6);
                litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_cType);
                return litaC_string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__ArrayTypeInfo* litaC_arrayInfo = (litaC_types__ArrayTypeInfo*)litaC_type;
                if(litaC_decay) {
                    {
                        litaC_types__PtrTypeInfo litaC_ptrInfo =  {
                            .info =  {
                                .kind = litaC_types__TypeKind_PTR
                            },
                            .ptrOf = litaC_arrayInfo->arrayOf
                        };
                        return litaC_cgen__CGen_cType(litaC_this, &((litaC_ptrInfo.info)), litaC_isCast, litaC_false);
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__TypeInfo* litaC_baseInfo = litaC_types__TypeInfo_getBaseType(&((litaC_arrayInfo->info)));
                const litaC_char* litaC_baseName = litaC_cgen__CGen_cType(litaC_this, litaC_baseInfo, litaC_false, litaC_false);
                litaC_string_buffer__StringBuffer litaC_buf = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
                litaC_string_buffer__StringBuffer litaC_line = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
                do {
                    {
                        if(litaC_arrayInfo->length < 0) {
                            {
                                if(litaC_arrayInfo->numOfElements) {
                                    {
                                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_buf)), "[", 1);
                                        litaC_cgen__CGen litaC_cgen =  {
                                            .lita = litaC_this->lita,
                                            .buf = litaC_buf,
                                            .line = litaC_line
                                        };
                                        litaC_cgen__CGen_emitStmt(&((litaC_cgen)), &((litaC_arrayInfo->numOfElements->stmt)));
                                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_buf)), "]", 1);
                                        
                                        
                                    }
                                    
                                } else {
                                    if(!(litaC_arrayInfo->isLengthDefined)) {
                                        {
                                            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_buf)), "[]", 2);
                                            
                                            
                                        }
                                        
                                    } else {
                                        {
                                            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_buf)), "[0]", 3);
                                            
                                            
                                        }
                                    } 
                                    
                                } 
                                
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_string_buffer__StringBuffer_append(&((litaC_buf)), "[%zu]", litaC_arrayInfo->length);
                                
                                
                            }
                        } 
                        
                        if(litaC_arrayInfo->arrayOf && litaC_arrayInfo->arrayOf->kind == litaC_types__TypeKind_ARRAY) {
                            {
                                litaC_arrayInfo = (litaC_types__ArrayTypeInfo*)litaC_arrayInfo->arrayOf;
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_arrayInfo = NULL;
                                
                                
                            }
                        } 
                        
                        
                        
                    }
                }
                while(litaC_arrayInfo);
                litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_baseName);
                litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_string_buffer__StringBuffer_cStrConst(&((litaC_buf))));
                return litaC_string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC_PTR: {
            {
                litaC_types__FuncPtrTypeInfo* litaC_funcInfo = (litaC_types__FuncPtrTypeInfo*)litaC_type;
                litaC_string_buffer__StringBuffer litaC_params = litaC_string_buffer__StringBufferInit(512, litaC_this->lita->allocator);
                if(litaC_funcInfo->isTrait) {
                    {
                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_params)), "void*", 5);
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcInfo->paramDecls)));litaC_i += 1) {
                    {
                        if(litaC_i > 0 || litaC_funcInfo->isTrait) {
                            {
                                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_params)), ",", 1);
                                
                                
                            }
                            
                        } 
                        
                        litaC_types__TypeInfo* litaC_param = litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_funcInfo->paramDecls)), litaC_i);
                        litaC_string_buffer__StringBuffer_appendStr(&((litaC_params)), litaC_cgen__CGen_cType(litaC_this, litaC_param, litaC_isCast, litaC_true));
                        
                        
                    }
                }
                litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "%s (*%s)(%s)", litaC_cgen__CGen_cType(litaC_this, litaC_funcInfo->returnType, litaC_isCast, litaC_decay), (litaC_isCast) ? "" : litaC_cgen__CGen_cTypeName(litaC_this, &((litaC_funcInfo->info.typeInfo))), litaC_string_buffer__StringBuffer_cStrConst(&((litaC_params))));
                return litaC_string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                
                
                
            }
            
            
        }
        default: {
            {
                return litaC_cgen__CGen_cTypeName(litaC_this, litaC_type);
                
                
                
            }
            
            
        }
    }
    
}

const litaC_char* litaC_cgen__CGen_cTypeDecl(litaC_cgen__CGen* litaC_this,litaC_types__TypeInfo* litaC_type,const litaC_char* litaC_name,litaC_bool litaC_decay) {
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__PtrTypeInfo* litaC_ptrInfo = (litaC_types__PtrTypeInfo*)litaC_type;
                litaC_types__TypeInfo* litaC_ptrOf = litaC_ptrInfo->ptrOf;
                if(litaC_ptrOf->kind == litaC_types__TypeKind_ARRAY && !(litaC_decay)) {
                    {
                        litaC_types__ArrayTypeInfo* litaC_arrayInfo = (litaC_types__ArrayTypeInfo*)litaC_ptrOf;
                        if(litaC_arrayInfo->isLengthDefined) {
                            {
                                litaC_types__TypeInfo* litaC_baseInfo = litaC_types__TypeInfo_getBaseType(&((litaC_arrayInfo->info)));
                                const litaC_char* litaC_cType = litaC_cgen__CGen_cType(litaC_this, litaC_baseInfo, litaC_false, litaC_false);
                                litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "%s (*%s)[%zu]", litaC_cType, litaC_name, litaC_arrayInfo->length);
                                return litaC_string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                const litaC_char* litaC_cType = litaC_cgen__CGen_cType(litaC_this, litaC_type, litaC_false, litaC_decay);
                litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_cType);
                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), " ", 1);
                litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_name);
                return litaC_string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__ConstTypeInfo* litaC_constInfo = (litaC_types__ConstTypeInfo*)litaC_type;
                if(litaC_types__IsPtrLike(litaC_constInfo->constOf)) {
                    {
                        const litaC_char* litaC_cType = litaC_cgen__CGen_cType(litaC_this, litaC_constInfo->constOf, litaC_false, litaC_decay);
                        litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_cType);
                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), " const ", 7);
                        litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_name);
                        return litaC_string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                        
                        
                        
                    }
                    
                } 
                
                const litaC_char* litaC_cType = litaC_cgen__CGen_cTypeDecl(litaC_this, litaC_constInfo->constOf, litaC_name, litaC_decay);
                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "const ", 6);
                litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_cType);
                return litaC_string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__ArrayTypeInfo* litaC_arrayInfo = (litaC_types__ArrayTypeInfo*)litaC_type;
                if(litaC_decay) {
                    {
                        litaC_types__PtrTypeInfo litaC_ptrInfo =  {
                            .info =  {
                                .kind = litaC_types__TypeKind_PTR
                            },
                            .ptrOf = litaC_arrayInfo->arrayOf
                        };
                        return litaC_cgen__CGen_cTypeDecl(litaC_this, &((litaC_ptrInfo.info)), litaC_name, litaC_false);
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__TypeInfo* litaC_baseInfo = litaC_types__TypeInfo_getBaseType(&((litaC_arrayInfo->info)));
                const litaC_char* litaC_baseName = litaC_cgen__CGen_cType(litaC_this, litaC_baseInfo, litaC_false, litaC_false);
                litaC_string_buffer__StringBuffer litaC_buf = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
                litaC_string_buffer__StringBuffer litaC_line = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
                do {
                    {
                        if(litaC_arrayInfo->length == 0) {
                            {
                                if(litaC_arrayInfo->numOfElements) {
                                    {
                                        litaC_cgen__CGen_flush(litaC_this);
                                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_buf)), "[", 1);
                                        litaC_cgen__CGen litaC_cgen =  {
                                            .lita = litaC_this->lita,
                                            .buf = litaC_buf,
                                            .line = litaC_line
                                        };
                                        litaC_cgen__CGen_emitStmt(&((litaC_cgen)), &((litaC_arrayInfo->numOfElements->stmt)));
                                        litaC_buf = litaC_cgen.buf;
                                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_buf)), "]", 1);
                                        
                                        
                                    }
                                    
                                } else {
                                    if(!(litaC_arrayInfo->isLengthDefined)) {
                                        {
                                            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_buf)), "[]", 2);
                                            
                                            
                                        }
                                        
                                    } else {
                                        {
                                            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_buf)), "[0]", 3);
                                            
                                            
                                        }
                                    } 
                                    
                                } 
                                
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_string_buffer__StringBuffer_append(&((litaC_buf)), "[%zu]", litaC_arrayInfo->length);
                                
                                
                            }
                        } 
                        
                        if(litaC_arrayInfo->arrayOf && litaC_arrayInfo->arrayOf->kind == litaC_types__TypeKind_ARRAY) {
                            {
                                litaC_arrayInfo = (litaC_types__ArrayTypeInfo*)litaC_arrayInfo->arrayOf;
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_arrayInfo = NULL;
                                
                                
                            }
                        } 
                        
                        
                        
                    }
                }
                while(litaC_arrayInfo);
                if(litaC_baseInfo->kind == litaC_types__TypeKind_FUNC_PTR) {
                    {
                        litaC_string_buffer__StringBuffer_insert(&((litaC_buf)), 0, "%s", litaC_name);
                        return litaC_cgen__CGen_cTypeDecl(litaC_this, litaC_baseInfo, litaC_string_buffer__StringBuffer_cStrConst(&((litaC_buf))), litaC_decay);
                        
                        
                        
                    }
                    
                } 
                
                litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_baseName);
                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), " ", 1);
                litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_name);
                litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_string_buffer__StringBuffer_cStr(&((litaC_buf))));
                return litaC_string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STR: {
            {
                litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), "const char* ");
                litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_name);
                return litaC_string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC_PTR: {
            {
                litaC_types__FuncPtrTypeInfo* litaC_funcInfo = (litaC_types__FuncPtrTypeInfo*)litaC_type;
                litaC_string_buffer__StringBuffer litaC_params = litaC_string_buffer__StringBufferInit(512, litaC_this->lita->allocator);
                if(litaC_funcInfo->isTrait) {
                    {
                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_params)), "void*", 5);
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcInfo->paramDecls)));litaC_i += 1) {
                    {
                        if(litaC_i > 0 || litaC_funcInfo->isTrait) {
                            {
                                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_params)), ",", 1);
                                
                                
                            }
                            
                        } 
                        
                        litaC_types__TypeInfo* litaC_param = litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_funcInfo->paramDecls)), litaC_i);
                        litaC_string_buffer__StringBuffer_appendStr(&((litaC_params)), litaC_cgen__CGen_cType(litaC_this, litaC_param, litaC_false, litaC_true));
                        
                        
                    }
                }
                litaC_string_buffer__StringBuffer_append(&((litaC_sb)), "%s (*%s)(%s)", litaC_cgen__CGen_cType(litaC_this, litaC_funcInfo->returnType, litaC_false, litaC_decay), litaC_name, litaC_string_buffer__StringBuffer_cStrConst(&((litaC_params))));
                return litaC_string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                
                
                
            }
            
            
        }
        default: {
            {
                const litaC_char* litaC_cType = litaC_cgen__CGen_cType(litaC_this, litaC_type, litaC_false, litaC_decay);
                litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_cType);
                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), " ", 1);
                litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_name);
                return litaC_string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                
                
                
            }
            
            
        }
    }
    
}

litaC_string_view__StringView litaC_cgen__CGen_foreignName(litaC_cgen__CGen* litaC_this,litaC_ast__Decl* litaC_decl,litaC_string_view__StringView litaC_defaultName) {
    if(!(litaC_decl)) {
        {
            return litaC_defaultName;
            
            
            
        }
        
    } 
    
    litaC_ast__NoteStmt* litaC_note = litaC_ast__Decl_getNote(litaC_decl, "foreign");
    if(!(litaC_note)) {
        {
            return litaC_defaultName;
            
            
            
        }
        
    } 
    
    if(litaC_array__Array_empty_cb_Token_ce_(&((litaC_note->attributes)))) {
        {
            return litaC_defaultName;
            
            
            
        }
        
    } 
    
    litaC_lex__Token litaC_arg = litaC_array__Array_get_cb_Token_ce_(&((litaC_note->attributes)), 0);
    return litaC_arg.value.str;
    
    
}

const litaC_char* litaC_cgen__CGen_cName(litaC_cgen__CGen* litaC_this,litaC_symbols__Symbol* litaC_sym) {
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    const litaC_char* litaC_declName = litaC_sym->name;
    if(litaC_types__IsFuncLike(litaC_sym->type)) {
        {
            litaC_declName = litaC_cgen__CGen_escapeNameStr(litaC_this, litaC_sym->name);
            
            
        }
        
    } else {
        if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_TYPE) {
            {
                litaC_declName = litaC_cgen__CGen_escapeName(litaC_this, litaC_sym->type);
                
                
            }
            
        } 
        
    } 
    
    if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_LOCAL) {
        {
            return litaC_cgen__CGen_prefix(litaC_this, litaC_declName, &((litaC_sb)));
            
            
            
        }
        
    } 
    
    if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_FOREIGN) {
        {
            if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_BUILTIN) {
                {
                    return litaC_cgen__CGen_prefix(litaC_this, litaC_sym->name, &((litaC_sb)));
                    
                    
                    
                }
                
            } 
            
            litaC_string_view__StringView litaC_name = litaC_cgen__CGen_foreignName(litaC_this, litaC_sym->decl, litaC_cgen__CGen_baseTypeName(litaC_this, litaC_sym->decl->name.value.str));
            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), litaC_name.buffer, litaC_name.length);
            return litaC_string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
            
            
            
        }
        
    } 
    
    litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_this->lita->options->cPrefix);
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), litaC_sym->declared->id.name.buffer, litaC_sym->declared->id.name.length);
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "__", 2);
    litaC_string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_declName);
    return litaC_string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
    
    
}

const litaC_char* litaC_cgen__CGen_cTypeName(litaC_cgen__CGen* litaC_this,litaC_types__TypeInfo* litaC_type) {
    assert(litaC_type != NULL);
    if(!(litaC_type->sym)) {
        {
            const litaC_char* litaC_typeName = litaC_cgen__CGen_escapeName(litaC_this, litaC_type);
            litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
            return litaC_cgen__CGen_prefix(litaC_this, litaC_typeName, &((litaC_sb)));
            
            
            
        }
        
    } 
    
    return litaC_cgen__CGen_cName(litaC_this, litaC_type->sym);
    
    
}

const litaC_char* litaC_cgen__CGen_prefix(litaC_cgen__CGen* litaC_this,const litaC_char* litaC_name,litaC_string_buffer__StringBuffer* litaC_sb) {
    litaC_string_buffer__StringBuffer_appendStr(litaC_sb, litaC_this->lita->options->cPrefix);
    litaC_string_buffer__StringBuffer_appendStr(litaC_sb, litaC_name);
    return litaC_string_buffer__StringBuffer_cStrConst(litaC_sb);
    
    
}

litaC_void litaC_cgen__CGen_emitTypeSpec(litaC_cgen__CGen* litaC_this,litaC_ast__TypeSpec* litaC_spec) {
    assert(litaC_spec != NULL);
    switch(litaC_spec->kind) {
        case litaC_ast__TypeSpecKind_NONE: {
            {
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_ARRAY: {
            {
                litaC_ast__ArrayTypeSpec* litaC_array = (litaC_ast__ArrayTypeSpec*)litaC_spec;
                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "[", 1);
                if(litaC_array->numElements) {
                    {
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_array->numElements->stmt)));
                        
                        
                    }
                    
                } 
                
                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "]", 1);
                litaC_cgen__CGen_emitTypeSpec(litaC_this, litaC_array->spec.base);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_PTR: {
            {
                litaC_ast__PtrTypeSpec* litaC_ptr = (litaC_ast__PtrTypeSpec*)litaC_spec;
                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "*", 1);
                litaC_cgen__CGen_emitTypeSpec(litaC_this, litaC_ptr->spec.base);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_CONST: {
            {
                litaC_ast__ConstTypeSpec* litaC_c = (litaC_ast__ConstTypeSpec*)litaC_spec;
                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "const ", 6);
                litaC_cgen__CGen_emitTypeSpec(litaC_this, litaC_c->spec.base);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_NAME: {
            {
                litaC_ast__NameTypeSpec* litaC_name = (litaC_ast__NameTypeSpec*)litaC_spec;
                litaC_string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), litaC_name->name);
                if(!(litaC_array__Array_empty_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs))))) {
                    {
                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "<", 1);
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ",", 1);
                                    
                                } 
                                
                                litaC_cgen__CGen_emitTypeSpec(litaC_this, litaC_array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)), litaC_i));
                                
                                
                            }
                        }
                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ">", 1);
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_FUNC_PTR: {
            {
                litaC_ast__FuncPtrTypeSpec* litaC_fn = (litaC_ast__FuncPtrTypeSpec*)litaC_spec;
                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "func", 4);
                if(!(litaC_array__Array_empty_cb_GenericParam_ce_(&((litaC_fn->genericParams))))) {
                    {
                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "<", 1);
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_fn->genericParams)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ",", 1);
                                    
                                } 
                                
                                litaC_cgen__CGen_emitName(litaC_this, litaC_array__Array_get_cb_GenericParam_ce_(&((litaC_fn->genericParams)), litaC_i).name);
                                
                                
                            }
                        }
                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ">", 1);
                        
                        
                    }
                    
                } 
                
                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "(", 1);
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_fn->args)));litaC_i += 1) {
                    {
                        if(litaC_i > 0) {
                            litaC_string_buffer__StringBuffer_append(&((litaC_this->buf)), ",");
                            
                        } 
                        
                        litaC_cgen__CGen_emitTypeSpec(litaC_this, litaC_array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_fn->args)), litaC_i));
                        
                        
                    }
                }
                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ") : ", 4);
                litaC_cgen__CGen_emitTypeSpec(litaC_this, litaC_fn->ret);
                return;
                
                
                
            }
            
            
        }
        default: {
            {
                litaC_common__Panic("Invalid TypeSpecKind: '%d'\n", litaC_spec->kind);
                
                
            }
            
            
        }
    }
    
}

litaC_void litaC_cgen__CGen_flush(litaC_cgen__CGen* litaC_this) {
    if(litaC_this->output) {
        {
            litaC_io__WriteBytes(litaC_this->output, litaC_this->buf.buffer, litaC_this->buf.length);
            litaC_this->buf.length = 0;
            
            
        }
        
    } 
    
    
}

litaC_void litaC_cgen__CGen_emitName(litaC_cgen__CGen* litaC_this,litaC_lex__Token litaC_tok) {
    if(litaC_tok.type != litaC_lex__TokenType_ERROR) {
        {
            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), litaC_tok.value.str.buffer, litaC_tok.value.str.length);
            
            
        }
        
    } 
    
    
}

litaC_void litaC_cgen__CGen_emitln(litaC_cgen__CGen* litaC_this) {
    litaC_string_buffer__StringBuffer_appendChar(&((litaC_this->buf)), '\n');
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_this->indent;litaC_i += 1) {
        {
            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "    ", 4);
            
            
        }
    }
    
}

litaC_void litaC_cgen__CGen_emit(litaC_cgen__CGen* litaC_this,const litaC_char* litaC_strFormat,...) {
    if(litaC_this->format) {
        {
            litaC_string_buffer__StringBuffer_clear(&((litaC_this->line)));
            va_list litaC_args;
            va_start(litaC_args, litaC_strFormat);
            litaC_string_buffer__StringBuffer_appendArgs(&((litaC_this->line)), litaC_strFormat, litaC_args);
            va_end(litaC_args);
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_this->line.length;litaC_i += 1) {
                {
                    litaC_char litaC_c = litaC_this->line.buffer[litaC_i];
                    if(litaC_c == '\n') {
                        {
                            litaC_cgen__CGen_emitln(litaC_this);
                            
                            
                        }
                        
                    } else {
                        if(litaC_c == '{') {
                            {
                                litaC_string_buffer__StringBuffer_appendChar(&((litaC_this->buf)), litaC_c);
                                litaC_this->indent += 1;
                                litaC_cgen__CGen_emitln(litaC_this);
                                
                                
                            }
                            
                        } else {
                            if(litaC_c == '}') {
                                {
                                    litaC_this->indent -= 1;
                                    litaC_cgen__CGen_emitln(litaC_this);
                                    litaC_string_buffer__StringBuffer_appendChar(&((litaC_this->buf)), litaC_c);
                                    
                                    
                                }
                                
                            } else {
                                {
                                    litaC_string_buffer__StringBuffer_appendChar(&((litaC_this->buf)), litaC_c);
                                    
                                    
                                }
                            } 
                            
                        } 
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } else {
        {
            va_list litaC_args;
            va_start(litaC_args, litaC_strFormat);
            litaC_string_buffer__StringBuffer_appendArgs(&((litaC_this->buf)), litaC_strFormat, litaC_args);
            va_end(litaC_args);
            
            
        }
    } 
    
    if(litaC_this->bufferFlush) {
        {
            if(litaC_this->buf.length > (litaC_this->buf.capacity / 2)) {
                {
                    litaC_cgen__CGen_flush(litaC_this);
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    
}

litaC_void litaC_cgen__CGen_emitStr(litaC_cgen__CGen* litaC_this,const litaC_char* litaC_str) {
    litaC_i32 litaC_len = strlen(litaC_str);
    litaC_cgen__CGen_emitStrn(litaC_this, litaC_str, litaC_len);
    
}

litaC_void litaC_cgen__CGen_emitStrn(litaC_cgen__CGen* litaC_this,const litaC_char* litaC_str,litaC_i32 litaC_len) {
    if(litaC_this->format) {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_len;litaC_i += 1) {
                {
                    litaC_char litaC_c = litaC_str[litaC_i];
                    if(litaC_c == '\n') {
                        {
                            litaC_cgen__CGen_emitln(litaC_this);
                            
                            
                        }
                        
                    } else {
                        if(litaC_c == '{') {
                            {
                                litaC_string_buffer__StringBuffer_appendChar(&((litaC_this->buf)), litaC_c);
                                litaC_this->indent += 1;
                                litaC_cgen__CGen_emitln(litaC_this);
                                
                                
                            }
                            
                        } else {
                            if(litaC_c == '}') {
                                {
                                    litaC_this->indent -= 1;
                                    litaC_cgen__CGen_emitln(litaC_this);
                                    litaC_string_buffer__StringBuffer_appendChar(&((litaC_this->buf)), litaC_c);
                                    
                                    
                                }
                                
                            } else {
                                {
                                    litaC_string_buffer__StringBuffer_appendChar(&((litaC_this->buf)), litaC_c);
                                    
                                    
                                }
                            } 
                            
                        } 
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } else {
        {
            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), litaC_str, litaC_len);
            
            
        }
    } 
    
    if(litaC_this->bufferFlush) {
        {
            if(litaC_this->buf.length > (litaC_this->buf.capacity / 2)) {
                {
                    litaC_cgen__CGen_flush(litaC_this);
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    
}

litaC_void litaC_cgen__CGen_emitNotes(litaC_cgen__CGen* litaC_this,litaC_ast__Attributes* litaC_attributes,litaC_bool litaC_isPrelude) {
    if(litaC_array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_attributes->notes)))) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_isPrelude) {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_attributes->notes)));litaC_i += 1) {
                {
                    litaC_cgen__CGen_emitPreludeNote(litaC_this, litaC_array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_attributes->notes)), litaC_i));
                    litaC_cgen__CGen_emitStrn(litaC_this, "\n", 1);
                    
                    
                }
            }
            
            
        }
        
    } else {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_attributes->notes)));litaC_i += 1) {
                {
                    litaC_cgen__CGen_emitPostludeNote(litaC_this, litaC_array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_attributes->notes)), litaC_i));
                    litaC_cgen__CGen_emitStrn(litaC_this, "\n", 1);
                    
                    
                }
            }
            
            
        }
    } 
    
    
}

litaC_void litaC_cgen__CGen_emitPreludeNote(litaC_cgen__CGen* litaC_this,litaC_ast__NoteStmt* litaC_note) {
    if(strncmp(litaC_note->name.value.str.buffer, "include", litaC_note->name.value.str.length) == 0) {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_Token_ce_(&((litaC_note->attributes)));litaC_i += 1) {
                {
                    litaC_lex__Token litaC_attr = litaC_array__Array_get_cb_Token_ce_(&((litaC_note->attributes)), litaC_i);
                    if(litaC_attr.value.str.length > 0 && litaC_attr.value.str.buffer[0] == '<') {
                        {
                            litaC_cgen__CGen_emit(litaC_this, "#include %.*s\n", litaC_attr.value.str.length, litaC_attr.value.str.buffer);
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_cgen__CGen_emit(litaC_this, "#include \"%.*s\"\n", litaC_attr.value.str.length, litaC_attr.value.str.buffer);
                            
                            
                        }
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } else {
        if(strncmp(litaC_note->name.value.str.buffer, "raw", litaC_note->name.value.str.length) == 0) {
            {
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_Token_ce_(&((litaC_note->attributes)));litaC_i += 1) {
                    {
                        litaC_lex__Token litaC_attr = litaC_array__Array_get_cb_Token_ce_(&((litaC_note->attributes)), litaC_i);
                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), litaC_attr.value.str.buffer, litaC_attr.value.str.length);
                        
                        
                    }
                }
                
                
            }
            
        } else {
            if(strncmp(litaC_note->name.value.str.buffer, "inline", litaC_note->name.value.str.length) == 0) {
                {
                    litaC_cgen__CGen_emitStr(litaC_this, "LITAC_INLINE ");
                    
                    
                }
                
            } else {
                if(strncmp(litaC_note->name.value.str.buffer, "noinline", litaC_note->name.value.str.length) == 0) {
                    {
                        litaC_cgen__CGen_emitStr(litaC_this, "LITAC_NOINLINE ");
                        
                        
                    }
                    
                } else {
                    if(strncmp(litaC_note->name.value.str.buffer, "static", litaC_note->name.value.str.length) == 0) {
                        {
                            litaC_cgen__CGen_emitStr(litaC_this, "static ");
                            
                            
                        }
                        
                    } else {
                        if(strncmp(litaC_note->name.value.str.buffer, "atomic", litaC_note->name.value.str.length) == 0) {
                            {
                                litaC_cgen__CGen_emitStr(litaC_this, "_Atomic ");
                                
                                
                            }
                            
                        } else {
                            if(strncmp(litaC_note->name.value.str.buffer, "register", litaC_note->name.value.str.length) == 0) {
                                {
                                    litaC_cgen__CGen_emitStr(litaC_this, "register ");
                                    
                                    
                                }
                                
                            } else {
                                if(strncmp(litaC_note->name.value.str.buffer, "threadlocal", litaC_note->name.value.str.length) == 0) {
                                    {
                                        litaC_cgen__CGen_emitStr(litaC_this, "LITAC_THREADLOCAL ");
                                        
                                        
                                    }
                                    
                                } else {
                                    if(strncmp(litaC_note->name.value.str.buffer, "export", litaC_note->name.value.str.length) == 0) {
                                        {
                                            litaC_cgen__CGen_emitStr(litaC_this, "LITAC_EXPORT ");
                                            
                                            
                                        }
                                        
                                    } else {
                                        if(strncmp(litaC_note->name.value.str.buffer, "packed", litaC_note->name.value.str.length) == 0) {
                                            {
                                                litaC_cgen__CGen_emitStr(litaC_this, "LITAC_PACKED ");
                                                
                                                
                                            }
                                            
                                        } else {
                                            if(strncmp(litaC_note->name.value.str.buffer, "cc", litaC_note->name.value.str.length) == 0) {
                                                {
                                                    if(!(litaC_array__Array_empty_cb_Token_ce_(&((litaC_note->attributes))))) {
                                                        {
                                                            litaC_lex__Token litaC_attr = litaC_array__Array_get_cb_Token_ce_(&((litaC_note->attributes)), 0);
                                                            litaC_cgen__CGen_emitStrn(litaC_this, litaC_attr.value.str.buffer, litaC_attr.value.str.length);
                                                            litaC_cgen__CGen_emitStrn(litaC_this, " ", 1);
                                                            
                                                            
                                                        }
                                                        
                                                    } 
                                                    
                                                    
                                                    
                                                }
                                                
                                            } else {
                                                if(strncmp(litaC_note->name.value.str.buffer, "cFile", litaC_note->name.value.str.length) == 0) {
                                                    {
                                                        
#define litaC_BUFFER_SIZE (1024 * 10)
                                                        litaC_char litaC_filename[_MAX_PATH] =  {
                                                            0
                                                        };
                                                        litaC_string__String litaC_filenameStr = litaC_string__StringInit(litaC_filename, _MAX_PATH, -(1));
                                                        litaC_char litaC_filedata[litaC_BUFFER_SIZE] =  {
                                                            0
                                                        };
                                                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_Token_ce_(&((litaC_note->attributes)));litaC_i += 1) {
                                                            {
                                                                litaC_lex__Token litaC_arg = litaC_array__Array_get_cb_Token_ce_(&((litaC_note->attributes)), litaC_i);
                                                                litaC_system__FilePath(litaC_note->stmt.node.startPos.filename, litaC_filename);
                                                                litaC_string__String_adjust(&((litaC_filenameStr)));
                                                                litaC_string__String_append(&((litaC_filenameStr)), "/%.*s", litaC_arg.value.str.length, litaC_arg.value.str.buffer);
                                                                if(!(litaC_system__FileExists(litaC_string__String_cStr(litaC_filenameStr)))) {
                                                                    {
                                                                        litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_note->stmt.node.startPos, "unable to locate file: '%.*s'", litaC_arg.value.str.length, litaC_arg.value.str.buffer);
                                                                        continue;
                                                                        
                                                                        
                                                                    }
                                                                    
                                                                } 
                                                                
                                                                FILE* litaC_file = fopen(litaC_filename, "r");
                                                                
                                                                if(!(litaC_file)) {
                                                                    {
                                                                        litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_note->stmt.node.startPos, "unable to open file: '%.*s'", litaC_filename);
                                                                        if(litaC_file) {
                                                                            fclose(litaC_file);
                                                                            
                                                                        } 
                                                                        ;
                                                                        continue;
                                                                        
                                                                        
                                                                    }
                                                                    
                                                                } 
                                                                
                                                                litaC_cgen__CGen_flush(litaC_this);
                                                                litaC_i64 litaC_bytesRead = 0L;
                                                                do {
                                                                    {
                                                                        litaC_bytesRead = fread(litaC_filedata, 1, litaC_BUFFER_SIZE, litaC_file);
                                                                        fwrite((const litaC_void*)litaC_filedata, sizeof(litaC_char), litaC_bytesRead, litaC_this->output);
                                                                        
                                                                        
                                                                    }
                                                                }
                                                                while(litaC_bytesRead > 0);
                                                                if(litaC_file) {
                                                                    fclose(litaC_file);
                                                                    
                                                                } 
                                                                ;
                                                                
                                                                
                                                            }
                                                        }
                                                        #undef litaC_BUFFER_SIZE
                                                        
                                                        
                                                    }
                                                    
                                                } 
                                                
                                            } 
                                            
                                        } 
                                        
                                    } 
                                    
                                } 
                                
                            } 
                            
                        } 
                        
                    } 
                    
                } 
                
            } 
            
        } 
        
    } 
    
    
}

litaC_void litaC_cgen__CGen_emitPostludeNote(litaC_cgen__CGen* litaC_this,litaC_ast__NoteStmt* litaC_note) {
    if(strncmp(litaC_note->name.value.str.buffer, "packed", litaC_note->name.value.str.length) == 0) {
        {
            litaC_cgen__CGen_emitStr(litaC_this, " LITAC_PACKED_POP ");
            
            
        }
        
    } 
    
    
}

litaC_void litaC_cgen__CGen_emitFieldName(litaC_cgen__CGen* litaC_this,litaC_ast__FieldStmt litaC_field) {
    assert(litaC_field.kind != litaC_ast__StmtKind_POISON_EXPR);
    litaC_ast__NoteStmt* litaC_alias = litaC_ast__Decl_getNote(&((litaC_field.varField->decl)), "alias");
    if(litaC_alias && litaC_array__Array_size_cb_Token_ce_(&((litaC_alias->attributes)))) {
        {
            litaC_lex__Token litaC_name = litaC_array__Array_get_cb_Token_ce_(&((litaC_alias->attributes)), 0);
            litaC_cgen__CGen_emitName(litaC_this, litaC_name);
            
            
        }
        
    } else {
        {
            litaC_cgen__CGen_emitName(litaC_this, litaC_field.varField->decl.name);
            
            
        }
    } 
    
    
}

litaC_void litaC_cgen__CGen_emitSymbol(litaC_cgen__CGen* litaC_this,litaC_symbols__Symbol* litaC_sym) {
    if(!(litaC_sym)) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(!((litaC_sym->flags & litaC_symbols__SymbolFlags_IS_USING))) {
        {
            litaC_cgen__CGen_emitStr(litaC_this, litaC_cgen__CGen_cName(litaC_this, litaC_sym));
            return;
            
            
            
        }
        
    } 
    
    litaC_symbols__Symbol* litaC_paramInfo = litaC_sym->usingParent;
    assert(litaC_paramInfo != NULL);
    litaC_types__AggregateTypeInfo* litaC_aggType = (litaC_types__AggregateTypeInfo*)litaC_types__TypeInfo_getBaseType(litaC_paramInfo->type);
    litaC_cgen__CGen_emitStr(litaC_this, litaC_cgen__CGen_cName(litaC_this, litaC_paramInfo));
    litaC_types__FieldPath litaC_path =  {
        
    };
    litaC_bool litaC_isFound = litaC_types__AggregateTypeInfo_getFieldPath(litaC_aggType, litaC_sym->name, &(litaC_path));
    assert(litaC_isFound);
    litaC_types__TypeInfo* litaC_nextType = litaC_paramInfo->type;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_path.numOfFields;litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_path.fields[litaC_i];
            if(litaC_nextType->kind == litaC_types__TypeKind_PTR) {
                {
                    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "->", 2);
                    
                    
                }
                
            } else {
                {
                    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ".", 1);
                    
                    
                }
            } 
            
            litaC_cgen__CGen_emitStrn(litaC_this, litaC_field.varField->decl.name.value.str.buffer, litaC_field.varField->decl.name.value.str.length);
            litaC_nextType = litaC_field.typeInfo;
            
            
        }
    }
    
}

litaC_void litaC_cgen__CGen_emitTraitFuncCall(litaC_cgen__CGen* litaC_this,litaC_ast__FuncCallExpr* litaC_expr) {
    switch(litaC_expr->object->stmt.node.kind) {
        case litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR: {
            {
                litaC_ast__IdentifierExpr* litaC_idExpr = (litaC_ast__IdentifierExpr*)litaC_expr->object;
                litaC_cgen__CGen_emit(litaC_this, "/* something here */");
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GET_EXPR: {
            {
                litaC_ast__GetExpr* litaC_getExpr = (litaC_ast__GetExpr*)litaC_expr->object;
                litaC_types__TypeInfo* litaC_type = litaC_getExpr->object->operand.typeInfo;
                if(litaC_getExpr->object->stmt.node.kind == litaC_ast__StmtKind_IDENTIFIER_EXPR) {
                    {
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_getExpr->object->stmt)));
                        if(litaC_types__IsPtr(litaC_type)) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, "->", 2);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, ".", 1);
                                
                                
                            }
                        } 
                        
                        litaC_cgen__CGen_emitStr(litaC_this, "__vtable->");
                        assert(litaC_types__IsAggregateLike(litaC_type));
                        litaC_types__AggregateTypeInfo* litaC_aggInfo = litaC_types__AsAggregate(litaC_type);
                        litaC_ast__FieldStmt litaC_field = litaC_types__AggregateTypeInfo_getField(litaC_aggInfo, litaC_getExpr->field->type->name);
                        litaC_cgen__CGen_emitFieldName(litaC_this, litaC_field);
                        litaC_cgen__CGen_emitStrn(litaC_this, "(", 1);
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_getExpr->object->stmt)));
                        if(litaC_types__IsPtr(litaC_type)) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, "->", 2);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, ".", 1);
                                
                                
                            }
                        } 
                        
                        litaC_cgen__CGen_emitStrn(litaC_this, "__this", 6);
                        
                        
                    }
                    
                } else {
                    {
                        litaC_char litaC_buffer[256];
                        const litaC_char* litaC_tmpName = litaC_cgen__CGen_allocTemp(litaC_this, litaC_type, litaC_buffer);
                        litaC_cgen__CGen_emit(litaC_this, "(%s = ", litaC_tmpName);
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_getExpr->object->stmt)));
                        litaC_cgen__CGen_emit(litaC_this, ", %s", litaC_tmpName);
                        if(litaC_types__IsPtr(litaC_type)) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, "->", 2);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, ".", 1);
                                
                                
                            }
                        } 
                        
                        litaC_cgen__CGen_emitStrn(litaC_this, "__vtable)->", 11);
                        assert(litaC_types__IsAggregateLike(litaC_type));
                        litaC_types__AggregateTypeInfo* litaC_aggInfo = litaC_types__AsAggregate(litaC_type);
                        litaC_ast__FieldStmt litaC_field = litaC_types__AggregateTypeInfo_getField(litaC_aggInfo, litaC_getExpr->field->type->name);
                        litaC_cgen__CGen_emitFieldName(litaC_this, litaC_field);
                        litaC_cgen__CGen_emit(litaC_this, "(%s", litaC_tmpName);
                        if(litaC_types__IsPtr(litaC_type)) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, "->", 2);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, ".", 1);
                                
                                
                            }
                        } 
                        
                        litaC_cgen__CGen_emitStrn(litaC_this, "__this", 6);
                        
                        
                    }
                } 
                
                if(litaC_array__Array_size_cb_CallArg_ce_(&((litaC_expr->arguments))) > 0) {
                    {
                        litaC_cgen__CGen_emitStrn(litaC_this, ", ", 2);
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    
}

litaC_void litaC_cgen__CGen_emitStmt(litaC_cgen__CGen* litaC_this,litaC_ast__Stmt* litaC_s) {
    if(!(litaC_s)) {
        return;
        
        
    } 
    
    switch(litaC_s->node.kind) {
        case litaC_ast__StmtKind_IMPORT_DECL: {
            {
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONST_DECL: 
        case litaC_ast__StmtKind_VAR_DECL: {
            {
                litaC_ast__VarDecl* litaC_decl = (litaC_ast__VarDecl*)litaC_s;
                litaC_cgen_decl__CGen_emitVarDecl(litaC_this, litaC_decl);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TRAIT_DECL: 
        case litaC_ast__StmtKind_UNION_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: {
            {
                litaC_ast__AggregateDecl* litaC_decl = (litaC_ast__AggregateDecl*)litaC_s;
                litaC_cgen_decl__CGen_emitAggregateDecl(litaC_this, litaC_decl);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_DECL: {
            {
                litaC_ast__EnumDecl* litaC_decl = (litaC_ast__EnumDecl*)litaC_s;
                litaC_cgen_decl__CGen_emitEnumDecl(litaC_this, litaC_decl);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                litaC_ast__FuncDecl* litaC_decl = (litaC_ast__FuncDecl*)litaC_s;
                litaC_cgen_decl__CGen_emitFuncDecl(litaC_this, litaC_decl);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            {
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_PARAM_DECL: {
            {
                assert(litaC_false);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NATIVE_DECL: {
            {
                assert(litaC_false);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_DECL: {
            {
                assert(litaC_false);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BLOCK_STMT: {
            {
                litaC_ast__BlockStmt* litaC_stmt = (litaC_ast__BlockStmt*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "{", 1);
                {
                    litaC_cgen__CGen_pushScope(litaC_this, &((litaC_cgen__CGenScope) {
                        
                    }));
                    
                    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)));litaC_i += 1) {
                        {
                            litaC_ast__Stmt* litaC_n = litaC_array__Array_get_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)), litaC_i);
                            litaC_cgen__CGen_emitStmt(litaC_this, litaC_n);
                            if(litaC_ast__IsExpr(&((litaC_n->node)))) {
                                {
                                    litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                                    
                                    
                                }
                                
                            } else {
                                {
                                    litaC_cgen__CGen_emitStrn(litaC_this, "\n", 1);
                                    
                                    
                                }
                            } 
                            
                            
                            
                        }
                    }
                    litaC_cgen__CGen_popScope(litaC_this);
                    
                    
                }
                litaC_cgen__CGen_emitStrn(litaC_this, "\n}", 2);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BREAK_STMT: {
            {
                litaC_cgen__CGen_popLoopScope(litaC_this, litaC_true);
                litaC_cgen__CGen_emitStrn(litaC_this, "break;", 6);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_COMP_STMT: {
            {
                litaC_ast__CompStmt* litaC_stmt = (litaC_ast__CompStmt*)litaC_s;
                litaC_ast__Stmt* litaC_result = litaC_stmt->evaluatedStmt;
                if(litaC_result) {
                    {
                        litaC_cgen__CGen_emitStmt(litaC_this, litaC_result);
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONTINUE_STMT: {
            {
                litaC_cgen__CGen_popLoopScope(litaC_this, litaC_false);
                litaC_cgen__CGen_emitStrn(litaC_this, "continue;", 9);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DEFER_STMT: {
            {
                litaC_ast__DeferStmt* litaC_stmt = (litaC_ast__DeferStmt*)litaC_s;
                if(litaC_array__Array_empty_cb__ptr_Stmt_ce_(&((litaC_this->currentScope->defers)))) {
                    {
                        litaC_array__Array_init_cb__ptr_Stmt_ce_(&((litaC_this->currentScope->defers)), 16, litaC_this->lita->allocator);
                        
                        
                    }
                    
                } 
                
                litaC_array__Array_add_cb__ptr_Stmt_ce_(&((litaC_this->currentScope->defers)), litaC_stmt->deferedStmt);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DO_WHILE_STMT: {
            {
                litaC_ast__DoWhileStmt* litaC_stmt = (litaC_ast__DoWhileStmt*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "do {", 4);
                {
                    litaC_cgen__CGen_pushScope(litaC_this, &((litaC_cgen__CGenScope) {
                        .isLoop = litaC_true
                    }));
                    
                    litaC_cgen__CGen_emitStmt(litaC_this, litaC_stmt->body);
                    if(litaC_ast__IsExpr(&((litaC_stmt->body->node)))) {
                        {
                            litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                            
                            
                        }
                        
                    } 
                    
                    litaC_cgen__CGen_popScope(litaC_this);
                    
                    
                }
                litaC_cgen__CGen_emitStrn(litaC_this, "}\nwhile(", 8);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_stmt->cond->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, ");", 2);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_EMPTY_STMT: {
            {
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_FIELD_ENTRY_DECL: {
            {
                assert(litaC_false);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FOR_STMT: {
            {
                litaC_ast__ForStmt* litaC_stmt = (litaC_ast__ForStmt*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "for(", 4);
                if(litaC_stmt->init) {
                    {
                        litaC_cgen__CGen_emitStmt(litaC_this, litaC_stmt->init);
                        if(litaC_ast__IsExpr(&((litaC_stmt->init->node)))) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } else {
                    {
                        litaC_cgen__CGen_emitStrn(litaC_this, ";", 1);
                        
                        
                    }
                } 
                
                if(litaC_stmt->cond) {
                    {
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_stmt->cond->stmt)));
                        
                        
                    }
                    
                } 
                
                litaC_cgen__CGen_emitStrn(litaC_this, ";", 1);
                if(litaC_stmt->post) {
                    {
                        litaC_cgen__CGen_emitStmt(litaC_this, litaC_stmt->post);
                        
                        
                    }
                    
                } 
                
                litaC_cgen__CGen_emitStrn(litaC_this, ") {", 3);
                if(litaC_stmt->body) {
                    {
                        litaC_cgen__CGen_pushScope(litaC_this, &((litaC_cgen__CGenScope) {
                            .isLoop = litaC_true
                        }));
                        
                        litaC_cgen__CGen_emitStmt(litaC_this, litaC_stmt->body);
                        if(litaC_ast__IsExpr(&((litaC_stmt->body->node)))) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                                
                                
                            }
                            
                        } 
                        
                        litaC_cgen__CGen_popScope(litaC_this);
                        
                        
                    }
                    
                } else {
                    {
                        litaC_cgen__CGen_emitStrn(litaC_this, ";", 1);
                        
                        
                    }
                } 
                
                litaC_cgen__CGen_emitStrn(litaC_this, "}", 1);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_BODY_STMT: {
            {
                litaC_ast__FuncBodyStmt* litaC_stmt = (litaC_ast__FuncBodyStmt*)litaC_s;
                litaC_cgen__CGen_pushScope(litaC_this, &((litaC_cgen__CGenScope) {
                    
                }));
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)));litaC_i += 1) {
                    {
                        litaC_ast__Stmt* litaC_n = litaC_array__Array_get_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)), litaC_i);
                        litaC_cgen__CGen_emitStmt(litaC_this, litaC_n);
                        if(litaC_ast__IsExpr(&((litaC_n->node)))) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, "\n", 1);
                                
                                
                            }
                        } 
                        
                        
                        
                    }
                }
                litaC_cgen__CGen_popScope(litaC_this);
                return;
                
                litaC_cgen__CGen_popScope(litaC_this);
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GOTO_STMT: {
            {
                litaC_ast__GotoStmt* litaC_stmt = (litaC_ast__GotoStmt*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "goto ", 5);
                litaC_cgen__CGen_emitName(litaC_this, litaC_stmt->label);
                litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IF_STMT: {
            {
                litaC_ast__IfStmt* litaC_stmt = (litaC_ast__IfStmt*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "if(", 3);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_stmt->cond->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, ") {", 3);
                {
                    litaC_cgen__CGen_pushScope(litaC_this, &((litaC_cgen__CGenScope) {
                        
                    }));
                    
                    litaC_cgen__CGen_emitStmt(litaC_this, litaC_stmt->then);
                    if(litaC_ast__IsExpr(&((litaC_stmt->then->node)))) {
                        {
                            litaC_cgen__CGen_emitStrn(litaC_this, ";", 1);
                            
                            
                        }
                        
                    } 
                    
                    litaC_cgen__CGen_emitStrn(litaC_this, "\n", 1);
                    litaC_cgen__CGen_popScope(litaC_this);
                    
                    
                }
                litaC_cgen__CGen_emitStrn(litaC_this, "} ", 2);
                if(litaC_stmt->elseStmt) {
                    {
                        litaC_cgen__CGen_emitStrn(litaC_this, "else {", 6);
                        {
                            litaC_cgen__CGen_pushScope(litaC_this, &((litaC_cgen__CGenScope) {
                                
                            }));
                            
                            litaC_cgen__CGen_emitStmt(litaC_this, litaC_stmt->elseStmt);
                            if(litaC_ast__IsExpr(&((litaC_stmt->elseStmt->node)))) {
                                {
                                    litaC_cgen__CGen_emitStrn(litaC_this, ";", 1);
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_cgen__CGen_popScope(litaC_this);
                            
                            
                        }
                        litaC_cgen__CGen_emitStrn(litaC_this, "} ", 2);
                        
                        
                    }
                    
                } 
                
                litaC_cgen__CGen_emitStrn(litaC_this, "\n", 1);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_LABEL_STMT: {
            {
                litaC_ast__LabelStmt* litaC_stmt = (litaC_ast__LabelStmt*)litaC_s;
                litaC_cgen__CGen_emitName(litaC_this, litaC_stmt->label);
                litaC_cgen__CGen_emitStrn(litaC_this, ":;\n", 3);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_MODULE_STMT: {
            {
                assert(litaC_false);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NOTE_STMT: {
            {
                litaC_ast__NoteStmt* litaC_stmt = (litaC_ast__NoteStmt*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "@", 1);
                litaC_cgen__CGen_emitName(litaC_this, litaC_stmt->name);
                if(!(litaC_array__Array_empty_cb_Token_ce_(&((litaC_stmt->attributes))))) {
                    {
                        litaC_cgen__CGen_emitStrn(litaC_this, "(", 1);
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_Token_ce_(&((litaC_stmt->attributes)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    litaC_cgen__CGen_emitStrn(litaC_this, ", ", 2);
                                    
                                } 
                                
                                litaC_cgen__CGen_emitStrn(litaC_this, "'", 1);
                                litaC_cgen__CGen_emitName(litaC_this, litaC_array__Array_get_cb_Token_ce_(&((litaC_stmt->attributes)), litaC_i));
                                litaC_cgen__CGen_emitStrn(litaC_this, "'", 1);
                                
                                
                            }
                        }
                        litaC_cgen__CGen_emitStrn(litaC_this, ")", 1);
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_PARAMETERS_STMT: {
            {
                assert(litaC_false);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_RETURN_STMT: {
            {
                litaC_ast__ReturnStmt* litaC_stmt = (litaC_ast__ReturnStmt*)litaC_s;
                if(litaC_stmt->expr && litaC_stmt->expr->operand.typeInfo != &(litaC_types__VOID_TYPE) && litaC_cgen__CGen_hasPendingDefers(litaC_this)) {
                    {
                        assert(litaC_this->currentFunc != NULL);
                        litaC_cgen__CGen_emit(litaC_this, "{%s = ", litaC_cgen__CGen_cTypeDecl(litaC_this, litaC_this->currentFunc->returnType, "___result", litaC_false));
                        if(!(litaC_cgen__CGen_emitTraitCast(litaC_this, litaC_stmt->expr))) {
                            {
                                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_stmt->expr->stmt)));
                                
                                
                            }
                            
                        } 
                        
                        litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                        litaC_cgen__CGen_emitDefers(litaC_this);
                        litaC_cgen__CGen_emitStr(litaC_this, "return ___result;\n}\n");
                        
                        
                    }
                    
                } else {
                    {
                        litaC_cgen__CGen_emitDefers(litaC_this);
                        litaC_cgen__CGen_emitStrn(litaC_this, "return", 6);
                        if(litaC_stmt->expr) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, " ", 1);
                                if(!(litaC_cgen__CGen_emitTraitCast(litaC_this, litaC_stmt->expr))) {
                                    {
                                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_stmt->expr->stmt)));
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                        
                        
                    }
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SWITCH_CASE_STMT: {
            {
                litaC_ast__SwitchCaseStmt* litaC_stmt = (litaC_ast__SwitchCaseStmt*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "case ", 5);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_stmt->cond->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, ": ", 2);
                litaC_cgen__CGen_emitStmt(litaC_this, litaC_stmt->body);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SWITCH_STMT: {
            {
                litaC_ast__SwitchStmt* litaC_stmt = (litaC_ast__SwitchStmt*)litaC_s;
                litaC_cgen__CGen_pushScope(litaC_this, &((litaC_cgen__CGenScope) {
                    .isSwitch = litaC_true
                }));
                
                litaC_cgen__CGen_emitStrn(litaC_this, "switch(", 7);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_stmt->cond->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, ") {", 3);
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_SwitchCaseStmt_ce_(&((litaC_stmt->cases)));litaC_i += 1) {
                    {
                        if(litaC_i > 0) {
                            litaC_cgen__CGen_emitln(litaC_this);
                            
                        } 
                        
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_array__Array_get_cb__ptr_SwitchCaseStmt_ce_(&((litaC_stmt->cases)), litaC_i)->stmt)));
                        
                        
                    }
                }
                if(litaC_stmt->defaultStmt) {
                    {
                        litaC_cgen__CGen_emitStrn(litaC_this, "\ndefault: ", 10);
                        litaC_cgen__CGen_emitStmt(litaC_this, litaC_stmt->defaultStmt);
                        
                        
                    }
                    
                } 
                
                litaC_cgen__CGen_emitStrn(litaC_this, "}", 1);
                litaC_cgen__CGen_popScope(litaC_this);
                return;
                
                litaC_cgen__CGen_popScope(litaC_this);
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
            {
                litaC_ast__TraitFieldDecl* litaC_decl = (litaC_ast__TraitFieldDecl*)litaC_s;
                litaC_cgen__CGen_emitLineInfo(litaC_this, &((litaC_decl->decl.stmt)));
                litaC_cgen__CGen_emitNotes(litaC_this, &(litaC_decl->decl.attributes), litaC_true);
                litaC_char litaC_name[256];
                litaC_string__String litaC_nameStr = litaC_string__StringInit(litaC_name, litaC_symbols__MAX_SYMBOL_NAME, -(1));
                litaC_string__String_setStrn(&((litaC_nameStr)), litaC_decl->decl.name.value.str.buffer, litaC_decl->decl.name.value.str.length);
                litaC_ast__NoteStmt* litaC_aliasNote = litaC_ast__Decl_getNote(&((litaC_decl->decl)), "alias");
                if(litaC_aliasNote && !(litaC_array__Array_empty_cb_Token_ce_(&((litaC_aliasNote->attributes))))) {
                    {
                        litaC_lex__Token litaC_aliasName = litaC_array__Array_get_cb_Token_ce_(&((litaC_aliasNote->attributes)), 0);
                        litaC_string__String_clear(&((litaC_nameStr)));
                        litaC_string__String_setStrn(&((litaC_nameStr)), litaC_aliasName.value.str.buffer, litaC_aliasName.value.str.length);
                        
                        
                    }
                    
                } 
                
                litaC_cgen__CGen_emitStr(litaC_this, litaC_cgen__CGen_cTypeDecl(litaC_this, litaC_decl->type->typeInfo, litaC_string__String_cStrConst(litaC_nameStr), litaC_false));
                litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_VAR_FIELD_DECL: {
            {
                litaC_ast__VarFieldDecl* litaC_decl = (litaC_ast__VarFieldDecl*)litaC_s;
                litaC_cgen__CGen_emitLineInfo(litaC_this, &((litaC_decl->decl.stmt)));
                litaC_cgen__CGen_emitNotes(litaC_this, &(litaC_decl->decl.attributes), litaC_true);
                litaC_char litaC_name[256];
                litaC_string__String litaC_nameStr = litaC_string__StringInit(litaC_name, litaC_symbols__MAX_SYMBOL_NAME, -(1));
                litaC_string__String_setStrn(&((litaC_nameStr)), litaC_decl->decl.name.value.str.buffer, litaC_decl->decl.name.value.str.length);
                litaC_ast__NoteStmt* litaC_aliasNote = litaC_ast__Decl_getNote(&((litaC_decl->decl)), "alias");
                if(litaC_aliasNote && !(litaC_array__Array_empty_cb_Token_ce_(&((litaC_aliasNote->attributes))))) {
                    {
                        litaC_lex__Token litaC_aliasName = litaC_array__Array_get_cb_Token_ce_(&((litaC_aliasNote->attributes)), 0);
                        litaC_string__String_clear(&((litaC_nameStr)));
                        litaC_string__String_setStrn(&((litaC_nameStr)), litaC_aliasName.value.str.buffer, litaC_aliasName.value.str.length);
                        
                        
                    }
                    
                } 
                
                litaC_cgen__CGen_emitStr(litaC_this, litaC_cgen__CGen_cTypeDecl(litaC_this, litaC_decl->type->typeInfo, litaC_string__String_cStrConst(litaC_nameStr), litaC_false));
                litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_WHILE_STMT: {
            {
                litaC_ast__WhileStmt* litaC_stmt = (litaC_ast__WhileStmt*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "while(", 6);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_stmt->cond->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, ") {", 3);
                {
                    litaC_cgen__CGen_pushScope(litaC_this, &((litaC_cgen__CGenScope) {
                        .isLoop = litaC_true
                    }));
                    
                    litaC_cgen__CGen_emitStmt(litaC_this, litaC_stmt->body);
                    if(litaC_ast__IsExpr(&((litaC_stmt->body->node)))) {
                        {
                            litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                            
                            
                        }
                        
                    } 
                    
                    litaC_cgen__CGen_popScope(litaC_this);
                    
                    
                }
                litaC_cgen__CGen_emitStrn(litaC_this, "}", 1);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ARRAY_DESIGNATION_EXPR: {
            {
                litaC_ast__ArrayDesignationExpr* litaC_expr = (litaC_ast__ArrayDesignationExpr*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "[", 1);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->index->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, "] = ", 4);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->value->stmt)));
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ARRAY_INIT_EXPR: {
            {
                litaC_ast__ArrayInitExpr* litaC_expr = (litaC_ast__ArrayInitExpr*)litaC_s;
                if(litaC_false && litaC_array__Array_empty_cb__ptr_Expr_ce_(&((litaC_expr->values)))) {
                    {
                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "{}", 2);
                        
                        
                    }
                    
                } else {
                    {
                        litaC_bool litaC_requiresCast = litaC_false;
                        if(litaC_expr->expr.stmt.node.parent) {
                            {
                                litaC_requiresCast = litaC_expr->expr.stmt.node.parent->kind == litaC_ast__StmtKind_RETURN_STMT || litaC_expr->expr.stmt.node.parent->kind == litaC_ast__StmtKind_FUNC_CALL_EXPR;
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_requiresCast || !(litaC_expr->expr.expectedType) || litaC_expr->expr.expectedType->kind == litaC_types__TypeKind_PTR) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, "(", 1);
                                litaC_cgen__CGen_emitStr(litaC_this, litaC_cgen__CGen_cType(litaC_this, litaC_expr->type->typeInfo, litaC_false, litaC_false));
                                litaC_cgen__CGen_emitStrn(litaC_this, ")", 1);
                                
                                
                            }
                            
                        } 
                        
                        litaC_cgen__CGen_emitStrn(litaC_this, " {", 2);
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Expr_ce_(&((litaC_expr->values)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    {
                                        litaC_cgen__CGen_emitStrn(litaC_this, ",\n", 2);
                                        
                                        
                                    }
                                    
                                } 
                                
                                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_array__Array_get_cb__ptr_Expr_ce_(&((litaC_expr->values)), litaC_i)->stmt)));
                                
                                
                            }
                        }
                        litaC_cgen__CGen_emitStrn(litaC_this, "}", 1);
                        
                        
                    }
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BINARY_EXPR: {
            {
                litaC_ast__BinaryExpr* litaC_expr = (litaC_ast__BinaryExpr*)litaC_s;
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->left->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, " ", 1);
                litaC_cgen__CGen_emitStr(litaC_this, litaC_lex__tokenText[litaC_expr->operator]);
                litaC_cgen__CGen_emitStrn(litaC_this, " ", 1);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->right->stmt)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BOOLEAN_EXPR: {
            {
                litaC_ast__BooleanExpr* litaC_expr = (litaC_ast__BooleanExpr*)litaC_s;
                litaC_cgen__CGen_emitStr(litaC_this, litaC_this->lita->options->cPrefix);
                if(litaC_expr->boolean) {
                    {
                        litaC_cgen__CGen_emitStrn(litaC_this, "true", 4);
                        
                        
                    }
                    
                } else {
                    {
                        litaC_cgen__CGen_emitStrn(litaC_this, "false", 5);
                        
                        
                    }
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CAST_EXPR: {
            {
                litaC_ast__CastExpr* litaC_expr = (litaC_ast__CastExpr*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "(", 1);
                litaC_cgen__CGen_emitStr(litaC_this, litaC_cgen__CGen_cType(litaC_this, litaC_expr->castTo->typeInfo, litaC_true, litaC_false));
                litaC_cgen__CGen_emitStrn(litaC_this, ")", 1);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->exprToCast->stmt)));
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CHAR_EXPR: {
            {
                litaC_ast__CharExpr* litaC_expr = (litaC_ast__CharExpr*)litaC_s;
                const litaC_char* litaC_c = litaC_cgen__escapeStrings[litaC_expr->character.value.intValue];
                if(litaC_c != 0) {
                    {
                        litaC_string_buffer__StringBuffer_append(&((litaC_this->buf)), "'%s'", litaC_c);
                        
                        
                    }
                    
                } else {
                    {
                        litaC_string_buffer__StringBuffer_append(&((litaC_this->buf)), "'%c'", (litaC_char)litaC_expr->character.value.intValue);
                        
                        
                    }
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_CALL_EXPR: {
            {
                litaC_ast__FuncCallExpr* litaC_expr = (litaC_ast__FuncCallExpr*)litaC_s;
                litaC_types__TypeInfo* litaC_objectType = litaC_expr->object->operand.typeInfo;
                litaC_bool litaC_isTrait = litaC_false;
                if(litaC_objectType->kind == litaC_types__TypeKind_FUNC_PTR) {
                    {
                        litaC_types__FuncPtrTypeInfo* litaC_funcPtr = (litaC_types__FuncPtrTypeInfo*)litaC_objectType;
                        if(litaC_funcPtr->isTrait) {
                            {
                                litaC_isTrait = litaC_true;
                                litaC_cgen__CGen_emitTraitFuncCall(litaC_this, litaC_expr);
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_isTrait)) {
                    {
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->object->stmt)));
                        litaC_cgen__CGen_emitStrn(litaC_this, "(", 1);
                        
                        
                    }
                    
                } 
                
                litaC_i32 litaC_i = 0;
                for(;litaC_i < litaC_array__Array_size_cb_CallArg_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
                    {
                        if(litaC_i > 0) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, ", ", 2);
                                
                                
                            }
                            
                        } 
                        
                        litaC_ast__Expr* litaC_arg = litaC_array__Array_get_cb_CallArg_ce_(&((litaC_expr->arguments)), litaC_i).argExpr;
                        if(!(litaC_cgen__CGen_emitTraitCast(litaC_this, litaC_arg))) {
                            {
                                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_arg->stmt)));
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                if(litaC_objectType->kind == litaC_types__TypeKind_FUNC) {
                    {
                        litaC_types__FuncTypeInfo* litaC_funcType = (litaC_types__FuncTypeInfo*)litaC_objectType;
                        for(;litaC_i < litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcType->decl->params->params)));litaC_i += 1) {
                            {
                                litaC_ast__ParameterDecl* litaC_param = litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcType->decl->params->params)), litaC_i);
                                if(litaC_param->defaultExpr) {
                                    {
                                        if(litaC_i > 0) {
                                            {
                                                litaC_cgen__CGen_emitStrn(litaC_this, ", ", 2);
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_param->defaultExpr->stmt)));
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                litaC_cgen__CGen_emitStrn(litaC_this, ")", 1);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: 
        case litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR: {
            {
                litaC_ast__IdentifierExpr* litaC_expr = (litaC_ast__IdentifierExpr*)litaC_s;
                litaC_types__TypeInfo* litaC_type = litaC_expr->type->spec.typeInfo;
                litaC_symbols__Symbol* litaC_sym = ((litaC_type)) ? litaC_type->sym : litaC_expr->sym;
                if(!(litaC_sym)) {
                    {
                        litaC_cgen__CGen_emitStr(litaC_this, litaC_this->lita->options->cPrefix);
                        litaC_cgen__CGen_emitStr(litaC_this, litaC_expr->type->name);
                        
                        
                    }
                    
                } else {
                    {
                        litaC_cgen__CGen_emitSymbol(litaC_this, litaC_sym);
                        
                        
                    }
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GET_EXPR: {
            {
                litaC_ast__GetExpr* litaC_expr = (litaC_ast__GetExpr*)litaC_s;
                if(litaC_expr->flags & litaC_ast__GetExprFlags_IS_METHOD_CALL) {
                    {
                        litaC_cgen__CGen_emitStr(litaC_this, litaC_cgen__CGen_cTypeName(litaC_this, litaC_expr->field->expr.operand.typeInfo));
                        return;
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__TypeInfo* litaC_objectType = litaC_expr->object->operand.typeInfo;
                if(litaC_expr->flags & litaC_ast__GetExprFlags_IS_ENUM) {
                    {
                        if(litaC_objectType->sym && litaC_objectType->sym->flags & litaC_symbols__SymbolFlags_IS_FOREIGN) {
                            {
                                litaC_string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), litaC_expr->field->type->name);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), litaC_cgen__CGen_cName(litaC_this, litaC_objectType->sym));
                                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "_", 1);
                                litaC_string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), litaC_expr->field->type->name);
                                
                                
                            }
                        } 
                        
                        return;
                        
                        
                        
                    }
                    
                } 
                
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->object->stmt)));
                if(!(litaC_types__IsAggregateLike(litaC_objectType))) {
                    {
                        if(litaC_objectType->kind == litaC_types__TypeKind_PTR) {
                            {
                                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "->", 2);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ".", 1);
                                
                                
                            }
                        } 
                        
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->field->expr.stmt)));
                        return;
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__TypeInfo* litaC_baseInfo = litaC_types__TypeInfo_getBaseType(litaC_objectType);
                assert(litaC_baseInfo != NULL);
                assert(litaC_types__IsAggregate(litaC_baseInfo));
                litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_baseInfo;
                if(litaC_expr->flags & litaC_ast__GetExprFlags_IS_USING) {
                    {
                        litaC_types__FieldPath litaC_path =  {
                            
                        };
                        litaC_bool litaC_isFound = litaC_types__AggregateTypeInfo_getFieldPath(litaC_aggInfo, litaC_expr->field->type->name, &(litaC_path));
                        assert(litaC_isFound);
                        litaC_types__TypeInfo* litaC_nextType = litaC_objectType;
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_path.numOfFields;litaC_i += 1) {
                            {
                                litaC_ast__FieldStmt litaC_field = litaC_path.fields[litaC_i];
                                if(litaC_nextType->kind == litaC_types__TypeKind_PTR) {
                                    {
                                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "->", 2);
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ".", 1);
                                        
                                        
                                    }
                                } 
                                
                                litaC_cgen__CGen_emitFieldName(litaC_this, litaC_field);
                                litaC_nextType = litaC_field.typeInfo;
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } else {
                    {
                        if(litaC_objectType->kind == litaC_types__TypeKind_PTR) {
                            {
                                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "->", 2);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ".", 1);
                                
                                
                            }
                        } 
                        
                        litaC_ast__FieldStmt litaC_field = litaC_types__AggregateTypeInfo_getField(litaC_aggInfo, litaC_expr->field->type->name);
                        if(litaC_baseInfo->kind == litaC_types__TypeKind_TRAIT) {
                            {
                                litaC_cgen__CGen_emit(litaC_this, "__vtable->");
                                
                                
                            }
                            
                        } 
                        
                        litaC_cgen__CGen_emitFieldName(litaC_this, litaC_field);
                        
                        
                    }
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GROUP_EXPR: {
            {
                litaC_ast__GroupExpr* litaC_expr = (litaC_ast__GroupExpr*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "(", 1);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->groupedExpr->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, ")", 1);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_INIT_ARG_EXPR: {
            {
                litaC_ast__InitArgExpr* litaC_expr = (litaC_ast__InitArgExpr*)litaC_s;
                if(litaC_expr->fieldName.type == litaC_lex__TokenType_IDENTIFIER) {
                    {
                        litaC_ast__Node* litaC_parentExpr = litaC_expr->expr.stmt.node.parent;
                        assert(litaC_parentExpr && litaC_parentExpr->kind == litaC_ast__StmtKind_INIT_EXPR);
                        litaC_types__TypeInfo* litaC_objectType = ((litaC_ast__InitExpr*)litaC_parentExpr)->type->spec.typeInfo;
                        assert(litaC_objectType != NULL);
                        assert(litaC_types__IsAggregateLike(litaC_objectType));
                        litaC_types__TypeInfo* litaC_baseInfo = litaC_types__TypeInfo_getBaseType(litaC_objectType);
                        assert(litaC_baseInfo != NULL);
                        assert(litaC_baseInfo->kind == litaC_types__TypeKind_STRUCT || litaC_baseInfo->kind == litaC_types__TypeKind_UNION);
                        litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_baseInfo;
                        litaC_ast__FieldStmt litaC_field = litaC_types__AggregateTypeInfo_getField(litaC_aggInfo, litaC_lex__Token_asString(&((litaC_expr->fieldName))));
                        if(litaC_field.kind == litaC_ast__StmtKind_VAR_FIELD_DECL) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, ".", 1);
                                litaC_cgen__CGen_emitFieldName(litaC_this, litaC_field);
                                litaC_cgen__CGen_emitStrn(litaC_this, " = ", 3);
                                
                                
                            }
                            
                        } else {
                            if(litaC_field.kind == litaC_ast__StmtKind_STRUCT_FIELD_DECL || litaC_field.kind == litaC_ast__StmtKind_UNION_FIELD_DECL) {
                                {
                                    litaC_ast__AggregateDecl* litaC_decl = litaC_field.aggregateField;
                                    litaC_cgen__CGen_emitStrn(litaC_this, ".", 1);
                                    litaC_cgen__CGen_emitName(litaC_this, litaC_decl->decl.declaration.name);
                                    litaC_cgen__CGen_emitStrn(litaC_this, " = ", 3);
                                    
                                    
                                }
                                
                            } else {
                                if(litaC_field.kind == litaC_ast__StmtKind_ENUM_FIELD_DECL) {
                                    {
                                        litaC_ast__EnumDecl* litaC_decl = litaC_field.enumField;
                                        litaC_cgen__CGen_emitStrn(litaC_this, ".", 1);
                                        litaC_cgen__CGen_emitName(litaC_this, litaC_decl->decl.name);
                                        litaC_cgen__CGen_emitStrn(litaC_this, " = ", 3);
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        assert(litaC_false);
                                        
                                        
                                    }
                                } 
                                
                            } 
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_cgen__CGen_emitTraitCast(litaC_this, litaC_expr->value))) {
                    {
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->value->stmt)));
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_INIT_EXPR: {
            {
                litaC_ast__InitExpr* litaC_expr = (litaC_ast__InitExpr*)litaC_s;
                litaC_bool litaC_requiresCast = litaC_false;
                if(litaC_expr->expr.stmt.node.parent) {
                    {
                        litaC_requiresCast = litaC_expr->expr.stmt.node.parent->kind == litaC_ast__StmtKind_RETURN_STMT || litaC_expr->expr.stmt.node.parent->kind == litaC_ast__StmtKind_FUNC_CALL_EXPR;
                        
                        
                    }
                    
                } 
                
                if(litaC_requiresCast || !(litaC_expr->expr.expectedType) || litaC_expr->expr.expectedType->kind == litaC_types__TypeKind_PTR) {
                    {
                        litaC_cgen__CGen_emitStrn(litaC_this, "(", 1);
                        litaC_cgen__CGen_emitStr(litaC_this, litaC_cgen__CGen_cType(litaC_this, litaC_expr->type->spec.typeInfo, litaC_false, litaC_false));
                        litaC_cgen__CGen_emitStrn(litaC_this, ")", 1);
                        
                        
                    }
                    
                } 
                
                litaC_cgen__CGen_emitStrn(litaC_this, " {", 2);
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
                    {
                        if(litaC_i > 0) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, ",\n", 2);
                                
                                
                            }
                            
                        } 
                        
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_array__Array_get_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)), litaC_i)->expr.stmt)));
                        
                        
                    }
                }
                litaC_cgen__CGen_emitStrn(litaC_this, "}", 1);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NULL_EXPR: {
            {
                litaC_cgen__CGen_emitStrn(litaC_this, "NULL", 4);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NUMBER_EXPR: {
            {
                litaC_ast__NumberExpr* litaC_expr = (litaC_ast__NumberExpr*)litaC_s;
                litaC_bool litaC_hasDecimal = litaC_false;
                litaC_bool litaC_isHex = litaC_false;
                litaC_bool litaC_isBin = litaC_false;
                litaC_usize litaC_length = litaC_expr->expr.stmt.node.startPos.end - litaC_expr->expr.stmt.node.startPos.start;
                const litaC_char* litaC_start = litaC_expr->expr.stmt.node.startPos.start;
                if(litaC_length > 2) {
                    {
                        litaC_char litaC_first = litaC_expr->expr.stmt.node.startPos.start[0];
                        litaC_i32 litaC_second = tolower(litaC_expr->expr.stmt.node.startPos.start[1]);
                        if(litaC_first == '0' && litaC_second == 'x') {
                            {
                                litaC_isHex = litaC_true;
                                
                                
                            }
                            
                        } else {
                            if(litaC_first == '0' && litaC_second == 'b') {
                                {
                                    litaC_isBin = litaC_true;
                                    
                                    
                                }
                                
                            } 
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                for(;litaC_start != litaC_expr->expr.stmt.node.startPos.end;litaC_start += 1) {
                    {
                        litaC_char litaC_c = *(litaC_start);
                        if(litaC_c == '.') {
                            {
                                litaC_hasDecimal = litaC_true;
                                
                                
                            }
                            
                        } else {
                            if(litaC_c == '_') {
                                {
                                    continue;
                                    
                                    
                                }
                                
                            } else {
                                if(isalpha(litaC_c)) {
                                    {
                                        if(!(litaC_isHex) && !(litaC_isBin)) {
                                            {
                                                break;
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        if(litaC_isHex) {
                                            {
                                                litaC_c = tolower(litaC_c);
                                                if(litaC_c != 'a' && litaC_c != 'b' && litaC_c != 'c' && litaC_c != 'd' && litaC_c != 'e' && litaC_c != 'f' && litaC_c != 'x') {
                                                    {
                                                        break;
                                                        
                                                        
                                                    }
                                                    
                                                } 
                                                
                                                
                                                
                                            }
                                            
                                        } else {
                                            if(litaC_isBin) {
                                                {
                                                    litaC_c = tolower(litaC_c);
                                                    if(litaC_c != 'b') {
                                                        {
                                                            break;
                                                            
                                                            
                                                        }
                                                        
                                                    } 
                                                    
                                                    
                                                    
                                                }
                                                
                                            } else {
                                                {
                                                    break;
                                                    
                                                    
                                                }
                                            } 
                                            
                                        } 
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                            } 
                            
                        } 
                        
                        litaC_string_buffer__StringBuffer_appendChar(&((litaC_this->buf)), *(litaC_start));
                        
                        
                    }
                }
                litaC_types__TypeInfo* litaC_type = litaC_expr->expr.operand.typeInfo;
                if(!(litaC_isHex) && !(litaC_isBin)) {
                    {
                        switch(litaC_type->kind) {
                            case litaC_types__TypeKind_F32: {
                                {
                                    if(!(litaC_hasDecimal)) {
                                        {
                                            litaC_cgen__CGen_emitStrn(litaC_this, ".", 1);
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    litaC_cgen__CGen_emitStrn(litaC_this, "f", 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_types__TypeKind_U8: 
                            case litaC_types__TypeKind_U16: 
                            case litaC_types__TypeKind_U32: {
                                {
                                    litaC_cgen__CGen_emitStrn(litaC_this, "U", 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_types__TypeKind_U64: {
                                {
                                    litaC_cgen__CGen_emitStrn(litaC_this, "UL", 2);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_types__TypeKind_I64: {
                                {
                                    litaC_cgen__CGen_emitStrn(litaC_this, "L", 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            default: {
                                {
                                    
                                    
                                }
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_OFFSET_OF_EXPR: {
            {
                litaC_ast__OffsetOfExpr* litaC_expr = (litaC_ast__OffsetOfExpr*)litaC_s;
                litaC_cgen__CGen_emit(litaC_this, "offsetof(%s, %.*s)", litaC_cgen__CGen_cType(litaC_this, litaC_expr->type->typeInfo, litaC_false, litaC_false), litaC_expr->field.value.str.length, litaC_expr->field.value.str.buffer);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SET_EXPR: {
            {
                litaC_ast__SetExpr* litaC_expr = (litaC_ast__SetExpr*)litaC_s;
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->object->stmt)));
                litaC_types__TypeInfo* litaC_objectType = litaC_expr->object->operand.typeInfo;
                if(litaC_expr->flags & litaC_ast__GetExprFlags_IS_USING) {
                    {
                        litaC_types__TypeInfo* litaC_baseInfo = litaC_types__TypeInfo_getBaseType(litaC_objectType);
                        assert(litaC_baseInfo != NULL);
                        assert(litaC_baseInfo->kind == litaC_types__TypeKind_STRUCT || litaC_baseInfo->kind == litaC_types__TypeKind_UNION);
                        litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_baseInfo;
                        litaC_types__FieldPath litaC_path =  {
                            
                        };
                        litaC_bool litaC_isFound = litaC_types__AggregateTypeInfo_getFieldPath(litaC_aggInfo, litaC_expr->field->type->name, &(litaC_path));
                        assert(litaC_isFound);
                        litaC_types__TypeInfo* litaC_nextType = litaC_objectType;
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_path.numOfFields;litaC_i += 1) {
                            {
                                litaC_ast__FieldStmt litaC_field = litaC_path.fields[litaC_i];
                                if(litaC_nextType->kind == litaC_types__TypeKind_PTR) {
                                    {
                                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "->", 2);
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ".", 1);
                                        
                                        
                                    }
                                } 
                                
                                litaC_cgen__CGen_emitStrn(litaC_this, litaC_field.varField->decl.name.value.str.buffer, litaC_field.varField->decl.name.value.str.length);
                                litaC_nextType = litaC_field.typeInfo;
                                
                                
                            }
                        }
                        litaC_cgen__CGen_emit(litaC_this, " %s ", litaC_lex__tokenText[litaC_expr->operator]);
                        
                        
                    }
                    
                } else {
                    {
                        if(litaC_objectType->kind == litaC_types__TypeKind_PTR) {
                            {
                                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "->", 2);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ".", 1);
                                
                                
                            }
                        } 
                        
                        litaC_string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), litaC_expr->field->type->name);
                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), " ", 1);
                        litaC_string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), litaC_lex__tokenText[litaC_expr->operator]);
                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), " ", 1);
                        
                        
                    }
                } 
                
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->value->stmt)));
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SIZE_OF_EXPR: {
            {
                litaC_ast__SizeOfExpr* litaC_expr = (litaC_ast__SizeOfExpr*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "sizeof(", 7);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->sizeOfExpr->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, ")", 1);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_STRING_EXPR: {
            {
                litaC_ast__StringExpr* litaC_expr = (litaC_ast__StringExpr*)litaC_s;
                if(litaC_expr->string.mod == litaC_lex__Mod_MULTISTR) {
                    {
                        litaC_string_buffer__StringBuffer_appendChar(&((litaC_this->buf)), '"');
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_expr->string.value.str.length;litaC_i += 1) {
                            {
                                litaC_char litaC_c = litaC_expr->string.value.str.buffer[litaC_i];
                                const litaC_char* litaC_escaped = litaC_cgen__escapeStrings[(litaC_u32)litaC_c];
                                if(litaC_escaped) {
                                    {
                                        litaC_string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), litaC_escaped);
                                        continue;
                                        
                                        
                                    }
                                    
                                } 
                                
                                if(litaC_c == '\\') {
                                    {
                                        litaC_u32 litaC_n = (litaC_u32)litaC_expr->string.value.str.buffer[litaC_i + 1];
                                        const litaC_char* litaC_escapedChar = litaC_cgen__escapeChars[litaC_n];
                                        if(litaC_escapedChar) {
                                            {
                                                const litaC_char* litaC_chars = litaC_cgen__escapeChars[litaC_n];
                                                assert(litaC_chars);
                                                litaC_string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), litaC_chars);
                                                litaC_i += 1;
                                                continue;
                                                
                                                
                                            }
                                            
                                        } else {
                                            {
                                                litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "\\", 1);
                                                
                                                
                                            }
                                        } 
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                if(litaC_c == '"') {
                                    {
                                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "\\", 1);
                                        
                                        
                                    }
                                    
                                } 
                                
                                litaC_string_buffer__StringBuffer_appendChar(&((litaC_this->buf)), litaC_c);
                                
                                
                            }
                        }
                        litaC_string_buffer__StringBuffer_appendChar(&((litaC_this->buf)), '"');
                        
                        
                    }
                    
                } else {
                    {
                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "\"", 1);
                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), litaC_expr->string.value.str.buffer, litaC_expr->string.value.str.length);
                        litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "\"", 1);
                        
                        
                    }
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_GET_EXPR: {
            {
                litaC_ast__SubscriptGetExpr* litaC_expr = (litaC_ast__SubscriptGetExpr*)litaC_s;
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->object->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, "[", 1);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->index->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, "]", 1);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_SET_EXPR: {
            {
                litaC_ast__SubscriptSetExpr* litaC_expr = (litaC_ast__SubscriptSetExpr*)litaC_s;
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->object->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, "[", 1);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->index->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, "] ", 2);
                litaC_cgen__CGen_emitStr(litaC_this, litaC_lex__tokenText[litaC_expr->operator]);
                litaC_cgen__CGen_emitStrn(litaC_this, " ", 1);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->value->stmt)));
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TERNARY_EXPR: {
            {
                litaC_ast__TernaryExpr* litaC_expr = (litaC_ast__TernaryExpr*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "(", 1);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->cond->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, ") ? ", 4);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->then->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, " : ", 3);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->other->stmt)));
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPE_IDENTIFIER_EXPR: {
            {
                litaC_ast__TypeIdentifierExpr* litaC_expr = (litaC_ast__TypeIdentifierExpr*)litaC_s;
                if(litaC_expr->type->typeInfo) {
                    {
                        litaC_cgen__CGen_emitStr(litaC_this, litaC_cgen__CGen_cType(litaC_this, litaC_expr->type->typeInfo, litaC_false, litaC_false));
                        
                        
                    }
                    
                } else {
                    {
                        if(litaC_expr->sym) {
                            {
                                litaC_cgen__CGen_emitSymbol(litaC_this, litaC_expr->sym);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_cgen__CGen_emitTypeSpec(litaC_this, litaC_expr->type);
                                
                                
                            }
                        } 
                        
                        
                        
                    }
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPE_OF_EXPR: {
            {
                litaC_ast__TypeOfExpr* litaC_expr = (litaC_ast__TypeOfExpr*)litaC_s;
                if(litaC_expr->typeOfExpr) {
                    {
                        litaC_cgen__CGen_emit(litaC_this, "%lldLL", litaC_expr->typeOfExpr->operand.typeInfo->typeid);
                        
                        
                    }
                    
                } else {
                    if(litaC_expr->type) {
                        {
                            litaC_cgen__CGen_emit(litaC_this, "%lldLL", litaC_expr->type->typeInfo->typeid);
                            
                            
                        }
                        
                    } 
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNARY_EXPR: {
            {
                litaC_ast__UnaryExpr* litaC_expr = (litaC_ast__UnaryExpr*)litaC_s;
                litaC_cgen__CGen_emitStr(litaC_this, litaC_lex__tokenText[litaC_expr->operator]);
                litaC_cgen__CGen_emitStrn(litaC_this, "(", 1);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->unaryExpr->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, ")", 1);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_EXPR: {
            {
                assert(litaC_false);
                return;
                
                
                
            }
            
            
        }
        default: {
            {
                litaC_cgen__CGen_emit(litaC_this, "<%s Not Implemented>", litaC_ast__StmtKindAsStr(litaC_s->node.kind));
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    
}

litaC_void litaC_dependency_graph__DependencyGraph_init(litaC_dependency_graph__DependencyGraph* litaC_this,litaC_lita__Lita* litaC_lita) {
    litaC_symbols__ProgramSymbols* litaC_symbols = &(litaC_lita->programSymbols);
    litaC_this->lita = litaC_lita;
    litaC_array__Array_init_cb__ptr_Symbol_ce_(&((litaC_this->sortedPrimitives)), litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_symbols->values))), litaC_lita->allocator);
    litaC_array__Array_init_cb__ptr_Symbol_ce_(&((litaC_this->sortedGlobals)), litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_symbols->values))), litaC_lita->allocator);
    litaC_array__Array_init_cb__ptr_Symbol_ce_(&((litaC_this->sortedAggregates)), litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_symbols->symbolTypes))), litaC_lita->allocator);
    litaC_array__Array_init_cb__ptr_Symbol_ce_(&((litaC_this->sortedFuncs)), litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_symbols->symbolFuncs))), litaC_lita->allocator);
    litaC_array__Array_init_cb__ptr_Symbol_ce_(&((litaC_this->sortedSymbols)), litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_symbols->values))) + litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_symbols->symbolTypes))) + litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_symbols->symbolFuncs))), litaC_lita->allocator);
    litaC_map__Map_init_cb__ptr_Symbol_c_Dependency_ce_(&((litaC_this->dependencies)), litaC_dependency_graph__EmptyDependency, litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_symbols->symbolTypes))), litaC_map__PtrHashFn_cb__ptr_Symbol_ce_, litaC_map__PtrEqualFn_cb__ptr_Symbol_ce_, litaC_lita->allocator, 0);
    
}

litaC_void litaC_dependency_graph__DependencyGraph_markDependencies(litaC_dependency_graph__DependencyGraph* litaC_this,litaC_dependency_graph__Dependency* litaC_dependency) {
    assert(litaC_dependency != NULL);
    assert(litaC_dependency->sym != NULL);
    assert(litaC_dependency->state != litaC_dependency_graph__State_RESOLVED);
    litaC_symbols__Symbol* litaC_sym = litaC_dependency->sym;
    if(!(litaC_types__IsAggregate(litaC_sym->type))) {
        {
            litaC_dependency->state = litaC_dependency_graph__State_RESOLVED;
            return;
            
            
            
        }
        
    } 
    
    litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_sym->type;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_aggInfo->decl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_aggInfo->decl->fields)), litaC_i);
            assert(litaC_field.typeInfo != NULL);
            litaC_symbols__Symbol* litaC_dependentSym = NULL;
            if(litaC_types__IsAggregate(litaC_field.typeInfo)) {
                {
                    litaC_dependentSym = litaC_field.typeInfo->sym;
                    
                    
                }
                
            } else {
                if(litaC_field.typeInfo->kind == litaC_types__TypeKind_ARRAY) {
                    {
                        litaC_types__ArrayTypeInfo* litaC_arrayInfo = (litaC_types__ArrayTypeInfo*)litaC_field.typeInfo;
                        litaC_types__TypeInfo* litaC_baseInfo = litaC_types__TypeInfo_getBaseType(&((litaC_arrayInfo->info)));
                        if(litaC_types__IsAggregate(litaC_baseInfo)) {
                            {
                                litaC_dependentSym = litaC_baseInfo->sym;
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            if(litaC_dependentSym) {
                {
                    litaC_dependency_graph__Dependency* litaC_other = litaC_map__Map_getPtr_cb__ptr_Symbol_c_Dependency_ce_(&((litaC_this->dependencies)), litaC_dependentSym);
                    assert(litaC_other != NULL);
                    litaC_array__Array_add_cb__ptr_Dependency_ce_(&((litaC_dependency->dependsOn)), litaC_other);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    
}

litaC_void litaC_dependency_graph__DependencyGraph_buildGraph(litaC_dependency_graph__DependencyGraph* litaC_this,litaC_symbols__ProgramSymbols* litaC_program) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_program->values)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_program->values)), litaC_i);
            if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_CONSTANT && litaC_types__IsPrimitive(litaC_sym->type)) {
                {
                    litaC_array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->sortedPrimitives)), litaC_sym);
                    
                    
                }
                
            } else {
                {
                    litaC_array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->sortedGlobals)), litaC_sym);
                    
                    
                }
            } 
            
            
            
        }
    }
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_program->symbolFuncs)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_program->symbolFuncs)), litaC_i);
            if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            litaC_array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->sortedFuncs)), litaC_sym);
            
            
        }
    }
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_program->symbolTypes)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_program->symbolTypes)), litaC_i);
            if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            litaC_dependency_graph__Dependency litaC_dep =  {
                .state = litaC_dependency_graph__State_PENDING,
                .sym = litaC_sym
            };
            litaC_array__Array_init_cb__ptr_Dependency_ce_(&((litaC_dep.dependsOn)), 64, litaC_this->lita->allocator);
            litaC_map__Map_put_cb__ptr_Symbol_c_Dependency_ce_(&((litaC_this->dependencies)), litaC_sym, litaC_dep);
            
            
        }
    }
    for(litaC_map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_ litaC_it = litaC_map__Map_iter_cb__ptr_Symbol_c_Dependency_ce_(&((litaC_this->dependencies)));litaC_map__MapIterator_hasNext_cb__ptr_Symbol_c_Dependency_ce_(&((litaC_it)));) {
        {
            litaC_map__MapEntry_cb__ptr_Symbol_c_Dependency_ce_ litaC_entry = litaC_map__MapIterator_next_cb__ptr_Symbol_c_Dependency_ce_(&((litaC_it)));
            litaC_dependency_graph__Dependency* litaC_dep = litaC_entry.valuePtr;
            litaC_dependency_graph__DependencyGraph_markDependencies(litaC_this, litaC_dep);
            
            
        }
    }
    
}

litaC_dependency_graph__Dependency* litaC_dependency_graph__DependencyGraph_resolveDependency(litaC_dependency_graph__DependencyGraph* litaC_this,litaC_dependency_graph__Dependency* litaC_dependency) {
    if(litaC_dependency->state == litaC_dependency_graph__State_RESOLVED) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Dependency_ce_(&((litaC_dependency->dependsOn)));litaC_i += 1) {
        {
            litaC_dependency_graph__Dependency* litaC_dep = litaC_array__Array_get_cb__ptr_Dependency_ce_(&((litaC_dependency->dependsOn)), litaC_i);
            if(litaC_dep->state != litaC_dependency_graph__State_RESOLVED) {
                {
                    return litaC_dep;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_dependency->state = litaC_dependency_graph__State_RESOLVED;
    litaC_array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->sortedAggregates)), litaC_dependency->sym);
    return NULL;
    
    
}

litaC_void litaC_dependency_graph__DependencyGraph_sortAggregates(litaC_dependency_graph__DependencyGraph* litaC_this) {
    litaC_array__Array_cb__ptr_Dependency_ce_ litaC_pending =  {
        
    };
    litaC_array__Array_init_cb__ptr_Dependency_ce_(&((litaC_pending)), litaC_map__Map_size_cb__ptr_Symbol_c_Dependency_ce_(&((litaC_this->dependencies))), litaC_this->lita->allocator);
    for(litaC_map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_ litaC_it = litaC_map__Map_iter_cb__ptr_Symbol_c_Dependency_ce_(&((litaC_this->dependencies)));litaC_map__MapIterator_hasNext_cb__ptr_Symbol_c_Dependency_ce_(&((litaC_it)));) {
        {
            litaC_map__MapEntry_cb__ptr_Symbol_c_Dependency_ce_ litaC_entry = litaC_map__MapIterator_next_cb__ptr_Symbol_c_Dependency_ce_(&((litaC_it)));
            litaC_dependency_graph__Dependency* litaC_dep = litaC_entry.valuePtr;
            if(litaC_dependency_graph__DependencyGraph_resolveDependency(litaC_this, litaC_dep) != NULL) {
                {
                    litaC_array__Array_add_cb__ptr_Dependency_ce_(&((litaC_pending)), litaC_dep);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_pending = litaC_dependency_graph__DependencyGraph_sortAggregatesDependencies(litaC_this, &((litaC_pending)));
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Dependency_ce_(&((litaC_pending)));litaC_i += 1) {
        {
            litaC_dependency_graph__Dependency* litaC_dep = litaC_array__Array_get_cb__ptr_Dependency_ce_(&((litaC_pending)), litaC_i);
            litaC_dependency_graph__Dependency* litaC_cause = litaC_dependency_graph__DependencyGraph_resolveDependency(litaC_this, litaC_dep);
            if(litaC_cause) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_dep->sym->decl->stmt.node.startPos, "could not resolve dependency order for '%s' because of cyclic dependency with '%s'", litaC_dep->sym->name, litaC_cause->sym->name);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    
}

litaC_array__Array_cb__ptr_Dependency_ce_ litaC_dependency_graph__DependencyGraph_sortAggregatesDependencies(litaC_dependency_graph__DependencyGraph* litaC_this,litaC_array__Array_cb__ptr_Dependency_ce_* litaC_deps) {
    litaC_array__Array_cb__ptr_Dependency_ce_ litaC_pending =  {
        
    };
    litaC_bool litaC_isInit = litaC_false;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Dependency_ce_(litaC_deps);litaC_i += 1) {
        {
            litaC_dependency_graph__Dependency* litaC_dep = litaC_array__Array_get_cb__ptr_Dependency_ce_(litaC_deps, litaC_i);
            if(litaC_dependency_graph__DependencyGraph_resolveDependency(litaC_this, litaC_dep) != NULL) {
                {
                    litaC_array__Array_cb__ptr_Dependency_ce_ litaC_result = litaC_dependency_graph__DependencyGraph_sortAggregatesDependencies(litaC_this, &((litaC_dep->dependsOn)));
                    if(!(litaC_array__Array_empty_cb__ptr_Dependency_ce_(&((litaC_result))))) {
                        {
                            if(!(litaC_isInit)) {
                                {
                                    litaC_array__Array_init_cb__ptr_Dependency_ce_(&((litaC_pending)), litaC_array__Array_size_cb__ptr_Dependency_ce_(litaC_deps), litaC_this->lita->allocator);
                                    litaC_isInit = litaC_true;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_array__Array_addAll_cb__ptr_Dependency_ce_(&((litaC_pending)), &((litaC_result)));
                    if(litaC_dependency_graph__DependencyGraph_resolveDependency(litaC_this, litaC_dep) != NULL) {
                        {
                            if(!(litaC_isInit)) {
                                {
                                    litaC_array__Array_init_cb__ptr_Dependency_ce_(&((litaC_pending)), litaC_array__Array_size_cb__ptr_Dependency_ce_(litaC_deps), litaC_this->lita->allocator);
                                    litaC_isInit = litaC_true;
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_array__Array_add_cb__ptr_Dependency_ce_(&((litaC_pending)), litaC_dep);
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_pending;
    
    
}

litaC_array__Array_cb__ptr_Symbol_ce_ litaC_dependency_graph__DependencyGraph_sort(litaC_dependency_graph__DependencyGraph* litaC_this) {
    litaC_dependency_graph__DependencyGraph_buildGraph(litaC_this, &((litaC_this->lita->programSymbols)));
    litaC_dependency_graph__DependencyGraph_sortAggregates(litaC_this);
    litaC_array__Array_clear_cb__ptr_Symbol_ce_(&((litaC_this->sortedSymbols)));
    litaC_array__Array_addAll_cb__ptr_Symbol_ce_(&((litaC_this->sortedSymbols)), &((litaC_this->sortedPrimitives)));
    litaC_array__Array_addAll_cb__ptr_Symbol_ce_(&((litaC_this->sortedSymbols)), &((litaC_this->sortedAggregates)));
    litaC_array__Array_addAll_cb__ptr_Symbol_ce_(&((litaC_this->sortedSymbols)), &((litaC_this->sortedGlobals)));
    litaC_array__Array_addAll_cb__ptr_Symbol_ce_(&((litaC_this->sortedSymbols)), &((litaC_this->sortedFuncs)));
    return litaC_this->sortedSymbols;
    
    
}

litaC_void litaC_cgen_decl__CGen_emitVarDecl(litaC_cgen__CGen* litaC_this,litaC_ast__VarDecl* litaC_decl) {
    assert(litaC_decl->decl.sym != NULL);
    if(litaC_decl->decl.sym->flags & litaC_symbols__SymbolFlags_IS_FOREIGN) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_decl->decl.sym->flags |= litaC_symbols__SymbolFlags_IS_EMITTED;
    litaC_cgen__CGen_emitNotes(litaC_this, &((litaC_decl->decl.attributes)), litaC_true);
    litaC_cgen__CGen_emitLineInfo(litaC_this, &((litaC_decl->decl.stmt)));
    const litaC_char* litaC_name = litaC_cgen__CGen_cName(litaC_this, litaC_decl->decl.sym);
    if(litaC_decl->decl.sym->flags & litaC_symbols__SymbolFlags_IS_CONSTANT && litaC_ast__Expr_isConstExpr(litaC_decl->expr)) {
        {
            assert(litaC_decl->expr != NULL);
            litaC_string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), "\n#define ");
            litaC_cgen__CGen_emitStr(litaC_this, litaC_name);
            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), " (", 2);
            litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_decl->expr->stmt)));
            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ")", 1);
            if(litaC_decl->decl.sym->flags & litaC_symbols__SymbolFlags_IS_LOCAL) {
                {
                    if(litaC_array__Array_empty_cb__ptr_const_char_ce_(&((litaC_this->currentScope->constDefs)))) {
                        {
                            litaC_array__Array_init_cb__ptr_const_char_ce_(&((litaC_this->currentScope->constDefs)), 16, litaC_this->lita->allocator);
                            
                            
                        }
                        
                    } 
                    
                    litaC_array__Array_add_cb__ptr_const_char_ce_(&((litaC_this->currentScope->constDefs)), litaC_name);
                    
                    
                }
                
            } 
            
            
            
        }
        
    } else {
        {
            litaC_string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), litaC_cgen__CGen_cTypeDecl(litaC_this, litaC_decl->decl.sym->type, litaC_name, litaC_false));
            if(litaC_decl->expr) {
                {
                    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), " = ", 3);
                    if(!(litaC_cgen__CGen_emitTraitCast(litaC_this, litaC_decl->expr))) {
                        {
                            litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_decl->expr->stmt)));
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ";", 1);
            
            
        }
    } 
    
    
}

litaC_void litaC_cgen_decl__CGen_emitFuncDeclSignature(litaC_cgen__CGen* litaC_this,litaC_ast__FuncDecl* litaC_decl,const litaC_char* litaC_name) {
    assert(litaC_decl->decl.declaration.sym != NULL);
    if(litaC_decl->decl.declaration.sym->flags & litaC_symbols__SymbolFlags_IS_FOREIGN) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_cgen__CGen_emitNotes(litaC_this, &((litaC_decl->decl.declaration.attributes)), litaC_true);
    litaC_cgen__CGen_emitLineInfo(litaC_this, &((litaC_decl->decl.declaration.stmt)));
    litaC_types__FuncTypeInfo* litaC_funcInfo = (litaC_types__FuncTypeInfo*)litaC_decl->decl.declaration.sym->type;
    if(litaC_funcInfo->returnType->kind == litaC_types__TypeKind_FUNC_PTR) {
        {
            litaC_types__FuncPtrTypeInfo* litaC_funcPtrInfo = (litaC_types__FuncPtrTypeInfo*)litaC_funcInfo->returnType;
            litaC_string_buffer__StringBuffer_append(&((litaC_this->buf)), "%s (*%s(", litaC_cgen__CGen_cType(litaC_this, litaC_funcPtrInfo->returnType, litaC_false, litaC_false), litaC_name);
            
            
        }
        
    } else {
        {
            litaC_string_buffer__StringBuffer_append(&((litaC_this->buf)), "%s %s(", litaC_cgen__CGen_cType(litaC_this, litaC_funcInfo->returnType, litaC_false, litaC_false), litaC_name);
            
            
        }
    } 
    
    litaC_bool litaC_decayArrays = litaC_true;
    litaC_i32 litaC_i = 0;
    litaC_string_buffer__StringBuffer litaC_tmp = litaC_string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    for(;litaC_i < litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params)));litaC_i += 1) {
        {
            if(litaC_i > 0) {
                {
                    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ",", 1);
                    
                    
                }
                
            } 
            
            litaC_ast__ParameterDecl* litaC_param = litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->decl->params->params)), litaC_i);
            litaC_string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), litaC_cgen__CGen_cTypeDecl(litaC_this, litaC_param->decl.sym->type, litaC_cgen__CGen_prefix(litaC_this, litaC_param->decl.sym->name, &(litaC_tmp)), litaC_decayArrays));
            litaC_string_buffer__StringBuffer_clear(&((litaC_tmp)));
            
            
        }
    }
    if(litaC_funcInfo->decl->flags & litaC_ast__FuncFlags_HAS_VARARGS) {
        {
            if(litaC_i > 0) {
                {
                    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ",", 1);
                    
                    
                }
                
            } 
            
            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "...", 3);
            
            
        }
        
    } 
    
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ")", 1);
    if(litaC_funcInfo->returnType->kind == litaC_types__TypeKind_FUNC_PTR) {
        {
            litaC_types__FuncPtrTypeInfo* litaC_funcPtrInfo = (litaC_types__FuncPtrTypeInfo*)litaC_funcInfo->returnType;
            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ")  (", 4);
            litaC_i32 litaC_j = 0;
            for(;litaC_j < litaC_array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcPtrInfo->paramDecls)));litaC_j += 1) {
                {
                    if(litaC_j > 0) {
                        {
                            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ",", 1);
                            
                            
                        }
                        
                    } 
                    
                    litaC_string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), litaC_cgen__CGen_cType(litaC_this, litaC_array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_funcPtrInfo->paramDecls)), litaC_j), litaC_false, litaC_false));
                    
                    
                }
            }
            if(litaC_funcPtrInfo->hasVarargs) {
                {
                    if(litaC_j > 0) {
                        {
                            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ",", 1);
                            
                            
                        }
                        
                    } 
                    
                    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "...", 3);
                    
                    
                }
                
            } 
            
            litaC_string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ")", 1);
            
            
        }
        
    } 
    
    
}

litaC_void litaC_cgen_decl__CGen_emitFuncDecl(litaC_cgen__CGen* litaC_this,litaC_ast__FuncDecl* litaC_decl) {
    assert(litaC_decl != NULL);
    if(litaC_decl->decl.declaration.sym->flags & litaC_symbols__SymbolFlags_IS_FOREIGN) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_decl->decl.declaration.sym->flags |= litaC_symbols__SymbolFlags_IS_EMITTED;
    const litaC_char* litaC_name = litaC_cgen__CGen_cName(litaC_this, litaC_decl->decl.declaration.sym);
    litaC_cgen_decl__CGen_emitFuncDeclSignature(litaC_this, litaC_decl, litaC_name);
    litaC_cgen__CGen_emitStrn(litaC_this, " {", 2);
    litaC_this->funcIndex = litaC_this->buf.length;
    if(litaC_decl->body) {
        {
            litaC_this->currentFunc = (litaC_types__FuncTypeInfo*)litaC_decl->decl.declaration.sym->type;
            litaC_cgen__CGen_emitStmt(litaC_this, litaC_decl->body);
            litaC_this->currentFunc = NULL;
            
            
        }
        
    } 
    
    litaC_cgen__CGen_emitStrn(litaC_this, "}\n", 2);
    
}

litaC_void litaC_cgen_decl__CGen_emitAggregateDecl(litaC_cgen__CGen* litaC_this,litaC_ast__AggregateDecl* litaC_decl) {
    assert(litaC_decl->decl.declaration.sym != NULL);
    if(litaC_decl->decl.declaration.sym->flags & litaC_symbols__SymbolFlags_IS_FOREIGN) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_decl->flags & litaC_ast__AggregateFlags_IS_EMBEDDED && litaC_this->aggregateLevel < 1) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_decl->decl.declaration.sym->flags |= litaC_symbols__SymbolFlags_IS_EMITTED;
    litaC_this->aggregateLevel += 1;
    
    litaC_cgen__CGen_emitNotes(litaC_this, &((litaC_decl->decl.declaration.attributes)), litaC_true);
    litaC_cgen__CGen_emitLineInfo(litaC_this, &((litaC_decl->decl.declaration.stmt)));
    const litaC_char* litaC_name = litaC_cgen__CGen_cName(litaC_this, litaC_decl->decl.declaration.sym);
    if(litaC_decl->flags & litaC_ast__AggregateFlags_IS_ANONYMOUS) {
        {
            litaC_name = "";
            
            
        }
        
    } 
    
    litaC_cgen__CGen_emit(litaC_this, "%s %s {", (litaC_decl->decl.declaration.stmt.node.kind == litaC_ast__StmtKind_UNION_DECL) ? "union" : "struct", litaC_name);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_decl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_array__Array_get_cb_FieldStmt_ce_(&((litaC_decl->fields)), litaC_i);
            switch(litaC_field.kind) {
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_field.varField->decl.stmt)));
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                    {
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_field.aggregateField->decl.declaration.stmt)));
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                    {
                        litaC_ast__Decl litaC_decl = litaC_field.enumField->decl;
                        litaC_cgen__CGen_emit(litaC_this, "enum %s %.*s;\n", litaC_cgen__CGen_cTypeName(litaC_this, litaC_decl.sym->type), litaC_decl.name.value.str.length, litaC_decl.name.value.str.buffer);
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    if(litaC_decl->decl.declaration.sym->flags & litaC_symbols__SymbolFlags_IS_TRAIT) {
        {
            litaC_module__Module* litaC_root = litaC_this->lita->programSymbols.root;
            assert(litaC_root != NULL);
            litaC_char litaC_vtableName[256] =  {
                
            };
            litaC_string__String litaC_vtableNameStr = litaC_string__StringInit(litaC_vtableName, litaC_symbols__MAX_SYMBOL_NAME, -(1));
            litaC_string__String_format(&((litaC_vtableNameStr)), "%s%.*s__%s", litaC_this->lita->options->cPrefix, litaC_root->id.name.length, litaC_root->id.name.buffer, litaC_cgen__CGen_escapeNameStr(litaC_this, litaC_decl->decl.declaration.sym->name));
            litaC_cgen__CGen_emit(litaC_this, "%s__VirtualTable* __vtable;\n", litaC_string__String_cStr(litaC_vtableNameStr));
            litaC_cgen__CGen_emitStrn(litaC_this, "void* __this;", 13);
            
            
        }
        
    } else {
        if(litaC_array__Array_empty_cb_FieldStmt_ce_(&((litaC_decl->fields)))) {
            {
                litaC_cgen__CGen_emitStr(litaC_this, "int __dummy;");
                
                
            }
            
        } 
        
    } 
    
    litaC_cgen__CGen_emitStrn(litaC_this, "}", 1);
    if(litaC_this->aggregateLevel > 1) {
        {
            if(litaC_decl->decl.declaration.name.value.str.length) {
                {
                    litaC_cgen__CGen_emitStrn(litaC_this, " ", 1);
                    litaC_cgen__CGen_emitStrn(litaC_this, litaC_decl->decl.declaration.name.value.str.buffer, litaC_decl->decl.declaration.name.value.str.length);
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
    litaC_cgen__CGen_emitNotes(litaC_this, &((litaC_decl->decl.declaration.attributes)), litaC_false);
    litaC_this->aggregateLevel -= 1;
    
}

litaC_void litaC_cgen_decl__CGen_emitEnumDecl(litaC_cgen__CGen* litaC_this,litaC_ast__EnumDecl* litaC_decl) {
    assert(litaC_decl->decl.sym != NULL);
    if(litaC_decl->decl.sym->flags & litaC_symbols__SymbolFlags_IS_FOREIGN) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_decl->decl.sym->flags |= litaC_symbols__SymbolFlags_IS_EMITTED;
    litaC_cgen__CGen_emitNotes(litaC_this, &((litaC_decl->decl.attributes)), litaC_true);
    litaC_cgen__CGen_emitLineInfo(litaC_this, &((litaC_decl->decl.stmt)));
    const litaC_char* litaC_name = litaC_cgen__CGen_cName(litaC_this, litaC_decl->decl.sym);
    litaC_cgen__CGen_emit(litaC_this, "typedef enum %s {", litaC_name);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_decl->fields)));litaC_i += 1) {
        {
            if(litaC_i > 0) {
                {
                    litaC_cgen__CGen_emit(litaC_this, ",\n");
                    
                    
                }
                
            } 
            
            litaC_ast__EnumFieldEntryDecl* litaC_field = litaC_array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_decl->fields)), litaC_i);
            litaC_cgen__CGen_emit(litaC_this, "%s_%.*s", litaC_name, litaC_field->decl.name.value.str.length, litaC_field->decl.name.value.str.buffer);
            if(litaC_field->value) {
                {
                    litaC_cgen__CGen_emitStrn(litaC_this, " = ", 3);
                    litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_field->value->stmt)));
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_cgen__CGen_emit(litaC_this, "} %s;\n", litaC_name);
    
}

litaC_lex__Token litaC_references__FindTokenByPosition(litaC_lsp__LspServer* litaC_lsp,const litaC_mem__Allocator* litaC_alloc,litaC_workspace__TextDocument* litaC_doc,litaC_protocol__Position litaC_pos) {
    litaC_lex__Lexer litaC_lex = litaC_lex__LexerInit(litaC_doc->filename, litaC_string_buffer__StringBuffer_cStr(&((litaC_doc->text))), litaC_alloc);
    litaC_i32 litaC_targetLine = litaC_pos.line + 1;
    litaC_lsp__LspServer_log(litaC_lsp, "Searching for token at: %d:%d\n", litaC_pos.line, litaC_pos.character);
    while(!(litaC_lex__Lexer_eof(&((litaC_lex))))) {
        {
            litaC_lex__Token litaC_token = litaC_lex__Lexer_nextToken(&((litaC_lex)));
            if(litaC_token.pos.lineNumber == litaC_targetLine) {
                {
                    do {
                        {
                            litaC_i32 litaC_len = (litaC_i32)(litaC_token.pos.end - litaC_token.pos.start);
                            if(litaC_token.pos.position >= litaC_pos.character && litaC_pos.character <= litaC_token.pos.position + litaC_len) {
                                {
                                    litaC_lsp__LspServer_log(litaC_lsp, "Found token: '%s'\n", litaC_lex__Token_asString(&((litaC_token))));
                                    return litaC_token;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_token = litaC_lex__Lexer_nextToken(&((litaC_lex)));
                            
                            
                        }
                    }
                    while(!(litaC_lex__Lexer_eof(&((litaC_lex)))) && litaC_token.pos.lineNumber == litaC_targetLine);
                    break;
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_lsp__LspServer_log(litaC_lsp, "No token found!\n");
    return litaC_lex__Lexer_eofToken(&((litaC_lex)));
    
    
}

litaC_void litaC_references__ReferenceDatabase_init(litaC_references__ReferenceDatabase* litaC_this,const litaC_mem__Allocator* litaC_allocator) {
    litaC_this->allocator = litaC_allocator;
    litaC_array__Array_init_cb_Reference_ce_(&((litaC_this->typeReferences)), 1024, litaC_allocator);
    litaC_array__Array_init_cb_FieldReference_ce_(&((litaC_this->fieldReferences)), 1024, litaC_allocator);
    litaC_map__Map_init_cb_usize_c_Array_cb_SrcPos_ce__ce_(&((litaC_this->symbols)), (litaC_array__Array_cb_SrcPos_ce_) {
        
    }, 1024, litaC_map__PtrHashFn_cb_usize_ce_, litaC_map__PtrEqualFn_cb_usize_ce_, litaC_allocator, 0);
    
}

litaC_void litaC_references__ReferenceDatabase_addSymbolReference(litaC_references__ReferenceDatabase* litaC_this,litaC_symbols__Symbol* litaC_symbol,litaC_lex__SrcPos litaC_pos) {
    if(!(litaC_symbol)) {
        return;
        
        
    } 
    
    litaC_usize litaC_ptr = (litaC_usize)litaC_symbol;
    if(!(litaC_map__Map_contains_cb_usize_c_Array_cb_SrcPos_ce__ce_(&((litaC_this->symbols)), litaC_ptr))) {
        {
            litaC_array__Array_cb_SrcPos_ce_ litaC_locations = litaC_array__ArrayInit_cb_SrcPos_ce_(16, litaC_this->allocator);
            litaC_map__Map_put_cb_usize_c_Array_cb_SrcPos_ce__ce_(&((litaC_this->symbols)), litaC_ptr, litaC_locations);
            
            
        }
        
    } 
    
    litaC_array__Array_cb_SrcPos_ce_* litaC_locations = litaC_map__Map_getPtr_cb_usize_c_Array_cb_SrcPos_ce__ce_(&((litaC_this->symbols)), litaC_ptr);
    litaC_array__Array_add_cb_SrcPos_ce_(litaC_locations, litaC_pos);
    
}

litaC_void litaC_references__ReferenceDatabase_addTypeReference(litaC_references__ReferenceDatabase* litaC_this,litaC_ast__TypeSpec* litaC_type) {
    if(!(litaC_type)) {
        return;
        
        
    } 
    
    litaC_ast__TypeSpec* litaC_base = litaC_ast__TypeSpec_getBaseType(litaC_type);
    if(!(litaC_base)) {
        return;
        
        
    } 
    
    litaC_references__ReferenceDatabase_addTypeReferenceByTypeInfo(litaC_this, litaC_type->pos, litaC_base->typeInfo);
    
}

litaC_void litaC_references__ReferenceDatabase_addTypeReferenceBySymbol(litaC_references__ReferenceDatabase* litaC_this,litaC_lex__SrcPos litaC_srcPos,litaC_symbols__Symbol* litaC_sym) {
    if(litaC_sym && litaC_sym->type) {
        {
            litaC_references__ReferenceDatabase_addTypeReferenceByTypeInfo(litaC_this, litaC_srcPos, litaC_sym->type);
            
            
        }
        
    } 
    
    
}

litaC_void litaC_references__ReferenceDatabase_addTypeReferenceByTypeInfo(litaC_references__ReferenceDatabase* litaC_this,litaC_lex__SrcPos litaC_srcPos,litaC_types__TypeInfo* litaC_typeInfo) {
    if(!(litaC_typeInfo)) {
        return;
        
        
    } 
    
    litaC_typeInfo = litaC_types__TypeInfo_getBaseType(litaC_typeInfo);
    if(litaC_types__IsGenericCapable(litaC_typeInfo)) {
        {
            if(litaC_typeInfo->sym && litaC_typeInfo->sym->flags & litaC_symbols__SymbolFlags_IS_FROM_GENERIC_TEMPLATE) {
                {
                    litaC_types__GenericTypeInfo* litaC_genInfo = (litaC_types__GenericTypeInfo*)litaC_typeInfo;
                    litaC_array__Array_add_cb_Reference_ce_(&((litaC_this->typeReferences)), (litaC_references__Reference) {
                        .type = litaC_genInfo->genericTypeid,
                        .pos = litaC_srcPos
                    });
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_array__Array_add_cb_Reference_ce_(&((litaC_this->typeReferences)), (litaC_references__Reference) {
        .type = litaC_typeInfo->typeid,
        .pos = litaC_srcPos
    });
    
}

litaC_void litaC_references__ReferenceDatabase_addFieldReference(litaC_references__ReferenceDatabase* litaC_this,litaC_lex__SrcPos litaC_srcPos,litaC_types__TypeInfo* litaC_parent,litaC_i32 litaC_offset) {
    if(!(litaC_parent)) {
        return;
        
        
    } 
    
    litaC_array__Array_add_cb_FieldReference_ce_(&((litaC_this->fieldReferences)), (litaC_references__FieldReference) {
        .parent = litaC_parent->typeid,
        .offset = litaC_offset,
        .pos = litaC_srcPos
    });
    
}

litaC_array__Array_cb_SrcPos_ce_ litaC_references__ReferenceDatabase_getSymbolReferences(litaC_references__ReferenceDatabase* litaC_this,litaC_symbols__Symbol* litaC_symbol) {
    if(!(litaC_symbol)) {
        return (litaC_array__Array_cb_SrcPos_ce_) {
            
        };
        
        
    } 
    
    litaC_usize litaC_ptr = (litaC_usize)litaC_symbol;
    if(litaC_map__Map_contains_cb_usize_c_Array_cb_SrcPos_ce__ce_(&((litaC_this->symbols)), litaC_ptr)) {
        {
            litaC_array__Array_cb_SrcPos_ce_ litaC_result = litaC_map__Map_get_cb_usize_c_Array_cb_SrcPos_ce__ce_(&((litaC_this->symbols)), litaC_ptr);
            return litaC_result;
            
            
            
        }
        
    } 
    
    return (litaC_array__Array_cb_SrcPos_ce_) {
        
    };
    
    
}

litaC_void litaC_references__ReferenceDatabase_getTypeReferences(litaC_references__ReferenceDatabase* litaC_this,litaC_i64 litaC_typeid,litaC_array__Array_cb_SrcPos_ce_* litaC_results) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_Reference_ce_(&((litaC_this->typeReferences)));litaC_i += 1) {
        {
            litaC_references__Reference* litaC_ref = litaC_array__Array_getPtr_cb_Reference_ce_(&((litaC_this->typeReferences)), litaC_i);
            if(litaC_ref->type == litaC_typeid) {
                {
                    litaC_array__Array_add_cb_SrcPos_ce_(litaC_results, litaC_ref->pos);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    
}

litaC_void litaC_references__ReferenceDatabase_getFieldReferences(litaC_references__ReferenceDatabase* litaC_this,litaC_i64 litaC_typeid,litaC_i32 litaC_offset,litaC_array__Array_cb_SrcPos_ce_* litaC_results) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldReference_ce_(&((litaC_this->fieldReferences)));litaC_i += 1) {
        {
            litaC_references__FieldReference* litaC_ref = litaC_array__Array_getPtr_cb_FieldReference_ce_(&((litaC_this->fieldReferences)), litaC_i);
            if(litaC_ref->parent == litaC_typeid && litaC_ref->offset == litaC_offset) {
                {
                    litaC_array__Array_add_cb_SrcPos_ce_(litaC_results, litaC_ref->pos);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    
}

LITAC_INLINE 
litaC_bool litaC_json__JsonNode_isNull(litaC_json__JsonNode* litaC_node) {
    return litaC_node->type == litaC_json__JsonType_NULL;
    
    
}

LITAC_INLINE 
litaC_bool litaC_json__JsonNode_isBool(litaC_json__JsonNode* litaC_node) {
    return litaC_node->type == litaC_json__JsonType_BOOLEAN;
    
    
}

LITAC_INLINE 
litaC_bool litaC_json__JsonNode_isTrue(litaC_json__JsonNode* litaC_node) {
    return litaC_node->type == litaC_json__JsonType_BOOLEAN && litaC_node->value.boolValue;
    
    
}

LITAC_INLINE 
litaC_bool litaC_json__JsonNode_isFalse(litaC_json__JsonNode* litaC_node) {
    return !(litaC_json__JsonNode_isTrue(litaC_node));
    
    
}

LITAC_INLINE 
litaC_bool litaC_json__JsonNode_isNumber(litaC_json__JsonNode* litaC_node) {
    return litaC_node->type == litaC_json__JsonType_INT_NUMBER || litaC_node->type == litaC_json__JsonType_FLOAT_NUMBER;
    
    
}

LITAC_INLINE 
litaC_bool litaC_json__JsonNode_isString(litaC_json__JsonNode* litaC_node) {
    return litaC_node->type == litaC_json__JsonType_STRING;
    
    
}

LITAC_INLINE 
litaC_bool litaC_json__JsonNode_isArray(litaC_json__JsonNode* litaC_node) {
    return litaC_node->type == litaC_json__JsonType_ARRAY;
    
    
}

LITAC_INLINE 
litaC_bool litaC_json__JsonNode_isObject(litaC_json__JsonNode* litaC_node) {
    return litaC_node->type == litaC_json__JsonType_OBJECT;
    
    
}

LITAC_INLINE 
const litaC_char* litaC_json__JsonNode_asString(litaC_json__JsonNode* litaC_node) {
    return litaC_node->value.strValue;
    
    
}

LITAC_INLINE 
litaC_bool litaC_json__JsonNode_asBool(litaC_json__JsonNode* litaC_node) {
    return litaC_node->value.boolValue;
    
    
}

LITAC_INLINE 
litaC_f64 litaC_json__JsonNode_asNumber(litaC_json__JsonNode* litaC_node) {
    return litaC_node->value.doubleValue;
    
    
}

LITAC_INLINE 
litaC_f64 litaC_json__JsonNode_asFloat(litaC_json__JsonNode* litaC_node) {
    return litaC_node->value.doubleValue;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_json__JsonNode_asInt(litaC_json__JsonNode* litaC_node) {
    return (litaC_i32)litaC_node->value.intValue;
    
    
}

LITAC_INLINE 
litaC_i64 litaC_json__JsonNode_asLong(litaC_json__JsonNode* litaC_node) {
    return (litaC_i64)litaC_node->value.intValue;
    
    
}

LITAC_INLINE 
litaC_array__Array_cb__ptr_JsonNode_ce_* litaC_json__JsonNode_asArray(litaC_json__JsonNode* litaC_node) {
    return litaC_node->value.arrayValue;
    
    
}

LITAC_INLINE 
litaC_json__JsonObject* litaC_json__JsonNode_asObject(litaC_json__JsonNode* litaC_node) {
    return litaC_node->value.objValue;
    
    
}

litaC_json__JsonNode* litaC_json__CreateJsonNumber(litaC_f64 litaC_value,const litaC_mem__Allocator* litaC_alloc) {
    litaC_json__JsonNode* litaC_node = litaC_mem__new_cb_JsonNode_ce_(litaC_alloc);
    litaC_node->alloc = litaC_alloc;
    litaC_node->type = litaC_json__JsonType_FLOAT_NUMBER;
    litaC_node->value = (litaC_json__JsonValue) {
        .doubleValue = litaC_value
    };
    return litaC_node;
    
    
}

litaC_json__JsonNode* litaC_json__CreateJsonIntNumber(litaC_i64 litaC_value,const litaC_mem__Allocator* litaC_alloc) {
    litaC_json__JsonNode* litaC_node = litaC_mem__new_cb_JsonNode_ce_(litaC_alloc);
    litaC_node->alloc = litaC_alloc;
    litaC_node->type = litaC_json__JsonType_INT_NUMBER;
    litaC_node->value = (litaC_json__JsonValue) {
        .intValue = litaC_value
    };
    return litaC_node;
    
    
}

litaC_json__JsonNode* litaC_json__CreateJsonFloatNumber(litaC_f64 litaC_value,const litaC_mem__Allocator* litaC_alloc) {
    return litaC_json__CreateJsonNumber(litaC_value, litaC_alloc);
    
    
}

litaC_json__JsonNode* litaC_json__CreateJsonString(const litaC_char* litaC_str,litaC_i32 litaC_len,const litaC_mem__Allocator* litaC_alloc) {
    if(litaC_len < 0) {
        {
            litaC_len = strlen(litaC_str);
            
            
        }
        
    } 
    
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(litaC_len + 1, litaC_alloc);
    litaC_string_buffer__StringBuffer_appendStrn(&((litaC_sb)), litaC_str, litaC_len);
    return litaC_json__CreateJsonStringNoDup(litaC_string_buffer__StringBuffer_cStr(&((litaC_sb))), litaC_alloc);
    
    
}

litaC_void litaC_json__EscapeString(litaC_string_buffer__StringBuffer* litaC_buf,const litaC_char* litaC_string,litaC_i32 litaC_length) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_length;litaC_i += 1) {
        {
            litaC_char litaC_c = litaC_string[litaC_i];
            const litaC_char* litaC_escaped = litaC_json__escapeStrings[(litaC_u32)litaC_c];
            if(litaC_escaped) {
                {
                    litaC_string_buffer__StringBuffer_appendStr(litaC_buf, litaC_escaped);
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_c == '\\') {
                {
                    litaC_u32 litaC_n = (litaC_u32)litaC_string[litaC_i + 1];
                    const litaC_char* litaC_escapedChar = litaC_json__escapeChars[litaC_n];
                    if(litaC_escapedChar) {
                        {
                            const litaC_char* litaC_chars = litaC_json__escapeChars[litaC_n];
                            assert(litaC_chars);
                            litaC_string_buffer__StringBuffer_appendStr(litaC_buf, litaC_chars);
                            litaC_i += 1;
                            continue;
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_string_buffer__StringBuffer_appendStrn(litaC_buf, "\\", 1);
                            
                            
                        }
                    } 
                    
                    
                    
                }
                
            } 
            
            if(litaC_c == '"') {
                {
                    litaC_string_buffer__StringBuffer_appendStrn(litaC_buf, "\\", 1);
                    
                    
                }
                
            } 
            
            litaC_string_buffer__StringBuffer_appendChar(litaC_buf, litaC_c);
            
            
        }
    }
    
}

litaC_json__JsonNode* litaC_json__CreateJsonStringNoDup(const litaC_char* litaC_str,const litaC_mem__Allocator* litaC_alloc) {
    litaC_json__JsonNode* litaC_node = litaC_mem__new_cb_JsonNode_ce_(litaC_alloc);
    litaC_node->alloc = litaC_alloc;
    litaC_node->type = litaC_json__JsonType_STRING;
    litaC_node->value = (litaC_json__JsonValue) {
        .strValue = litaC_str
    };
    return litaC_node;
    
    
}

litaC_json__JsonNode* litaC_json__CreateJsonArray(const litaC_mem__Allocator* litaC_alloc) {
    litaC_json__JsonNode* litaC_node = litaC_mem__new_cb_JsonNode_ce_(litaC_alloc);
    litaC_node->alloc = litaC_alloc;
    litaC_node->type = litaC_json__JsonType_ARRAY;
    litaC_node->value = (litaC_json__JsonValue) {
        .arrayValue = litaC_mem__new_cb_Array_cb__ptr_JsonNode_ce__ce_(litaC_alloc)
    };
    litaC_array__Array_init_cb__ptr_JsonNode_ce_(litaC_node->value.arrayValue, 16, litaC_alloc);
    return litaC_node;
    
    
}

litaC_json__JsonNode* litaC_json__CreateJsonObject(const litaC_mem__Allocator* litaC_alloc) {
    litaC_json__JsonNode* litaC_node = litaC_mem__new_cb_JsonNode_ce_(litaC_alloc);
    litaC_node->alloc = litaC_alloc;
    litaC_node->type = litaC_json__JsonType_OBJECT;
    litaC_node->value = (litaC_json__JsonValue) {
        .objValue = litaC_mem__new_cb_JsonObject_ce_(litaC_alloc)
    };
    litaC_map__Map_init_cb__ptr_const_char_c_i32_ce_(&((litaC_node->value.objValue->indexes)), -(1), 16, &(litaC_map__StrHashFn), &(litaC_map__StrEqualFn), litaC_alloc, 0);
    litaC_array__Array_init_cb_Entry_ce_(&((litaC_node->value.objValue->values)), 16, litaC_alloc);
    return litaC_node;
    
    
}

litaC_void litaC_json__JsonNode_put(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_json__JsonNode* litaC_n,litaC_i32 litaC_len) {
    if(litaC_node->type != litaC_json__JsonType_OBJECT) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_len < 0) {
        {
            litaC_len = strlen(litaC_key);
            
            
        }
        
    } 
    
    litaC_char* litaC_copy = (litaC_char*)litaC_mem__memduplicate((const litaC_void*)litaC_key, litaC_len + 1, litaC_node->alloc);
    litaC_copy[litaC_len] = '\0';
    litaC_json__Entry litaC_entry =  {
        .key = litaC_copy,
        .value = litaC_n
    };
    litaC_array__Array_add_cb_Entry_ce_(&((litaC_node->value.objValue->values)), litaC_entry);
    litaC_map__Map_put_cb__ptr_const_char_c_i32_ce_(&((litaC_node->value.objValue->indexes)), litaC_copy, litaC_array__Array_size_cb_Entry_ce_(&((litaC_node->value.objValue->values))) - 1);
    
}

litaC_void litaC_json__JsonNode_putNoDup(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_json__JsonNode* litaC_n,litaC_i32 litaC_len) {
    if(litaC_node->type != litaC_json__JsonType_OBJECT) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_len < 0) {
        {
            litaC_len = strlen(litaC_key);
            
            
        }
        
    } 
    
    litaC_json__Entry litaC_entry =  {
        .key = litaC_key,
        .value = litaC_n
    };
    litaC_array__Array_add_cb_Entry_ce_(&((litaC_node->value.objValue->values)), litaC_entry);
    litaC_map__Map_put_cb__ptr_const_char_c_i32_ce_(&((litaC_node->value.objValue->indexes)), litaC_key, litaC_array__Array_size_cb_Entry_ce_(&((litaC_node->value.objValue->values))) - 1);
    
}

litaC_void litaC_json__JsonNode_putStr(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,const litaC_char* litaC_str,litaC_i32 litaC_len) {
    if(litaC_node->type != litaC_json__JsonType_OBJECT) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_json__JsonNode* litaC_value = litaC_json__CreateJsonString(litaC_str, -(1), litaC_node->alloc);
    litaC_json__JsonNode_put(litaC_node, litaC_key, litaC_value, litaC_len);
    
}

litaC_void litaC_json__JsonNode_putNumber(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_f64 litaC_number,litaC_i32 litaC_len) {
    if(litaC_node->type != litaC_json__JsonType_OBJECT) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_json__JsonNode* litaC_value = litaC_json__CreateJsonFloatNumber(litaC_number, litaC_node->alloc);
    litaC_json__JsonNode_put(litaC_node, litaC_key, litaC_value, litaC_len);
    
}

litaC_void litaC_json__JsonNode_putIntNumber(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_i64 litaC_number,litaC_i32 litaC_len) {
    if(litaC_node->type != litaC_json__JsonType_OBJECT) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_json__JsonNode* litaC_value = litaC_json__CreateJsonIntNumber(litaC_number, litaC_node->alloc);
    litaC_json__JsonNode_put(litaC_node, litaC_key, litaC_value, litaC_len);
    
}

litaC_void litaC_json__JsonNode_putFloatNumber(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_f64 litaC_number,litaC_i32 litaC_len) {
    if(litaC_node->type != litaC_json__JsonType_OBJECT) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_json__JsonNode* litaC_value = litaC_json__CreateJsonFloatNumber(litaC_number, litaC_node->alloc);
    litaC_json__JsonNode_put(litaC_node, litaC_key, litaC_value, litaC_len);
    
}

litaC_void litaC_json__JsonNode_putBool(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_bool litaC_b,litaC_i32 litaC_len) {
    if(litaC_node->type != litaC_json__JsonType_OBJECT) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_json__JsonNode_put(litaC_node, litaC_key, (litaC_b) ? litaC_json__JSON_TRUE : litaC_json__JSON_FALSE, litaC_len);
    
}

litaC_bool litaC_json__JsonNode_contains(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key) {
    if(litaC_node->type != litaC_json__JsonType_OBJECT) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_map__Map_contains_cb__ptr_const_char_c_i32_ce_(&((litaC_node->value.objValue->indexes)), litaC_key);
    
    
}

litaC_json__JsonNode* litaC_json__JsonNode_get(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key) {
    if(litaC_node->type != litaC_json__JsonType_OBJECT) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_index = litaC_map__Map_get_cb__ptr_const_char_c_i32_ce_(&((litaC_node->value.objValue->indexes)), litaC_key);
    if(litaC_index < 0) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    return litaC_array__Array_get_cb_Entry_ce_(&((litaC_node->value.objValue->values)), litaC_index).value;
    
    
}

litaC_bool litaC_json__JsonNode_getBool(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_bool litaC_defaultValue) {
    litaC_json__JsonNode* litaC_n = litaC_json__JsonNode_get(litaC_node, litaC_key);
    if(!(litaC_n) || !(litaC_json__JsonNode_isBool(litaC_n))) {
        {
            return litaC_defaultValue;
            
            
            
        }
        
    } 
    
    return litaC_n->value.boolValue;
    
    
}

litaC_i32 litaC_json__JsonNode_getInt(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_i32 litaC_defaultValue) {
    litaC_json__JsonNode* litaC_n = litaC_json__JsonNode_get(litaC_node, litaC_key);
    if(!(litaC_n)) {
        {
            return litaC_defaultValue;
            
            
            
        }
        
    } 
    
    if(litaC_n->type == litaC_json__JsonType_FLOAT_NUMBER) {
        {
            return (litaC_i32)litaC_n->value.doubleValue;
            
            
            
        }
        
    } else {
        if(litaC_n->type == litaC_json__JsonType_INT_NUMBER) {
            {
                return (litaC_i32)litaC_n->value.intValue;
                
                
                
            }
            
        } 
        
    } 
    
    return litaC_defaultValue;
    
    
}

litaC_i64 litaC_json__JsonNode_getLong(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_i64 litaC_defaultValue) {
    litaC_json__JsonNode* litaC_n = litaC_json__JsonNode_get(litaC_node, litaC_key);
    if(!(litaC_n) || !(litaC_json__JsonNode_isNumber(litaC_n))) {
        {
            return litaC_defaultValue;
            
            
            
        }
        
    } 
    
    if(litaC_n->type == litaC_json__JsonType_FLOAT_NUMBER) {
        {
            return (litaC_i64)litaC_n->value.doubleValue;
            
            
            
        }
        
    } else {
        if(litaC_n->type == litaC_json__JsonType_INT_NUMBER) {
            {
                return litaC_n->value.intValue;
                
                
                
            }
            
        } 
        
    } 
    
    return litaC_defaultValue;
    
    
}

litaC_f64 litaC_json__JsonNode_getFloat(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_f64 litaC_defaultValue) {
    litaC_json__JsonNode* litaC_n = litaC_json__JsonNode_get(litaC_node, litaC_key);
    if(!(litaC_n)) {
        {
            return litaC_defaultValue;
            
            
            
        }
        
    } 
    
    if(litaC_n->type == litaC_json__JsonType_FLOAT_NUMBER) {
        {
            return litaC_n->value.doubleValue;
            
            
            
        }
        
    } else {
        if(litaC_n->type == litaC_json__JsonType_INT_NUMBER) {
            {
                return (litaC_f64)litaC_n->value.intValue;
                
                
                
            }
            
        } 
        
    } 
    
    return litaC_defaultValue;
    
    
}

const litaC_char* litaC_json__JsonNode_getStr(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,const litaC_char* litaC_defaultValue) {
    litaC_json__JsonNode* litaC_n = litaC_json__JsonNode_get(litaC_node, litaC_key);
    if(!(litaC_n) || !(litaC_json__JsonNode_isString(litaC_n))) {
        {
            return litaC_defaultValue;
            
            
            
        }
        
    } 
    
    return litaC_n->value.strValue;
    
    
}

litaC_char* litaC_json__JsonNode_getStrCopy(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_char* litaC_str,litaC_i32 litaC_len) {
    litaC_json__JsonNode* litaC_n = litaC_json__JsonNode_get(litaC_node, litaC_key);
    if(!(litaC_n) || !(litaC_json__JsonNode_isString(litaC_n))) {
        {
            return litaC_str;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_srcLen = strlen(litaC_n->value.strValue);
    strncpy(litaC_str, litaC_n->value.strValue, MIN(litaC_srcLen, litaC_len));
    return litaC_str;
    
    
}

litaC_json__JsonNode* litaC_json__JsonNode_getArray(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key) {
    litaC_json__JsonNode* litaC_n = litaC_json__JsonNode_get(litaC_node, litaC_key);
    if(!(litaC_n) || !(litaC_json__JsonNode_isArray(litaC_n))) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    return litaC_n;
    
    
}

litaC_json__JsonNode* litaC_json__JsonNode_getObject(litaC_json__JsonNode* litaC_node,const litaC_char* litaC_key) {
    litaC_json__JsonNode* litaC_n = litaC_json__JsonNode_get(litaC_node, litaC_key);
    if(!(litaC_n) || !(litaC_json__JsonNode_isObject(litaC_n))) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    return litaC_n;
    
    
}

litaC_void litaC_json__JsonNode_add(litaC_json__JsonNode* litaC_node,litaC_json__JsonNode* litaC_n) {
    if(litaC_node->type == litaC_json__JsonType_ARRAY) {
        {
            litaC_array__Array_add_cb__ptr_JsonNode_ce_(litaC_node->value.arrayValue, litaC_n);
            
            
        }
        
    } 
    
    
}

litaC_json__JsonNode* litaC_json__JsonNode_at(litaC_json__JsonNode* litaC_node,litaC_i32 litaC_index) {
    if(litaC_node->type != litaC_json__JsonType_ARRAY) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    return litaC_array__Array_get_cb__ptr_JsonNode_ce_(litaC_node->value.arrayValue, litaC_index);
    
    
}

litaC_i32 litaC_json__JsonNode_size(litaC_json__JsonNode* litaC_node) {
    if(litaC_node->type == litaC_json__JsonType_ARRAY) {
        {
            return litaC_array__Array_size_cb__ptr_JsonNode_ce_(litaC_node->value.arrayValue);
            
            
            
        }
        
    } else {
        if(litaC_node->type == litaC_json__JsonType_OBJECT) {
            {
                return litaC_map__Map_size_cb__ptr_const_char_c_i32_ce_(&((litaC_node->value.objValue->indexes)));
                
                
                
            }
            
        } 
        
    } 
    
    return 0;
    
    
}

litaC_bool litaC_json__JsonNode_equals(litaC_json__JsonNode* litaC_node,litaC_json__JsonNode* litaC_other) {
    if(litaC_node == litaC_other) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    if(!(litaC_node) && litaC_other) {
        return litaC_false;
        
        
    } 
    
    if(litaC_node && !(litaC_other)) {
        return litaC_false;
        
        
    } 
    
    if(litaC_node->type != litaC_other->type) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_node->type) {
        case litaC_json__JsonType_ARRAY: {
            {
                if(litaC_array__Array_size_cb__ptr_JsonNode_ce_(litaC_node->value.arrayValue) != litaC_array__Array_size_cb__ptr_JsonNode_ce_(litaC_other->value.arrayValue)) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_JsonNode_ce_(litaC_node->value.arrayValue);litaC_i += 1) {
                    {
                        litaC_json__JsonNode* litaC_thisElement = litaC_array__Array_get_cb__ptr_JsonNode_ce_(litaC_node->value.arrayValue, litaC_i);
                        litaC_json__JsonNode* litaC_otherElement = litaC_array__Array_get_cb__ptr_JsonNode_ce_(litaC_other->value.arrayValue, litaC_i);
                        if(!(litaC_json__JsonNode_equals(litaC_thisElement, litaC_otherElement))) {
                            {
                                return litaC_false;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_json__JsonType_OBJECT: {
            {
                litaC_i32 litaC_thisCount = 0;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_Entry_ce_(&((litaC_node->value.objValue->values)));litaC_i += 1) {
                    {
                        litaC_json__Entry litaC_entry = litaC_array__Array_get_cb_Entry_ce_(&((litaC_node->value.objValue->values)), litaC_i);
                        const litaC_char* litaC_key = litaC_entry.key;
                        litaC_json__JsonNode* litaC_thisValue = litaC_entry.value;
                        if(litaC_thisValue != NULL && litaC_thisValue->type != litaC_json__JsonType_NULL) {
                            {
                                litaC_thisCount += 1;
                                
                                
                            }
                            
                        } 
                        
                        litaC_json__JsonNode* litaC_otherValue = litaC_json__JsonNode_get(litaC_other, litaC_key);
                        if(!(litaC_json__JsonNode_equals(litaC_thisValue, litaC_otherValue))) {
                            {
                                return litaC_false;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                litaC_i32 litaC_otherCount = 0;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_Entry_ce_(&((litaC_other->value.objValue->values)));litaC_i += 1) {
                    {
                        litaC_json__Entry litaC_entry = litaC_array__Array_get_cb_Entry_ce_(&((litaC_other->value.objValue->values)), litaC_i);
                        const litaC_char* litaC_key = litaC_entry.key;
                        litaC_json__JsonNode* litaC_otherValue = litaC_entry.value;
                        if(litaC_otherValue != NULL && litaC_otherValue->type != litaC_json__JsonType_NULL) {
                            {
                                litaC_otherCount += 1;
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                return litaC_otherCount == litaC_thisCount;
                
                
                
            }
            
            
        }
        case litaC_json__JsonType_STRING: {
            {
                return strcmp(litaC_node->value.strValue, litaC_other->value.strValue) == 0;
                
                
                
            }
            
            
        }
        case litaC_json__JsonType_NULL: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_json__JsonType_BOOLEAN: {
            {
                return litaC_node->value.boolValue == litaC_other->value.boolValue;
                
                
                
            }
            
            
        }
        case litaC_json__JsonType_INT_NUMBER: {
            {
                return litaC_node->value.intValue == litaC_other->value.intValue;
                
                
                
            }
            
            
        }
        case litaC_json__JsonType_FLOAT_NUMBER: {
            {
                return litaC_node->value.doubleValue == litaC_other->value.doubleValue;
                
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    
}

const litaC_char* litaC_json__JsonNode_print(litaC_json__JsonNode* litaC_node,litaC_string_buffer__StringBuffer* litaC_buf) {
    litaC_json__PrintJson(litaC_node, litaC_buf);
    return litaC_string_buffer__StringBuffer_cStr(litaC_buf);
    
    
}

litaC_void litaC_json__JsonNode_free(litaC_json__JsonNode* litaC_node) {
    if(!(litaC_node)) {
        {
            return;
            
            
            
        }
        
    } 
    
    const litaC_mem__Allocator* litaC_alloc = litaC_node->alloc;
    if(!(litaC_alloc)) {
        {
            return;
            
            
            
        }
        
    } 
    
    switch(litaC_node->type) {
        case litaC_json__JsonType_ARRAY: {
            {
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_JsonNode_ce_(litaC_node->value.arrayValue);litaC_i += 1) {
                    {
                        litaC_json__JsonNode* litaC_n = litaC_array__Array_get_cb__ptr_JsonNode_ce_(litaC_node->value.arrayValue, litaC_i);
                        if(litaC_n) {
                            {
                                litaC_json__JsonNode_free(litaC_n);
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                litaC_array__Array_free_cb__ptr_JsonNode_ce_(litaC_node->value.arrayValue);
                litaC_mem__Allocator_free(litaC_alloc, (litaC_void*)litaC_node->value.arrayValue);
                break;
                
                
            }
            
            
        }
        case litaC_json__JsonType_OBJECT: {
            {
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_Entry_ce_(&((litaC_node->value.objValue->values)));litaC_i += 1) {
                    {
                        litaC_json__Entry litaC_entry = litaC_array__Array_get_cb_Entry_ce_(&((litaC_node->value.objValue->values)), litaC_i);
                        const litaC_char* litaC_key = litaC_entry.key;
                        litaC_json__JsonNode* litaC_node = litaC_entry.value;
                        litaC_mem__Allocator_free(litaC_alloc, (litaC_void*)litaC_key);
                        if(litaC_node) {
                            {
                                litaC_json__JsonNode_free(litaC_node);
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                litaC_map__Map_free_cb__ptr_const_char_c_i32_ce_(&((litaC_node->value.objValue->indexes)));
                litaC_array__Array_free_cb_Entry_ce_(&((litaC_node->value.objValue->values)));
                litaC_mem__Allocator_free(litaC_alloc, (litaC_void*)litaC_node->value.objValue);
                break;
                
                
            }
            
            
        }
        case litaC_json__JsonType_STRING: {
            {
                litaC_mem__Allocator_free(litaC_alloc, (litaC_void*)litaC_node->value.strValue);
                break;
                
                
            }
            
            
        }
        default: {
            
            
        }
    }
    litaC_mem__Allocator_free(litaC_alloc, (litaC_void*)litaC_node);
    
}

litaC_json__JsonParser litaC_json__JsonParserInit(const litaC_mem__Allocator* litaC_alloc) {
    litaC_json__JsonParser litaC_parser =  {
        
    };
    litaC_json__JsonParser_init(&((litaC_parser)), litaC_alloc);
    return litaC_parser;
    
    
}

litaC_void litaC_json__JsonParser_init(litaC_json__JsonParser* litaC_p,const litaC_mem__Allocator* litaC_alloc) {
    litaC_p->alloc = litaC_alloc;
    litaC_p->status = litaC_json__JsonParserStatus_OK;
    memset(litaC_p->errorMsg, 0, litaC_json__MAX_MESSAGE_SIZE);
    litaC_p->stream = NULL;
    litaC_p->lineStart = NULL;
    litaC_p->token.pos.name = "<string>";
    litaC_p->token.pos.line = 1;
    litaC_string_buffer__StringBuffer_init(&((litaC_p->buffer)), 16, litaC_alloc);
    
}

litaC_void litaC_json__JsonParser_free(litaC_json__JsonParser* litaC_p) {
    litaC_string_buffer__StringBuffer_free(&((litaC_p->buffer)));
    litaC_p->stream = NULL;
    litaC_p->lineStart = NULL;
    
}

litaC_json__JsonNode* litaC_json__JsonParser_parseJson(litaC_json__JsonParser* litaC_p,const litaC_char* litaC_buffer) {
    litaC_p->stream = litaC_buffer;
    litaC_p->lineStart = litaC_p->stream;
    litaC_string_buffer__StringBuffer_clear(&((litaC_p->buffer)));
    litaC_json__JsonParser_nextToken(litaC_p);
    litaC_json__JsonNode* litaC_node = litaC_json__JsonParser_parseJsonNode(litaC_p);
    if(litaC_json__JsonParser_hasError(litaC_p)) {
        {
            if(litaC_node) {
                {
                    litaC_json__JsonNode_free(litaC_node);
                    
                    
                }
                
            } 
            
            return NULL;
            
            
            
        }
        
    } 
    
    return litaC_node;
    
    
}

litaC_bool litaC_json__JsonParser_hasError(litaC_json__JsonParser* litaC_p) {
    return litaC_p->status == litaC_json__JsonParserStatus_ERROR;
    
    
}

litaC_void litaC_json__PrintJson(litaC_json__JsonNode* litaC_node,litaC_string_buffer__StringBuffer* litaC_buf) {
    if(!(litaC_node)) {
        {
            return;
            
            
            
        }
        
    } 
    
    switch(litaC_node->type) {
        case litaC_json__JsonType_NULL: {
            {
                litaC_string_buffer__StringBuffer_appendStrn(litaC_buf, "null", 4);
                break;
                
                
            }
            
            
        }
        case litaC_json__JsonType_BOOLEAN: {
            {
                ((litaC_node->value.boolValue)) ? litaC_string_buffer__StringBuffer_appendStrn(litaC_buf, "true", 4) : litaC_string_buffer__StringBuffer_appendStrn(litaC_buf, "false", 5);
                break;
                
                
            }
            
            
        }
        case litaC_json__JsonType_INT_NUMBER: {
            {
                litaC_string_buffer__StringBuffer_append(litaC_buf, "%lld", litaC_node->value.intValue);
                break;
                
                
            }
            
            
        }
        case litaC_json__JsonType_FLOAT_NUMBER: {
            {
                litaC_string_buffer__StringBuffer_append(litaC_buf, "%f", litaC_node->value.doubleValue);
                break;
                
                
            }
            
            
        }
        case litaC_json__JsonType_STRING: {
            {
                litaC_string_buffer__StringBuffer_append(litaC_buf, "\"%s\"", litaC_node->value.strValue);
                break;
                
                
            }
            
            
        }
        case litaC_json__JsonType_OBJECT: {
            {
                litaC_string_buffer__StringBuffer_appendStrn(litaC_buf, "{", 1);
                litaC_json__JsonObject* litaC_obj = litaC_node->value.objValue;
                litaC_bool litaC_isFirst = litaC_true;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_Entry_ce_(&((litaC_obj->values)));litaC_i += 1) {
                    {
                        litaC_json__Entry litaC_entry = litaC_array__Array_get_cb_Entry_ce_(&((litaC_obj->values)), litaC_i);
                        if(!(litaC_isFirst)) {
                            litaC_string_buffer__StringBuffer_appendStrn(litaC_buf, ",", 1);
                            
                        } 
                        
                        litaC_string_buffer__StringBuffer_append(litaC_buf, "\"%s\":", litaC_entry.key);
                        litaC_json__PrintJson(litaC_entry.value, litaC_buf);
                        litaC_isFirst = litaC_false;
                        
                        
                    }
                }
                litaC_string_buffer__StringBuffer_appendStrn(litaC_buf, "}", 1);
                break;
                
                
            }
            
            
        }
        case litaC_json__JsonType_ARRAY: {
            {
                litaC_string_buffer__StringBuffer_appendStrn(litaC_buf, "[", 1);
                litaC_array__Array_cb__ptr_JsonNode_ce_* litaC_array = litaC_node->value.arrayValue;
                litaC_bool litaC_isFirst = litaC_true;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_JsonNode_ce_(litaC_array);litaC_i += 1) {
                    {
                        if(!(litaC_isFirst)) {
                            litaC_string_buffer__StringBuffer_appendStrn(litaC_buf, ",", 1);
                            
                        } 
                        
                        litaC_json__PrintJson(litaC_array__Array_get_cb__ptr_JsonNode_ce_(litaC_array, litaC_i), litaC_buf);
                        litaC_isFirst = litaC_false;
                        
                        
                    }
                }
                litaC_string_buffer__StringBuffer_appendStrn(litaC_buf, "]", 1);
                break;
                
                
            }
            
            
        }
    }
    
}

litaC_json__JsonNode* litaC_json__JsonParser_parseJsonNode(litaC_json__JsonParser* litaC_p) {
    if(litaC_json__JsonParser_hasError(litaC_p)) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    switch(litaC_p->token.kind) {
        case litaC_json__TokenKind_EOF: 
        case litaC_json__TokenKind_ERROR: {
            return NULL;
            
            
            
        }
        case litaC_json__TokenKind_TRUE: {
            litaC_json__JsonParser_nextToken(litaC_p);
            return litaC_json__JSON_TRUE;
            
            
            
        }
        case litaC_json__TokenKind_FALSE: {
            litaC_json__JsonParser_nextToken(litaC_p);
            return litaC_json__JSON_FALSE;
            
            
            
        }
        case litaC_json__TokenKind_NULL: {
            litaC_json__JsonParser_nextToken(litaC_p);
            return litaC_json__JSON_NULL;
            
            
            
        }
        case litaC_json__TokenKind_INT_NUMBER: {
            litaC_json__JsonParser_nextToken(litaC_p);
            return litaC_json__JsonParser_parseJsonIntNumber(litaC_p);
            
            
            
        }
        case litaC_json__TokenKind_REAL_NUMBER: {
            litaC_json__JsonParser_nextToken(litaC_p);
            return litaC_json__JsonParser_parseJsonRealNumber(litaC_p);
            
            
            
        }
        case litaC_json__TokenKind_STRING: {
            litaC_json__JsonParser_nextToken(litaC_p);
            return litaC_json__JsonParser_parseJsonStr(litaC_p);
            
            
            
        }
        case litaC_json__TokenKind_LEFT_BRACE: {
            litaC_json__JsonParser_nextToken(litaC_p);
            return litaC_json__JsonParser_parseJsonObject(litaC_p);
            
            
            
        }
        case litaC_json__TokenKind_LEFT_BRACKET: {
            litaC_json__JsonParser_nextToken(litaC_p);
            return litaC_json__JsonParser_parseJsonArray(litaC_p);
            
            
            
        }
        default: {
            
            
        }
    }
    return NULL;
    
    
}

litaC_json__JsonNode* litaC_json__JsonParser_parseJsonIntNumber(litaC_json__JsonParser* litaC_p) {
    return litaC_json__CreateJsonIntNumber(litaC_p->token.intNumValue, litaC_p->alloc);
    
    
}

litaC_json__JsonNode* litaC_json__JsonParser_parseJsonRealNumber(litaC_json__JsonParser* litaC_p) {
    return litaC_json__CreateJsonFloatNumber(litaC_p->token.realNumValue, litaC_p->alloc);
    
    
}

litaC_json__JsonNode* litaC_json__JsonParser_parseJsonStr(litaC_json__JsonParser* litaC_p) {
    return litaC_json__CreateJsonStringNoDup(litaC_p->token.strValue, litaC_p->alloc);
    
    
}

litaC_json__JsonNode* litaC_json__JsonParser_parseJsonArray(litaC_json__JsonParser* litaC_p) {
    litaC_json__JsonNode* litaC_node = litaC_json__CreateJsonArray(litaC_p->alloc);
    do {
        {
            if(litaC_json__JsonParser_check(litaC_p, litaC_json__TokenKind_RIGHT_BRACKET)) {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_json__JsonNode* litaC_element = litaC_json__JsonParser_parseJsonNode(litaC_p);
            litaC_array__Array_add_cb__ptr_JsonNode_ce_(litaC_node->value.arrayValue, litaC_element);
            
            
        }
    }
    while(litaC_json__JsonParser_match(litaC_p, litaC_json__TokenKind_COMMA));
    litaC_json__JsonParser_expect(litaC_p, litaC_json__TokenKind_RIGHT_BRACKET);
    return litaC_node;
    
    
}

litaC_json__JsonNode* litaC_json__JsonParser_parseJsonObject(litaC_json__JsonParser* litaC_p) {
    litaC_json__JsonNode* litaC_node = litaC_json__CreateJsonObject(litaC_p->alloc);
    do {
        {
            if(litaC_json__JsonParser_check(litaC_p, litaC_json__TokenKind_RIGHT_BRACE)) {
                {
                    break;
                    
                    
                }
                
            } 
            
            const litaC_char* litaC_key = litaC_p->token.strValue;
            if(!(litaC_json__JsonParser_expect(litaC_p, litaC_json__TokenKind_STRING))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            if(!(litaC_json__JsonParser_expect(litaC_p, litaC_json__TokenKind_COLON))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_json__JsonNode* litaC_value = litaC_json__JsonParser_parseJsonNode(litaC_p);
            litaC_json__JsonNode_putNoDup(litaC_node, litaC_key, litaC_value, -(1));
            
            
        }
    }
    while(litaC_json__JsonParser_match(litaC_p, litaC_json__TokenKind_COMMA));
    litaC_json__JsonParser_expect(litaC_p, litaC_json__TokenKind_RIGHT_BRACE);
    err:;
    
    return litaC_node;
    
    
}

const litaC_char* litaC_json__TokenName(litaC_json__TokenKind litaC_t) {
    return litaC_json__tokenKindNames[litaC_t];
    
    
}

litaC_void litaC_json__JsonParser_error(litaC_json__JsonParser* litaC_p,const litaC_char* litaC_format,...) {
    va_list litaC_args;
    va_start(litaC_args, litaC_format);
    vsnprintf(litaC_p->errorMsg, litaC_json__MAX_MESSAGE_SIZE, litaC_format, litaC_args);
    va_end(litaC_args);
    litaC_p->status = litaC_json__JsonParserStatus_ERROR;
    litaC_p->token.kind = litaC_json__TokenKind_ERROR;
    
}

litaC_void litaC_json__JsonParser_scanInt(litaC_json__JsonParser* litaC_p) {
    litaC_i32 litaC_base = 10;
    const litaC_char* litaC_start_digits = litaC_p->stream;
    if(*(litaC_p->stream) == '0') {
        {
            litaC_p->stream += 1;
            if(tolower(*(litaC_p->stream)) == 'x') {
                {
                    litaC_p->stream += 1;
                    litaC_base = 16;
                    litaC_start_digits = litaC_p->stream;
                    
                    
                }
                
            } else {
                if(tolower(*(litaC_p->stream)) == 'b') {
                    {
                        litaC_p->stream += 1;
                        litaC_base = 2;
                        litaC_start_digits = litaC_p->stream;
                        
                        
                    }
                    
                } else {
                    if(isdigit(*(litaC_p->stream))) {
                        {
                            litaC_base = 8;
                            litaC_start_digits = litaC_p->stream;
                            
                            
                        }
                        
                    } 
                    
                } 
                
            } 
            
            
            
        }
        
    } 
    
    litaC_i64 litaC_val = 0;
    for(;;) {
        {
            if(*(litaC_p->stream) == '_') {
                {
                    litaC_p->stream += 1;
                    continue;
                    
                    
                }
                
            } 
            
            litaC_i32 litaC_digit = litaC_json__charToDigit[(litaC_i32)(*(litaC_p->stream))];
            if(litaC_digit == 0 && *(litaC_p->stream) != '0') {
                {
                    break;
                    
                    
                }
                
            } 
            
            if(litaC_digit >= litaC_base) {
                {
                    litaC_json__JsonParser_error(litaC_p, "Digit '%c' out of range for base %d", *(litaC_p->stream), litaC_base);
                    litaC_digit = 0;
                    
                    
                }
                
            } 
            
            if(litaC_val > (ULLONG_MAX - litaC_digit) / litaC_base) {
                {
                    litaC_json__JsonParser_error(litaC_p, "Integer literal overflow");
                    while(isdigit(*(litaC_p->stream))) {
                        {
                            litaC_p->stream += 1;
                            
                            
                        }
                    }
                    litaC_val = 0;
                    break;
                    
                    
                }
                
            } 
            
            litaC_val = litaC_val * litaC_base + litaC_digit;
            litaC_p->stream += 1;
            
            
        }
    }
    if(litaC_p->stream == litaC_start_digits) {
        {
            litaC_json__JsonParser_error(litaC_p, "Expected base %d digit, got '%c'", litaC_base, *(litaC_p->stream));
            
            
        }
        
    } 
    
    if(litaC_json__JsonParser_hasError(litaC_p)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_p->token.kind = litaC_json__TokenKind_INT_NUMBER;
    litaC_p->token.intNumValue = litaC_val;
    
}

litaC_void litaC_json__JsonParser_scanFloat(litaC_json__JsonParser* litaC_p) {
    const litaC_char* litaC_start = litaC_p->stream;
    while(isdigit(*(litaC_p->stream))) {
        {
            litaC_p->stream += 1;
            
            
        }
    }
    if(*(litaC_p->stream) == '.') {
        {
            litaC_p->stream += 1;
            
            
        }
        
    } 
    
    while(isdigit(*(litaC_p->stream))) {
        {
            litaC_p->stream += 1;
            
            
        }
    }
    if(tolower(*(litaC_p->stream)) == 'e') {
        {
            litaC_p->stream += 1;
            if(*(litaC_p->stream) == '+' || *(litaC_p->stream) == '-') {
                {
                    litaC_p->stream += 1;
                    
                    
                }
                
            } 
            
            if(!(isdigit(*(litaC_p->stream)))) {
                {
                    litaC_json__JsonParser_error(litaC_p, "Expected digit after float literal exponent, found '%c'.", *(litaC_p->stream));
                    
                    
                }
                
            } 
            
            while(isdigit(*(litaC_p->stream))) {
                {
                    litaC_p->stream += 1;
                    
                    
                }
            }
            
            
        }
        
    } 
    
    litaC_f64 litaC_val = strtod(litaC_start, NULL);
    if(litaC_val == HUGE_VAL) {
        {
            litaC_json__JsonParser_error(litaC_p, "Float literal overflow");
            
            
        }
        
    } 
    
    if(litaC_json__JsonParser_hasError(litaC_p)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_p->token.kind = litaC_json__TokenKind_REAL_NUMBER;
    litaC_p->token.realNumValue = litaC_val;
    
}

litaC_void litaC_json__JsonParser_scanStr(litaC_json__JsonParser* litaC_p) {
    assert(*(litaC_p->stream) == '"');
    litaC_p->stream += 1;
    litaC_string_buffer__StringBuffer_clear(&((litaC_p->buffer)));
    while(*(litaC_p->stream) && *(litaC_p->stream) != '"') {
        {
            litaC_char litaC_val = *(litaC_p->stream);
            if(litaC_val == '\n') {
                {
                    litaC_json__JsonParser_error(litaC_p, "String literal cannot contain newline");
                    break;
                    
                    
                }
                
            } else {
                if(litaC_val == '\\') {
                    {
                        litaC_p->stream += 1;
                        if(*(litaC_p->stream) == 'x') {
                            {
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_val = litaC_json__escapeToChar[(litaC_i32)(*(litaC_p->stream))];
                                if(litaC_val == 0 && *(litaC_p->stream) != '0') {
                                    {
                                        litaC_json__JsonParser_error(litaC_p, "Invalid string literal escape '\\%c'", *(litaC_p->stream));
                                        
                                        
                                    }
                                    
                                } 
                                
                                litaC_p->stream += 1;
                                
                                
                            }
                        } 
                        
                        
                        
                    }
                    
                } else {
                    {
                        litaC_p->stream += 1;
                        
                        
                    }
                } 
                
            } 
            
            litaC_string_buffer__StringBuffer_append(&((litaC_p->buffer)), "%c", litaC_val);
            
            
        }
    }
    if(*(litaC_p->stream)) {
        {
            litaC_p->stream += 1;
            
            
        }
        
    } else {
        {
            litaC_json__JsonParser_error(litaC_p, "Unexpected end of file within string literal");
            
            
        }
    } 
    
    if(litaC_json__JsonParser_hasError(litaC_p)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_p->token.kind = litaC_json__TokenKind_STRING;
    litaC_p->token.strValue = (const litaC_char*)litaC_mem__memduplicate((const litaC_void*)litaC_string_buffer__StringBuffer_cStr(&((litaC_p->buffer))), litaC_string_buffer__StringBuffer_size(&((litaC_p->buffer))) + 1, litaC_p->alloc);
    
}

litaC_void litaC_json__JsonParser_scanMultiStr(litaC_json__JsonParser* litaC_p) {
    assert(*(litaC_p->stream) == '`');
    litaC_p->stream += 1;
    litaC_string_buffer__StringBuffer_clear(&((litaC_p->buffer)));
    while(*(litaC_p->stream) && *(litaC_p->stream) != '`') {
        {
            litaC_char litaC_val = *(litaC_p->stream);
            if(litaC_val == '\\') {
                {
                    litaC_p->stream += 1;
                    if(*(litaC_p->stream) == '`') {
                        {
                            litaC_val = '`';
                            litaC_p->stream += 1;
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_string_buffer__StringBuffer_append(&((litaC_p->buffer)), "%c", litaC_val);
                            litaC_val = *(litaC_p->stream);
                            litaC_p->stream += 1;
                            
                            
                        }
                    } 
                    
                    
                    
                }
                
            } else {
                {
                    litaC_p->stream += 1;
                    
                    
                }
            } 
            
            litaC_string_buffer__StringBuffer_append(&((litaC_p->buffer)), "%c", litaC_val);
            
            
        }
    }
    if(*(litaC_p->stream)) {
        {
            litaC_p->stream += 1;
            
            
        }
        
    } else {
        {
            litaC_json__JsonParser_error(litaC_p, "Unexpected end of file within string literal");
            
            
        }
    } 
    
    if(litaC_json__JsonParser_hasError(litaC_p)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_p->token.kind = litaC_json__TokenKind_STRING;
    litaC_p->token.strValue = (const litaC_char*)litaC_mem__memduplicate((const litaC_void*)litaC_string_buffer__StringBuffer_cStr(&((litaC_p->buffer))), litaC_string_buffer__StringBuffer_size(&((litaC_p->buffer))) + 1, litaC_p->alloc);
    
}

litaC_void litaC_json__JsonParser_skipComments(litaC_json__JsonParser* litaC_l) {
    if(*(litaC_l->stream) == '/') {
        {
            if(litaC_l->stream[1] == '/') {
                {
                    litaC_l->stream += 1;
                    do {
                        {
                            litaC_l->stream += 1;
                            if(*(litaC_l->stream) == '\n') {
                                {
                                    break;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                    }
                    while(litaC_l->stream);
                    
                    
                }
                
            } else {
                if(litaC_l->stream[1] == '*') {
                    {
                        litaC_l->stream += 1;
                        do {
                            {
                                litaC_l->stream += 1;
                                if((litaC_l->stream[0] == '*' && litaC_l->stream[1] == '/')) {
                                    {
                                        litaC_l->stream += 2;
                                        break;
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                        }
                        while(litaC_l->stream);
                        
                        
                    }
                    
                } 
                
            } 
            
            
            
        }
        
    } 
    
    
}

litaC_void litaC_json__JsonParser_nextToken(litaC_json__JsonParser* litaC_p) {
    repeat:;
    
    if(litaC_json__JsonParser_hasError(litaC_p)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_json__JsonParser_skipComments(litaC_p);
    litaC_p->token.start = litaC_p->stream;
    switch(*(litaC_p->stream)) {
        case ' ': 
        case '\n': 
        case '\r': 
        case '\t': {
            {
                while(isspace(*(litaC_p->stream))) {
                    {
                        if(*(litaC_p->stream) == '\n') {
                            {
                                litaC_p->lineStart = litaC_p->stream;
                                litaC_p->token.pos.line += 1;
                                
                                
                            }
                            
                        } 
                        
                        litaC_p->stream += 1;
                        
                        
                    }
                }
                goto repeat;
                
                
                
            }
            
            
        }
        case '"': {
            {
                litaC_json__JsonParser_scanStr(litaC_p);
                break;
                
                
            }
            
            
        }
        case '`': {
            {
                litaC_json__JsonParser_scanMultiStr(litaC_p);
                break;
                
                
            }
            
            
        }
        case '.': {
            if(isdigit(litaC_p->stream[1])) {
                {
                    litaC_json__JsonParser_scanFloat(litaC_p);
                    
                    
                }
                
            } 
            
            break;
            
            
        }
        case '0': 
        case '1': 
        case '2': 
        case '3': 
        case '4': 
        case '5': 
        case '6': 
        case '7': 
        case '8': 
        case '9': {
            {
                while(isdigit(*(litaC_p->stream))) {
                    {
                        litaC_p->stream += 1;
                        
                        
                    }
                }
                litaC_char litaC_c = *(litaC_p->stream);
                litaC_p->stream = litaC_p->token.start;
                if(litaC_c == '.' || tolower(litaC_c) == 'e') {
                    {
                        litaC_json__JsonParser_scanFloat(litaC_p);
                        
                        
                    }
                    
                } else {
                    {
                        litaC_json__JsonParser_scanInt(litaC_p);
                        
                        
                    }
                } 
                
                break;
                
                
            }
            
            
        }
        case 'n': {
            {
                if(litaC_p->stream[1] == 'u' && litaC_p->stream[2] == 'l' && litaC_p->stream[3] == 'l') {
                    {
                        litaC_p->stream += 4;
                        litaC_p->token.kind = litaC_json__TokenKind_NULL;
                        break;
                        
                        
                    }
                    
                } 
                
                litaC_json__JsonParser_error(litaC_p, "invalid identifier, did you mean 'null'?");
                break;
                
                
            }
            
            
        }
        case 't': {
            {
                if(litaC_p->stream[1] == 'r' && litaC_p->stream[2] == 'u' && litaC_p->stream[3] == 'e') {
                    {
                        litaC_p->stream += 4;
                        litaC_p->token.kind = litaC_json__TokenKind_TRUE;
                        break;
                        
                        
                    }
                    
                } 
                
                litaC_json__JsonParser_error(litaC_p, "invalid identifier, did you mean 'true'?");
                break;
                
                
            }
            
            
        }
        case 'f': {
            {
                if(litaC_p->stream[1] == 'a' && litaC_p->stream[2] == 'l' && litaC_p->stream[3] == 's' && litaC_p->stream[4] == 'e') {
                    {
                        litaC_p->stream += 5;
                        litaC_p->token.kind = litaC_json__TokenKind_FALSE;
                        break;
                        
                        
                    }
                    
                } 
                
                litaC_json__JsonParser_error(litaC_p, "invalid identifier, did you mean 'false'?");
                break;
                
                
            }
            
            
        }
        case '\0': {
            litaC_p->token.kind = litaC_json__TokenKind_EOF;
            litaC_p->stream += 1;
            break;
            
            
        }
        case '{': {
            litaC_p->token.kind = litaC_json__TokenKind_LEFT_BRACE;
            litaC_p->stream += 1;
            break;
            
            
        }
        case '}': {
            litaC_p->token.kind = litaC_json__TokenKind_RIGHT_BRACE;
            litaC_p->stream += 1;
            break;
            
            
        }
        case '[': {
            litaC_p->token.kind = litaC_json__TokenKind_LEFT_BRACKET;
            litaC_p->stream += 1;
            break;
            
            
        }
        case ']': {
            litaC_p->token.kind = litaC_json__TokenKind_RIGHT_BRACKET;
            litaC_p->stream += 1;
            break;
            
            
        }
        case ',': {
            litaC_p->token.kind = litaC_json__TokenKind_COMMA;
            litaC_p->stream += 1;
            break;
            
            
        }
        case ':': {
            litaC_p->token.kind = litaC_json__TokenKind_COLON;
            litaC_p->stream += 1;
            break;
            
            
        }
        default: {
            litaC_json__JsonParser_error(litaC_p, "Invalid '%c' token", *(litaC_p->stream));
            litaC_p->stream += 1;
            litaC_p->token.kind = litaC_json__TokenKind_ERROR;
            break;
            
            
        }
    }
    litaC_p->token.end = litaC_p->stream;
    
}

litaC_bool litaC_json__JsonParser_check(litaC_json__JsonParser* litaC_p,litaC_json__TokenKind litaC_kind) {
    return litaC_p->token.kind == litaC_kind;
    
    
}

litaC_bool litaC_json__JsonParser_match(litaC_json__JsonParser* litaC_p,litaC_json__TokenKind litaC_kind) {
    if(!(litaC_json__JsonParser_check(litaC_p, litaC_kind))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_json__JsonParser_nextToken(litaC_p);
    return litaC_true;
    
    
}

litaC_bool litaC_json__JsonParser_expect(litaC_json__JsonParser* litaC_p,litaC_json__TokenKind litaC_kind) {
    if(!(litaC_json__JsonParser_check(litaC_p, litaC_kind))) {
        {
            if(litaC_json__JsonParser_hasError(litaC_p)) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_json__JsonParser_error(litaC_p, "Expected token %s, got %s", litaC_json__TokenName(litaC_kind), litaC_json__TokenName(litaC_p->token.kind));
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_json__JsonParser_nextToken(litaC_p);
    return litaC_true;
    
    
}

litaC_void litaC_workspace__Workspace_init(litaC_workspace__Workspace* litaC_this,litaC_lsp__LspServer* litaC_lsp,const litaC_mem__Allocator* litaC_alloc) {
    litaC_this->allocator = litaC_alloc;
    litaC_this->lsp = litaC_lsp;
    litaC_this->openedDocuments = litaC_map__StrMap_cb__ptr_TextDocument_ce_(NULL, 64, litaC_this->allocator);
    
}

litaC_void litaC_workspace__Workspace_setup(litaC_workspace__Workspace* litaC_this,const litaC_char* litaC_rootPath,const litaC_char* litaC_rootUri) {
    litaC_this->rootPath = litaC_rootPath;
    litaC_lita__Lita* litaC_lita = litaC_this->lsp->lita;
    litaC_char litaC_filepath[_MAX_PATH] =  {
        0
    };
    litaC_string__String litaC_pathStr = litaC_string__StringInit(litaC_filepath, _MAX_PATH, -(1));
    litaC_string__String_format(&((litaC_pathStr)), "%s/src/main.lita", litaC_rootPath);
    litaC_lsp__LspServer_log(litaC_this->lsp, "Checking for main at: '%s'...", litaC_string__String_cStr(litaC_pathStr));
    if(litaC_system__FileExists(litaC_string__String_cStrConst(litaC_pathStr))) {
        {
            litaC_lsp__LspServer_log(litaC_this->lsp, "found!\n");
            litaC_system__GetAbsolutePath("", litaC_string__String_cStr(litaC_pathStr), litaC_lita->options->inputFile);
            litaC_system__FilePath(litaC_lita->options->inputFile, litaC_lita->options->srcPath);
            const litaC_char* litaC_lib = litaC_system__GetEnv("LITAC_HOME");
            if(!(litaC_lib)) {
                litaC_lib = "";
                
            } 
            
            litaC_system__GetAbsolutePath("", litaC_lib, litaC_lita->options->litaPath);
            litaC_lsp__LspServer_log(litaC_this->lsp, "Lita.inputFile = '%s'\nLita.srcPath = '%s'\nLita.libPath = '%s'\nLita.litaPath = '%s'\n", litaC_lita->options->inputFile, litaC_lita->options->srcPath, litaC_lita->options->libPath, litaC_lita->options->litaPath);
            litaC_lita->options->checkerOnly = litaC_true;
            return;
            
            
            
        }
        
    } 
    
    litaC_lsp__LspServer_log(litaC_this->lsp, "unable to find main.lita from '%s'\n", litaC_rootPath);
    
}

litaC_bool litaC_workspace__Workspace_isDocumentOpen(litaC_workspace__Workspace* litaC_this,const litaC_char* litaC_uri) {
    if(!(litaC_uri)) {
        return litaC_false;
        
        
    } 
    
    return litaC_map__Map_contains_cb__ptr_const_char_c__ptr_TextDocument_ce_(&((litaC_this->openedDocuments)), litaC_uri);
    
    
}

litaC_void litaC_workspace__Workspace_openDocument(litaC_workspace__Workspace* litaC_this,const litaC_char* litaC_uri,const litaC_char* litaC_text) {
    if(!(litaC_uri)) {
        return;
        
        
    } 
    
    litaC_char* litaC_moduleUri = litaC_string__StringCopy(litaC_uri, -(1), litaC_this->allocator);
    litaC_workspace__TextDocument* litaC_doc = litaC_mem__new_cb_TextDocument_ce_(litaC_this->allocator);
    litaC_doc->text = litaC_string_buffer__StringBufferInit(strlen(litaC_text), litaC_this->allocator);
    litaC_string_buffer__StringBuffer_append(&((litaC_doc->text)), "%s", litaC_text);
    litaC_system__UriToFilePath(litaC_uri, litaC_doc->filename);
    litaC_map__Map_put_cb__ptr_const_char_c__ptr_TextDocument_ce_(&((litaC_this->openedDocuments)), litaC_moduleUri, litaC_doc);
    
}

litaC_void litaC_workspace__Workspace_closeDocument(litaC_workspace__Workspace* litaC_this,const litaC_char* litaC_uri) {
    if(!(litaC_uri)) {
        return;
        
        
    } 
    
    litaC_workspace__TextDocument* litaC_doc = litaC_map__Map_remove_cb__ptr_const_char_c__ptr_TextDocument_ce_(&((litaC_this->openedDocuments)), litaC_uri);
    if(!(litaC_doc)) {
        {
            
            
        }
        
    } 
    
    
}

litaC_void litaC_workspace__Workspace_saveDocument(litaC_workspace__Workspace* litaC_this,const litaC_char* litaC_uri) {
    if(!(litaC_uri)) {
        return;
        
        
    } 
    
    
}

litaC_void litaC_workspace__Workspace_changeDocument(litaC_workspace__Workspace* litaC_this,const litaC_char* litaC_uri,litaC_protocol__TextDocumentChangeEvent* litaC_change) {
    if(!(litaC_uri)) {
        return;
        
        
    } 
    
    
}

litaC_json__JsonNode* litaC_workspace__Workspace_documentSymbols(litaC_workspace__Workspace* litaC_this,const litaC_char* litaC_uri,const litaC_mem__Allocator* litaC_alloc) {
    if(!(litaC_uri)) {
        return NULL;
        
        
    } 
    
    litaC_workspace__TextDocument* litaC_doc = litaC_map__Map_get_cb__ptr_const_char_c__ptr_TextDocument_ce_(&((litaC_this->openedDocuments)), litaC_uri);
    litaC_lsp__LspServer_log(litaC_this->lsp, "Uri: '%s' has doc: %d\n", litaC_uri, litaC_doc != NULL);
    if(!(litaC_doc)) {
        return NULL;
        
        
    } 
    
    litaC_symbols__ProgramSymbols* litaC_syms = &(litaC_this->lsp->lita->programSymbols);
    litaC_json__JsonNode* litaC_results = litaC_json__CreateJsonArray(litaC_alloc);
    for(litaC_map__MapIterator_cb__ptr_const_char_c__ptr_Symbol_ce_ litaC_it = litaC_map__Map_iter_cb__ptr_const_char_c__ptr_Symbol_ce_(&((litaC_this->lsp->lita->genericSymbols)));litaC_map__MapIterator_hasNext_cb__ptr_const_char_c__ptr_Symbol_ce_(&((litaC_it)));) {
        {
            litaC_map__MapEntry_cb__ptr_const_char_c__ptr_Symbol_ce_ litaC_entry = litaC_map__MapIterator_next_cb__ptr_const_char_c__ptr_Symbol_ce_(&((litaC_it)));
            litaC_symbols__Symbol* litaC_sym = litaC_entry.value;
            litaC_workspace__Workspace_addDocumentSymbol(litaC_this, litaC_results, litaC_sym, litaC_doc->filename, litaC_alloc);
            
            
        }
    }
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_syms->values)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_syms->values)), litaC_i);
            litaC_workspace__Workspace_addDocumentSymbol(litaC_this, litaC_results, litaC_sym, litaC_doc->filename, litaC_alloc);
            
            
        }
    }
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_syms->symbolTypes)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_syms->symbolTypes)), litaC_i);
            litaC_workspace__Workspace_addDocumentSymbol(litaC_this, litaC_results, litaC_sym, litaC_doc->filename, litaC_alloc);
            
            
        }
    }
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_syms->symbolFuncs)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_syms->symbolFuncs)), litaC_i);
            litaC_workspace__Workspace_addDocumentSymbol(litaC_this, litaC_results, litaC_sym, litaC_doc->filename, litaC_alloc);
            
            
        }
    }
    return litaC_results;
    
    
}

litaC_void litaC_workspace__Workspace_addDocumentSymbol(litaC_workspace__Workspace* litaC_this,litaC_json__JsonNode* litaC_results,litaC_symbols__Symbol* litaC_sym,const litaC_char* litaC_docFilename,const litaC_mem__Allocator* litaC_alloc) {
    litaC_char litaC_absPath[_MAX_PATH] =  {
        0
    };
    litaC_char* litaC_path = litaC_system__GetAbsolutePath(litaC_this->rootPath, litaC_sym->declared->id.filename, litaC_absPath);
    if(litaC_system__PathEquals(litaC_path, litaC_docFilename)) {
        {
            litaC_json__JsonNode* litaC_info = litaC_protocol__SymbolToSymbolInformation(litaC_sym, litaC_this->rootPath, litaC_alloc);
            if(litaC_info) {
                {
                    litaC_json__JsonNode_add(litaC_results, litaC_info);
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    
}

litaC_json__JsonNode* litaC_workspace__Workspace_references(litaC_workspace__Workspace* litaC_this,const litaC_char* litaC_uri,litaC_json__JsonNode* litaC_position,const litaC_mem__Allocator* litaC_alloc) {
    litaC_lsp__LspServer_log(litaC_this->lsp, "looking up references...\n");
    if(!(litaC_uri) || !(litaC_position)) {
        return litaC_json__JSON_NULL;
        
        
    } 
    
    litaC_util__SourceLocation litaC_location = litaC_workspace__Workspace_getNodeAtSourcePos(litaC_this, litaC_uri, litaC_position);
    if(litaC_location.kind == litaC_util__SourceLocationKind_NONE) {
        {
            return litaC_json__JSON_NULL;
            
            
            
        }
        
    } 
    
    if(litaC_location.kind == litaC_util__SourceLocationKind_AST) {
        {
            litaC_lsp__LspServer_log(litaC_this->lsp, "Found ast node: %s\n", litaC_ast__StmtKindAsStr(litaC_location.node->kind));
            switch(litaC_location.node->kind) {
                case litaC_ast__StmtKind_NATIVE_DECL: 
                case litaC_ast__StmtKind_TYPEDEF_DECL: 
                case litaC_ast__StmtKind_UNION_DECL: 
                case litaC_ast__StmtKind_STRUCT_DECL: 
                case litaC_ast__StmtKind_TRAIT_DECL: 
                case litaC_ast__StmtKind_ENUM_DECL: 
                case litaC_ast__StmtKind_FUNC_DECL: {
                    {
                        litaC_ast__Decl* litaC_decl = (litaC_ast__Decl*)litaC_location.node;
                        if(litaC_decl->sym && litaC_decl->sym->type) {
                            {
                                litaC_i64 litaC_typeid = litaC_decl->sym->type->typeid;
                                return litaC_workspace__Workspace_findTypeReferences(litaC_this, litaC_typeid, litaC_alloc);
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        litaC_ast__TraitFieldDecl* litaC_varField = (litaC_ast__TraitFieldDecl*)litaC_location.node;
                        litaC_ast__Node* litaC_parentNode = litaC_varField->decl.stmt.node.parent;
                        while(litaC_parentNode && (litaC_parentNode->kind == litaC_ast__StmtKind_UNION_DECL || litaC_parentNode->kind == litaC_ast__StmtKind_STRUCT_DECL)) {
                            {
                                litaC_ast__AggregateDecl* litaC_decl = (litaC_ast__AggregateDecl*)litaC_parentNode;
                                if(litaC_decl->flags & litaC_ast__AggregateFlags_IS_ANONYMOUS) {
                                    {
                                        litaC_parentNode = litaC_decl->decl.declaration.stmt.node.parent;
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        litaC_types__TypeInfo* litaC_parentType = litaC_decl->decl.declaration.sym->type;
                                        if(litaC_parentType) {
                                            {
                                                litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_parentType;
                                                litaC_types__FieldPositionResult litaC_fieldResult = litaC_types__AggregateTypeInfo_getFieldPosition(litaC_aggInfo, litaC_lex__Token_asString(&((litaC_varField->decl.name))));
                                                litaC_lsp__LspServer_log(litaC_this->lsp, "Getting field position: %d\n", litaC_fieldResult.position);
                                                if(litaC_fieldResult.aggInfo) {
                                                    {
                                                        return litaC_workspace__Workspace_findFieldReferences(litaC_this, litaC_fieldResult.aggInfo->info.typeInfo.typeid, litaC_fieldResult.position, litaC_alloc);
                                                        
                                                        
                                                        
                                                    }
                                                    
                                                } 
                                                
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        break;
                                        
                                        
                                    }
                                } 
                                
                                
                                
                            }
                        }
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_varField = (litaC_ast__VarFieldDecl*)litaC_location.node;
                        litaC_ast__Node* litaC_parentNode = litaC_varField->decl.stmt.node.parent;
                        while(litaC_parentNode && (litaC_parentNode->kind == litaC_ast__StmtKind_UNION_DECL || litaC_parentNode->kind == litaC_ast__StmtKind_STRUCT_DECL)) {
                            {
                                litaC_ast__AggregateDecl* litaC_decl = (litaC_ast__AggregateDecl*)litaC_parentNode;
                                if(litaC_decl->flags & litaC_ast__AggregateFlags_IS_ANONYMOUS) {
                                    {
                                        litaC_parentNode = litaC_decl->decl.declaration.stmt.node.parent;
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        litaC_types__TypeInfo* litaC_parentType = litaC_decl->decl.declaration.sym->type;
                                        if(litaC_parentType) {
                                            {
                                                litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_parentType;
                                                litaC_types__FieldPositionResult litaC_fieldResult = litaC_types__AggregateTypeInfo_getFieldPosition(litaC_aggInfo, litaC_lex__Token_asString(&((litaC_varField->decl.name))));
                                                litaC_lsp__LspServer_log(litaC_this->lsp, "Getting field position: %d\n", litaC_fieldResult.position);
                                                if(litaC_fieldResult.aggInfo) {
                                                    {
                                                        return litaC_workspace__Workspace_findFieldReferences(litaC_this, litaC_fieldResult.aggInfo->info.typeInfo.typeid, litaC_fieldResult.position, litaC_alloc);
                                                        
                                                        
                                                        
                                                    }
                                                    
                                                } 
                                                
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        break;
                                        
                                        
                                    }
                                } 
                                
                                
                                
                            }
                        }
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_CONST_DECL: 
                case litaC_ast__StmtKind_VAR_DECL: 
                case litaC_ast__StmtKind_PARAM_DECL: {
                    {
                        litaC_ast__Decl* litaC_decl = (litaC_ast__Decl*)litaC_location.node;
                        litaC_array__Array_cb_SrcPos_ce_ litaC_result = litaC_references__ReferenceDatabase_getSymbolReferences(&((litaC_this->lsp->lita->references)), litaC_decl->sym);
                        return litaC_protocol__SrcPosToLocations(litaC_this->rootPath, &(litaC_result), litaC_alloc);
                        
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_INIT_ARG_EXPR: {
                    {
                        litaC_ast__InitArgExpr* litaC_arg = (litaC_ast__InitArgExpr*)litaC_location.node;
                        litaC_ast__Node* litaC_parentNode = litaC_arg->expr.stmt.node.parent;
                        if(litaC_parentNode && (litaC_parentNode->kind == litaC_ast__StmtKind_INIT_EXPR)) {
                            {
                                litaC_ast__InitExpr* litaC_init = (litaC_ast__InitExpr*)litaC_parentNode;
                                litaC_types__TypeInfo* litaC_parentType = litaC_init->expr.operand.typeInfo;
                                if(litaC_types__IsAggregate(litaC_parentType)) {
                                    {
                                        litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_parentType;
                                        litaC_types__FieldPositionResult litaC_fieldResult = litaC_types__AggregateTypeInfo_getFieldPosition(litaC_aggInfo, litaC_lex__Token_asString(&((litaC_arg->fieldName))));
                                        if(litaC_fieldResult.aggInfo) {
                                            {
                                                litaC_lsp__LspServer_log(litaC_this->lsp, "Getting field position: %llu %d\n", litaC_fieldResult.aggInfo->info.typeInfo.typeid, litaC_fieldResult.position);
                                                return litaC_workspace__Workspace_findFieldReferences(litaC_this, litaC_fieldResult.aggInfo->info.typeInfo.typeid, litaC_fieldResult.position, litaC_alloc);
                                                
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR: {
                    {
                        litaC_ast__IdentifierExpr* litaC_expr = (litaC_ast__IdentifierExpr*)litaC_location.node;
                        if(litaC_expr->sym && litaC_expr->sym->type) {
                            {
                                return litaC_workspace__Workspace_findTypeReferences(litaC_this, litaC_expr->sym->type->typeid, litaC_alloc);
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_IDENTIFIER_EXPR: {
                    {
                        litaC_ast__IdentifierExpr* litaC_expr = (litaC_ast__IdentifierExpr*)litaC_location.node;
                        litaC_array__Array_cb_SrcPos_ce_ litaC_result = litaC_references__ReferenceDatabase_getSymbolReferences(&((litaC_this->lsp->lita->references)), litaC_expr->sym);
                        return litaC_protocol__SrcPosToLocations(litaC_this->rootPath, &(litaC_result), litaC_alloc);
                        
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_GET_EXPR: {
                    {
                        litaC_ast__GetExpr* litaC_expr = (litaC_ast__GetExpr*)litaC_location.node;
                        litaC_types__TypeInfo* litaC_base = litaC_types__TypeInfo_getBaseType(litaC_expr->object->operand.typeInfo);
                        if(litaC_types__IsAggregate(litaC_base)) {
                            {
                                litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_base;
                                litaC_types__FieldPositionResult litaC_fieldResult = litaC_types__AggregateTypeInfo_getFieldPosition(litaC_aggInfo, litaC_expr->field->type->name);
                                litaC_lsp__LspServer_log(litaC_this->lsp, "Getting field position: %d\n", litaC_fieldResult.position);
                                if(litaC_fieldResult.aggInfo) {
                                    {
                                        return litaC_workspace__Workspace_findFieldReferences(litaC_this, litaC_fieldResult.aggInfo->info.typeInfo.typeid, litaC_fieldResult.position, litaC_alloc);
                                        
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        if(!(litaC_expr->field->expr.operand.typeInfo)) {
                                            {
                                                break;
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        litaC_i64 litaC_fieldType = litaC_expr->field->expr.operand.typeInfo->typeid;
                                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_this->lsp->lita->programSymbols.symbolFuncs)));litaC_i += 1) {
                                            {
                                                litaC_symbols__Symbol* litaC_fn = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_this->lsp->lita->programSymbols.symbolFuncs)), litaC_i);
                                                if(!((litaC_fn->flags & litaC_symbols__SymbolFlags_IS_METHOD))) {
                                                    {
                                                        continue;
                                                        
                                                        
                                                    }
                                                    
                                                } 
                                                
                                                if(litaC_fn->type->typeid == litaC_fieldType) {
                                                    {
                                                        return litaC_workspace__Workspace_findTypeReferences(litaC_this, litaC_fn->type->typeid, litaC_alloc);
                                                        
                                                        
                                                        
                                                    }
                                                    
                                                } 
                                                
                                                
                                                
                                            }
                                        }
                                        
                                        
                                    }
                                } 
                                
                                
                                
                            }
                            
                        } else {
                            if(litaC_base->kind == litaC_types__TypeKind_ENUM) {
                                {
                                    litaC_types__EnumTypeInfo* litaC_enumInfo = (litaC_types__EnumTypeInfo*)litaC_base;
                                    litaC_i32 litaC_index = litaC_types__EnumTypeInfo_getFieldIndex(litaC_enumInfo, litaC_expr->field->type->name);
                                    litaC_lsp__LspServer_log(litaC_this->lsp, "Getting enum position: %d\n", litaC_index);
                                    return litaC_workspace__Workspace_findFieldReferences(litaC_this, litaC_enumInfo->info.typeid, litaC_index, litaC_alloc);
                                    
                                    
                                    
                                }
                                
                            } 
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_SET_EXPR: {
                    {
                        litaC_ast__SetExpr* litaC_expr = (litaC_ast__SetExpr*)litaC_location.node;
                        litaC_types__TypeInfo* litaC_base = litaC_types__TypeInfo_getBaseType(litaC_expr->object->operand.typeInfo);
                        if(litaC_types__IsAggregate(litaC_base)) {
                            {
                                litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_base;
                                litaC_types__FieldPositionResult litaC_fieldResult = litaC_types__AggregateTypeInfo_getFieldPosition(litaC_aggInfo, litaC_expr->field->type->name);
                                if(litaC_fieldResult.aggInfo) {
                                    {
                                        return litaC_workspace__Workspace_findFieldReferences(litaC_this, litaC_fieldResult.aggInfo->info.typeInfo.typeid, litaC_fieldResult.position, litaC_alloc);
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } else {
                            if(litaC_base->kind == litaC_types__TypeKind_ENUM) {
                                {
                                    litaC_types__EnumTypeInfo* litaC_enumInfo = (litaC_types__EnumTypeInfo*)litaC_base;
                                    litaC_i32 litaC_index = litaC_types__EnumTypeInfo_getFieldIndex(litaC_enumInfo, litaC_expr->field->type->name);
                                    litaC_lsp__LspServer_log(litaC_this->lsp, "Getting enum position: %d\n", litaC_index);
                                    return litaC_workspace__Workspace_findFieldReferences(litaC_this, litaC_enumInfo->info.typeid, litaC_index, litaC_alloc);
                                    
                                    
                                    
                                }
                                
                            } 
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
        
    } else {
        if(litaC_location.kind == litaC_util__SourceLocationKind_TYPE) {
            {
                litaC_lsp__LspServer_log(litaC_this->lsp, "Found type: %s\n", litaC_ast__TypeSpecKindAsStr(litaC_location.type->kind));
                if(!(litaC_location.type->typeInfo)) {
                    {
                        return litaC_json__JSON_NULL;
                        
                        
                        
                    }
                    
                } 
                
                litaC_i64 litaC_typeid = litaC_location.type->typeInfo->typeid;
                litaC_lsp__LspServer_log(litaC_this->lsp, "~typeid: %llu\n", litaC_typeid);
                return litaC_workspace__Workspace_findTypeReferences(litaC_this, litaC_typeid, litaC_alloc);
                
                
                
            }
            
        } 
        
    } 
    
    return litaC_json__JSON_NULL;
    
    
}

litaC_json__JsonNode* litaC_workspace__Workspace_findTypeReferences(litaC_workspace__Workspace* litaC_this,litaC_i64 litaC_typeid,const litaC_mem__Allocator* litaC_alloc) {
    litaC_array__Array_cb_SrcPos_ce_ litaC_results = litaC_array__ArrayInit_cb_SrcPos_ce_(64, litaC_alloc);
    litaC_references__ReferenceDatabase_getTypeReferences(&((litaC_this->lsp->lita->references)), litaC_typeid, &(litaC_results));
    return litaC_protocol__SrcPosToLocations(litaC_this->rootPath, &(litaC_results), litaC_alloc);
    
    
}

litaC_json__JsonNode* litaC_workspace__Workspace_findFieldReferences(litaC_workspace__Workspace* litaC_this,litaC_i64 litaC_typeid,litaC_i32 litaC_offset,const litaC_mem__Allocator* litaC_alloc) {
    litaC_array__Array_cb_SrcPos_ce_ litaC_results = litaC_array__ArrayInit_cb_SrcPos_ce_(64, litaC_alloc);
    litaC_references__ReferenceDatabase_getFieldReferences(&((litaC_this->lsp->lita->references)), litaC_typeid, litaC_offset, &(litaC_results));
    return litaC_protocol__SrcPosToLocations(litaC_this->rootPath, &(litaC_results), litaC_alloc);
    
    
}

litaC_util__SourceLocation litaC_workspace__Workspace_getNodeAtSourcePos(litaC_workspace__Workspace* litaC_this,const litaC_char* litaC_uri,litaC_json__JsonNode* litaC_position) {
    assert(litaC_uri != NULL);
    assert(litaC_position != NULL);
    litaC_workspace__TextDocument* litaC_doc = litaC_map__Map_get_cb__ptr_const_char_c__ptr_TextDocument_ce_(&((litaC_this->openedDocuments)), litaC_uri);
    litaC_protocol__Position litaC_pos =  {
        .line = litaC_json__JsonNode_getInt(litaC_position, "line", 0),
        .character = litaC_json__JsonNode_getInt(litaC_position, "character", 0)
    };
    litaC_util__SourceLookup litaC_lookup =  {
        .lsp = litaC_this->lsp,
        .lookupPos = litaC_pos,
        .result =  {
            .kind = litaC_util__SourceLocationKind_NONE,
            .module = NULL,
            .location =  {
                .uri = litaC_uri
            }
        }
    };
    litaC_module__Module* litaC_module = litaC_map__Map_get_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_this->lsp->lita->modules)), litaC_doc->filename);
    if(!(litaC_module)) {
        {
            litaC_lsp__LspServer_log(litaC_this->lsp, "No module found for: '%s'\n", litaC_doc->filename);
            return (litaC_util__SourceLocation) {
                .kind = litaC_util__SourceLocationKind_NONE
            };
            
            
            
        }
        
    } 
    
    litaC_lsp__LspServer_log(litaC_this->lsp, "Module for: '%s'\n", litaC_doc->filename);
    litaC_util__SourceLocation litaC_location = litaC_util__SourceLookup_findAstNodeByPosition(&((litaC_lookup)), litaC_module->ast, litaC_pos);
    litaC_location.module = litaC_module;
    return litaC_location;
    
    
}

litaC_json__JsonNode* litaC_workspace__Workspace_goToDefinition(litaC_workspace__Workspace* litaC_this,const litaC_char* litaC_uri,litaC_json__JsonNode* litaC_position,const litaC_mem__Allocator* litaC_alloc) {
    litaC_lsp__LspServer_log(litaC_this->lsp, "looking up definition...\n");
    if(!(litaC_uri) || !(litaC_position)) {
        return litaC_json__JSON_NULL;
        
        
    } 
    
    litaC_util__SourceLocation litaC_location = litaC_workspace__Workspace_getNodeAtSourcePos(litaC_this, litaC_uri, litaC_position);
    if(litaC_location.kind == litaC_util__SourceLocationKind_NONE) {
        {
            litaC_protocol__Position litaC_pos =  {
                .line = litaC_json__JsonNode_getInt(litaC_position, "line", 0),
                .character = litaC_json__JsonNode_getInt(litaC_position, "character", 0)
            };
            litaC_lsp__LspServer_log(litaC_this->lsp, "No ast node found at '%s:%d:%d'\n", litaC_uri, litaC_pos.line, litaC_pos.character);
            return litaC_json__JSON_NULL;
            
            
            
        }
        
    } 
    
    if(litaC_location.kind == litaC_util__SourceLocationKind_AST) {
        {
            litaC_lsp__LspServer_log(litaC_this->lsp, "Found ast node: %s\n", litaC_ast__StmtKindAsStr(litaC_location.node->kind));
            switch(litaC_location.node->kind) {
                case litaC_ast__StmtKind_IMPORT_DECL: {
                    {
                        litaC_ast__ImportDecl* litaC_importDecl = (litaC_ast__ImportDecl*)litaC_location.node;
                        if(!(litaC_importDecl->moduleId)) {
                            {
                                litaC_lsp__LspServer_log(litaC_this->lsp, "ImportDecl.moduleId is null!\n");
                                return litaC_json__JSON_NULL;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_lex__SrcPos litaC_pos =  {
                            .filename = litaC_importDecl->moduleId->filename,
                            .lineStart = NULL,
                            .start = NULL,
                            .end = NULL,
                            .lineNumber = 1,
                            .position = 0
                        };
                        return litaC_protocol__SrcPosWithEndToLocation(litaC_pos, litaC_pos, litaC_this->rootPath, litaC_alloc);
                        
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_NATIVE_DECL: 
                case litaC_ast__StmtKind_TYPEDEF_DECL: 
                case litaC_ast__StmtKind_UNION_DECL: 
                case litaC_ast__StmtKind_STRUCT_DECL: 
                case litaC_ast__StmtKind_TRAIT_DECL: 
                case litaC_ast__StmtKind_ENUM_DECL: 
                case litaC_ast__StmtKind_FUNC_DECL: {
                    {
                        litaC_ast__Decl* litaC_decl = (litaC_ast__Decl*)litaC_location.node;
                        return litaC_protocol__SrcPosWithEndToLocation(litaC_decl->stmt.node.startPos, litaC_decl->stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                        
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        litaC_ast__TraitFieldDecl* litaC_varField = (litaC_ast__TraitFieldDecl*)litaC_location.node;
                        litaC_ast__Node* litaC_parentNode = litaC_varField->decl.stmt.node.parent;
                        while(litaC_parentNode && (litaC_parentNode->kind == litaC_ast__StmtKind_UNION_DECL || litaC_parentNode->kind == litaC_ast__StmtKind_STRUCT_DECL)) {
                            {
                                litaC_ast__AggregateDecl* litaC_decl = (litaC_ast__AggregateDecl*)litaC_parentNode;
                                {
                                    litaC_types__TypeInfo* litaC_parentType = litaC_decl->decl.declaration.sym->type;
                                    if(litaC_parentType) {
                                        {
                                            litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_parentType;
                                            litaC_types__FieldPositionResult litaC_fieldResult = litaC_types__AggregateTypeInfo_getFieldPosition(litaC_aggInfo, litaC_lex__Token_asString(&((litaC_varField->decl.name))));
                                            litaC_lsp__LspServer_log(litaC_this->lsp, "Getting field position: %d\n", litaC_fieldResult.position);
                                            if(litaC_fieldResult.aggInfo && litaC_fieldResult.aggInfo->info.typeInfo.sym) {
                                                {
                                                    litaC_ast__Decl* litaC_decl = litaC_fieldResult.aggInfo->info.typeInfo.sym->decl;
                                                    return litaC_protocol__SrcPosWithEndToLocation(litaC_decl->stmt.node.startPos, litaC_decl->stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                    
                                                    
                                                    
                                                }
                                                
                                            } 
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                        }
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_varField = (litaC_ast__VarFieldDecl*)litaC_location.node;
                        litaC_ast__Node* litaC_parentNode = litaC_varField->decl.stmt.node.parent;
                        while(litaC_parentNode && (litaC_parentNode->kind == litaC_ast__StmtKind_UNION_DECL || litaC_parentNode->kind == litaC_ast__StmtKind_STRUCT_DECL)) {
                            {
                                litaC_ast__AggregateDecl* litaC_decl = (litaC_ast__AggregateDecl*)litaC_parentNode;
                                {
                                    litaC_types__TypeInfo* litaC_parentType = litaC_decl->decl.declaration.sym->type;
                                    if(litaC_parentType) {
                                        {
                                            litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_parentType;
                                            litaC_types__FieldPositionResult litaC_fieldResult = litaC_types__AggregateTypeInfo_getFieldPosition(litaC_aggInfo, litaC_lex__Token_asString(&((litaC_varField->decl.name))));
                                            litaC_lsp__LspServer_log(litaC_this->lsp, "Getting field position: %d\n", litaC_fieldResult.position);
                                            if(litaC_fieldResult.aggInfo && litaC_fieldResult.aggInfo->info.typeInfo.sym) {
                                                {
                                                    litaC_ast__Decl* litaC_decl = litaC_fieldResult.aggInfo->info.typeInfo.sym->decl;
                                                    return litaC_protocol__SrcPosWithEndToLocation(litaC_decl->stmt.node.startPos, litaC_decl->stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                    
                                                    
                                                    
                                                }
                                                
                                            } 
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                        }
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_CONST_DECL: 
                case litaC_ast__StmtKind_VAR_DECL: 
                case litaC_ast__StmtKind_PARAM_DECL: {
                    {
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_INIT_ARG_EXPR: {
                    {
                        litaC_ast__InitArgExpr* litaC_arg = (litaC_ast__InitArgExpr*)litaC_location.node;
                        litaC_ast__Node* litaC_parentNode = litaC_arg->expr.stmt.node.parent;
                        if(litaC_parentNode && (litaC_parentNode->kind == litaC_ast__StmtKind_INIT_EXPR)) {
                            {
                                litaC_ast__InitExpr* litaC_init = (litaC_ast__InitExpr*)litaC_parentNode;
                                litaC_types__TypeInfo* litaC_parentType = litaC_init->expr.operand.typeInfo;
                                if(litaC_types__IsAggregate(litaC_parentType)) {
                                    {
                                        litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_parentType;
                                        litaC_ast__FieldStmt litaC_field = litaC_types__AggregateTypeInfo_getField(litaC_aggInfo, litaC_lex__Token_asString(&((litaC_arg->fieldName))));
                                        if(litaC_field.kind != litaC_ast__StmtKind_POISON_EXPR) {
                                            {
                                                switch(litaC_field.kind) {
                                                    case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                                                        {
                                                            litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                                                            return litaC_protocol__SrcPosWithEndToLocation(litaC_varField->decl.stmt.node.startPos, litaC_varField->decl.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                            
                                                            
                                                            
                                                        }
                                                        
                                                        
                                                    }
                                                    case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                                                        {
                                                            litaC_ast__EnumDecl* litaC_enumField = litaC_field.enumField;
                                                            return litaC_protocol__SrcPosWithEndToLocation(litaC_enumField->decl.stmt.node.startPos, litaC_enumField->decl.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                            
                                                            
                                                            
                                                        }
                                                        
                                                        
                                                    }
                                                    case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                                                    case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                                                        {
                                                            litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                                                            return litaC_protocol__SrcPosWithEndToLocation(litaC_aggField->decl.declaration.stmt.node.startPos, litaC_aggField->decl.declaration.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                            
                                                            
                                                            
                                                        }
                                                        
                                                        
                                                    }
                                                    default: {
                                                        {
                                                            
                                                            
                                                        }
                                                        
                                                        
                                                    }
                                                }
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR: 
                case litaC_ast__StmtKind_IDENTIFIER_EXPR: {
                    {
                        litaC_ast__IdentifierExpr* litaC_expr = (litaC_ast__IdentifierExpr*)litaC_location.node;
                        if(litaC_expr->sym && litaC_expr->sym->decl) {
                            {
                                litaC_ast__Decl* litaC_decl = litaC_expr->sym->decl;
                                return litaC_protocol__SrcPosWithEndToLocation(litaC_decl->stmt.node.startPos, litaC_decl->stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_GET_EXPR: {
                    {
                        litaC_ast__GetExpr* litaC_expr = (litaC_ast__GetExpr*)litaC_location.node;
                        litaC_types__TypeInfo* litaC_base = litaC_types__TypeInfo_getBaseType(litaC_expr->object->operand.typeInfo);
                        if(!(litaC_base)) {
                            {
                                break;
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_types__IsAggregate(litaC_base)) {
                            {
                                litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_base;
                                litaC_ast__FieldStmt litaC_field = litaC_types__AggregateTypeInfo_getField(litaC_aggInfo, litaC_expr->field->type->name);
                                if(litaC_field.kind != litaC_ast__StmtKind_POISON_EXPR) {
                                    {
                                        switch(litaC_field.kind) {
                                            case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                                                {
                                                    litaC_ast__TraitFieldDecl* litaC_varField = litaC_field.traitField;
                                                    return litaC_protocol__SrcPosWithEndToLocation(litaC_varField->decl.stmt.node.startPos, litaC_varField->decl.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                    
                                                    
                                                    
                                                }
                                                
                                                
                                            }
                                            case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                                                {
                                                    litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                                                    return litaC_protocol__SrcPosWithEndToLocation(litaC_varField->decl.stmt.node.startPos, litaC_varField->decl.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                    
                                                    
                                                    
                                                }
                                                
                                                
                                            }
                                            case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                                                {
                                                    litaC_ast__EnumDecl* litaC_enumField = litaC_field.enumField;
                                                    return litaC_protocol__SrcPosWithEndToLocation(litaC_enumField->decl.stmt.node.startPos, litaC_enumField->decl.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                    
                                                    
                                                    
                                                }
                                                
                                                
                                            }
                                            case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                                            case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                                                {
                                                    litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                                                    return litaC_protocol__SrcPosWithEndToLocation(litaC_aggField->decl.declaration.stmt.node.startPos, litaC_aggField->decl.declaration.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                    
                                                    
                                                    
                                                }
                                                
                                                
                                            }
                                            default: {
                                                {
                                                    
                                                    
                                                }
                                                
                                                
                                            }
                                        }
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        if(!(litaC_expr->field->expr.operand.typeInfo)) {
                                            {
                                                break;
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        litaC_i64 litaC_fieldType = litaC_expr->field->expr.operand.typeInfo->typeid;
                                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Symbol_ce_(&((litaC_this->lsp->lita->programSymbols.symbolFuncs)));litaC_i += 1) {
                                            {
                                                litaC_symbols__Symbol* litaC_fn = litaC_array__Array_get_cb__ptr_Symbol_ce_(&((litaC_this->lsp->lita->programSymbols.symbolFuncs)), litaC_i);
                                                if(!((litaC_fn->flags & litaC_symbols__SymbolFlags_IS_METHOD))) {
                                                    {
                                                        continue;
                                                        
                                                        
                                                    }
                                                    
                                                } 
                                                
                                                if(litaC_fn->type->typeid == litaC_fieldType) {
                                                    {
                                                        litaC_ast__Decl* litaC_decl = litaC_fn->decl;
                                                        return litaC_protocol__SrcPosWithEndToLocation(litaC_decl->stmt.node.startPos, litaC_decl->stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                        
                                                        
                                                        
                                                    }
                                                    
                                                } 
                                                
                                                
                                                
                                            }
                                        }
                                        
                                        
                                    }
                                } 
                                
                                
                                
                            }
                            
                        } else {
                            if(litaC_base->kind == litaC_types__TypeKind_ENUM) {
                                {
                                    litaC_types__EnumTypeInfo* litaC_enumInfo = (litaC_types__EnumTypeInfo*)litaC_base;
                                    litaC_i32 litaC_index = litaC_types__EnumTypeInfo_getFieldIndex(litaC_enumInfo, litaC_expr->field->type->name);
                                    if(litaC_index >= 0) {
                                        {
                                            litaC_ast__EnumFieldEntryDecl* litaC_entryDecl = litaC_array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_enumInfo->decl->fields)), litaC_index);
                                            return litaC_protocol__SrcPosWithEndToLocation(litaC_entryDecl->decl.stmt.node.startPos, litaC_entryDecl->decl.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    
                                    
                                }
                                
                            } 
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_SET_EXPR: {
                    {
                        litaC_ast__SetExpr* litaC_expr = (litaC_ast__SetExpr*)litaC_location.node;
                        litaC_types__TypeInfo* litaC_base = litaC_types__TypeInfo_getBaseType(litaC_expr->object->operand.typeInfo);
                        if(litaC_types__IsAggregate(litaC_base)) {
                            {
                                litaC_types__AggregateTypeInfo* litaC_aggInfo = (litaC_types__AggregateTypeInfo*)litaC_base;
                                litaC_ast__FieldStmt litaC_field = litaC_types__AggregateTypeInfo_getField(litaC_aggInfo, litaC_expr->field->type->name);
                                if(litaC_field.kind != litaC_ast__StmtKind_POISON_EXPR) {
                                    {
                                        switch(litaC_field.kind) {
                                            case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                                                {
                                                    litaC_ast__TraitFieldDecl* litaC_varField = litaC_field.traitField;
                                                    return litaC_protocol__SrcPosWithEndToLocation(litaC_varField->decl.stmt.node.startPos, litaC_varField->decl.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                    
                                                    
                                                    
                                                }
                                                
                                                
                                            }
                                            case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                                                {
                                                    litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                                                    return litaC_protocol__SrcPosWithEndToLocation(litaC_varField->decl.stmt.node.startPos, litaC_varField->decl.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                    
                                                    
                                                    
                                                }
                                                
                                                
                                            }
                                            case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                                                {
                                                    litaC_ast__EnumDecl* litaC_enumField = litaC_field.enumField;
                                                    return litaC_protocol__SrcPosWithEndToLocation(litaC_enumField->decl.stmt.node.startPos, litaC_enumField->decl.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                    
                                                    
                                                    
                                                }
                                                
                                                
                                            }
                                            case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                                            case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                                                {
                                                    litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                                                    return litaC_protocol__SrcPosWithEndToLocation(litaC_aggField->decl.declaration.stmt.node.startPos, litaC_aggField->decl.declaration.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                    
                                                    
                                                    
                                                }
                                                
                                                
                                            }
                                            default: {
                                                {
                                                    
                                                    
                                                }
                                                
                                                
                                            }
                                        }
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
        
    } else {
        if(litaC_location.kind == litaC_util__SourceLocationKind_TYPE) {
            {
                litaC_lsp__LspServer_log(litaC_this->lsp, "Found type: %s\n", litaC_ast__TypeSpecKindAsStr(litaC_location.type->kind));
                litaC_symbols__Symbol* litaC_sym = NULL;
                if(litaC_location.type->kind == litaC_ast__TypeSpecKind_NAME && litaC_location.module) {
                    {
                        litaC_ast__NameTypeSpec* litaC_name = (litaC_ast__NameTypeSpec*)litaC_location.type;
                        litaC_sym = litaC_module__Module_getType(litaC_location.module, litaC_name->name);
                        
                        
                    }
                    
                } 
                
                if(!(litaC_sym)) {
                    {
                        if(!(litaC_location.type->typeInfo) || !(litaC_location.type->typeInfo->sym)) {
                            {
                                return litaC_json__JSON_NULL;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_sym = litaC_location.type->typeInfo->sym;
                        
                        
                    }
                    
                } 
                
                litaC_ast__Decl* litaC_decl = litaC_sym->decl;
                return litaC_protocol__SrcPosWithEndToLocation(litaC_decl->stmt.node.startPos, litaC_decl->stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                
                
                
            }
            
        } 
        
    } 
    
    return litaC_json__JSON_NULL;
    
    
}

litaC_phase_result__PhaseResult* litaC_workspace__Workspace_runDiagnostics(litaC_workspace__Workspace* litaC_this,const litaC_mem__Allocator* litaC_alloc) {
    litaC_f64 litaC_startTime = litaC_system__SystemTimeMSec();
    litaC_lita__Lita* litaC_lita = litaC_this->lsp->lita;
    litaC_lita__Lita_reset(litaC_lita);
    litaC_module__Module* litaC_root = litaC_lita__Lita_parse(litaC_lita);
    if(!(litaC_root)) {
        {
            litaC_lsp__LspServer_log(litaC_this->lsp, "Failed to parse\n");
            goto report;
            
            
            
        }
        
    } 
    
    litaC_bool litaC_checked = litaC_lita__Lita_typeCheck(litaC_lita, litaC_root);
    if(!(litaC_checked)) {
        {
            litaC_lsp__LspServer_log(litaC_this->lsp, "Failed to type check\n");
            goto report;
            
            
            
        }
        
    } 
    
    litaC_f64 litaC_totalTime = litaC_system__SystemTimeMSec();
    litaC_lsp__LspServer_log(litaC_this->lsp, "Successfully compiled in %.3f msec\n", litaC_totalTime);
    report:;
    
    return &(litaC_lita->result);
    
    
}

litaC_void litaC_lsp__LspServer_init(litaC_lsp__LspServer* litaC_this,litaC_lita__Lita* litaC_lita) {
    litaC_this->lita = litaC_lita;
    litaC_this->isRunning = litaC_false;
    litaC_this->isInitialized = litaC_false;
    litaC_this->logFile = fopen("litac_lsp.log", "w");
    if(!(litaC_this->logFile)) {
        {
            printf("Couldn't open log file!\n");
            
            
        }
        
    } 
    
    litaC_usize litaC_size = 1024 * 1024 * 100;
    litaC_mem__LinearAllocator_init(&((litaC_this->requestAllocator)), litaC_mem__Allocator_alloc(litaC_mem__defaultAllocator, litaC_size), litaC_size);
    litaC_mem__LinearAllocator_init(&((litaC_this->applicationAllocator)), litaC_mem__Allocator_alloc(litaC_mem__defaultAllocator, litaC_size), litaC_size);
    litaC_this->message = litaC_string_buffer__StringBufferInit(litaC_lsp__IN_BUFFER_SIZE, litaC_mem__defaultAllocator);
    litaC_this->output = litaC_string_buffer__StringBufferInit(litaC_lsp__IN_BUFFER_SIZE, litaC_mem__defaultAllocator);
    litaC_this->outbound = litaC_string_buffer__StringBufferInit(litaC_lsp__IN_BUFFER_SIZE, litaC_mem__defaultAllocator);
    litaC_workspace__Workspace_init(&((litaC_this->workspace)), litaC_this, litaC_lsp__LspServer_appAlloc(litaC_this));
    
}

const litaC_mem__Allocator* litaC_lsp__LspServer_requestAlloc(litaC_lsp__LspServer* litaC_this) {
    return (const litaC_mem__Allocator*)(&(litaC_this->requestAllocator));
    
    
}

const litaC_mem__Allocator* litaC_lsp__LspServer_appAlloc(litaC_lsp__LspServer* litaC_this) {
    return (const litaC_mem__Allocator*)(&(litaC_this->applicationAllocator));
    
    
}

litaC_void litaC_lsp__LspServer_free(litaC_lsp__LspServer* litaC_this) {
    if(litaC_this->applicationAllocator.mem) {
        {
            litaC_mem__Allocator_free(litaC_mem__defaultAllocator, litaC_this->applicationAllocator.mem);
            
            
        }
        
    } 
    
    if(litaC_this->requestAllocator.mem) {
        {
            litaC_mem__Allocator_free(litaC_mem__defaultAllocator, litaC_this->requestAllocator.mem);
            
            
        }
        
    } 
    
    litaC_string_buffer__StringBuffer_free(&((litaC_this->message)));
    litaC_string_buffer__StringBuffer_free(&((litaC_this->output)));
    if(litaC_this->logFile) {
        {
            fclose(litaC_this->logFile);
            
            
        }
        
    } 
    
    
}

litaC_void litaC_lsp__LspServer_start(litaC_lsp__LspServer* litaC_this) {
    litaC_lsp__LspServer_log(litaC_this, "starting Lita Language Server v%s\n", litaC_lsp__VERSION);
    
    litaC_this->isRunning = litaC_true;
    while(litaC_true) {
        {
            litaC_lsp__LspServer_readMessage(litaC_this);
            
            
        }
    }
    litaC_lsp__LspServer_log(litaC_this, "terminating Lita Language Server\n");
    
}

litaC_void litaC_lsp__LspServer_log(litaC_lsp__LspServer* litaC_this,const litaC_char* litaC_format,...) {
    va_list litaC_args;
    va_start(litaC_args, litaC_format);
    vfprintf(litaC_this->logFile, litaC_format, litaC_args);
    va_end(litaC_args);
    fflush(litaC_this->logFile);
    
}

litaC_void litaC_lsp__LspServer_readMessage(litaC_lsp__LspServer* litaC_this) {
    litaC_string_buffer__StringBuffer_clear(&((litaC_this->message)));
    litaC_lsp__LspServer_log(litaC_this, "Waiting for message..\n");
    litaC_i32 litaC_size = litaC_lsp__LspServer_readHeader(litaC_this);
    if(litaC_size < 0) {
        {
            litaC_lsp__LspServer_writeErrorResponse(litaC_this, 0, litaC_protocol__ErrorCodes_ParseError, "error reading 'Content-Length'");
            return;
            
            
            
        }
        
    } 
    
    litaC_f64 litaC_startTime = litaC_system__SystemTimeMSec();
    
    
    litaC_lsp__LspServer_log(litaC_this, "Received message size: %d\n", litaC_size);
    litaC_string_buffer__StringBuffer_reserve(&((litaC_this->message)), litaC_size);
    litaC_i64 litaC_bytesRead = fread(litaC_this->message.buffer, 1, litaC_size, stdin);
    litaC_lsp__LspServer_log(litaC_this, "Received %d bytes from fread\n", litaC_bytesRead);
    if(litaC_bytesRead != litaC_size) {
        {
            litaC_lsp__LspServer_log(litaC_this, "message received size of %d did not match Content-Length: %d\n", litaC_bytesRead, litaC_size);
            litaC_size = (litaC_i32)litaC_bytesRead;
            
            
        }
        
    } 
    
    litaC_this->message.length = litaC_size;
    litaC_lsp__LspServer_log(litaC_this, "Received message: '%.*s'\n", litaC_size, litaC_this->message.buffer);
    litaC_json__JsonParser litaC_parser = litaC_json__JsonParserInit(litaC_lsp__LspServer_requestAlloc(litaC_this));
    
    litaC_json__JsonNode* litaC_json = litaC_json__JsonParser_parseJson(&((litaC_parser)), litaC_string_buffer__StringBuffer_cStr(&((litaC_this->message))));
    if(litaC_json__JsonParser_hasError(&((litaC_parser)))) {
        {
            litaC_lsp__LspServer_log(litaC_this, "json parsing error: %s\n", litaC_parser.errorMsg);
            litaC_json__JsonParser_free(&((litaC_parser)));
            litaC_this->requestAllocator.currentOffset = 0;
            litaC_lsp__LspServer_log(litaC_this, ">>> Request Handling Time: %.4fms\n\n", litaC_system__SystemTimeMSec() - litaC_startTime);
            return;
            
            
            
        }
        
    } 
    
    litaC_lsp__LspServer_handleMessage(litaC_this, litaC_json);
    litaC_json__JsonParser_free(&((litaC_parser)));
    litaC_this->requestAllocator.currentOffset = 0;
    litaC_lsp__LspServer_log(litaC_this, ">>> Request Handling Time: %.4fms\n\n", litaC_system__SystemTimeMSec() - litaC_startTime);
    
}

litaC_i32 litaC_lsp__LspServer_readHeader(litaC_lsp__LspServer* litaC_this) {
    litaC_char litaC_header[256] =  {
        0
    };
    litaC_i32 litaC_sizeIndex = 0;
    litaC_i32 litaC_index = 0;
    litaC_lsp__LspServer_log(litaC_this, "Reading header:\n'");
    while(litaC_true) {
        {
            litaC_i32 litaC_r = getchar();
            if(litaC_r == EOF) {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_char litaC_c = (litaC_char)litaC_r;
            litaC_lsp__LspServer_log(litaC_this, "%c", litaC_c);
            if(litaC_c == ' ') {
                {
                    litaC_sizeIndex = litaC_index + 1;
                    
                    
                }
                
            } 
            
            if(litaC_c == '\n' || litaC_c == '\r') {
                {
                    litaC_header[litaC_index] = '\0';
                    break;
                    
                    
                }
                
            } else {
                {
                    litaC_header[litaC_index] = litaC_c;
                    
                    
                }
            } 
            
            litaC_index += 1;
            
            
        }
    }
    litaC_lsp__LspServer_log(litaC_this, "'\nRead header: '%s'\n", litaC_header);
    if(strncmp(litaC_header, "Content-Length: ", litaC_sizeIndex) != 0) {
        {
            litaC_lsp__LspServer_log(litaC_this, "Invalid header: '%s'\n", litaC_header);
            return -(1);
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_size = atoi(&(litaC_header[litaC_sizeIndex]));
    return litaC_size + 1;
    
    
}

litaC_void litaC_lsp__LspServer_handleMessage(litaC_lsp__LspServer* litaC_this,litaC_json__JsonNode* litaC_msg) {
    const litaC_char* litaC_method = litaC_json__JsonNode_getStr(litaC_msg, "method", NULL);
    if(!(litaC_method)) {
        {
            litaC_lsp__LspServer_writeErrorResponse(litaC_this, 0, litaC_protocol__ErrorCodes_MethodNotFound, "no method defined");
            return;
            
            
            
        }
        
    } 
    
    if(!(litaC_this->isRunning)) {
        {
            if(strcmp(litaC_method, "exit") == 0) {
                {
                    exit(0);
                    
                    
                }
                
            } else {
                {
                    litaC_lsp__LspServer_writeErrorResponse(litaC_this, 0, litaC_protocol__ErrorCodes_InvalidRequest, "not yet properly initialized");
                    return;
                    
                    
                    
                }
            } 
            
            
            
        }
        
    } 
    
    litaC_json__JsonNode* litaC_params = litaC_json__JsonNode_getObject(litaC_msg, "params");
    if(strcmp(litaC_method, "initialize") == 0) {
        {
            litaC_lsp__LspServer_handleInitializeMessage(litaC_this, litaC_msg, litaC_params);
            
            
        }
        
    } else {
        if(strcmp(litaC_method, "initialized") == 0) {
            {
                litaC_this->isInitialized = litaC_true;
                
                
            }
            
        } else {
            if(!(litaC_this->isInitialized)) {
                {
                    litaC_lsp__LspServer_writeErrorResponse(litaC_this, 0, litaC_protocol__ErrorCodes_ServerNotInitialized, "not yet properly initialized");
                    
                    
                }
                
            } else {
                if(strcmp(litaC_method, "textDocument/didOpen") == 0) {
                    {
                        litaC_lsp__LspServer_handleTextDocumentOpenMessage(litaC_this, litaC_msg, litaC_params);
                        
                        
                    }
                    
                } else {
                    if(strcmp(litaC_method, "textDocument/didClose") == 0) {
                        {
                            litaC_lsp__LspServer_handleTextDocumentCloseMessage(litaC_this, litaC_msg, litaC_params);
                            
                            
                        }
                        
                    } else {
                        if(strcmp(litaC_method, "textDocument/didSave") == 0) {
                            {
                                litaC_lsp__LspServer_handleTextDocumentSaveMessage(litaC_this, litaC_msg, litaC_params);
                                
                                
                            }
                            
                        } else {
                            if(strcmp(litaC_method, "textDocument/documentSymbol") == 0) {
                                {
                                    litaC_lsp__LspServer_handleTextDocumentSymbolMessage(litaC_this, litaC_msg, litaC_params);
                                    
                                    
                                }
                                
                            } else {
                                if(strcmp(litaC_method, "textDocument/didSave") == 0) {
                                    {
                                        litaC_lsp__LspServer_handleTextDocumentSaveMessage(litaC_this, litaC_msg, litaC_params);
                                        
                                        
                                    }
                                    
                                } else {
                                    if(strcmp(litaC_method, "textDocument/references") == 0) {
                                        {
                                            litaC_lsp__LspServer_handleTextDocumentReferencesMessage(litaC_this, litaC_msg, litaC_params);
                                            
                                            
                                        }
                                        
                                    } else {
                                        if(strcmp(litaC_method, "textDocument/definition") == 0) {
                                            {
                                                litaC_lsp__LspServer_handleTextDocumentDefinitionMessage(litaC_this, litaC_msg, litaC_params);
                                                
                                                
                                            }
                                            
                                        } else {
                                            if(strcmp(litaC_method, "$/cancelRequest") == 0) {
                                                {
                                                    
                                                    
                                                }
                                                
                                            } else {
                                                if(strcmp(litaC_method, "shutdown") == 0) {
                                                    {
                                                        litaC_this->isRunning = litaC_false;
                                                        
                                                        
                                                    }
                                                    
                                                } else {
                                                    {
                                                        litaC_lsp__LspServer_writeErrorResponse(litaC_this, 0, litaC_protocol__ErrorCodes_MethodNotFound, "unsupported method: '%s'", litaC_method);
                                                        
                                                        
                                                    }
                                                } 
                                                
                                            } 
                                            
                                        } 
                                        
                                    } 
                                    
                                } 
                                
                            } 
                            
                        } 
                        
                    } 
                    
                } 
                
            } 
            
        } 
        
    } 
    
    
}

litaC_void litaC_lsp__LspServer_handleInitializeMessage(litaC_lsp__LspServer* litaC_this,litaC_json__JsonNode* litaC_msg,litaC_json__JsonNode* litaC_params) {
    const litaC_char* litaC_rootPath = litaC_json__JsonNode_getStr(litaC_params, "rootPath", "");
    const litaC_char* litaC_rootUri = litaC_json__JsonNode_getStr(litaC_params, "rootUri", "");
    litaC_lsp__LspServer_log(litaC_this, "Root Path = '%s'\n", litaC_rootPath);
    litaC_char litaC_path[_MAX_PATH] =  {
        0
    };
    litaC_system__UriToFilePath(litaC_rootUri, litaC_path);
    litaC_lsp__LspServer_log(litaC_this, "Root Uri = '%s' as path: '%s'\n", litaC_rootUri, litaC_path);
    litaC_workspace__Workspace_setup(&((litaC_this->workspace)), litaC_path, litaC_rootUri);
    const char* litaC_capabilities = "\n    {\n        \"capabilities\": {\n            \"textDocumentSync\": 2,\n            \"definitionProvider\": true,\n            \"documentSymbolProvider\": true,\n            \"workspaceSymbolProvider\": true,\n            \"referencesProvider\": true,\n            \"completionProvider\": {\n                \"resolveProvider\": true,\n                \"triggerCharacters\": [\n                    \".\"\n                ]\n            }\n        }\n    }";
    litaC_json__JsonNode* litaC_resp = litaC_lsp__LspServer_createResponse(litaC_this, litaC_json__JsonNode_getInt(litaC_msg, "id", 0));
    litaC_json__JsonParser litaC_parser = litaC_json__JsonParserInit(litaC_lsp__LspServer_requestAlloc(litaC_this));
    litaC_json__JsonNode_put(litaC_resp, "result", litaC_json__JsonParser_parseJson(&((litaC_parser)), litaC_capabilities), -(1));
    litaC_json__JsonNode_put(litaC_resp, "error", litaC_json__JSON_NULL, -(1));
    litaC_lsp__LspServer_writeResponse(litaC_this, litaC_resp);
    
}

litaC_void litaC_lsp__LspServer_handleTextDocumentOpenMessage(litaC_lsp__LspServer* litaC_this,litaC_json__JsonNode* litaC_msg,litaC_json__JsonNode* litaC_params) {
    litaC_json__JsonNode* litaC_textDoc = litaC_json__JsonNode_getObject(litaC_params, "textDocument");
    if(!(litaC_textDoc)) {
        {
            return;
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_uri = litaC_json__JsonNode_getStr(litaC_textDoc, "uri", NULL);
    litaC_workspace__Workspace_openDocument(&((litaC_this->workspace)), litaC_uri, litaC_json__JsonNode_getStr(litaC_textDoc, "text", NULL));
    litaC_lsp__LspServer_writeDiagnostic(litaC_this, litaC_uri);
    
}

litaC_void litaC_lsp__LspServer_handleTextDocumentCloseMessage(litaC_lsp__LspServer* litaC_this,litaC_json__JsonNode* litaC_msg,litaC_json__JsonNode* litaC_params) {
    litaC_json__JsonNode* litaC_textDoc = litaC_json__JsonNode_getObject(litaC_params, "textDocument");
    if(!(litaC_textDoc)) {
        {
            return;
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_uri = litaC_json__JsonNode_getStr(litaC_textDoc, "uri", NULL);
    litaC_workspace__Workspace_closeDocument(&((litaC_this->workspace)), litaC_uri);
    
}

litaC_void litaC_lsp__LspServer_handleTextDocumentSymbolMessage(litaC_lsp__LspServer* litaC_this,litaC_json__JsonNode* litaC_msg,litaC_json__JsonNode* litaC_params) {
    litaC_json__JsonNode* litaC_textDoc = litaC_json__JsonNode_getObject(litaC_params, "textDocument");
    if(!(litaC_textDoc)) {
        {
            return;
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_uri = litaC_json__JsonNode_getStr(litaC_textDoc, "uri", NULL);
    litaC_json__JsonNode* litaC_results = litaC_workspace__Workspace_documentSymbols(&((litaC_this->workspace)), litaC_uri, litaC_lsp__LspServer_requestAlloc(litaC_this));
    litaC_json__JsonNode* litaC_resp = litaC_lsp__LspServer_createResponse(litaC_this, litaC_json__JsonNode_getInt(litaC_msg, "id", 0));
    litaC_json__JsonNode_put(litaC_resp, "result", litaC_results, -(1));
    litaC_json__JsonNode_put(litaC_resp, "error", litaC_json__JSON_NULL, -(1));
    litaC_lsp__LspServer_writeResponse(litaC_this, litaC_resp);
    
}

litaC_void litaC_lsp__LspServer_handleTextDocumentSaveMessage(litaC_lsp__LspServer* litaC_this,litaC_json__JsonNode* litaC_msg,litaC_json__JsonNode* litaC_params) {
    litaC_json__JsonNode* litaC_textDoc = litaC_json__JsonNode_getObject(litaC_params, "textDocument");
    if(!(litaC_textDoc)) {
        {
            return;
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_uri = litaC_json__JsonNode_getStr(litaC_textDoc, "uri", NULL);
    litaC_workspace__Workspace_saveDocument(&((litaC_this->workspace)), litaC_uri);
    litaC_lsp__LspServer_writeDiagnostic(litaC_this, litaC_uri);
    
}

litaC_void litaC_lsp__LspServer_handleTextDocumentChangeMessage(litaC_lsp__LspServer* litaC_this,litaC_json__JsonNode* litaC_msg,litaC_json__JsonNode* litaC_params) {
    litaC_json__JsonNode* litaC_textDoc = litaC_json__JsonNode_getObject(litaC_params, "textDocument");
    if(!(litaC_textDoc)) {
        {
            return;
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_uri = litaC_json__JsonNode_getStr(litaC_textDoc, "uri", NULL);
    litaC_json__JsonNode* litaC_range = litaC_json__JsonNode_getObject(litaC_textDoc, "range");
    const litaC_char* litaC_text = litaC_json__JsonNode_getStr(litaC_textDoc, "text", NULL);
    litaC_protocol__TextDocumentChangeEvent litaC_change =  {
        .range = NULL,
        .text = litaC_text
    };
    litaC_protocol__Range litaC_r =  {
        
    };
    if(litaC_range) {
        {
            litaC_json__JsonNode* litaC_start = litaC_json__JsonNode_getObject(litaC_range, "start");
            if(litaC_start) {
                {
                    litaC_r.start.line = litaC_json__JsonNode_getInt(litaC_start, "line", 0);
                    litaC_r.start.character = litaC_json__JsonNode_getInt(litaC_start, "character", 0);
                    
                    
                }
                
            } 
            
            litaC_json__JsonNode* litaC_end = litaC_json__JsonNode_getObject(litaC_range, "end");
            if(litaC_end) {
                {
                    litaC_r.end.line = litaC_json__JsonNode_getInt(litaC_end, "line", 0);
                    litaC_r.end.character = litaC_json__JsonNode_getInt(litaC_end, "character", 0);
                    
                    
                }
                
            } 
            
            litaC_change.range = &(litaC_r);
            
            
        }
        
    } 
    
    litaC_workspace__Workspace_changeDocument(&((litaC_this->workspace)), litaC_uri, &(litaC_change));
    litaC_lsp__LspServer_writeDiagnostic(litaC_this, litaC_uri);
    
}

litaC_void litaC_lsp__LspServer_handleTextDocumentReferencesMessage(litaC_lsp__LspServer* litaC_this,litaC_json__JsonNode* litaC_msg,litaC_json__JsonNode* litaC_params) {
    litaC_json__JsonNode* litaC_textDoc = litaC_json__JsonNode_getObject(litaC_params, "textDocument");
    if(!(litaC_textDoc)) {
        {
            return;
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_uri = litaC_json__JsonNode_getStr(litaC_textDoc, "uri", NULL);
    litaC_json__JsonNode* litaC_pos = litaC_json__JsonNode_getObject(litaC_params, "position");
    litaC_json__JsonNode* litaC_results = litaC_workspace__Workspace_references(&((litaC_this->workspace)), litaC_uri, litaC_pos, litaC_lsp__LspServer_requestAlloc(litaC_this));
    litaC_json__JsonNode* litaC_resp = litaC_lsp__LspServer_createResponse(litaC_this, litaC_json__JsonNode_getInt(litaC_msg, "id", 0));
    litaC_json__JsonNode_put(litaC_resp, "result", litaC_results, -(1));
    litaC_json__JsonNode_put(litaC_resp, "error", litaC_json__JSON_NULL, -(1));
    litaC_lsp__LspServer_writeResponse(litaC_this, litaC_resp);
    
}

litaC_void litaC_lsp__LspServer_handleTextDocumentDefinitionMessage(litaC_lsp__LspServer* litaC_this,litaC_json__JsonNode* litaC_msg,litaC_json__JsonNode* litaC_params) {
    litaC_json__JsonNode* litaC_textDoc = litaC_json__JsonNode_getObject(litaC_params, "textDocument");
    if(!(litaC_textDoc)) {
        {
            return;
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_uri = litaC_json__JsonNode_getStr(litaC_textDoc, "uri", NULL);
    litaC_json__JsonNode* litaC_pos = litaC_json__JsonNode_getObject(litaC_params, "position");
    litaC_json__JsonNode* litaC_results = litaC_workspace__Workspace_goToDefinition(&((litaC_this->workspace)), litaC_uri, litaC_pos, litaC_lsp__LspServer_requestAlloc(litaC_this));
    litaC_json__JsonNode* litaC_resp = litaC_lsp__LspServer_createResponse(litaC_this, litaC_json__JsonNode_getInt(litaC_msg, "id", 0));
    litaC_json__JsonNode_put(litaC_resp, "result", litaC_results, -(1));
    litaC_json__JsonNode_put(litaC_resp, "error", litaC_json__JSON_NULL, -(1));
    litaC_lsp__LspServer_writeResponse(litaC_this, litaC_resp);
    
}

litaC_void litaC_lsp__LspServer_writeDiagnostic(litaC_lsp__LspServer* litaC_this,const litaC_char* litaC_docUri) {
    litaC_lsp__LspServer_log(litaC_this, "Running diagnostics for: '%s'\n", litaC_docUri);
    litaC_phase_result__PhaseResult* litaC_result = litaC_workspace__Workspace_runDiagnostics(&((litaC_this->workspace)), litaC_lsp__LspServer_requestAlloc(litaC_this));
    litaC_json__JsonNode* litaC_params = litaC_json__CreateJsonObject(litaC_lsp__LspServer_requestAlloc(litaC_this));
    litaC_json__JsonNode_putStr(litaC_params, "uri", litaC_docUri, -(1));
    litaC_json__JsonNode* litaC_diagnostics = litaC_json__CreateJsonArray(litaC_lsp__LspServer_requestAlloc(litaC_this));
    litaC_json__JsonNode_put(litaC_params, "diagnostics", litaC_diagnostics, -(1));
    litaC_json__JsonNode* litaC_resp = litaC_json__CreateJsonObject(litaC_lsp__LspServer_requestAlloc(litaC_this));
    litaC_json__JsonNode_putStr(litaC_resp, "method", "textDocument/publishDiagnostics", -(1));
    litaC_json__JsonNode_put(litaC_resp, "params", litaC_params, -(1));
    litaC_char litaC_output[_MAX_PATH] =  {
        0
    };
    litaC_char* litaC_openedDocFilename = litaC_system__UriToFilePath(litaC_docUri, litaC_output);
    if(!(litaC_array__Array_empty_cb_PhaseError_ce_(&((litaC_result->errors))))) {
        {
            litaC_char litaC_outputPath[_MAX_PATH] =  {
                0
            };
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_PhaseError_ce_(&((litaC_result->errors)));litaC_i += 1) {
                {
                    litaC_phase_result__PhaseError litaC_error = litaC_array__Array_get_cb_PhaseError_ce_(&((litaC_result->errors)), litaC_i);
                    if(!(litaC_error.pos.filename)) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    litaC_char* litaC_modulePathOfError = litaC_system__GetAbsolutePath(litaC_this->workspace.rootPath, litaC_error.pos.filename, litaC_outputPath);
                    if(strcmp(litaC_modulePathOfError, litaC_openedDocFilename) != 0) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    litaC_json__JsonNode* litaC_diagnostic = litaC_json__CreateJsonObject(litaC_lsp__LspServer_requestAlloc(litaC_this));
                    litaC_json__JsonNode_putStr(litaC_diagnostic, "message", litaC_error.message, -(1));
                    litaC_json__JsonNode_putIntNumber(litaC_diagnostic, "severity", 1, -(1));
                    litaC_char* litaC_sourceLine = litaC_string__StringCopy(litaC_error.pos.start, (litaC_i32)(litaC_error.pos.end - litaC_error.pos.start), litaC_lsp__LspServer_requestAlloc(litaC_this));
                    litaC_json__JsonNode_putStr(litaC_diagnostic, "source", litaC_sourceLine, -(1));
                    litaC_json__JsonNode_put(litaC_diagnostic, "range", litaC_protocol__SrcPosToRange(litaC_error.pos, litaC_lsp__LspServer_requestAlloc(litaC_this)), -(1));
                    litaC_json__JsonNode_add(litaC_diagnostics, litaC_diagnostic);
                    
                    
                }
            }
            
            
        }
        
    } 
    
    litaC_lsp__LspServer_writeResponse(litaC_this, litaC_resp);
    
}

litaC_void litaC_lsp__LspServer_writeErrorResponse(litaC_lsp__LspServer* litaC_this,litaC_i64 litaC_id,litaC_i32 litaC_code,const litaC_char* litaC_format,...) {
    va_list litaC_args;
    va_start(litaC_args, litaC_format);
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(512, litaC_lsp__LspServer_requestAlloc(litaC_this));
    litaC_string_buffer__StringBuffer_appendArgs(&((litaC_sb)), litaC_format, litaC_args);
    va_end(litaC_args);
    litaC_json__JsonNode* litaC_error = litaC_json__CreateJsonObject(litaC_lsp__LspServer_requestAlloc(litaC_this));
    litaC_json__JsonNode_putStr(litaC_error, "message", litaC_string_buffer__StringBuffer_cStr(&((litaC_sb))), -(1));
    litaC_json__JsonNode_putIntNumber(litaC_error, "code", litaC_code, -(1));
    litaC_json__JsonNode* litaC_resp = litaC_lsp__LspServer_createResponse(litaC_this, litaC_id);
    litaC_json__JsonNode_put(litaC_resp, "error", litaC_error, -(1));
    litaC_lsp__LspServer_writeResponse(litaC_this, litaC_resp);
    
}

litaC_void litaC_lsp__LspServer_writeResponse(litaC_lsp__LspServer* litaC_this,litaC_json__JsonNode* litaC_msg) {
    litaC_string_buffer__StringBuffer_clear(&((litaC_this->output)));
    litaC_string_buffer__StringBuffer_clear(&((litaC_this->outbound)));
    const litaC_char* litaC_jsonStr = litaC_json__JsonNode_print(litaC_msg, &((litaC_this->output)));
    litaC_i32 litaC_length = litaC_this->output.length;
    if(litaC_length < 1) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_string_buffer__StringBuffer_append(&((litaC_this->outbound)), "Content-Length: %d\n\n%.*s", litaC_length, litaC_length, litaC_this->output.buffer);
    litaC_lsp__LspServer_log(litaC_this, "Sending: Len: %d %.*s\n", litaC_this->outbound.length, litaC_this->outbound.length, litaC_this->outbound.buffer);
    fwrite((const litaC_void*)litaC_string_buffer__StringBuffer_cStr(&((litaC_this->outbound))), sizeof(litaC_char), litaC_this->outbound.length, stdout);
    fflush(stdout);
    
}

litaC_json__JsonNode* litaC_lsp__LspServer_createResponse(litaC_lsp__LspServer* litaC_this,litaC_i64 litaC_id) {
    litaC_json__JsonNode* litaC_response = litaC_json__CreateJsonObject(litaC_lsp__LspServer_requestAlloc(litaC_this));
    litaC_json__JsonNode_putStr(litaC_response, "jsonrpc", "2.0", -(1));
    if(litaC_id > -(1)) {
        {
            litaC_json__JsonNode_putIntNumber(litaC_response, "id", litaC_id, -(1));
            
            
        }
        
    } 
    
    return litaC_response;
    
    
}

litaC_protocol__SymbolInfoKind litaC_protocol__SymbolKindFromSymbol(litaC_symbols__Symbol* litaC_sym) {
    if(!(litaC_sym)) {
        return litaC_protocol__SymbolInfoKind_Null;
        
        
    } 
    
    switch(litaC_sym->kind) {
        case litaC_symbols__SymbolKind_CONST: {
            {
                return litaC_protocol__SymbolInfoKind_Constant;
                
                
                
            }
            
            
        }
        case litaC_symbols__SymbolKind_FUNC: {
            {
                return litaC_protocol__SymbolInfoKind_Function;
                
                
                
            }
            
            
        }
        case litaC_symbols__SymbolKind_VAR: {
            {
                return litaC_protocol__SymbolInfoKind_Variable;
                
                
                
            }
            
            
        }
        case litaC_symbols__SymbolKind_TYPE: {
            {
                litaC_types__TypeInfo* litaC_type = litaC_sym->type;
                if(!(litaC_type)) {
                    return litaC_protocol__SymbolInfoKind_Null;
                    
                    
                } 
                
                switch(litaC_type->kind) {
                    case litaC_types__TypeKind_ARRAY: {
                        {
                            return litaC_protocol__SymbolInfoKind_Array;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_BOOL: {
                        {
                            return litaC_protocol__SymbolInfoKind_Boolean;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_CHAR: {
                        {
                            return litaC_protocol__SymbolInfoKind_Number;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_ENUM: {
                        {
                            return litaC_protocol__SymbolInfoKind_Enum;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_FUNC: {
                        {
                            return litaC_protocol__SymbolInfoKind_Function;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_FUNC_PTR: {
                        {
                            return litaC_protocol__SymbolInfoKind_Object;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_GENERIC_PARAM: {
                        {
                            return litaC_protocol__SymbolInfoKind_TypeParameter;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_NULL: {
                        {
                            return litaC_protocol__SymbolInfoKind_Null;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_PTR: {
                        {
                            return litaC_protocol__SymbolInfoKind_Object;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_STR: {
                        {
                            return litaC_protocol__SymbolInfoKind_String;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_STRUCT: {
                        {
                            return litaC_protocol__SymbolInfoKind_Struct;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_UNION: {
                        {
                            return litaC_protocol__SymbolInfoKind_Struct;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_TRAIT: {
                        {
                            return litaC_protocol__SymbolInfoKind_Interface;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_VOID: {
                        {
                            return litaC_protocol__SymbolInfoKind_Null;
                            
                            
                            
                        }
                        
                        
                    }
                    default: {
                        {
                            return litaC_protocol__SymbolInfoKind_Number;
                            
                            
                            
                        }
                        
                        
                    }
                }
                
                
            }
            
            
        }
        default: {
            {
                return litaC_protocol__SymbolInfoKind_Variable;
                
                
                
            }
            
            
        }
    }
    
}

litaC_json__JsonNode* litaC_protocol__SymbolToSymbolInformation(litaC_symbols__Symbol* litaC_sym,const litaC_char* litaC_rootPath,const litaC_mem__Allocator* litaC_alloc) {
    if(!(litaC_sym)) {
        return NULL;
        
        
    } 
    
    litaC_json__JsonNode* litaC_result = litaC_json__CreateJsonObject(litaC_alloc);
    litaC_json__JsonNode_putStr(litaC_result, "name", litaC_sym->name, -(1));
    litaC_json__JsonNode_putBool(litaC_result, "deprecated", (litaC_sym->flags & litaC_symbols__SymbolFlags_IS_TYPE) && litaC_ast__Decl_hasNote(litaC_sym->decl, "deprecated"), -(1));
    litaC_i32 litaC_kind = (litaC_i32)litaC_protocol__SymbolKindFromSymbol(litaC_sym);
    litaC_json__JsonNode_putIntNumber(litaC_result, "kind", (litaC_i64)litaC_kind, -(1));
    if(litaC_sym->decl) {
        {
            litaC_json__JsonNode_put(litaC_result, "location", litaC_protocol__SrcPosToLocation(litaC_sym->decl->stmt.node.startPos, litaC_rootPath, litaC_alloc), -(1));
            
            
        }
        
    } 
    
    return litaC_result;
    
    
}

litaC_json__JsonNode* litaC_protocol__SrcPosToLocation(litaC_lex__SrcPos litaC_pos,const litaC_char* litaC_rootPath,const litaC_mem__Allocator* litaC_alloc) {
    if(!(litaC_pos.filename)) {
        return NULL;
        
        
    } 
    
    litaC_char litaC_absPath[_MAX_PATH] =  {
        0
    };
    litaC_system__GetAbsolutePath(litaC_rootPath, litaC_pos.filename, litaC_absPath);
    litaC_char litaC_uri[_MAX_PATH] =  {
        0
    };
    litaC_system__FilePathToUri(litaC_absPath, litaC_uri);
    litaC_json__JsonNode* litaC_result = litaC_json__CreateJsonObject(litaC_alloc);
    litaC_json__JsonNode_putStr(litaC_result, "uri", litaC_uri, -(1));
    litaC_json__JsonNode_put(litaC_result, "range", litaC_protocol__SrcPosToRange(litaC_pos, litaC_alloc), -(1));
    return litaC_result;
    
    
}

litaC_json__JsonNode* litaC_protocol__SrcPosWithEndToLocation(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_char* litaC_rootPath,const litaC_mem__Allocator* litaC_alloc) {
    if(!(litaC_startPos.filename)) {
        return NULL;
        
        
    } 
    
    litaC_char litaC_absPath[_MAX_PATH] =  {
        0
    };
    litaC_system__GetAbsolutePath(litaC_rootPath, litaC_startPos.filename, litaC_absPath);
    litaC_char litaC_uri[_MAX_PATH] =  {
        0
    };
    litaC_system__FilePathToUri(litaC_absPath, litaC_uri);
    litaC_json__JsonNode* litaC_result = litaC_json__CreateJsonObject(litaC_alloc);
    litaC_json__JsonNode_putStr(litaC_result, "uri", litaC_uri, -(1));
    litaC_json__JsonNode_put(litaC_result, "range", litaC_protocol__SrcPosWithEndToRange(litaC_startPos, litaC_endPos, litaC_alloc), -(1));
    return litaC_result;
    
    
}

litaC_json__JsonNode* litaC_protocol__SrcPosToRange(litaC_lex__SrcPos litaC_pos,const litaC_mem__Allocator* litaC_alloc) {
    litaC_i64 litaC_lineNumber = (litaC_i64)MAX(litaC_pos.lineNumber - 1, 0);
    litaC_json__JsonNode* litaC_start = litaC_json__CreateJsonObject(litaC_alloc);
    litaC_json__JsonNode_putIntNumber(litaC_start, "line", litaC_lineNumber, -(1));
    litaC_i64 litaC_offset = MAX(0L, (litaC_i64)(litaC_pos.start - litaC_pos.lineStart));
    litaC_json__JsonNode_putIntNumber(litaC_start, "character", litaC_offset, -(1));
    litaC_json__JsonNode* litaC_end = litaC_json__CreateJsonObject(litaC_alloc);
    litaC_json__JsonNode_putIntNumber(litaC_end, "line", litaC_lineNumber, -(1));
    litaC_i64 litaC_length = MAX(1L, (litaC_i64)(litaC_pos.end - litaC_pos.start));
    litaC_json__JsonNode_putIntNumber(litaC_end, "character", litaC_offset + litaC_length, -(1));
    litaC_json__JsonNode* litaC_range = litaC_json__CreateJsonObject(litaC_alloc);
    litaC_json__JsonNode_put(litaC_range, "start", litaC_start, -(1));
    litaC_json__JsonNode_put(litaC_range, "end", litaC_end, -(1));
    return litaC_range;
    
    
}

litaC_json__JsonNode* litaC_protocol__SrcPosWithEndToRange(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_mem__Allocator* litaC_alloc) {
    litaC_i64 litaC_startLineNumber = (litaC_i64)MAX(litaC_startPos.lineNumber - 1, 0);
    litaC_json__JsonNode* litaC_start = litaC_json__CreateJsonObject(litaC_alloc);
    litaC_json__JsonNode_putIntNumber(litaC_start, "line", litaC_startLineNumber, -(1));
    litaC_i64 litaC_startOffset = MAX(0L, (litaC_i64)(litaC_startPos.start - litaC_startPos.lineStart));
    litaC_json__JsonNode_putIntNumber(litaC_start, "character", litaC_startOffset, -(1));
    litaC_i64 litaC_endLineNumber = (litaC_i64)MAX(litaC_endPos.lineNumber - 1, 0);
    litaC_json__JsonNode* litaC_end = litaC_json__CreateJsonObject(litaC_alloc);
    litaC_json__JsonNode_putIntNumber(litaC_end, "line", litaC_endLineNumber, -(1));
    litaC_i64 litaC_endOffset = MAX(1L, (litaC_i64)(litaC_endPos.start - litaC_endPos.lineStart));
    litaC_json__JsonNode_putIntNumber(litaC_end, "character", litaC_endOffset, -(1));
    litaC_json__JsonNode* litaC_range = litaC_json__CreateJsonObject(litaC_alloc);
    litaC_json__JsonNode_put(litaC_range, "start", litaC_start, -(1));
    litaC_json__JsonNode_put(litaC_range, "end", litaC_end, -(1));
    return litaC_range;
    
    
}

litaC_json__JsonNode* litaC_protocol__SrcPosToLocations(const litaC_char* litaC_rootPath,litaC_array__Array_cb_SrcPos_ce_* litaC_results,const litaC_mem__Allocator* litaC_alloc) {
    if(litaC_array__Array_empty_cb_SrcPos_ce_(litaC_results)) {
        {
            return litaC_json__JSON_NULL;
            
            
            
        }
        
    } 
    
    litaC_json__JsonNode* litaC_locations = litaC_json__CreateJsonArray(litaC_alloc);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_SrcPos_ce_(litaC_results);litaC_i += 1) {
        {
            litaC_lex__SrcPos* litaC_pos = litaC_array__Array_getPtr_cb_SrcPos_ce_(litaC_results, litaC_i);
            litaC_json__JsonNode_add(litaC_locations, litaC_protocol__SrcPosToLocation(*((litaC_pos)), litaC_rootPath, litaC_alloc));
            
            
        }
    }
    return litaC_locations;
    
    
}

litaC_void litaC_util__PosToRange(litaC_lex__SrcPos litaC_srcPos,litaC_protocol__Range* litaC_range) {
    litaC_i32 litaC_lineNumber = MAX(0, litaC_srcPos.lineNumber - 1);
    litaC_i32 litaC_offset = MAX(0, (litaC_i32)(litaC_srcPos.start - litaC_srcPos.lineStart));
    litaC_range->start.character = litaC_offset;
    litaC_range->start.line = litaC_lineNumber;
    litaC_offset = MAX(1, (litaC_i32)(litaC_srcPos.end - litaC_srcPos.start));
    litaC_range->end.character = litaC_offset;
    litaC_range->end.line = litaC_lineNumber;
    
}

litaC_bool litaC_util__IsSrcPosAtPosition(litaC_lex__SrcPos* litaC_srcPos,litaC_protocol__Position litaC_pos) {
    if(!(litaC_srcPos)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_srcPos->start)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_fromIndex = litaC_srcPos->position;
    litaC_i32 litaC_toIndex = litaC_fromIndex + (litaC_i32)(litaC_srcPos->end - litaC_srcPos->start);
    if((litaC_pos.line + 1) == litaC_srcPos->lineNumber) {
        {
            if(litaC_pos.character >= litaC_fromIndex && litaC_pos.character <= litaC_toIndex) {
                {
                    return litaC_true;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    return litaC_false;
    
    
}

litaC_util__SourceLocation litaC_util__SourceLookup_findAstNodeByPosition(litaC_util__SourceLookup* litaC_this,litaC_ast__ModuleStmt* litaC_moduleAst,litaC_protocol__Position litaC_pos) {
    if(!(litaC_moduleAst)) {
        {
            return (litaC_util__SourceLocation) {
                
            };
            
            
            
        }
        
    } 
    
    litaC_util__SourceLookup_visitStmt(litaC_this, &((litaC_moduleAst->stmt)));
    return litaC_this->result;
    
    
}

litaC_bool litaC_util__SourceLookup_isNodeAtPos(litaC_util__SourceLookup* litaC_this,litaC_ast__Node* litaC_node) {
    if(!(litaC_node)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_lex__SrcPos litaC_srcPos = litaC_node->startPos;
    if(litaC_util__SourceLookup_isSrcAtPos(litaC_this, &((litaC_srcPos)))) {
        {
            litaC_this->result.kind = litaC_util__SourceLocationKind_AST;
            litaC_this->result.node = litaC_node;
            litaC_util__PosToRange(litaC_srcPos, &(litaC_this->result.location.range));
            return litaC_true;
            
            
            
        }
        
    } 
    
    return litaC_false;
    
    
}

litaC_bool litaC_util__SourceLookup_isSrcAtPos(litaC_util__SourceLookup* litaC_this,litaC_lex__SrcPos* litaC_srcPos) {
    if(!(litaC_srcPos)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_util__IsSrcPosAtPosition(litaC_srcPos, litaC_this->lookupPos)) {
        {
            litaC_util__PosToRange(*((litaC_srcPos)), &(litaC_this->result.location.range));
            return litaC_true;
            
            
            
        }
        
    } 
    
    return litaC_false;
    
    
}

litaC_bool litaC_util__SourceLookup_isTokenAtPos(litaC_util__SourceLookup* litaC_this,litaC_lex__Token litaC_token) {
    if(litaC_util__IsSrcPosAtPosition(&((litaC_token.pos)), litaC_this->lookupPos)) {
        {
            litaC_util__PosToRange(litaC_token.pos, &(litaC_this->result.location.range));
            return litaC_true;
            
            
            
        }
        
    } 
    
    return litaC_false;
    
    
}

litaC_bool litaC_util__SourceLookup_isTypeAtPos(litaC_util__SourceLookup* litaC_this,litaC_ast__TypeSpec* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_type->kind) {
        case litaC_ast__TypeSpecKind_ARRAY: {
            {
                litaC_ast__ArrayTypeSpec* litaC_arraySpec = (litaC_ast__ArrayTypeSpec*)litaC_type;
                if(litaC_arraySpec->numElements) {
                    {
                        if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_arraySpec->numElements)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_isTypeAtPos(litaC_this, litaC_arraySpec->spec.base)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_PTR: {
            {
                if(litaC_util__SourceLookup_isTypeAtPos(litaC_this, litaC_type->base)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_CONST: {
            {
                if(litaC_util__SourceLookup_isTypeAtPos(litaC_this, litaC_type->base)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_NAME: {
            {
                litaC_ast__NameTypeSpec* litaC_name = (litaC_ast__NameTypeSpec*)litaC_type;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)));litaC_i += 1) {
                    {
                        litaC_ast__TypeSpec* litaC_param = litaC_array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)), litaC_i);
                        if(litaC_util__SourceLookup_isTypeAtPos(litaC_this, litaC_param)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_FUNC_PTR: {
            {
                litaC_ast__FuncPtrTypeSpec* litaC_funcPtr = (litaC_ast__FuncPtrTypeSpec*)litaC_type;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_GenericParam_ce_(&((litaC_funcPtr->genericParams)));litaC_i += 1) {
                    {
                        litaC_ast__GenericParam* litaC_param = litaC_array__Array_getPtr_cb_GenericParam_ce_(&((litaC_funcPtr->genericParams)), litaC_i);
                        if(litaC_util__SourceLookup_isTokenAtPos(litaC_this, litaC_param->name)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_funcPtr->args)));litaC_i += 1) {
                    {
                        litaC_ast__TypeSpec* litaC_param = litaC_array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_funcPtr->args)), litaC_i);
                        if(litaC_util__SourceLookup_isTypeAtPos(litaC_this, litaC_param)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                if(litaC_util__SourceLookup_isTypeAtPos(litaC_this, litaC_funcPtr->spec.base)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_isTypeAtPos(litaC_this, litaC_funcPtr->ret)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_NONE: 
        default: {
            {
                
                
            }
            
            
        }
    }
    if(litaC_util__SourceLookup_isSrcAtPos(litaC_this, &((litaC_type->pos)))) {
        {
            litaC_this->result.kind = litaC_util__SourceLocationKind_TYPE;
            litaC_this->result.type = litaC_type;
            return litaC_true;
            
            
            
        }
        
    } 
    
    return litaC_false;
    
    
}

litaC_bool litaC_util__SourceLookup_isDeclAtPos(litaC_util__SourceLookup* litaC_this,litaC_ast__Decl* litaC_decl) {
    if(!(litaC_decl)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_util__SourceLookup_isTokenAtPos(litaC_this, litaC_decl->name)) {
        {
            litaC_this->result.kind = litaC_util__SourceLocationKind_AST;
            litaC_this->result.node = &(litaC_decl->stmt.node);
            litaC_util__PosToRange(litaC_decl->name.pos, &(litaC_this->result.location.range));
            return litaC_true;
            
            
            
        }
        
    } 
    
    return litaC_util__SourceLookup_isNodeAtPos(litaC_this, &((litaC_decl->stmt.node)));
    
    
}

litaC_bool litaC_util__SourceLookup_visitDecl(litaC_util__SourceLookup* litaC_this,litaC_ast__Decl* litaC_node) {
    if(!(litaC_node)) {
        return litaC_false;
        
        
    } 
    
    switch(litaC_node->stmt.node.kind) {
        case litaC_ast__StmtKind_IMPORT_DECL: {
            {
                litaC_ast__ImportDecl* litaC_decl = (litaC_ast__ImportDecl*)litaC_node;
                if(litaC_decl->alias.type == litaC_lex__TokenType_IDENTIFIER) {
                    {
                        if(litaC_util__SourceLookup_isTokenAtPos(litaC_this, litaC_decl->alias)) {
                            {
                                litaC_this->result.kind = litaC_util__SourceLocationKind_AST;
                                litaC_this->result.node = &(litaC_decl->decl.stmt.node);
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_isDeclAtPos(litaC_this, &((litaC_decl->decl)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONST_DECL: 
        case litaC_ast__StmtKind_VAR_DECL: {
            {
                litaC_ast__VarDecl* litaC_decl = (litaC_ast__VarDecl*)litaC_node;
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_decl->expr)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_isTypeAtPos(litaC_this, litaC_decl->typeSpec)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_isDeclAtPos(litaC_this, &((litaC_decl->decl)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TRAIT_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: 
        case litaC_ast__StmtKind_UNION_DECL: {
            {
                litaC_ast__AggregateDecl* litaC_decl = (litaC_ast__AggregateDecl*)litaC_node;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_FieldStmt_ce_(&((litaC_decl->fields)));litaC_i += 1) {
                    {
                        litaC_ast__FieldStmt* litaC_field = litaC_array__Array_getPtr_cb_FieldStmt_ce_(&((litaC_decl->fields)), litaC_i);
                        switch(litaC_field->kind) {
                            case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                                {
                                    if(litaC_util__SourceLookup_visitDecl(litaC_this, &((litaC_field->traitField->decl)))) {
                                        {
                                            return litaC_true;
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                                {
                                    if(litaC_util__SourceLookup_visitDecl(litaC_this, &((litaC_field->varField->decl)))) {
                                        {
                                            return litaC_true;
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                                {
                                    if(litaC_util__SourceLookup_visitDecl(litaC_this, &((litaC_field->enumField->decl)))) {
                                        {
                                            return litaC_true;
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_STRUCT_FIELD_DECL: 
                            case litaC_ast__StmtKind_UNION_FIELD_DECL: {
                                {
                                    if(litaC_util__SourceLookup_visitDecl(litaC_this, &((litaC_field->aggregateField->decl.declaration)))) {
                                        {
                                            return litaC_true;
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            default: {
                                assert(litaC_false);
                                
                                
                            }
                        }
                        
                        
                    }
                }
                if(litaC_util__SourceLookup_isDeclAtPos(litaC_this, &((litaC_decl->decl.declaration)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_DECL: {
            {
                litaC_ast__EnumDecl* litaC_decl = (litaC_ast__EnumDecl*)litaC_node;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_decl->fields)));litaC_i += 1) {
                    {
                        litaC_ast__EnumFieldEntryDecl* litaC_field = litaC_array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_decl->fields)), litaC_i);
                        if(litaC_util__SourceLookup_visitDecl(litaC_this, &((litaC_field->decl)))) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                if(litaC_util__SourceLookup_isDeclAtPos(litaC_this, &((litaC_decl->decl)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                litaC_ast__FuncDecl* litaC_decl = (litaC_ast__FuncDecl*)litaC_node;
                if(litaC_util__SourceLookup_visitStmt(litaC_this, &((litaC_decl->params->stmt)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_visitStmt(litaC_this, litaC_decl->body)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_isTypeAtPos(litaC_this, litaC_decl->returnType)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_isDeclAtPos(litaC_this, &((litaC_decl->decl.declaration)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            {
                litaC_ast__TypedefDecl* litaC_decl = (litaC_ast__TypedefDecl*)litaC_node;
                if(litaC_util__SourceLookup_isTypeAtPos(litaC_this, litaC_decl->type)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_isDeclAtPos(litaC_this, &((litaC_decl->decl.declaration)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_PARAM_DECL: {
            {
                litaC_ast__ParameterDecl* litaC_decl = (litaC_ast__ParameterDecl*)litaC_node;
                if(litaC_decl->defaultExpr) {
                    {
                        if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_decl->defaultExpr)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_isTypeAtPos(litaC_this, litaC_decl->type)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_isDeclAtPos(litaC_this, &((litaC_decl->decl)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NATIVE_DECL: {
            {
                litaC_ast__NativeDecl* litaC_decl = (litaC_ast__NativeDecl*)litaC_node;
                if(litaC_util__SourceLookup_isDeclAtPos(litaC_this, &((litaC_decl->decl)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NOTES_DECL: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_FIELD_ENTRY_DECL: {
            {
                litaC_ast__EnumFieldEntryDecl* litaC_decl = (litaC_ast__EnumFieldEntryDecl*)litaC_node;
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_decl->value)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_isDeclAtPos(litaC_this, &((litaC_decl->decl)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
            {
                litaC_ast__TraitFieldDecl* litaC_decl = (litaC_ast__TraitFieldDecl*)litaC_node;
                if(litaC_util__SourceLookup_isTypeAtPos(litaC_this, litaC_decl->type)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_isDeclAtPos(litaC_this, &((litaC_decl->decl)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_VAR_FIELD_DECL: {
            {
                litaC_ast__VarFieldDecl* litaC_decl = (litaC_ast__VarFieldDecl*)litaC_node;
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_decl->defaultExpr)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_isTypeAtPos(litaC_this, litaC_decl->type)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_isDeclAtPos(litaC_this, &((litaC_decl->decl)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_FIELD_DECL: 
        case litaC_ast__StmtKind_STRUCT_FIELD_DECL: 
        case litaC_ast__StmtKind_UNION_FIELD_DECL: {
            {
                assert(litaC_false);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_DECL: {
            {
                break;
                
                
            }
            
            
        }
        default: {
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_bool litaC_util__SourceLookup_visitStmt(litaC_util__SourceLookup* litaC_this,litaC_ast__Stmt* litaC_node) {
    if(!(litaC_node)) {
        return litaC_false;
        
        
    } 
    
    if(litaC_ast__IsExpr(&((litaC_node->node)))) {
        {
            return litaC_util__SourceLookup_visitExpr(litaC_this, (litaC_ast__Expr*)litaC_node);
            
            
            
        }
        
    } 
    
    if(litaC_ast__IsDecl(&((litaC_node->node)))) {
        {
            return litaC_util__SourceLookup_visitDecl(litaC_this, (litaC_ast__Decl*)litaC_node);
            
            
            
        }
        
    } 
    
    switch(litaC_node->node.kind) {
        case litaC_ast__StmtKind_BLOCK_STMT: {
            {
                litaC_ast__BlockStmt* litaC_stmt = (litaC_ast__BlockStmt*)litaC_node;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)));litaC_i += 1) {
                    {
                        litaC_ast__Stmt* litaC_s = litaC_array__Array_get_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)), litaC_i);
                        if(litaC_util__SourceLookup_visitStmt(litaC_this, litaC_s)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DEFER_STMT: {
            {
                litaC_ast__DeferStmt* litaC_stmt = (litaC_ast__DeferStmt*)litaC_node;
                if(litaC_util__SourceLookup_visitStmt(litaC_this, litaC_stmt->deferedStmt)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DO_WHILE_STMT: {
            {
                litaC_ast__DoWhileStmt* litaC_stmt = (litaC_ast__DoWhileStmt*)litaC_node;
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_stmt->cond)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_visitStmt(litaC_this, litaC_stmt->body)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FOR_STMT: {
            {
                litaC_ast__ForStmt* litaC_stmt = (litaC_ast__ForStmt*)litaC_node;
                if(litaC_util__SourceLookup_visitStmt(litaC_this, litaC_stmt->init)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_stmt->cond)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_visitStmt(litaC_this, litaC_stmt->post)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_visitStmt(litaC_this, litaC_stmt->body)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_BODY_STMT: {
            {
                litaC_ast__FuncBodyStmt* litaC_stmt = (litaC_ast__FuncBodyStmt*)litaC_node;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)));litaC_i += 1) {
                    {
                        litaC_ast__Stmt* litaC_s = litaC_array__Array_get_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)), litaC_i);
                        if(litaC_util__SourceLookup_visitStmt(litaC_this, litaC_s)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IF_STMT: {
            {
                litaC_ast__IfStmt* litaC_stmt = (litaC_ast__IfStmt*)litaC_node;
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_stmt->cond)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_visitStmt(litaC_this, litaC_stmt->then)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_visitStmt(litaC_this, litaC_stmt->elseStmt)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_MODULE_STMT: {
            {
                litaC_ast__ModuleStmt* litaC_stmt = (litaC_ast__ModuleStmt*)litaC_node;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_ImportDecl_ce_(&((litaC_stmt->imports)));litaC_i += 1) {
                    {
                        litaC_ast__ImportDecl* litaC_imp = litaC_array__Array_get_cb__ptr_ImportDecl_ce_(&((litaC_stmt->imports)), litaC_i);
                        if(litaC_util__SourceLookup_visitDecl(litaC_this, &((litaC_imp->decl)))) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_stmt->notes)));litaC_i += 1) {
                    {
                        litaC_ast__NoteStmt* litaC_n = litaC_array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_stmt->notes)), litaC_i);
                        if(litaC_util__SourceLookup_visitStmt(litaC_this, &((litaC_n->stmt)))) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Decl_ce_(&((litaC_stmt->declarations)));litaC_i += 1) {
                    {
                        litaC_ast__Decl* litaC_d = litaC_array__Array_get_cb__ptr_Decl_ce_(&((litaC_stmt->declarations)), litaC_i);
                        if(litaC_util__SourceLookup_visitDecl(litaC_this, litaC_d)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_PARAMETERS_STMT: {
            {
                litaC_ast__ParametersStmt* litaC_stmt = (litaC_ast__ParametersStmt*)litaC_node;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_stmt->params)));litaC_i += 1) {
                    {
                        litaC_ast__ParameterDecl* litaC_p = litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_stmt->params)), litaC_i);
                        if(litaC_util__SourceLookup_visitDecl(litaC_this, &((litaC_p->decl)))) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_RETURN_STMT: {
            {
                litaC_ast__ReturnStmt* litaC_stmt = (litaC_ast__ReturnStmt*)litaC_node;
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_stmt->expr)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SWITCH_CASE_STMT: {
            {
                litaC_ast__SwitchCaseStmt* litaC_stmt = (litaC_ast__SwitchCaseStmt*)litaC_node;
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_stmt->cond)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_visitStmt(litaC_this, litaC_stmt->body)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SWITCH_STMT: {
            {
                litaC_ast__SwitchStmt* litaC_stmt = (litaC_ast__SwitchStmt*)litaC_node;
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_stmt->cond)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_SwitchCaseStmt_ce_(&((litaC_stmt->cases)));litaC_i += 1) {
                    {
                        litaC_ast__SwitchCaseStmt* litaC_s = litaC_array__Array_get_cb__ptr_SwitchCaseStmt_ce_(&((litaC_stmt->cases)), litaC_i);
                        if(litaC_util__SourceLookup_visitStmt(litaC_this, &((litaC_s->stmt)))) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                if(litaC_util__SourceLookup_visitStmt(litaC_this, litaC_stmt->defaultStmt)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_WHILE_STMT: {
            {
                litaC_ast__WhileStmt* litaC_stmt = (litaC_ast__WhileStmt*)litaC_node;
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_stmt->cond)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_visitStmt(litaC_this, litaC_stmt->body)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BREAK_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONTINUE_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_EMPTY_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GOTO_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_COMP_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_LABEL_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NOTE_STMT: {
            {
                break;
                
                
            }
            
            
        }
        default: {
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_bool litaC_util__SourceLookup_visitExpr(litaC_util__SourceLookup* litaC_this,litaC_ast__Expr* litaC_node) {
    if(!(litaC_node)) {
        return litaC_false;
        
        
    } 
    
    switch(litaC_node->stmt.node.kind) {
        case litaC_ast__StmtKind_ARRAY_DESIGNATION_EXPR: {
            {
                litaC_ast__ArrayDesignationExpr* litaC_expr = (litaC_ast__ArrayDesignationExpr*)litaC_node;
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_expr->value)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_expr->index)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ARRAY_INIT_EXPR: {
            {
                litaC_ast__ArrayInitExpr* litaC_expr = (litaC_ast__ArrayInitExpr*)litaC_node;
                if(litaC_util__SourceLookup_isTypeAtPos(litaC_this, litaC_expr->type)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_Expr_ce_(&((litaC_expr->values)));litaC_i += 1) {
                    {
                        litaC_ast__Expr* litaC_e = litaC_array__Array_get_cb__ptr_Expr_ce_(&((litaC_expr->values)), litaC_i);
                        if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_e)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BINARY_EXPR: {
            {
                litaC_ast__BinaryExpr* litaC_expr = (litaC_ast__BinaryExpr*)litaC_node;
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_expr->left)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_expr->right)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CAST_EXPR: {
            {
                litaC_ast__CastExpr* litaC_expr = (litaC_ast__CastExpr*)litaC_node;
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_expr->exprToCast)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_isTypeAtPos(litaC_this, litaC_expr->castTo)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_CALL_EXPR: {
            {
                litaC_ast__FuncCallExpr* litaC_expr = (litaC_ast__FuncCallExpr*)litaC_node;
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_expr->object)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_CallArg_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
                    {
                        litaC_ast__Expr* litaC_arg = litaC_array__Array_get_cb_CallArg_ce_(&((litaC_expr->arguments)), litaC_i).argExpr;
                        if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_arg)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR: 
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: {
            {
                litaC_ast__IdentifierExpr* litaC_expr = (litaC_ast__IdentifierExpr*)litaC_node;
                if(litaC_util__SourceLookup_isTypeAtPos(litaC_this, &((litaC_expr->type->spec)))) {
                    {
                        litaC_this->result.kind = litaC_util__SourceLocationKind_AST;
                        litaC_this->result.node = &(litaC_expr->expr.stmt.node);
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPE_IDENTIFIER_EXPR: {
            {
                litaC_ast__TypeIdentifierExpr* litaC_expr = (litaC_ast__TypeIdentifierExpr*)litaC_node;
                if(litaC_util__SourceLookup_isTypeAtPos(litaC_this, litaC_expr->type)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GET_EXPR: {
            {
                litaC_ast__GetExpr* litaC_expr = (litaC_ast__GetExpr*)litaC_node;
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_expr->object)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_visitExpr(litaC_this, &((litaC_expr->field->expr)))) {
                    {
                        litaC_this->result.kind = litaC_util__SourceLocationKind_AST;
                        litaC_this->result.node = &(litaC_node->stmt.node);
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GROUP_EXPR: {
            {
                litaC_ast__GroupExpr* litaC_expr = (litaC_ast__GroupExpr*)litaC_node;
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_expr->groupedExpr)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_INIT_EXPR: {
            {
                litaC_ast__InitExpr* litaC_expr = (litaC_ast__InitExpr*)litaC_node;
                if(litaC_util__SourceLookup_isTypeAtPos(litaC_this, &((litaC_expr->type->spec)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)));litaC_i += 1) {
                    {
                        litaC_ast__TypeSpec* litaC_arg = litaC_array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)), litaC_i);
                        if(litaC_util__SourceLookup_isTypeAtPos(litaC_this, litaC_arg)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
                    {
                        litaC_ast__InitArgExpr* litaC_arg = litaC_array__Array_get_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)), litaC_i);
                        if(litaC_util__SourceLookup_visitExpr(litaC_this, &((litaC_arg->expr)))) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_INIT_ARG_EXPR: {
            {
                litaC_ast__InitArgExpr* litaC_expr = (litaC_ast__InitArgExpr*)litaC_node;
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_expr->value)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_expr->fieldName.type == litaC_lex__TokenType_IDENTIFIER) {
                    {
                        if(litaC_util__SourceLookup_isTokenAtPos(litaC_this, litaC_expr->fieldName)) {
                            {
                                litaC_this->result.kind = litaC_util__SourceLocationKind_AST;
                                litaC_this->result.node = &(litaC_node->stmt.node);
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_OFFSET_OF_EXPR: {
            {
                litaC_ast__OffsetOfExpr* litaC_expr = (litaC_ast__OffsetOfExpr*)litaC_node;
                if(litaC_util__SourceLookup_isTypeAtPos(litaC_this, litaC_expr->type)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_expr->field.type == litaC_lex__TokenType_IDENTIFIER) {
                    {
                        if(litaC_util__SourceLookup_isTokenAtPos(litaC_this, litaC_expr->field)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SET_EXPR: {
            {
                litaC_ast__SetExpr* litaC_expr = (litaC_ast__SetExpr*)litaC_node;
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_expr->object)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_visitExpr(litaC_this, &((litaC_expr->field->expr)))) {
                    {
                        litaC_this->result.kind = litaC_util__SourceLocationKind_AST;
                        litaC_this->result.node = &(litaC_node->stmt.node);
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_expr->value)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SIZE_OF_EXPR: {
            {
                litaC_ast__SizeOfExpr* litaC_expr = (litaC_ast__SizeOfExpr*)litaC_node;
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_expr->sizeOfExpr)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_GET_EXPR: {
            {
                litaC_ast__SubscriptGetExpr* litaC_expr = (litaC_ast__SubscriptGetExpr*)litaC_node;
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_expr->object)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_expr->index)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_SET_EXPR: {
            {
                litaC_ast__SubscriptSetExpr* litaC_expr = (litaC_ast__SubscriptSetExpr*)litaC_node;
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_expr->object)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_expr->index)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_expr->value)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TERNARY_EXPR: {
            {
                litaC_ast__TernaryExpr* litaC_expr = (litaC_ast__TernaryExpr*)litaC_node;
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_expr->cond)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_expr->then)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_expr->other)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPE_OF_EXPR: {
            {
                litaC_ast__TypeOfExpr* litaC_expr = (litaC_ast__TypeOfExpr*)litaC_node;
                if(litaC_util__SourceLookup_isTypeAtPos(litaC_this, litaC_expr->type)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_expr->typeOfExpr)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNARY_EXPR: {
            {
                litaC_ast__UnaryExpr* litaC_expr = (litaC_ast__UnaryExpr*)litaC_node;
                if(litaC_util__SourceLookup_visitExpr(litaC_this, litaC_expr->unaryExpr)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NULL_EXPR: 
        case litaC_ast__StmtKind_NUMBER_EXPR: 
        case litaC_ast__StmtKind_STRING_EXPR: 
        case litaC_ast__StmtKind_CHAR_EXPR: 
        case litaC_ast__StmtKind_BOOLEAN_EXPR: 
        case litaC_ast__StmtKind_POISON_EXPR: {
            {
                break;
                
                
            }
            
            
        }
        default: {
            
            
        }
    }
    return litaC_false;
    
    
}

const litaC_char* litaC_io__FileStatusAsStr(litaC_io__FileStatus litaC_enumType) {
    switch(litaC_enumType) {
        case litaC_io__FileStatus_Ok: {
            return "Ok";
            
            
            
        }
        case litaC_io__FileStatus_FileNotFoundError: {
            return "FileNotFoundError";
            
            
            
        }
        case litaC_io__FileStatus_IOError: {
            return "IOError";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

const litaC_char* litaC_lex__TokenTypeAsStr(litaC_lex__TokenType litaC_enumType) {
    switch(litaC_enumType) {
        case litaC_lex__TokenType_IMPORT: {
            return "IMPORT";
            
            
            
        }
        case litaC_lex__TokenType_STRUCT: {
            return "STRUCT";
            
            
            
        }
        case litaC_lex__TokenType_UNION: {
            return "UNION";
            
            
            
        }
        case litaC_lex__TokenType_TRAIT: {
            return "TRAIT";
            
            
            
        }
        case litaC_lex__TokenType_ENUM: {
            return "ENUM";
            
            
            
        }
        case litaC_lex__TokenType_FUNC: {
            return "FUNC";
            
            
            
        }
        case litaC_lex__TokenType_TYPEDEF: {
            return "TYPEDEF";
            
            
            
        }
        case litaC_lex__TokenType_VAR: {
            return "VAR";
            
            
            
        }
        case litaC_lex__TokenType_CONST: {
            return "CONST";
            
            
            
        }
        case litaC_lex__TokenType_NULL: {
            return "NULL";
            
            
            
        }
        case litaC_lex__TokenType_VOID: {
            return "VOID";
            
            
            
        }
        case litaC_lex__TokenType_TRUE: {
            return "TRUE";
            
            
            
        }
        case litaC_lex__TokenType_FALSE: {
            return "FALSE";
            
            
            
        }
        case litaC_lex__TokenType_BOOL: {
            return "BOOL";
            
            
            
        }
        case litaC_lex__TokenType_CHAR: {
            return "CHAR";
            
            
            
        }
        case litaC_lex__TokenType_I8: {
            return "I8";
            
            
            
        }
        case litaC_lex__TokenType_U8: {
            return "U8";
            
            
            
        }
        case litaC_lex__TokenType_I16: {
            return "I16";
            
            
            
        }
        case litaC_lex__TokenType_U16: {
            return "U16";
            
            
            
        }
        case litaC_lex__TokenType_I32: {
            return "I32";
            
            
            
        }
        case litaC_lex__TokenType_U32: {
            return "U32";
            
            
            
        }
        case litaC_lex__TokenType_I64: {
            return "I64";
            
            
            
        }
        case litaC_lex__TokenType_U64: {
            return "U64";
            
            
            
        }
        case litaC_lex__TokenType_F32: {
            return "F32";
            
            
            
        }
        case litaC_lex__TokenType_F64: {
            return "F64";
            
            
            
        }
        case litaC_lex__TokenType_USIZE: {
            return "USIZE";
            
            
            
        }
        case litaC_lex__TokenType_FOR: {
            return "FOR";
            
            
            
        }
        case litaC_lex__TokenType_WHILE: {
            return "WHILE";
            
            
            
        }
        case litaC_lex__TokenType_DO: {
            return "DO";
            
            
            
        }
        case litaC_lex__TokenType_IF: {
            return "IF";
            
            
            
        }
        case litaC_lex__TokenType_ELSE: {
            return "ELSE";
            
            
            
        }
        case litaC_lex__TokenType_SWITCH: {
            return "SWITCH";
            
            
            
        }
        case litaC_lex__TokenType_CASE: {
            return "CASE";
            
            
            
        }
        case litaC_lex__TokenType_DEFAULT: {
            return "DEFAULT";
            
            
            
        }
        case litaC_lex__TokenType_DEFER: {
            return "DEFER";
            
            
            
        }
        case litaC_lex__TokenType_BREAK: {
            return "BREAK";
            
            
            
        }
        case litaC_lex__TokenType_CONTINUE: {
            return "CONTINUE";
            
            
            
        }
        case litaC_lex__TokenType_RETURN: {
            return "RETURN";
            
            
            
        }
        case litaC_lex__TokenType_GOTO: {
            return "GOTO";
            
            
            
        }
        case litaC_lex__TokenType_SIZEOF: {
            return "SIZEOF";
            
            
            
        }
        case litaC_lex__TokenType_TYPEOF: {
            return "TYPEOF";
            
            
            
        }
        case litaC_lex__TokenType_OFFSETOF: {
            return "OFFSETOF";
            
            
            
        }
        case litaC_lex__TokenType_AS: {
            return "AS";
            
            
            
        }
        case litaC_lex__TokenType_PUBLIC: {
            return "PUBLIC";
            
            
            
        }
        case litaC_lex__TokenType_USING: {
            return "USING";
            
            
            
        }
        case litaC_lex__TokenType_PLUS: {
            return "PLUS";
            
            
            
        }
        case litaC_lex__TokenType_MINUS: {
            return "MINUS";
            
            
            
        }
        case litaC_lex__TokenType_STAR: {
            return "STAR";
            
            
            
        }
        case litaC_lex__TokenType_MOD: {
            return "MOD";
            
            
            
        }
        case litaC_lex__TokenType_SLASH: {
            return "SLASH";
            
            
            
        }
        case litaC_lex__TokenType_DOLLAR: {
            return "DOLLAR";
            
            
            
        }
        case litaC_lex__TokenType_HASH: {
            return "HASH";
            
            
            
        }
        case litaC_lex__TokenType_DOT: {
            return "DOT";
            
            
            
        }
        case litaC_lex__TokenType_VAR_ARGS: {
            return "VAR_ARGS";
            
            
            
        }
        case litaC_lex__TokenType_AT: {
            return "AT";
            
            
            
        }
        case litaC_lex__TokenType_QUESTION_MARK: {
            return "QUESTION_MARK";
            
            
            
        }
        case litaC_lex__TokenType_COMMA: {
            return "COMMA";
            
            
            
        }
        case litaC_lex__TokenType_SEMICOLON: {
            return "SEMICOLON";
            
            
            
        }
        case litaC_lex__TokenType_COLON: {
            return "COLON";
            
            
            
        }
        case litaC_lex__TokenType_COLON_COLON: {
            return "COLON_COLON";
            
            
            
        }
        case litaC_lex__TokenType_DOUBLE_QUOTE: {
            return "DOUBLE_QUOTE";
            
            
            
        }
        case litaC_lex__TokenType_LESS_THAN: {
            return "LESS_THAN";
            
            
            
        }
        case litaC_lex__TokenType_LESS_EQUALS: {
            return "LESS_EQUALS";
            
            
            
        }
        case litaC_lex__TokenType_GREATER_THAN: {
            return "GREATER_THAN";
            
            
            
        }
        case litaC_lex__TokenType_GREATER_EQUALS: {
            return "GREATER_EQUALS";
            
            
            
        }
        case litaC_lex__TokenType_EQUALS_EQUALS: {
            return "EQUALS_EQUALS";
            
            
            
        }
        case litaC_lex__TokenType_EQUALS: {
            return "EQUALS";
            
            
            
        }
        case litaC_lex__TokenType_NOT_EQUALS: {
            return "NOT_EQUALS";
            
            
            
        }
        case litaC_lex__TokenType_PLUS_EQ: {
            return "PLUS_EQ";
            
            
            
        }
        case litaC_lex__TokenType_MINUS_EQ: {
            return "MINUS_EQ";
            
            
            
        }
        case litaC_lex__TokenType_DIV_EQ: {
            return "DIV_EQ";
            
            
            
        }
        case litaC_lex__TokenType_MUL_EQ: {
            return "MUL_EQ";
            
            
            
        }
        case litaC_lex__TokenType_MOD_EQ: {
            return "MOD_EQ";
            
            
            
        }
        case litaC_lex__TokenType_LSHIFT_EQ: {
            return "LSHIFT_EQ";
            
            
            
        }
        case litaC_lex__TokenType_RSHIFT_EQ: {
            return "RSHIFT_EQ";
            
            
            
        }
        case litaC_lex__TokenType_BNOT_EQ: {
            return "BNOT_EQ";
            
            
            
        }
        case litaC_lex__TokenType_XOR_EQ: {
            return "XOR_EQ";
            
            
            
        }
        case litaC_lex__TokenType_BAND_EQ: {
            return "BAND_EQ";
            
            
            
        }
        case litaC_lex__TokenType_BOR_EQ: {
            return "BOR_EQ";
            
            
            
        }
        case litaC_lex__TokenType_LSHIFT: {
            return "LSHIFT";
            
            
            
        }
        case litaC_lex__TokenType_RSHIFT: {
            return "RSHIFT";
            
            
            
        }
        case litaC_lex__TokenType_BNOT: {
            return "BNOT";
            
            
            
        }
        case litaC_lex__TokenType_XOR: {
            return "XOR";
            
            
            
        }
        case litaC_lex__TokenType_BAND: {
            return "BAND";
            
            
            
        }
        case litaC_lex__TokenType_BOR: {
            return "BOR";
            
            
            
        }
        case litaC_lex__TokenType_LEFT_PAREN: {
            return "LEFT_PAREN";
            
            
            
        }
        case litaC_lex__TokenType_RIGHT_PAREN: {
            return "RIGHT_PAREN";
            
            
            
        }
        case litaC_lex__TokenType_LEFT_BRACKET: {
            return "LEFT_BRACKET";
            
            
            
        }
        case litaC_lex__TokenType_RIGHT_BRACKET: {
            return "RIGHT_BRACKET";
            
            
            
        }
        case litaC_lex__TokenType_LEFT_BRACE: {
            return "LEFT_BRACE";
            
            
            
        }
        case litaC_lex__TokenType_RIGHT_BRACE: {
            return "RIGHT_BRACE";
            
            
            
        }
        case litaC_lex__TokenType_NOT: {
            return "NOT";
            
            
            
        }
        case litaC_lex__TokenType_OR: {
            return "OR";
            
            
            
        }
        case litaC_lex__TokenType_AND: {
            return "AND";
            
            
            
        }
        case litaC_lex__TokenType_STRING: {
            return "STRING";
            
            
            
        }
        case litaC_lex__TokenType_IDENTIFIER: {
            return "IDENTIFIER";
            
            
            
        }
        case litaC_lex__TokenType_INT_NUMBER: {
            return "INT_NUMBER";
            
            
            
        }
        case litaC_lex__TokenType_FLOAT_NUMBER: {
            return "FLOAT_NUMBER";
            
            
            
        }
        case litaC_lex__TokenType_ERROR: {
            return "ERROR";
            
            
            
        }
        case litaC_lex__TokenType_END_OF_FILE: {
            return "END_OF_FILE";
            
            
            
        }
        case litaC_lex__TokenType_MAX_TOKEN_TYPES: {
            return "MAX_TOKEN_TYPES";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

const litaC_char* litaC_types__TypeKindAsStr(litaC_types__TypeKind litaC_enumType) {
    switch(litaC_enumType) {
        case litaC_types__TypeKind_BOOL: {
            return "BOOL";
            
            
            
        }
        case litaC_types__TypeKind_CHAR: {
            return "CHAR";
            
            
            
        }
        case litaC_types__TypeKind_I8: {
            return "I8";
            
            
            
        }
        case litaC_types__TypeKind_U8: {
            return "U8";
            
            
            
        }
        case litaC_types__TypeKind_I16: {
            return "I16";
            
            
            
        }
        case litaC_types__TypeKind_U16: {
            return "U16";
            
            
            
        }
        case litaC_types__TypeKind_I32: {
            return "I32";
            
            
            
        }
        case litaC_types__TypeKind_U32: {
            return "U32";
            
            
            
        }
        case litaC_types__TypeKind_I64: {
            return "I64";
            
            
            
        }
        case litaC_types__TypeKind_U64: {
            return "U64";
            
            
            
        }
        case litaC_types__TypeKind_F32: {
            return "F32";
            
            
            
        }
        case litaC_types__TypeKind_F64: {
            return "F64";
            
            
            
        }
        case litaC_types__TypeKind_USIZE: {
            return "USIZE";
            
            
            
        }
        case litaC_types__TypeKind_NULL: {
            return "NULL";
            
            
            
        }
        case litaC_types__TypeKind_VOID: {
            return "VOID";
            
            
            
        }
        case litaC_types__TypeKind_STR: {
            return "STR";
            
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            return "ARRAY";
            
            
            
        }
        case litaC_types__TypeKind_PTR: {
            return "PTR";
            
            
            
        }
        case litaC_types__TypeKind_FUNC_PTR: {
            return "FUNC_PTR";
            
            
            
        }
        case litaC_types__TypeKind_STRUCT: {
            return "STRUCT";
            
            
            
        }
        case litaC_types__TypeKind_UNION: {
            return "UNION";
            
            
            
        }
        case litaC_types__TypeKind_TRAIT: {
            return "TRAIT";
            
            
            
        }
        case litaC_types__TypeKind_ENUM: {
            return "ENUM";
            
            
            
        }
        case litaC_types__TypeKind_FUNC: {
            return "FUNC";
            
            
            
        }
        case litaC_types__TypeKind_CONST: {
            return "CONST";
            
            
            
        }
        case litaC_types__TypeKind_GENERIC_PARAM: {
            return "GENERIC_PARAM";
            
            
            
        }
        case litaC_types__TypeKind_POISON: {
            return "POISON";
            
            
            
        }
        case litaC_types__TypeKind_MAX_TYPE_KINDS: {
            return "MAX_TYPE_KINDS";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

const litaC_char* litaC_ast__StmtKindAsStr(litaC_ast__StmtKind litaC_enumType) {
    switch(litaC_enumType) {
        case litaC_ast__StmtKind_IMPORT_DECL: {
            return "IMPORT_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_CONST_DECL: {
            return "CONST_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_VAR_DECL: {
            return "VAR_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_STRUCT_DECL: {
            return "STRUCT_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_UNION_DECL: {
            return "UNION_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_TRAIT_DECL: {
            return "TRAIT_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_ENUM_DECL: {
            return "ENUM_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_FUNC_DECL: {
            return "FUNC_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            return "TYPEDEF_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_PARAM_DECL: {
            return "PARAM_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_NATIVE_DECL: {
            return "NATIVE_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_NOTES_DECL: {
            return "NOTES_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_VAR_FIELD_DECL: {
            return "VAR_FIELD_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_ENUM_FIELD_ENTRY_DECL: {
            return "ENUM_FIELD_ENTRY_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
            return "ENUM_FIELD_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
            return "STRUCT_FIELD_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_UNION_FIELD_DECL: {
            return "UNION_FIELD_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
            return "TRAIT_FIELD_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_POISON_DECL: {
            return "POISON_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_BLOCK_STMT: {
            return "BLOCK_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_BREAK_STMT: {
            return "BREAK_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_COMP_STMT: {
            return "COMP_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_CONTINUE_STMT: {
            return "CONTINUE_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_DEFER_STMT: {
            return "DEFER_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_DO_WHILE_STMT: {
            return "DO_WHILE_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_EMPTY_STMT: {
            return "EMPTY_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_FOR_STMT: {
            return "FOR_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_FUNC_BODY_STMT: {
            return "FUNC_BODY_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_GOTO_STMT: {
            return "GOTO_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_IF_STMT: {
            return "IF_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_LABEL_STMT: {
            return "LABEL_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_MODULE_STMT: {
            return "MODULE_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_NOTE_STMT: {
            return "NOTE_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_PARAMETERS_STMT: {
            return "PARAMETERS_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_RETURN_STMT: {
            return "RETURN_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_SWITCH_CASE_STMT: {
            return "SWITCH_CASE_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_SWITCH_STMT: {
            return "SWITCH_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_WHILE_STMT: {
            return "WHILE_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_ARRAY_DESIGNATION_EXPR: {
            return "ARRAY_DESIGNATION_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_ARRAY_INIT_EXPR: {
            return "ARRAY_INIT_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_BINARY_EXPR: {
            return "BINARY_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_BOOLEAN_EXPR: {
            return "BOOLEAN_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_CAST_EXPR: {
            return "CAST_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_CHAR_EXPR: {
            return "CHAR_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_FUNC_CALL_EXPR: {
            return "FUNC_CALL_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR: {
            return "FUNC_IDENTIFIER_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_GET_EXPR: {
            return "GET_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_GROUP_EXPR: {
            return "GROUP_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: {
            return "IDENTIFIER_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_INIT_EXPR: {
            return "INIT_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_INIT_ARG_EXPR: {
            return "INIT_ARG_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_NULL_EXPR: {
            return "NULL_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_NUMBER_EXPR: {
            return "NUMBER_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_OFFSET_OF_EXPR: {
            return "OFFSET_OF_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_SET_EXPR: {
            return "SET_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_SIZE_OF_EXPR: {
            return "SIZE_OF_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_STRING_EXPR: {
            return "STRING_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_GET_EXPR: {
            return "SUBSCRIPT_GET_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_SET_EXPR: {
            return "SUBSCRIPT_SET_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_TERNARY_EXPR: {
            return "TERNARY_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_TYPE_IDENTIFIER_EXPR: {
            return "TYPE_IDENTIFIER_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_TYPE_OF_EXPR: {
            return "TYPE_OF_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_UNARY_EXPR: {
            return "UNARY_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_POISON_EXPR: {
            return "POISON_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_MAX_STMT_KINDS: {
            return "MAX_STMT_KINDS";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

const litaC_char* litaC_ast__TypeSpecKindAsStr(litaC_ast__TypeSpecKind litaC_enumType) {
    switch(litaC_enumType) {
        case litaC_ast__TypeSpecKind_NONE: {
            return "NONE";
            
            
            
        }
        case litaC_ast__TypeSpecKind_ARRAY: {
            return "ARRAY";
            
            
            
        }
        case litaC_ast__TypeSpecKind_PTR: {
            return "PTR";
            
            
            
        }
        case litaC_ast__TypeSpecKind_CONST: {
            return "CONST";
            
            
            
        }
        case litaC_ast__TypeSpecKind_NAME: {
            return "NAME";
            
            
            
        }
        case litaC_ast__TypeSpecKind_FUNC_PTR: {
            return "FUNC_PTR";
            
            
            
        }
        case litaC_ast__TypeSpecKind_MAX_TYPESPEC_KINDS: {
            return "MAX_TYPESPEC_KINDS";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

const litaC_char* litaC_symbols__SymbolKindAsStr(litaC_symbols__SymbolKind litaC_enumType) {
    switch(litaC_enumType) {
        case litaC_symbols__SymbolKind_TYPE: {
            return "TYPE";
            
            
            
        }
        case litaC_symbols__SymbolKind_VAR: {
            return "VAR";
            
            
            
        }
        case litaC_symbols__SymbolKind_CONST: {
            return "CONST";
            
            
            
        }
        case litaC_symbols__SymbolKind_FUNC: {
            return "FUNC";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

const litaC_char* litaC_symbols__SymbolStateAsStr(litaC_symbols__SymbolState litaC_enumType) {
    switch(litaC_enumType) {
        case litaC_symbols__SymbolState_UNRESOLVED: {
            return "UNRESOLVED";
            
            
            
        }
        case litaC_symbols__SymbolState_RESOLVING: {
            return "RESOLVING";
            
            
            
        }
        case litaC_symbols__SymbolState_RESOLVED: {
            return "RESOLVED";
            
            
            
        }
        case litaC_symbols__SymbolState_ERROR: {
            return "ERROR";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

const litaC_char* litaC_lita__MetricTypeAsStr(litaC_lita__MetricType litaC_enumType) {
    switch(litaC_enumType) {
        case litaC_lita__MetricType_PARSING: {
            return "PARSING";
            
            
            
        }
        case litaC_lita__MetricType_TYPE_CHECKING: {
            return "TYPE_CHECKING";
            
            
            
        }
        case litaC_lita__MetricType_CGEN: {
            return "CGEN";
            
            
            
        }
        case litaC_lita__MetricType_CCOMPILE: {
            return "CCOMPILE";
            
            
            
        }
        case litaC_lita__MetricType_MAX_METRIC_TYPES: {
            return "MAX_METRIC_TYPES";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

const litaC_char* litaC_lita__TypeInfoOptionAsStr(litaC_lita__TypeInfoOption litaC_enumType) {
    switch(litaC_enumType) {
        case litaC_lita__TypeInfoOption_NONE: {
            return "NONE";
            
            
            
        }
        case litaC_lita__TypeInfoOption_TAGGED: {
            return "TAGGED";
            
            
            
        }
        case litaC_lita__TypeInfoOption_ALL: {
            return "ALL";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

const litaC_char* litaC_json__JsonTypeAsStr(litaC_json__JsonType litaC_enumType) {
    switch(litaC_enumType) {
        case litaC_json__JsonType_NULL: {
            return "NULL";
            
            
            
        }
        case litaC_json__JsonType_BOOLEAN: {
            return "BOOLEAN";
            
            
            
        }
        case litaC_json__JsonType_INT_NUMBER: {
            return "INT_NUMBER";
            
            
            
        }
        case litaC_json__JsonType_FLOAT_NUMBER: {
            return "FLOAT_NUMBER";
            
            
            
        }
        case litaC_json__JsonType_STRING: {
            return "STRING";
            
            
            
        }
        case litaC_json__JsonType_OBJECT: {
            return "OBJECT";
            
            
            
        }
        case litaC_json__JsonType_ARRAY: {
            return "ARRAY";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

const litaC_char* litaC_protocol__SymbolInfoKindAsStr(litaC_protocol__SymbolInfoKind litaC_enumType) {
    switch(litaC_enumType) {
        case litaC_protocol__SymbolInfoKind_File: {
            return "File";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_Module: {
            return "Module";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_Namespace: {
            return "Namespace";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_Package: {
            return "Package";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_Class: {
            return "Class";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_Method: {
            return "Method";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_Property: {
            return "Property";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_Field: {
            return "Field";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_Constructor: {
            return "Constructor";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_Enum: {
            return "Enum";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_Interface: {
            return "Interface";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_Function: {
            return "Function";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_Variable: {
            return "Variable";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_Constant: {
            return "Constant";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_String: {
            return "String";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_Number: {
            return "Number";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_Boolean: {
            return "Boolean";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_Array: {
            return "Array";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_Object: {
            return "Object";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_Key: {
            return "Key";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_Null: {
            return "Null";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_EnumMember: {
            return "EnumMember";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_Struct: {
            return "Struct";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_Event: {
            return "Event";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_Operator: {
            return "Operator";
            
            
            
        }
        case litaC_protocol__SymbolInfoKind_TypeParameter: {
            return "TypeParameter";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb_PhaseError_ce_(litaC_array__Array_cb_PhaseError_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_PhaseError_ce_(litaC_array__Array_cb_PhaseError_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_phase_result__PhaseError litaC_array__Array_get_cb_PhaseError_ce_(litaC_array__Array_cb_PhaseError_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_const_char_ce_(litaC_array__Array_cb__ptr_const_char_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

const litaC_char* litaC_array__Array_get_cb__ptr_const_char_ce_(litaC_array__Array_cb__ptr_const_char_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_mem__Arena* litaC_mem__new_cb_Arena_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_mem__Arena* litaC_result = (litaC_mem__Arena*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_mem__Arena));
    return litaC_result;
    
    
}

litaC_void litaC_array__Array_init_cb__ptr_Allocation_ce_(litaC_array__Array_cb__ptr_Allocation_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_mem__Allocation*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_mem__Allocation**)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_array__Array_free_cb__ptr_Allocation_ce_(litaC_array__Array_cb__ptr_Allocation_ce_* litaC_a) {
    if(litaC_a && litaC_a->elements) {
        {
            litaC_mem__Allocator_free(litaC_a->alloc, (litaC_void*)litaC_a->elements);
            litaC_a->elements = NULL;
            litaC_a->length = 0;
            litaC_a->capacity = 0;
            
            
        }
        
    } 
    
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_Allocation_ce_(litaC_array__Array_cb__ptr_Allocation_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_mem__Allocation* litaC_array__Array_get_cb__ptr_Allocation_ce_(litaC_array__Array_cb__ptr_Allocation_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_mem__Allocation* litaC_mem__new_cb_Allocation_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_mem__Allocation* litaC_result = (litaC_mem__Allocation*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_mem__Allocation));
    return litaC_result;
    
    
}

litaC_void litaC_array__Array_add_cb__ptr_Allocation_ce_(litaC_array__Array_cb__ptr_Allocation_ce_* litaC_a,litaC_mem__Allocation* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_Allocation_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb__ptr_Allocation_ce_(litaC_array__Array_cb__ptr_Allocation_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_mem__Allocation*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_mem__Allocation*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_mem__Allocation**)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

litaC_mem__Allocation* litaC_array__Array_removeAt_cb__ptr_Allocation_ce_(litaC_array__Array_cb__ptr_Allocation_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    litaC_mem__Allocation* litaC_r = litaC_a->elements[litaC_index];
    if(litaC_index < litaC_a->length - 1) {
        {
            memmove((litaC_void*)(&(litaC_a->elements[litaC_index])), (const litaC_void*)(&(litaC_a->elements[litaC_index + 1])), ((litaC_a->length - 1) - litaC_index) * sizeof(litaC_mem__Allocation*));
            
            
        }
        
    } 
    
    litaC_a->length -= 1;
    return litaC_r;
    
    
}

litaC_array__Array_cb_Option_ce_ litaC_array__ArrayInit_cb_Option_ce_(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_array__Array_cb_Option_ce_ litaC_array =  {
        
    };
    litaC_array__Array_init_cb_Option_ce_(&((litaC_array)), litaC_initialSize, litaC_alloc);
    return litaC_array;
    
    
}

litaC_void litaC_array__Array_init_cb_Option_ce_(litaC_array__Array_cb_Option_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_cmdline__Option) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_cmdline__Option*)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_array__Array_cb__ptr_const_char_ce_ litaC_array__ArrayInit_cb__ptr_const_char_ce_(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_array__Array_cb__ptr_const_char_ce_ litaC_array =  {
        
    };
    litaC_array__Array_init_cb__ptr_const_char_ce_(&((litaC_array)), litaC_initialSize, litaC_alloc);
    return litaC_array;
    
    
}

litaC_void litaC_array__Array_init_cb__ptr_const_char_ce_(litaC_array__Array_cb__ptr_const_char_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(const litaC_char*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (const litaC_char**)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_array__Array_free_cb_Option_ce_(litaC_array__Array_cb_Option_ce_* litaC_a) {
    if(litaC_a && litaC_a->elements) {
        {
            litaC_mem__Allocator_free(litaC_a->alloc, (litaC_void*)litaC_a->elements);
            litaC_a->elements = NULL;
            litaC_a->length = 0;
            litaC_a->capacity = 0;
            
            
        }
        
    } 
    
    
}

litaC_void litaC_array__Array_free_cb__ptr_const_char_ce_(litaC_array__Array_cb__ptr_const_char_ce_* litaC_a) {
    if(litaC_a && litaC_a->elements) {
        {
            litaC_mem__Allocator_free(litaC_a->alloc, (litaC_void*)litaC_a->elements);
            litaC_a->elements = NULL;
            litaC_a->length = 0;
            litaC_a->capacity = 0;
            
            
        }
        
    } 
    
    
}

litaC_void litaC_array__Array_add_cb_Option_ce_(litaC_array__Array_cb_Option_ce_* litaC_a,litaC_cmdline__Option litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb_Option_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb_Option_ce_(litaC_array__Array_cb_Option_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_cmdline__Option) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_cmdline__Option) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_cmdline__Option*)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_Option_ce_(litaC_array__Array_cb_Option_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_void litaC_array__Array_add_cb__ptr_const_char_ce_(litaC_array__Array_cb__ptr_const_char_ce_* litaC_a,const litaC_char* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_const_char_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb__ptr_const_char_ce_(litaC_array__Array_cb__ptr_const_char_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(const litaC_char*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(const litaC_char*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (const litaC_char**)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

litaC_array__Array_cb__ptr_TypeInfo_ce_ litaC_array__ArrayInit_cb__ptr_TypeInfo_ce_(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_array__Array_cb__ptr_TypeInfo_ce_ litaC_array =  {
        
    };
    litaC_array__Array_init_cb__ptr_TypeInfo_ce_(&((litaC_array)), litaC_initialSize, litaC_alloc);
    return litaC_array;
    
    
}

litaC_void litaC_array__Array_init_cb__ptr_TypeInfo_ce_(litaC_array__Array_cb__ptr_TypeInfo_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_types__TypeInfo*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_types__TypeInfo**)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_TypeInfo_ce_(litaC_array__Array_cb__ptr_TypeInfo_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_void litaC_array__Array_add_cb__ptr_TypeInfo_ce_(litaC_array__Array_cb__ptr_TypeInfo_ce_* litaC_a,litaC_types__TypeInfo* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_TypeInfo_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb__ptr_TypeInfo_ce_(litaC_array__Array_cb__ptr_TypeInfo_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_types__TypeInfo*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_types__TypeInfo*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_types__TypeInfo**)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

litaC_types__TypeInfo* litaC_array__Array_get_cb__ptr_TypeInfo_ce_(litaC_array__Array_cb__ptr_TypeInfo_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb_GenericParam_ce_(litaC_array__Array_cb_GenericParam_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_GenericParam_ce_(litaC_array__Array_cb_GenericParam_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__GenericParam litaC_array__Array_get_cb_GenericParam_ce_(litaC_array__Array_cb_GenericParam_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(litaC_array__Array_cb__ptr_ParameterDecl_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__ParameterDecl* litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(litaC_array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb_FieldStmt_ce_(litaC_array__Array_cb_FieldStmt_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

litaC_void litaC_array__Array_init_cb__ptr_TypeSpec_ce_(litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__TypeSpec*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__TypeSpec**)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_array__Array_add_cb__ptr_TypeSpec_ce_(litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_a,litaC_ast__TypeSpec* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_TypeSpec_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb__ptr_TypeSpec_ce_(litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__TypeSpec*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__TypeSpec*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__TypeSpec**)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

litaC_array__Array_cb_GenericParam_ce_ litaC_array__ArrayInit_cb_GenericParam_ce_(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_array__Array_cb_GenericParam_ce_ litaC_array =  {
        
    };
    litaC_array__Array_init_cb_GenericParam_ce_(&((litaC_array)), litaC_initialSize, litaC_alloc);
    return litaC_array;
    
    
}

litaC_void litaC_array__Array_init_cb_GenericParam_ce_(litaC_array__Array_cb_GenericParam_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__GenericParam) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__GenericParam*)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_array__Array_addAll_cb_GenericParam_ce_(litaC_array__Array_cb_GenericParam_ce_* litaC_a,litaC_array__Array_cb_GenericParam_ce_* litaC_other) {
    if(!(litaC_other) || litaC_other->length == 0) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_a->length + litaC_other->length > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb_GenericParam_ce_(litaC_a, litaC_other->length);
            
            
        }
        
    } 
    
    memcpy((litaC_void*)(&(litaC_a->elements[litaC_a->length])), (const litaC_void*)(&(litaC_other->elements[0])), litaC_other->length * sizeof(litaC_ast__GenericParam));
    litaC_a->length += litaC_other->length;
    
}

litaC_void litaC_array__ArrayGrow_cb_GenericParam_ce_(litaC_array__Array_cb_GenericParam_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__GenericParam) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__GenericParam) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__GenericParam*)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(litaC_array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__EnumFieldEntryDecl* litaC_array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(litaC_array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_FieldStmt_ce_(litaC_array__Array_cb_FieldStmt_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__FieldStmt litaC_array__Array_get_cb_FieldStmt_ce_(litaC_array__Array_cb_FieldStmt_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb__ptr_ParameterDecl_ce_(litaC_array__Array_cb__ptr_ParameterDecl_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

litaC_ast__ParameterDecl* litaC_array__Array_first_cb__ptr_ParameterDecl_ce_(litaC_array__Array_cb__ptr_ParameterDecl_ce_* litaC_a) {
    assert(litaC_a->length != 0);
    return litaC_a->elements[0];
    
    
}

litaC_ast__NameTypeSpec* litaC_mem__new_cb_NameTypeSpec_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__NameTypeSpec* litaC_result = (litaC_ast__NameTypeSpec*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__NameTypeSpec));
    return litaC_result;
    
    
}

litaC_ast__TypeSpec* litaC_mem__new_cb_TypeSpec_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__TypeSpec* litaC_result = (litaC_ast__TypeSpec*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__TypeSpec));
    return litaC_result;
    
    
}

litaC_ast__ArrayTypeSpec* litaC_mem__new_cb_ArrayTypeSpec_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__ArrayTypeSpec* litaC_result = (litaC_ast__ArrayTypeSpec*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__ArrayTypeSpec));
    return litaC_result;
    
    
}

litaC_ast__PtrTypeSpec* litaC_mem__new_cb_PtrTypeSpec_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__PtrTypeSpec* litaC_result = (litaC_ast__PtrTypeSpec*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__PtrTypeSpec));
    return litaC_result;
    
    
}

litaC_ast__ConstTypeSpec* litaC_mem__new_cb_ConstTypeSpec_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__ConstTypeSpec* litaC_result = (litaC_ast__ConstTypeSpec*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__ConstTypeSpec));
    return litaC_result;
    
    
}

litaC_ast__FuncPtrTypeSpec* litaC_mem__new_cb_FuncPtrTypeSpec_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__FuncPtrTypeSpec* litaC_result = (litaC_ast__FuncPtrTypeSpec*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__FuncPtrTypeSpec));
    return litaC_result;
    
    
}

litaC_ast__ImportDecl* litaC_mem__new_cb_ImportDecl_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__ImportDecl* litaC_result = (litaC_ast__ImportDecl*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__ImportDecl));
    return litaC_result;
    
    
}

litaC_ast__VarDecl* litaC_mem__new_cb_VarDecl_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__VarDecl* litaC_result = (litaC_ast__VarDecl*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__VarDecl));
    return litaC_result;
    
    
}

litaC_ast__FuncDecl* litaC_mem__new_cb_FuncDecl_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__FuncDecl* litaC_result = (litaC_ast__FuncDecl*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__FuncDecl));
    return litaC_result;
    
    
}

litaC_ast__ParametersStmt* litaC_ast__Node_becomeParentOf_cb_ParametersStmt_ce_(litaC_ast__Node* litaC_n,litaC_ast__ParametersStmt* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->stmt.node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__Stmt* litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(litaC_ast__Node* litaC_n,litaC_ast__Stmt* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__AggregateDecl* litaC_mem__new_cb_AggregateDecl_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__AggregateDecl* litaC_result = (litaC_ast__AggregateDecl*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__AggregateDecl));
    return litaC_result;
    
    
}

litaC_ast__EnumDecl* litaC_ast__Node_becomeParentOf_cb_EnumDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__EnumDecl* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->decl.stmt.node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__AggregateDecl* litaC_ast__Node_becomeParentOf_cb_AggregateDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__AggregateDecl* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->decl.declaration.stmt.node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__TraitFieldDecl* litaC_ast__Node_becomeParentOf_cb_TraitFieldDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__TraitFieldDecl* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->decl.stmt.node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__VarFieldDecl* litaC_ast__Node_becomeParentOf_cb_VarFieldDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__VarFieldDecl* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->decl.stmt.node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__Expr* litaC_ast__Node_becomeParentOf_cb_Expr_ce_(litaC_ast__Node* litaC_n,litaC_ast__Expr* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->stmt.node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__EnumDecl* litaC_mem__new_cb_EnumDecl_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__EnumDecl* litaC_result = (litaC_ast__EnumDecl*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__EnumDecl));
    return litaC_result;
    
    
}

litaC_array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_EnumFieldEntryDecl_ce_(litaC_ast__Node* litaC_n,litaC_array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_children) {
    litaC_i32 litaC_size = litaC_array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(litaC_children);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_size;litaC_i += 1) {
        {
            litaC_ast__EnumFieldEntryDecl* litaC_child = litaC_array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(litaC_children, litaC_i);
            if(litaC_child) {
                {
                    litaC_ast__Node_becomeParentOf_cb_EnumFieldEntryDecl_ce_(litaC_n, litaC_child);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_children;
    
    
}

litaC_ast__EnumFieldEntryDecl* litaC_ast__Node_becomeParentOf_cb_EnumFieldEntryDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__EnumFieldEntryDecl* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->decl.stmt.node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__TypedefDecl* litaC_mem__new_cb_TypedefDecl_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__TypedefDecl* litaC_result = (litaC_ast__TypedefDecl*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__TypedefDecl));
    return litaC_result;
    
    
}

litaC_ast__ParameterDecl* litaC_mem__new_cb_ParameterDecl_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__ParameterDecl* litaC_result = (litaC_ast__ParameterDecl*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__ParameterDecl));
    return litaC_result;
    
    
}

litaC_ast__NotesDecl* litaC_mem__new_cb_NotesDecl_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__NotesDecl* litaC_result = (litaC_ast__NotesDecl*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__NotesDecl));
    return litaC_result;
    
    
}

litaC_ast__NativeDecl* litaC_mem__new_cb_NativeDecl_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__NativeDecl* litaC_result = (litaC_ast__NativeDecl*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__NativeDecl));
    return litaC_result;
    
    
}

litaC_ast__PoisonDecl* litaC_mem__new_cb_PoisonDecl_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__PoisonDecl* litaC_result = (litaC_ast__PoisonDecl*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__PoisonDecl));
    return litaC_result;
    
    
}

litaC_ast__TernaryExpr* litaC_mem__new_cb_TernaryExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__TernaryExpr* litaC_result = (litaC_ast__TernaryExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__TernaryExpr));
    return litaC_result;
    
    
}

litaC_ast__BinaryExpr* litaC_mem__new_cb_BinaryExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__BinaryExpr* litaC_result = (litaC_ast__BinaryExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__BinaryExpr));
    return litaC_result;
    
    
}

litaC_ast__UnaryExpr* litaC_mem__new_cb_UnaryExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__UnaryExpr* litaC_result = (litaC_ast__UnaryExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__UnaryExpr));
    return litaC_result;
    
    
}

litaC_ast__InitExpr* litaC_mem__new_cb_InitExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__InitExpr* litaC_result = (litaC_ast__InitExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__InitExpr));
    return litaC_result;
    
    
}

litaC_array__Array_cb__ptr_InitArgExpr_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_InitArgExpr_ce_(litaC_ast__Node* litaC_n,litaC_array__Array_cb__ptr_InitArgExpr_ce_* litaC_children) {
    litaC_i32 litaC_size = litaC_array__Array_size_cb__ptr_InitArgExpr_ce_(litaC_children);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_size;litaC_i += 1) {
        {
            litaC_ast__InitArgExpr* litaC_child = litaC_array__Array_get_cb__ptr_InitArgExpr_ce_(litaC_children, litaC_i);
            if(litaC_child) {
                {
                    litaC_ast__Node_becomeParentOf_cb_InitArgExpr_ce_(litaC_n, litaC_child);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_children;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_InitArgExpr_ce_(litaC_array__Array_cb__ptr_InitArgExpr_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__InitArgExpr* litaC_array__Array_get_cb__ptr_InitArgExpr_ce_(litaC_array__Array_cb__ptr_InitArgExpr_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_ast__InitArgExpr* litaC_ast__Node_becomeParentOf_cb_InitArgExpr_ce_(litaC_ast__Node* litaC_n,litaC_ast__InitArgExpr* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->expr.stmt.node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__FuncCallExpr* litaC_mem__new_cb_FuncCallExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__FuncCallExpr* litaC_result = (litaC_ast__FuncCallExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__FuncCallExpr));
    return litaC_result;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__CallArg litaC_array__Array_get_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_ast__SubscriptGetExpr* litaC_mem__new_cb_SubscriptGetExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__SubscriptGetExpr* litaC_result = (litaC_ast__SubscriptGetExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__SubscriptGetExpr));
    return litaC_result;
    
    
}

litaC_ast__SubscriptSetExpr* litaC_mem__new_cb_SubscriptSetExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__SubscriptSetExpr* litaC_result = (litaC_ast__SubscriptSetExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__SubscriptSetExpr));
    return litaC_result;
    
    
}

litaC_ast__GetExpr* litaC_mem__new_cb_GetExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__GetExpr* litaC_result = (litaC_ast__GetExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__GetExpr));
    return litaC_result;
    
    
}

litaC_ast__IdentifierExpr* litaC_ast__Node_becomeParentOf_cb_IdentifierExpr_ce_(litaC_ast__Node* litaC_n,litaC_ast__IdentifierExpr* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->expr.stmt.node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__SetExpr* litaC_mem__new_cb_SetExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__SetExpr* litaC_result = (litaC_ast__SetExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__SetExpr));
    return litaC_result;
    
    
}

litaC_ast__IdentifierExpr* litaC_mem__new_cb_IdentifierExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__IdentifierExpr* litaC_result = (litaC_ast__IdentifierExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__IdentifierExpr));
    return litaC_result;
    
    
}

litaC_ast__TypeIdentifierExpr* litaC_mem__new_cb_TypeIdentifierExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__TypeIdentifierExpr* litaC_result = (litaC_ast__TypeIdentifierExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__TypeIdentifierExpr));
    return litaC_result;
    
    
}

litaC_ast__CastExpr* litaC_mem__new_cb_CastExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__CastExpr* litaC_result = (litaC_ast__CastExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__CastExpr));
    return litaC_result;
    
    
}

litaC_ast__ArrayDesignationExpr* litaC_mem__new_cb_ArrayDesignationExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__ArrayDesignationExpr* litaC_result = (litaC_ast__ArrayDesignationExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__ArrayDesignationExpr));
    return litaC_result;
    
    
}

litaC_ast__InitArgExpr* litaC_mem__new_cb_InitArgExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__InitArgExpr* litaC_result = (litaC_ast__InitArgExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__InitArgExpr));
    return litaC_result;
    
    
}

litaC_ast__BooleanExpr* litaC_mem__new_cb_BooleanExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__BooleanExpr* litaC_result = (litaC_ast__BooleanExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__BooleanExpr));
    return litaC_result;
    
    
}

litaC_ast__NullExpr* litaC_mem__new_cb_NullExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__NullExpr* litaC_result = (litaC_ast__NullExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__NullExpr));
    return litaC_result;
    
    
}

litaC_ast__NumberExpr* litaC_mem__new_cb_NumberExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__NumberExpr* litaC_result = (litaC_ast__NumberExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__NumberExpr));
    return litaC_result;
    
    
}

litaC_ast__StringExpr* litaC_mem__new_cb_StringExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__StringExpr* litaC_result = (litaC_ast__StringExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__StringExpr));
    return litaC_result;
    
    
}

litaC_ast__CharExpr* litaC_mem__new_cb_CharExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__CharExpr* litaC_result = (litaC_ast__CharExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__CharExpr));
    return litaC_result;
    
    
}

litaC_ast__GroupExpr* litaC_mem__new_cb_GroupExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__GroupExpr* litaC_result = (litaC_ast__GroupExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__GroupExpr));
    return litaC_result;
    
    
}

litaC_ast__ArrayInitExpr* litaC_mem__new_cb_ArrayInitExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__ArrayInitExpr* litaC_result = (litaC_ast__ArrayInitExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__ArrayInitExpr));
    return litaC_result;
    
    
}

litaC_array__Array_cb__ptr_Expr_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_Expr_ce_(litaC_ast__Node* litaC_n,litaC_array__Array_cb__ptr_Expr_ce_* litaC_children) {
    litaC_i32 litaC_size = litaC_array__Array_size_cb__ptr_Expr_ce_(litaC_children);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_size;litaC_i += 1) {
        {
            litaC_ast__Expr* litaC_child = litaC_array__Array_get_cb__ptr_Expr_ce_(litaC_children, litaC_i);
            if(litaC_child) {
                {
                    litaC_ast__Node_becomeParentOf_cb_Expr_ce_(litaC_n, litaC_child);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_children;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_Expr_ce_(litaC_array__Array_cb__ptr_Expr_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__Expr* litaC_array__Array_get_cb__ptr_Expr_ce_(litaC_array__Array_cb__ptr_Expr_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb__ptr_Expr_ce_(litaC_array__Array_cb__ptr_Expr_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

litaC_ast__SizeOfExpr* litaC_mem__new_cb_SizeOfExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__SizeOfExpr* litaC_result = (litaC_ast__SizeOfExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__SizeOfExpr));
    return litaC_result;
    
    
}

litaC_ast__TypeOfExpr* litaC_mem__new_cb_TypeOfExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__TypeOfExpr* litaC_result = (litaC_ast__TypeOfExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__TypeOfExpr));
    return litaC_result;
    
    
}

litaC_ast__OffsetOfExpr* litaC_mem__new_cb_OffsetOfExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__OffsetOfExpr* litaC_result = (litaC_ast__OffsetOfExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__OffsetOfExpr));
    return litaC_result;
    
    
}

litaC_ast__PoisonExpr* litaC_mem__new_cb_PoisonExpr_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__PoisonExpr* litaC_result = (litaC_ast__PoisonExpr*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__PoisonExpr));
    return litaC_result;
    
    
}

litaC_ast__ModuleStmt* litaC_mem__new_cb_ModuleStmt_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__ModuleStmt* litaC_result = (litaC_ast__ModuleStmt*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__ModuleStmt));
    return litaC_result;
    
    
}

litaC_ast__CompStmt* litaC_mem__new_cb_CompStmt_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__CompStmt* litaC_result = (litaC_ast__CompStmt*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__CompStmt));
    return litaC_result;
    
    
}

litaC_ast__BlockStmt* litaC_mem__new_cb_BlockStmt_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__BlockStmt* litaC_result = (litaC_ast__BlockStmt*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__BlockStmt));
    return litaC_result;
    
    
}

litaC_array__Array_cb__ptr_Stmt_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_Stmt_ce_(litaC_ast__Node* litaC_n,litaC_array__Array_cb__ptr_Stmt_ce_* litaC_children) {
    litaC_i32 litaC_size = litaC_array__Array_size_cb__ptr_Stmt_ce_(litaC_children);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_size;litaC_i += 1) {
        {
            litaC_ast__Stmt* litaC_child = litaC_array__Array_get_cb__ptr_Stmt_ce_(litaC_children, litaC_i);
            if(litaC_child) {
                {
                    litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(litaC_n, litaC_child);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_children;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_Stmt_ce_(litaC_array__Array_cb__ptr_Stmt_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__Stmt* litaC_array__Array_get_cb__ptr_Stmt_ce_(litaC_array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_ast__IfStmt* litaC_mem__new_cb_IfStmt_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__IfStmt* litaC_result = (litaC_ast__IfStmt*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__IfStmt));
    return litaC_result;
    
    
}

litaC_ast__WhileStmt* litaC_mem__new_cb_WhileStmt_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__WhileStmt* litaC_result = (litaC_ast__WhileStmt*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__WhileStmt));
    return litaC_result;
    
    
}

litaC_ast__DoWhileStmt* litaC_mem__new_cb_DoWhileStmt_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__DoWhileStmt* litaC_result = (litaC_ast__DoWhileStmt*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__DoWhileStmt));
    return litaC_result;
    
    
}

litaC_ast__ForStmt* litaC_mem__new_cb_ForStmt_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__ForStmt* litaC_result = (litaC_ast__ForStmt*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__ForStmt));
    return litaC_result;
    
    
}

litaC_ast__SwitchCaseStmt* litaC_mem__new_cb_SwitchCaseStmt_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__SwitchCaseStmt* litaC_result = (litaC_ast__SwitchCaseStmt*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__SwitchCaseStmt));
    return litaC_result;
    
    
}

litaC_ast__SwitchStmt* litaC_mem__new_cb_SwitchStmt_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__SwitchStmt* litaC_result = (litaC_ast__SwitchStmt*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__SwitchStmt));
    return litaC_result;
    
    
}

litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_SwitchCaseStmt_ce_(litaC_ast__Node* litaC_n,litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_children) {
    litaC_i32 litaC_size = litaC_array__Array_size_cb__ptr_SwitchCaseStmt_ce_(litaC_children);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_size;litaC_i += 1) {
        {
            litaC_ast__SwitchCaseStmt* litaC_child = litaC_array__Array_get_cb__ptr_SwitchCaseStmt_ce_(litaC_children, litaC_i);
            if(litaC_child) {
                {
                    litaC_ast__Node_becomeParentOf_cb_SwitchCaseStmt_ce_(litaC_n, litaC_child);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_children;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_SwitchCaseStmt_ce_(litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__SwitchCaseStmt* litaC_array__Array_get_cb__ptr_SwitchCaseStmt_ce_(litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_ast__SwitchCaseStmt* litaC_ast__Node_becomeParentOf_cb_SwitchCaseStmt_ce_(litaC_ast__Node* litaC_n,litaC_ast__SwitchCaseStmt* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->stmt.node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__BreakStmt* litaC_mem__new_cb_BreakStmt_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__BreakStmt* litaC_result = (litaC_ast__BreakStmt*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__BreakStmt));
    return litaC_result;
    
    
}

litaC_ast__ContinueStmt* litaC_mem__new_cb_ContinueStmt_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__ContinueStmt* litaC_result = (litaC_ast__ContinueStmt*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__ContinueStmt));
    return litaC_result;
    
    
}

litaC_ast__ReturnStmt* litaC_mem__new_cb_ReturnStmt_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__ReturnStmt* litaC_result = (litaC_ast__ReturnStmt*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__ReturnStmt));
    return litaC_result;
    
    
}

litaC_ast__DeferStmt* litaC_mem__new_cb_DeferStmt_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__DeferStmt* litaC_result = (litaC_ast__DeferStmt*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__DeferStmt));
    return litaC_result;
    
    
}

litaC_ast__GotoStmt* litaC_mem__new_cb_GotoStmt_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__GotoStmt* litaC_result = (litaC_ast__GotoStmt*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__GotoStmt));
    return litaC_result;
    
    
}

litaC_ast__LabelStmt* litaC_mem__new_cb_LabelStmt_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__LabelStmt* litaC_result = (litaC_ast__LabelStmt*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__LabelStmt));
    return litaC_result;
    
    
}

litaC_ast__NoteStmt* litaC_mem__new_cb_NoteStmt_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__NoteStmt* litaC_result = (litaC_ast__NoteStmt*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__NoteStmt));
    return litaC_result;
    
    
}

litaC_ast__EmptyStmt* litaC_mem__new_cb_EmptyStmt_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__EmptyStmt* litaC_result = (litaC_ast__EmptyStmt*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__EmptyStmt));
    return litaC_result;
    
    
}

litaC_ast__ParametersStmt* litaC_mem__new_cb_ParametersStmt_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__ParametersStmt* litaC_result = (litaC_ast__ParametersStmt*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__ParametersStmt));
    return litaC_result;
    
    
}

litaC_array__Array_cb__ptr_ParameterDecl_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_ParameterDecl_ce_(litaC_ast__Node* litaC_n,litaC_array__Array_cb__ptr_ParameterDecl_ce_* litaC_children) {
    litaC_i32 litaC_size = litaC_array__Array_size_cb__ptr_ParameterDecl_ce_(litaC_children);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_size;litaC_i += 1) {
        {
            litaC_ast__ParameterDecl* litaC_child = litaC_array__Array_get_cb__ptr_ParameterDecl_ce_(litaC_children, litaC_i);
            if(litaC_child) {
                {
                    litaC_ast__Node_becomeParentOf_cb_ParameterDecl_ce_(litaC_n, litaC_child);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_children;
    
    
}

litaC_ast__ParameterDecl* litaC_ast__Node_becomeParentOf_cb_ParameterDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__ParameterDecl* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->decl.stmt.node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__VarFieldDecl* litaC_mem__new_cb_VarFieldDecl_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__VarFieldDecl* litaC_result = (litaC_ast__VarFieldDecl*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__VarFieldDecl));
    return litaC_result;
    
    
}

litaC_ast__TraitFieldDecl* litaC_mem__new_cb_TraitFieldDecl_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__TraitFieldDecl* litaC_result = (litaC_ast__TraitFieldDecl*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__TraitFieldDecl));
    return litaC_result;
    
    
}

litaC_ast__EnumFieldEntryDecl* litaC_mem__new_cb_EnumFieldEntryDecl_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_ast__EnumFieldEntryDecl* litaC_result = (litaC_ast__EnumFieldEntryDecl*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__EnumFieldEntryDecl));
    return litaC_result;
    
    
}

LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb__ptr_NoteStmt_ce_(litaC_array__Array_cb__ptr_NoteStmt_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_NoteStmt_ce_(litaC_array__Array_cb__ptr_NoteStmt_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__NoteStmt* litaC_array__Array_get_cb__ptr_NoteStmt_ce_(litaC_array__Array_cb__ptr_NoteStmt_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_symbols__Scope* litaC_mem__new_cb_Scope_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_symbols__Scope* litaC_result = (litaC_symbols__Scope*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_symbols__Scope));
    return litaC_result;
    
    
}

litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_ litaC_map__StrMap_cb__ptr_Symbol_ce_(litaC_symbols__Symbol* litaC_emptyValue,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_ litaC_m =  {
        
    };
    litaC_map__Map_init_cb__ptr_const_char_c__ptr_Symbol_ce_(&((litaC_m)), litaC_emptyValue, litaC_initialSize, litaC_map__StrHashFn, litaC_map__StrEqualFn, litaC_alloc, 0);
    return litaC_m;
    
    
}

litaC_void litaC_map__Map_init_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_* litaC_m,litaC_symbols__Symbol* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(const litaC_char*),litaC_bool (*litaC_equalFn)(const litaC_char*,const litaC_char*),const litaC_mem__Allocator* litaC_alloc,const litaC_char* litaC_emptyKey) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_m->length = 0;
    litaC_m->capacity = 0;
    litaC_m->hashFn = litaC_hashFn;
    litaC_m->equalFn = litaC_equalFn;
    litaC_m->alloc = litaC_alloc;
    litaC_m->keys = 0;
    litaC_m->values = 0;
    litaC_m->emptyValue = litaC_emptyValue;
    litaC_m->emptyKey = litaC_emptyKey;
    litaC_initialSize = (litaC_i32)litaC_map__nextPowerOf2(litaC_initialSize);
    litaC_map__MapGrow_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_m, litaC_initialSize);
    
}

litaC_void litaC_map__MapGrow_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_* litaC_m,litaC_i32 litaC_newlength) {
    if(litaC_newlength < 16) {
        {
            litaC_newlength = 16;
            
            
        }
        
    } 
    
    litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_ litaC_newMap =  {
        .length = 0,
        .capacity = litaC_newlength,
        .keys = (const litaC_char**)litaC_mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(const litaC_char*)),
        .values = (litaC_symbols__Symbol**)litaC_mem__Allocator_alloc(litaC_m->alloc, litaC_newlength * sizeof(litaC_symbols__Symbol*)),
        .hashFn = litaC_m->hashFn,
        .equalFn = litaC_m->equalFn,
        .emptyValue = litaC_m->emptyValue,
        .emptyKey = litaC_m->emptyKey,
        .alloc = litaC_m->alloc
    };
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            if(!(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey))) {
                {
                    litaC_map__Map_put_cb__ptr_const_char_c__ptr_Symbol_ce_(&((litaC_newMap)), litaC_m->keys[litaC_i], litaC_m->values[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_map__Map_free_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_m);
    *(litaC_m) = litaC_newMap;
    
}

litaC_void litaC_map__Map_put_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_* litaC_m,const litaC_char* litaC_key,litaC_symbols__Symbol* litaC_value) {
    if(2 * litaC_m->length >= litaC_m->capacity) {
        {
            litaC_map__MapGrow_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_m, 2 * litaC_m->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                {
                    litaC_m->length += 1;
                    litaC_m->keys[litaC_i] = litaC_key;
                    litaC_m->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                    {
                        litaC_m->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_void litaC_map__Map_free_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_* litaC_m) {
    if(litaC_m) {
        {
            litaC_m->capacity = 0;
            litaC_m->length = 0;
            litaC_mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->keys);
            litaC_mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->values);
            litaC_m->keys = NULL;
            litaC_m->values = NULL;
            
            
        }
        
    } 
    
    
}

litaC_symbols__Symbol* litaC_map__Map_get_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_* litaC_m,const litaC_char* litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_m->emptyValue;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                {
                    return litaC_m->values[litaC_i];
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                    {
                        return litaC_m->emptyValue;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_m->emptyValue;
    
    
}

litaC_bool litaC_map__Map_contains_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_* litaC_m,const litaC_char* litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                {
                    return litaC_true;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_symbols__Symbol* litaC_mem__new_cb_Symbol_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_symbols__Symbol* litaC_result = (litaC_symbols__Symbol*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_symbols__Symbol));
    return litaC_result;
    
    
}

litaC_void litaC_array__Array_init_cb_ModuleImport_ce_(litaC_array__Array_cb_ModuleImport_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_module__ModuleImport) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_module__ModuleImport*)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_module__Module* litaC_mem__new_cb_Module_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_module__Module* litaC_result = (litaC_module__Module*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_module__Module));
    return litaC_result;
    
    
}

litaC_map__MapIterator_cb__ptr_const_char_c__ptr_Symbol_ce_ litaC_map__Map_iter_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Symbol_ce_* litaC_m) {
    return (litaC_map__MapIterator_cb__ptr_const_char_c__ptr_Symbol_ce_) {
        .m = litaC_m,
        .it = 0,
        .count = 0
    };
    
    
}

litaC_bool litaC_map__MapIterator_hasNext_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_map__MapIterator_cb__ptr_const_char_c__ptr_Symbol_ce_* litaC_iter) {
    return litaC_iter->count < litaC_iter->m->length;
    
    
}

litaC_map__MapEntry_cb__ptr_const_char_c__ptr_Symbol_ce_ litaC_map__MapIterator_next_cb__ptr_const_char_c__ptr_Symbol_ce_(litaC_map__MapIterator_cb__ptr_const_char_c__ptr_Symbol_ce_* litaC_iter) {
    litaC_i32 litaC_i = litaC_iter->it;
    assert(litaC_i < litaC_iter->m->capacity);
    
    for(;litaC_i < litaC_iter->m->capacity;litaC_i += 1) {
        {
            litaC_bool litaC_hasValue = !(litaC_iter->m->equalFn(litaC_iter->m->keys[litaC_i], litaC_iter->m->emptyKey));
            if(litaC_hasValue) {
                {
                    litaC_iter->count += 1;
                    {
                        litaC_map__MapEntry_cb__ptr_const_char_c__ptr_Symbol_ce_ ___result = (litaC_map__MapEntry_cb__ptr_const_char_c__ptr_Symbol_ce_) {
                            .key = litaC_iter->m->keys[litaC_i],
                            .value = litaC_iter->m->values[litaC_i],
                            .valuePtr = &(litaC_iter->m->values[litaC_i])
                        };
                        litaC_iter->it = litaC_i + 1;
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    {
        litaC_map__MapEntry_cb__ptr_const_char_c__ptr_Symbol_ce_ ___result = (litaC_map__MapEntry_cb__ptr_const_char_c__ptr_Symbol_ce_) {
            
        };
        litaC_iter->it = litaC_i + 1;
        return ___result;
        
    }
    
    litaC_iter->it = litaC_i + 1;
    
}

litaC_void litaC_array__Array_add_cb_ModuleImport_ce_(litaC_array__Array_cb_ModuleImport_ce_* litaC_a,litaC_module__ModuleImport litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb_ModuleImport_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb_ModuleImport_ce_(litaC_array__Array_cb_ModuleImport_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_module__ModuleImport) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_module__ModuleImport) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_module__ModuleImport*)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

litaC_void litaC_array__Array_init_cb_PhaseError_ce_(litaC_array__Array_cb_PhaseError_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_phase_result__PhaseError) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_phase_result__PhaseError*)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_array__Array_add_cb_PhaseError_ce_(litaC_array__Array_cb_PhaseError_ce_* litaC_a,litaC_phase_result__PhaseError litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb_PhaseError_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb_PhaseError_ce_(litaC_array__Array_cb_PhaseError_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_phase_result__PhaseError) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_phase_result__PhaseError) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_phase_result__PhaseError*)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

litaC_map__Map_cb__ptr_const_char_c__ptr_Module_ce_ litaC_map__StrMap_cb__ptr_Module_ce_(litaC_module__Module* litaC_emptyValue,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_map__Map_cb__ptr_const_char_c__ptr_Module_ce_ litaC_m =  {
        
    };
    litaC_map__Map_init_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_m)), litaC_emptyValue, litaC_initialSize, litaC_map__StrHashFn, litaC_map__StrEqualFn, litaC_alloc, 0);
    return litaC_m;
    
    
}

litaC_void litaC_map__Map_init_cb__ptr_const_char_c__ptr_Module_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m,litaC_module__Module* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(const litaC_char*),litaC_bool (*litaC_equalFn)(const litaC_char*,const litaC_char*),const litaC_mem__Allocator* litaC_alloc,const litaC_char* litaC_emptyKey) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_m->length = 0;
    litaC_m->capacity = 0;
    litaC_m->hashFn = litaC_hashFn;
    litaC_m->equalFn = litaC_equalFn;
    litaC_m->alloc = litaC_alloc;
    litaC_m->keys = 0;
    litaC_m->values = 0;
    litaC_m->emptyValue = litaC_emptyValue;
    litaC_m->emptyKey = litaC_emptyKey;
    litaC_initialSize = (litaC_i32)litaC_map__nextPowerOf2(litaC_initialSize);
    litaC_map__MapGrow_cb__ptr_const_char_c__ptr_Module_ce_(litaC_m, litaC_initialSize);
    
}

litaC_void litaC_map__MapGrow_cb__ptr_const_char_c__ptr_Module_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m,litaC_i32 litaC_newlength) {
    if(litaC_newlength < 16) {
        {
            litaC_newlength = 16;
            
            
        }
        
    } 
    
    litaC_map__Map_cb__ptr_const_char_c__ptr_Module_ce_ litaC_newMap =  {
        .length = 0,
        .capacity = litaC_newlength,
        .keys = (const litaC_char**)litaC_mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(const litaC_char*)),
        .values = (litaC_module__Module**)litaC_mem__Allocator_alloc(litaC_m->alloc, litaC_newlength * sizeof(litaC_module__Module*)),
        .hashFn = litaC_m->hashFn,
        .equalFn = litaC_m->equalFn,
        .emptyValue = litaC_m->emptyValue,
        .emptyKey = litaC_m->emptyKey,
        .alloc = litaC_m->alloc
    };
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            if(!(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey))) {
                {
                    litaC_map__Map_put_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_newMap)), litaC_m->keys[litaC_i], litaC_m->values[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_map__Map_free_cb__ptr_const_char_c__ptr_Module_ce_(litaC_m);
    *(litaC_m) = litaC_newMap;
    
}

litaC_void litaC_map__Map_put_cb__ptr_const_char_c__ptr_Module_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m,const litaC_char* litaC_key,litaC_module__Module* litaC_value) {
    if(2 * litaC_m->length >= litaC_m->capacity) {
        {
            litaC_map__MapGrow_cb__ptr_const_char_c__ptr_Module_ce_(litaC_m, 2 * litaC_m->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                {
                    litaC_m->length += 1;
                    litaC_m->keys[litaC_i] = litaC_key;
                    litaC_m->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                    {
                        litaC_m->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_void litaC_map__Map_free_cb__ptr_const_char_c__ptr_Module_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m) {
    if(litaC_m) {
        {
            litaC_m->capacity = 0;
            litaC_m->length = 0;
            litaC_mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->keys);
            litaC_mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->values);
            litaC_m->keys = NULL;
            litaC_m->values = NULL;
            
            
        }
        
    } 
    
    
}

litaC_void litaC_array__Array_add_cb__ptr_ImportDecl_ce_(litaC_array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_ast__ImportDecl* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_ImportDecl_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb__ptr_ImportDecl_ce_(litaC_array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__ImportDecl*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__ImportDecl*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__ImportDecl**)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_ImportDecl_ce_(litaC_array__Array_cb__ptr_ImportDecl_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__ImportDecl* litaC_array__Array_get_cb__ptr_ImportDecl_ce_(litaC_array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_module__Module* litaC_map__Map_get_cb__ptr_const_char_c__ptr_Module_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m,const litaC_char* litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_m->emptyValue;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                {
                    return litaC_m->values[litaC_i];
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                    {
                        return litaC_m->emptyValue;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_m->emptyValue;
    
    
}

litaC_void litaC_array__Array_init_cb__ptr_CompStmt_ce_(litaC_array__Array_cb__ptr_CompStmt_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__CompStmt*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__CompStmt**)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_array__Array_add_cb__ptr_CompStmt_ce_(litaC_array__Array_cb__ptr_CompStmt_ce_* litaC_a,litaC_ast__CompStmt* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_CompStmt_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb__ptr_CompStmt_ce_(litaC_array__Array_cb__ptr_CompStmt_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__CompStmt*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__CompStmt*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__CompStmt**)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

litaC_void litaC_array__Array_add_cb__ptr_NoteStmt_ce_(litaC_array__Array_cb__ptr_NoteStmt_ce_* litaC_a,litaC_ast__NoteStmt* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_NoteStmt_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb__ptr_NoteStmt_ce_(litaC_array__Array_cb__ptr_NoteStmt_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__NoteStmt*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__NoteStmt*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__NoteStmt**)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

litaC_void litaC_array__Array_addAll_cb__ptr_NoteStmt_ce_(litaC_array__Array_cb__ptr_NoteStmt_ce_* litaC_a,litaC_array__Array_cb__ptr_NoteStmt_ce_* litaC_other) {
    if(!(litaC_other) || litaC_other->length == 0) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_a->length + litaC_other->length > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_NoteStmt_ce_(litaC_a, litaC_other->length);
            
            
        }
        
    } 
    
    memcpy((litaC_void*)(&(litaC_a->elements[litaC_a->length])), (const litaC_void*)(&(litaC_other->elements[0])), litaC_other->length * sizeof(litaC_ast__NoteStmt*));
    litaC_a->length += litaC_other->length;
    
}

litaC_void litaC_array__Array_add_cb__ptr_Decl_ce_(litaC_array__Array_cb__ptr_Decl_ce_* litaC_a,litaC_ast__Decl* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_Decl_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb__ptr_Decl_ce_(litaC_array__Array_cb__ptr_Decl_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__Decl*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__Decl*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__Decl**)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_CompStmt_ce_(litaC_array__Array_cb__ptr_CompStmt_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__CompStmt* litaC_array__Array_get_cb__ptr_CompStmt_ce_(litaC_array__Array_cb__ptr_CompStmt_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_Token_ce_(litaC_array__Array_cb_Token_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_lex__Token litaC_array__Array_get_cb_Token_ce_(litaC_array__Array_cb_Token_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_void litaC_array__Array_addAll_cb__ptr_ImportDecl_ce_(litaC_array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_array__Array_cb__ptr_ImportDecl_ce_* litaC_other) {
    if(!(litaC_other) || litaC_other->length == 0) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_a->length + litaC_other->length > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_ImportDecl_ce_(litaC_a, litaC_other->length);
            
            
        }
        
    } 
    
    memcpy((litaC_void*)(&(litaC_a->elements[litaC_a->length])), (const litaC_void*)(&(litaC_other->elements[0])), litaC_other->length * sizeof(litaC_ast__ImportDecl*));
    litaC_a->length += litaC_other->length;
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_Decl_ce_(litaC_array__Array_cb__ptr_Decl_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_void litaC_array__Array_addAll_cb__ptr_Decl_ce_(litaC_array__Array_cb__ptr_Decl_ce_* litaC_a,litaC_array__Array_cb__ptr_Decl_ce_* litaC_other) {
    if(!(litaC_other) || litaC_other->length == 0) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_a->length + litaC_other->length > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_Decl_ce_(litaC_a, litaC_other->length);
            
            
        }
        
    } 
    
    memcpy((litaC_void*)(&(litaC_a->elements[litaC_a->length])), (const litaC_void*)(&(litaC_other->elements[0])), litaC_other->length * sizeof(litaC_ast__Decl*));
    litaC_a->length += litaC_other->length;
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_Symbol_ce_(litaC_array__Array_cb__ptr_Symbol_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_symbols__Symbol* litaC_array__Array_get_cb__ptr_Symbol_ce_(litaC_array__Array_cb__ptr_Symbol_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_ast__Decl* litaC_array__Array_get_cb__ptr_Decl_ce_(litaC_array__Array_cb__ptr_Decl_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_ModuleImport_ce_(litaC_array__Array_cb_ModuleImport_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_module__ModuleImport litaC_array__Array_get_cb_ModuleImport_ce_(litaC_array__Array_cb_ModuleImport_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb__ptr_TypeSpec_ce_(litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_TypeSpec_ce_(litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__TypeSpec* litaC_array__Array_get_cb__ptr_TypeSpec_ce_(litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_void litaC_array__Array_add_cb_GenericParam_ce_(litaC_array__Array_cb_GenericParam_ce_* litaC_a,litaC_ast__GenericParam litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb_GenericParam_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

litaC_array__Array_cb_CallArg_ce_ litaC_array__ArrayInit_cb_CallArg_ce_(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_array__Array_cb_CallArg_ce_ litaC_array =  {
        
    };
    litaC_array__Array_init_cb_CallArg_ce_(&((litaC_array)), litaC_initialSize, litaC_alloc);
    return litaC_array;
    
    
}

litaC_void litaC_array__Array_init_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__CallArg) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__CallArg*)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_array__Array_add_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_a,litaC_ast__CallArg litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb_CallArg_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__CallArg) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__CallArg) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__CallArg*)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

litaC_array__Array_cb__ptr_Expr_ce_ litaC_array__ArrayInit_cb__ptr_Expr_ce_(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_array__Array_cb__ptr_Expr_ce_ litaC_array =  {
        
    };
    litaC_array__Array_init_cb__ptr_Expr_ce_(&((litaC_array)), litaC_initialSize, litaC_alloc);
    return litaC_array;
    
    
}

litaC_void litaC_array__Array_init_cb__ptr_Expr_ce_(litaC_array__Array_cb__ptr_Expr_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__Expr*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__Expr**)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_array__Array_add_cb__ptr_Expr_ce_(litaC_array__Array_cb__ptr_Expr_ce_* litaC_a,litaC_ast__Expr* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_Expr_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb__ptr_Expr_ce_(litaC_array__Array_cb__ptr_Expr_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__Expr*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__Expr*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__Expr**)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb__ptr_Stmt_ce_(litaC_array__Array_cb__ptr_Stmt_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

litaC_array__Array_cb__ptr_Stmt_ce_ litaC_array__ArrayInit_cb__ptr_Stmt_ce_(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_array__Array_cb__ptr_Stmt_ce_ litaC_array =  {
        
    };
    litaC_array__Array_init_cb__ptr_Stmt_ce_(&((litaC_array)), litaC_initialSize, litaC_alloc);
    return litaC_array;
    
    
}

litaC_void litaC_array__Array_init_cb__ptr_Stmt_ce_(litaC_array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__Stmt*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__Stmt**)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_array__Array_add_cb__ptr_Stmt_ce_(litaC_array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_ast__Stmt* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_Stmt_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb__ptr_Stmt_ce_(litaC_array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__Stmt*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__Stmt*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__Stmt**)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb__ptr_InitArgExpr_ce_(litaC_array__Array_cb__ptr_InitArgExpr_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

litaC_void litaC_array__Array_init_cb__ptr_InitArgExpr_ce_(litaC_array__Array_cb__ptr_InitArgExpr_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__InitArgExpr*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__InitArgExpr**)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_array__Array_add_cb__ptr_InitArgExpr_ce_(litaC_array__Array_cb__ptr_InitArgExpr_ce_* litaC_a,litaC_ast__InitArgExpr* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_InitArgExpr_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb__ptr_InitArgExpr_ce_(litaC_array__Array_cb__ptr_InitArgExpr_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__InitArgExpr*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__InitArgExpr*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__InitArgExpr**)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

litaC_void litaC_array__Array_init_cb__ptr_ParameterDecl_ce_(litaC_array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__ParameterDecl*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__ParameterDecl**)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_array__Array_add_cb__ptr_ParameterDecl_ce_(litaC_array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_ast__ParameterDecl* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_ParameterDecl_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb__ptr_ParameterDecl_ce_(litaC_array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__ParameterDecl*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__ParameterDecl*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__ParameterDecl**)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb__ptr_SwitchCaseStmt_ce_(litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

litaC_void litaC_array__Array_init_cb__ptr_SwitchCaseStmt_ce_(litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__SwitchCaseStmt*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__SwitchCaseStmt**)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_array__Array_add_cb__ptr_SwitchCaseStmt_ce_(litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a,litaC_ast__SwitchCaseStmt* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_SwitchCaseStmt_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb__ptr_SwitchCaseStmt_ce_(litaC_array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__SwitchCaseStmt*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__SwitchCaseStmt*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__SwitchCaseStmt**)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

litaC_array__Array_cb_GenericParam_ce_ litaC_array__Array_copy_cb_GenericParam_ce_(litaC_array__Array_cb_GenericParam_ce_* litaC_a,const litaC_mem__Allocator* litaC_allocator) {
    litaC_array__Array_cb_GenericParam_ce_ litaC_copy = litaC_array__ArrayInit_cb_GenericParam_ce_(litaC_a->length, (litaC_allocator) ? litaC_allocator : litaC_a->alloc);
    memcpy(litaC_copy.elements, litaC_a->elements, litaC_a->length * sizeof(litaC_ast__GenericParam));
    litaC_copy.length = litaC_a->length;
    return litaC_copy;
    
    
}

litaC_array__Array_cb_FieldStmt_ce_ litaC_array__ArrayInit_cb_FieldStmt_ce_(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_array__Array_cb_FieldStmt_ce_ litaC_array =  {
        
    };
    litaC_array__Array_init_cb_FieldStmt_ce_(&((litaC_array)), litaC_initialSize, litaC_alloc);
    return litaC_array;
    
    
}

litaC_void litaC_array__Array_init_cb_FieldStmt_ce_(litaC_array__Array_cb_FieldStmt_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__FieldStmt) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__FieldStmt*)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_array__Array_add_cb_FieldStmt_ce_(litaC_array__Array_cb_FieldStmt_ce_* litaC_a,litaC_ast__FieldStmt litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb_FieldStmt_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb_FieldStmt_ce_(litaC_array__Array_cb_FieldStmt_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__FieldStmt) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__FieldStmt) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__FieldStmt*)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

litaC_void litaC_array__Array_insertAt_cb__ptr_Stmt_ce_(litaC_array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__Stmt* litaC_element) {
    assert(litaC_index >= 0 && litaC_index <= litaC_a->length);
    if(litaC_index == litaC_a->length) {
        {
            litaC_array__Array_add_cb__ptr_Stmt_ce_(litaC_a, litaC_element);
            return;
            
            
            
        }
        
    } 
    
    litaC_a->length += 1;
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_Stmt_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    memmove((litaC_void*)(&(litaC_a->elements[litaC_index + 1])), (const litaC_void*)(&(litaC_a->elements[litaC_index])), (litaC_a->length - litaC_index) * sizeof(litaC_ast__Stmt*));
    litaC_array__Array_set_cb__ptr_Stmt_ce_(litaC_a, litaC_index, litaC_element);
    
}

litaC_void litaC_array__Array_set_cb__ptr_Stmt_ce_(litaC_array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__Stmt* litaC_element) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    {
        litaC_a->elements[litaC_index] = litaC_element;
        
        
    }
    
}

litaC_void litaC_array__Array_init_cb__ptr_Module_ce_(litaC_array__Array_cb__ptr_Module_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_module__Module*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_module__Module**)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_array__Array_init_cb__ptr_FuncTypeInfo_ce_(litaC_array__Array_cb__ptr_FuncTypeInfo_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_types__FuncTypeInfo*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_types__FuncTypeInfo**)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_array__Array_init_cb__ptr_Symbol_ce_(litaC_array__Array_cb__ptr_Symbol_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_symbols__Symbol*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_symbols__Symbol**)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_array__Array_init_cb_Array_cb_GenericParam_ce__ce_(litaC_array__Array_cb_Array_cb_GenericParam_ce__ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_array__Array_cb_GenericParam_ce_) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_array__Array_cb_GenericParam_ce_*)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_u32 litaC_map__PtrHashFn_cb_i64_ce_(litaC_i64 litaC_a) {
    litaC_u32 litaC_hash = (litaC_u32)(((litaC_usize)litaC_a) % 4294967291U);
    return litaC_hash;
    
    
}

litaC_bool litaC_map__PtrEqualFn_cb_i64_ce_(litaC_i64 litaC_a,litaC_i64 litaC_b) {
    return litaC_a == litaC_b;
    
    
}

litaC_void litaC_map__Map_init_cb_i64_c_Array_cb_i64_ce__ce_(litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m,litaC_array__Array_cb_i64_ce_ litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_i64),litaC_bool (*litaC_equalFn)(litaC_i64,litaC_i64),const litaC_mem__Allocator* litaC_alloc,litaC_i64 litaC_emptyKey) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_m->length = 0;
    litaC_m->capacity = 0;
    litaC_m->hashFn = litaC_hashFn;
    litaC_m->equalFn = litaC_equalFn;
    litaC_m->alloc = litaC_alloc;
    litaC_m->keys = 0;
    litaC_m->values = 0;
    litaC_m->emptyValue = litaC_emptyValue;
    litaC_m->emptyKey = litaC_emptyKey;
    litaC_initialSize = (litaC_i32)litaC_map__nextPowerOf2(litaC_initialSize);
    litaC_map__MapGrow_cb_i64_c_Array_cb_i64_ce__ce_(litaC_m, litaC_initialSize);
    
}

litaC_void litaC_map__MapGrow_cb_i64_c_Array_cb_i64_ce__ce_(litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m,litaC_i32 litaC_newlength) {
    if(litaC_newlength < 16) {
        {
            litaC_newlength = 16;
            
            
        }
        
    } 
    
    litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_ litaC_newMap =  {
        .length = 0,
        .capacity = litaC_newlength,
        .keys = (litaC_i64*)litaC_mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_i64)),
        .values = (litaC_array__Array_cb_i64_ce_*)litaC_mem__Allocator_alloc(litaC_m->alloc, litaC_newlength * sizeof(litaC_array__Array_cb_i64_ce_)),
        .hashFn = litaC_m->hashFn,
        .equalFn = litaC_m->equalFn,
        .emptyValue = litaC_m->emptyValue,
        .emptyKey = litaC_m->emptyKey,
        .alloc = litaC_m->alloc
    };
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            if(!(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey))) {
                {
                    litaC_map__Map_put_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_newMap)), litaC_m->keys[litaC_i], litaC_m->values[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_map__Map_free_cb_i64_c_Array_cb_i64_ce__ce_(litaC_m);
    *(litaC_m) = litaC_newMap;
    
}

litaC_void litaC_map__Map_put_cb_i64_c_Array_cb_i64_ce__ce_(litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m,litaC_i64 litaC_key,litaC_array__Array_cb_i64_ce_ litaC_value) {
    if(2 * litaC_m->length >= litaC_m->capacity) {
        {
            litaC_map__MapGrow_cb_i64_c_Array_cb_i64_ce__ce_(litaC_m, 2 * litaC_m->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                {
                    litaC_m->length += 1;
                    litaC_m->keys[litaC_i] = litaC_key;
                    litaC_m->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                    {
                        litaC_m->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_void litaC_map__Map_free_cb_i64_c_Array_cb_i64_ce__ce_(litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m) {
    if(litaC_m) {
        {
            litaC_m->capacity = 0;
            litaC_m->length = 0;
            litaC_mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->keys);
            litaC_mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->values);
            litaC_m->keys = NULL;
            litaC_m->values = NULL;
            
            
        }
        
    } 
    
    
}

litaC_void litaC_array__Array_push_cb__ptr_Module_ce_(litaC_array__Array_cb__ptr_Module_ce_* litaC_a,litaC_module__Module* litaC_element) {
    litaC_array__Array_add_cb__ptr_Module_ce_(litaC_a, litaC_element);
    
}

litaC_void litaC_array__Array_add_cb__ptr_Module_ce_(litaC_array__Array_cb__ptr_Module_ce_* litaC_a,litaC_module__Module* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_Module_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb__ptr_Module_ce_(litaC_array__Array_cb__ptr_Module_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_module__Module*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_module__Module*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_module__Module**)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_Module_ce_(litaC_array__Array_cb__ptr_Module_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_module__Module* litaC_array__Array_pop_cb__ptr_Module_ce_(litaC_array__Array_cb__ptr_Module_ce_* litaC_a) {
    assert(litaC_a->length != 0);
    litaC_module__Module* litaC_r = litaC_a->elements[litaC_a->length - 1];
    litaC_a->length -= 1;
    return litaC_r;
    
    
}

litaC_module__Module* litaC_array__Array_last_cb__ptr_Module_ce_(litaC_array__Array_cb__ptr_Module_ce_* litaC_a) {
    assert(litaC_a->length != 0);
    return litaC_a->elements[litaC_a->length - 1];
    
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_Array_cb_GenericParam_ce__ce_(litaC_array__Array_cb_Array_cb_GenericParam_ce__ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_void litaC_array__Array_add_cb__ptr_Symbol_ce_(litaC_array__Array_cb__ptr_Symbol_ce_* litaC_a,litaC_symbols__Symbol* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_Symbol_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb__ptr_Symbol_ce_(litaC_array__Array_cb__ptr_Symbol_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_symbols__Symbol*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_symbols__Symbol*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_symbols__Symbol**)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

litaC_void litaC_array__Array_add_cb_Array_cb_GenericParam_ce__ce_(litaC_array__Array_cb_Array_cb_GenericParam_ce__ce_* litaC_a,litaC_array__Array_cb_GenericParam_ce_ litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb_Array_cb_GenericParam_ce__ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb_Array_cb_GenericParam_ce__ce_(litaC_array__Array_cb_Array_cb_GenericParam_ce__ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_array__Array_cb_GenericParam_ce_) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_array__Array_cb_GenericParam_ce_) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_array__Array_cb_GenericParam_ce_*)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

litaC_array__Array_cb_GenericParam_ce_ litaC_array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(litaC_array__Array_cb_Array_cb_GenericParam_ce__ce_* litaC_a) {
    assert(litaC_a->length != 0);
    litaC_array__Array_cb_GenericParam_ce_ litaC_r = litaC_a->elements[litaC_a->length - 1];
    litaC_a->length -= 1;
    return litaC_r;
    
    
}

litaC_bool litaC_map__Map_contains_cb_i64_c_Array_cb_i64_ce__ce_(litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m,litaC_i64 litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                {
                    return litaC_true;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_array__Array_cb_i64_ce_* litaC_map__Map_getPtr_cb_i64_c_Array_cb_i64_ce__ce_(litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m,litaC_i64 litaC_key) {
    if(litaC_m->length == 0) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                {
                    return &(litaC_m->values[litaC_i]);
                    
                    
                    
                }
                
            } else {
                if(!(litaC_m->keys[litaC_i])) {
                    {
                        return NULL;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return NULL;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_i64_ce_(litaC_array__Array_cb_i64_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_i64 litaC_array__Array_get_cb_i64_ce_(litaC_array__Array_cb_i64_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_array__Array_cb_i64_ce_ litaC_array__ArrayInit_cb_i64_ce_(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_array__Array_cb_i64_ce_ litaC_array =  {
        
    };
    litaC_array__Array_init_cb_i64_ce_(&((litaC_array)), litaC_initialSize, litaC_alloc);
    return litaC_array;
    
    
}

litaC_void litaC_array__Array_init_cb_i64_ce_(litaC_array__Array_cb_i64_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_i64) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_i64*)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_array__Array_add_cb_i64_ce_(litaC_array__Array_cb_i64_ce_* litaC_a,litaC_i64 litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb_i64_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb_i64_ce_(litaC_array__Array_cb_i64_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_i64) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_i64) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_i64*)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

litaC_types__FuncTypeInfo* litaC_array__Array_last_cb__ptr_FuncTypeInfo_ce_(litaC_array__Array_cb__ptr_FuncTypeInfo_ce_* litaC_a) {
    assert(litaC_a->length != 0);
    return litaC_a->elements[litaC_a->length - 1];
    
    
}

litaC_void litaC_map__Map_init_cb_i64_c__ptr_ConstTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_ConstTypeInfo_ce_* litaC_m,litaC_types__ConstTypeInfo* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_i64),litaC_bool (*litaC_equalFn)(litaC_i64,litaC_i64),const litaC_mem__Allocator* litaC_alloc,litaC_i64 litaC_emptyKey) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_m->length = 0;
    litaC_m->capacity = 0;
    litaC_m->hashFn = litaC_hashFn;
    litaC_m->equalFn = litaC_equalFn;
    litaC_m->alloc = litaC_alloc;
    litaC_m->keys = 0;
    litaC_m->values = 0;
    litaC_m->emptyValue = litaC_emptyValue;
    litaC_m->emptyKey = litaC_emptyKey;
    litaC_initialSize = (litaC_i32)litaC_map__nextPowerOf2(litaC_initialSize);
    litaC_map__MapGrow_cb_i64_c__ptr_ConstTypeInfo_ce_(litaC_m, litaC_initialSize);
    
}

litaC_void litaC_map__MapGrow_cb_i64_c__ptr_ConstTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_ConstTypeInfo_ce_* litaC_m,litaC_i32 litaC_newlength) {
    if(litaC_newlength < 16) {
        {
            litaC_newlength = 16;
            
            
        }
        
    } 
    
    litaC_map__Map_cb_i64_c__ptr_ConstTypeInfo_ce_ litaC_newMap =  {
        .length = 0,
        .capacity = litaC_newlength,
        .keys = (litaC_i64*)litaC_mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_i64)),
        .values = (litaC_types__ConstTypeInfo**)litaC_mem__Allocator_alloc(litaC_m->alloc, litaC_newlength * sizeof(litaC_types__ConstTypeInfo*)),
        .hashFn = litaC_m->hashFn,
        .equalFn = litaC_m->equalFn,
        .emptyValue = litaC_m->emptyValue,
        .emptyKey = litaC_m->emptyKey,
        .alloc = litaC_m->alloc
    };
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            if(!(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey))) {
                {
                    litaC_map__Map_put_cb_i64_c__ptr_ConstTypeInfo_ce_(&((litaC_newMap)), litaC_m->keys[litaC_i], litaC_m->values[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_map__Map_free_cb_i64_c__ptr_ConstTypeInfo_ce_(litaC_m);
    *(litaC_m) = litaC_newMap;
    
}

litaC_void litaC_map__Map_put_cb_i64_c__ptr_ConstTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_ConstTypeInfo_ce_* litaC_m,litaC_i64 litaC_key,litaC_types__ConstTypeInfo* litaC_value) {
    if(2 * litaC_m->length >= litaC_m->capacity) {
        {
            litaC_map__MapGrow_cb_i64_c__ptr_ConstTypeInfo_ce_(litaC_m, 2 * litaC_m->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                {
                    litaC_m->length += 1;
                    litaC_m->keys[litaC_i] = litaC_key;
                    litaC_m->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                    {
                        litaC_m->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_void litaC_map__Map_free_cb_i64_c__ptr_ConstTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_ConstTypeInfo_ce_* litaC_m) {
    if(litaC_m) {
        {
            litaC_m->capacity = 0;
            litaC_m->length = 0;
            litaC_mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->keys);
            litaC_mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->values);
            litaC_m->keys = NULL;
            litaC_m->values = NULL;
            
            
        }
        
    } 
    
    
}

litaC_void litaC_map__Map_init_cb_i64_c__ptr_PtrTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_PtrTypeInfo_ce_* litaC_m,litaC_types__PtrTypeInfo* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_i64),litaC_bool (*litaC_equalFn)(litaC_i64,litaC_i64),const litaC_mem__Allocator* litaC_alloc,litaC_i64 litaC_emptyKey) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_m->length = 0;
    litaC_m->capacity = 0;
    litaC_m->hashFn = litaC_hashFn;
    litaC_m->equalFn = litaC_equalFn;
    litaC_m->alloc = litaC_alloc;
    litaC_m->keys = 0;
    litaC_m->values = 0;
    litaC_m->emptyValue = litaC_emptyValue;
    litaC_m->emptyKey = litaC_emptyKey;
    litaC_initialSize = (litaC_i32)litaC_map__nextPowerOf2(litaC_initialSize);
    litaC_map__MapGrow_cb_i64_c__ptr_PtrTypeInfo_ce_(litaC_m, litaC_initialSize);
    
}

litaC_void litaC_map__MapGrow_cb_i64_c__ptr_PtrTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_PtrTypeInfo_ce_* litaC_m,litaC_i32 litaC_newlength) {
    if(litaC_newlength < 16) {
        {
            litaC_newlength = 16;
            
            
        }
        
    } 
    
    litaC_map__Map_cb_i64_c__ptr_PtrTypeInfo_ce_ litaC_newMap =  {
        .length = 0,
        .capacity = litaC_newlength,
        .keys = (litaC_i64*)litaC_mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_i64)),
        .values = (litaC_types__PtrTypeInfo**)litaC_mem__Allocator_alloc(litaC_m->alloc, litaC_newlength * sizeof(litaC_types__PtrTypeInfo*)),
        .hashFn = litaC_m->hashFn,
        .equalFn = litaC_m->equalFn,
        .emptyValue = litaC_m->emptyValue,
        .emptyKey = litaC_m->emptyKey,
        .alloc = litaC_m->alloc
    };
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            if(!(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey))) {
                {
                    litaC_map__Map_put_cb_i64_c__ptr_PtrTypeInfo_ce_(&((litaC_newMap)), litaC_m->keys[litaC_i], litaC_m->values[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_map__Map_free_cb_i64_c__ptr_PtrTypeInfo_ce_(litaC_m);
    *(litaC_m) = litaC_newMap;
    
}

litaC_void litaC_map__Map_put_cb_i64_c__ptr_PtrTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_PtrTypeInfo_ce_* litaC_m,litaC_i64 litaC_key,litaC_types__PtrTypeInfo* litaC_value) {
    if(2 * litaC_m->length >= litaC_m->capacity) {
        {
            litaC_map__MapGrow_cb_i64_c__ptr_PtrTypeInfo_ce_(litaC_m, 2 * litaC_m->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                {
                    litaC_m->length += 1;
                    litaC_m->keys[litaC_i] = litaC_key;
                    litaC_m->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                    {
                        litaC_m->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_void litaC_map__Map_free_cb_i64_c__ptr_PtrTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_PtrTypeInfo_ce_* litaC_m) {
    if(litaC_m) {
        {
            litaC_m->capacity = 0;
            litaC_m->length = 0;
            litaC_mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->keys);
            litaC_mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->values);
            litaC_m->keys = NULL;
            litaC_m->values = NULL;
            
            
        }
        
    } 
    
    
}

litaC_void litaC_map__Map_init_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(litaC_map__Map_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_* litaC_m,litaC_types__ArrayTypeInfo* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_types_new__ArrayEntry),litaC_bool (*litaC_equalFn)(litaC_types_new__ArrayEntry,litaC_types_new__ArrayEntry),const litaC_mem__Allocator* litaC_alloc,litaC_types_new__ArrayEntry litaC_emptyKey) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_m->length = 0;
    litaC_m->capacity = 0;
    litaC_m->hashFn = litaC_hashFn;
    litaC_m->equalFn = litaC_equalFn;
    litaC_m->alloc = litaC_alloc;
    litaC_m->keys = 0;
    litaC_m->values = 0;
    litaC_m->emptyValue = litaC_emptyValue;
    litaC_m->emptyKey = litaC_emptyKey;
    litaC_initialSize = (litaC_i32)litaC_map__nextPowerOf2(litaC_initialSize);
    litaC_map__MapGrow_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(litaC_m, litaC_initialSize);
    
}

litaC_void litaC_map__MapGrow_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(litaC_map__Map_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_* litaC_m,litaC_i32 litaC_newlength) {
    if(litaC_newlength < 16) {
        {
            litaC_newlength = 16;
            
            
        }
        
    } 
    
    litaC_map__Map_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_ litaC_newMap =  {
        .length = 0,
        .capacity = litaC_newlength,
        .keys = (litaC_types_new__ArrayEntry*)litaC_mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_types_new__ArrayEntry)),
        .values = (litaC_types__ArrayTypeInfo**)litaC_mem__Allocator_alloc(litaC_m->alloc, litaC_newlength * sizeof(litaC_types__ArrayTypeInfo*)),
        .hashFn = litaC_m->hashFn,
        .equalFn = litaC_m->equalFn,
        .emptyValue = litaC_m->emptyValue,
        .emptyKey = litaC_m->emptyKey,
        .alloc = litaC_m->alloc
    };
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            if(!(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey))) {
                {
                    litaC_map__Map_put_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(&((litaC_newMap)), litaC_m->keys[litaC_i], litaC_m->values[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_map__Map_free_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(litaC_m);
    *(litaC_m) = litaC_newMap;
    
}

litaC_void litaC_map__Map_put_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(litaC_map__Map_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_* litaC_m,litaC_types_new__ArrayEntry litaC_key,litaC_types__ArrayTypeInfo* litaC_value) {
    if(2 * litaC_m->length >= litaC_m->capacity) {
        {
            litaC_map__MapGrow_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(litaC_m, 2 * litaC_m->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                {
                    litaC_m->length += 1;
                    litaC_m->keys[litaC_i] = litaC_key;
                    litaC_m->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                    {
                        litaC_m->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_void litaC_map__Map_free_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(litaC_map__Map_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_* litaC_m) {
    if(litaC_m) {
        {
            litaC_m->capacity = 0;
            litaC_m->length = 0;
            litaC_mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->keys);
            litaC_mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->values);
            litaC_m->keys = NULL;
            litaC_m->values = NULL;
            
            
        }
        
    } 
    
    
}

litaC_void litaC_map__Map_init_cb__ptr_const_char_c__ptr_TypeInfo_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TypeInfo_ce_* litaC_m,litaC_types__TypeInfo* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(const litaC_char*),litaC_bool (*litaC_equalFn)(const litaC_char*,const litaC_char*),const litaC_mem__Allocator* litaC_alloc,const litaC_char* litaC_emptyKey) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_m->length = 0;
    litaC_m->capacity = 0;
    litaC_m->hashFn = litaC_hashFn;
    litaC_m->equalFn = litaC_equalFn;
    litaC_m->alloc = litaC_alloc;
    litaC_m->keys = 0;
    litaC_m->values = 0;
    litaC_m->emptyValue = litaC_emptyValue;
    litaC_m->emptyKey = litaC_emptyKey;
    litaC_initialSize = (litaC_i32)litaC_map__nextPowerOf2(litaC_initialSize);
    litaC_map__MapGrow_cb__ptr_const_char_c__ptr_TypeInfo_ce_(litaC_m, litaC_initialSize);
    
}

litaC_void litaC_map__MapGrow_cb__ptr_const_char_c__ptr_TypeInfo_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TypeInfo_ce_* litaC_m,litaC_i32 litaC_newlength) {
    if(litaC_newlength < 16) {
        {
            litaC_newlength = 16;
            
            
        }
        
    } 
    
    litaC_map__Map_cb__ptr_const_char_c__ptr_TypeInfo_ce_ litaC_newMap =  {
        .length = 0,
        .capacity = litaC_newlength,
        .keys = (const litaC_char**)litaC_mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(const litaC_char*)),
        .values = (litaC_types__TypeInfo**)litaC_mem__Allocator_alloc(litaC_m->alloc, litaC_newlength * sizeof(litaC_types__TypeInfo*)),
        .hashFn = litaC_m->hashFn,
        .equalFn = litaC_m->equalFn,
        .emptyValue = litaC_m->emptyValue,
        .emptyKey = litaC_m->emptyKey,
        .alloc = litaC_m->alloc
    };
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            if(!(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey))) {
                {
                    litaC_map__Map_put_cb__ptr_const_char_c__ptr_TypeInfo_ce_(&((litaC_newMap)), litaC_m->keys[litaC_i], litaC_m->values[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_map__Map_free_cb__ptr_const_char_c__ptr_TypeInfo_ce_(litaC_m);
    *(litaC_m) = litaC_newMap;
    
}

litaC_void litaC_map__Map_put_cb__ptr_const_char_c__ptr_TypeInfo_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TypeInfo_ce_* litaC_m,const litaC_char* litaC_key,litaC_types__TypeInfo* litaC_value) {
    if(2 * litaC_m->length >= litaC_m->capacity) {
        {
            litaC_map__MapGrow_cb__ptr_const_char_c__ptr_TypeInfo_ce_(litaC_m, 2 * litaC_m->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                {
                    litaC_m->length += 1;
                    litaC_m->keys[litaC_i] = litaC_key;
                    litaC_m->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                    {
                        litaC_m->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_void litaC_map__Map_free_cb__ptr_const_char_c__ptr_TypeInfo_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TypeInfo_ce_* litaC_m) {
    if(litaC_m) {
        {
            litaC_m->capacity = 0;
            litaC_m->length = 0;
            litaC_mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->keys);
            litaC_mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->values);
            litaC_m->keys = NULL;
            litaC_m->values = NULL;
            
            
        }
        
    } 
    
    
}

litaC_types__TypeInfo* litaC_map__Map_get_cb__ptr_const_char_c__ptr_TypeInfo_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TypeInfo_ce_* litaC_m,const litaC_char* litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_m->emptyValue;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                {
                    return litaC_m->values[litaC_i];
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                    {
                        return litaC_m->emptyValue;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_m->emptyValue;
    
    
}

litaC_types__TypeInfo* litaC_mem__new_cb_TypeInfo_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_types__TypeInfo* litaC_result = (litaC_types__TypeInfo*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_types__TypeInfo));
    return litaC_result;
    
    
}

litaC_types__FuncTypeInfo* litaC_mem__new_cb_FuncTypeInfo_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_types__FuncTypeInfo* litaC_result = (litaC_types__FuncTypeInfo*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_types__FuncTypeInfo));
    return litaC_result;
    
    
}

litaC_types__ArrayTypeInfo* litaC_map__Map_get_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(litaC_map__Map_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_* litaC_m,litaC_types_new__ArrayEntry litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_m->emptyValue;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                {
                    return litaC_m->values[litaC_i];
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                    {
                        return litaC_m->emptyValue;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_m->emptyValue;
    
    
}

litaC_types__ArrayTypeInfo* litaC_mem__new_cb_ArrayTypeInfo_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_types__ArrayTypeInfo* litaC_result = (litaC_types__ArrayTypeInfo*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_types__ArrayTypeInfo));
    return litaC_result;
    
    
}

litaC_types__FuncPtrTypeInfo* litaC_mem__new_cb_FuncPtrTypeInfo_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_types__FuncPtrTypeInfo* litaC_result = (litaC_types__FuncPtrTypeInfo*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_types__FuncPtrTypeInfo));
    return litaC_result;
    
    
}

litaC_types__AggregateTypeInfo* litaC_mem__new_cb_AggregateTypeInfo_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_types__AggregateTypeInfo* litaC_result = (litaC_types__AggregateTypeInfo*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_types__AggregateTypeInfo));
    return litaC_result;
    
    
}

litaC_types__EnumTypeInfo* litaC_mem__new_cb_EnumTypeInfo_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_types__EnumTypeInfo* litaC_result = (litaC_types__EnumTypeInfo*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_types__EnumTypeInfo));
    return litaC_result;
    
    
}

litaC_types__ConstTypeInfo* litaC_map__Map_get_cb_i64_c__ptr_ConstTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_ConstTypeInfo_ce_* litaC_m,litaC_i64 litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_m->emptyValue;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                {
                    return litaC_m->values[litaC_i];
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                    {
                        return litaC_m->emptyValue;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_m->emptyValue;
    
    
}

litaC_types__ConstTypeInfo* litaC_mem__new_cb_ConstTypeInfo_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_types__ConstTypeInfo* litaC_result = (litaC_types__ConstTypeInfo*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_types__ConstTypeInfo));
    return litaC_result;
    
    
}

litaC_types__PtrTypeInfo* litaC_map__Map_get_cb_i64_c__ptr_PtrTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_PtrTypeInfo_ce_* litaC_m,litaC_i64 litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_m->emptyValue;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                {
                    return litaC_m->values[litaC_i];
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                    {
                        return litaC_m->emptyValue;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_m->emptyValue;
    
    
}

litaC_types__PtrTypeInfo* litaC_mem__new_cb_PtrTypeInfo_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_types__PtrTypeInfo* litaC_result = (litaC_types__PtrTypeInfo*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_types__PtrTypeInfo));
    return litaC_result;
    
    
}

LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb_Token_ce_(litaC_array__Array_cb_Token_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

litaC_ast__GenericParam litaC_array__Array_removeAt_cb_GenericParam_ce_(litaC_array__Array_cb_GenericParam_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    litaC_ast__GenericParam litaC_r = litaC_a->elements[litaC_index];
    if(litaC_index < litaC_a->length - 1) {
        {
            memmove((litaC_void*)(&(litaC_a->elements[litaC_index])), (const litaC_void*)(&(litaC_a->elements[litaC_index + 1])), ((litaC_a->length - 1) - litaC_index) * sizeof(litaC_ast__GenericParam));
            
            
        }
        
    } 
    
    litaC_a->length -= 1;
    return litaC_r;
    
    
}

litaC_void litaC_array__Array_set_cb__ptr_TypeSpec_ce_(litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__TypeSpec* litaC_element) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    {
        litaC_a->elements[litaC_index] = litaC_element;
        
        
    }
    
}

litaC_map__MapIterator_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_ litaC_map__Map_iter_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(litaC_map__Map_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_* litaC_m) {
    return (litaC_map__MapIterator_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_) {
        .m = litaC_m,
        .it = 0,
        .count = 0
    };
    
    
}

litaC_bool litaC_map__MapIterator_hasNext_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(litaC_map__MapIterator_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_* litaC_iter) {
    return litaC_iter->count < litaC_iter->m->length;
    
    
}

litaC_map__MapEntry_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_ litaC_map__MapIterator_next_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_(litaC_map__MapIterator_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_* litaC_iter) {
    litaC_i32 litaC_i = litaC_iter->it;
    assert(litaC_i < litaC_iter->m->capacity);
    
    for(;litaC_i < litaC_iter->m->capacity;litaC_i += 1) {
        {
            litaC_bool litaC_hasValue = !(litaC_iter->m->equalFn(litaC_iter->m->keys[litaC_i], litaC_iter->m->emptyKey));
            if(litaC_hasValue) {
                {
                    litaC_iter->count += 1;
                    {
                        litaC_map__MapEntry_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_ ___result = (litaC_map__MapEntry_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_) {
                            .key = litaC_iter->m->keys[litaC_i],
                            .value = litaC_iter->m->values[litaC_i],
                            .valuePtr = &(litaC_iter->m->values[litaC_i])
                        };
                        litaC_iter->it = litaC_i + 1;
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    {
        litaC_map__MapEntry_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_ ___result = (litaC_map__MapEntry_cb_ArrayEntry_c__ptr_ArrayTypeInfo_ce_) {
            
        };
        litaC_iter->it = litaC_i + 1;
        return ___result;
        
    }
    
    litaC_iter->it = litaC_i + 1;
    
}

litaC_map__MapIterator_cb_i64_c__ptr_PtrTypeInfo_ce_ litaC_map__Map_iter_cb_i64_c__ptr_PtrTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_PtrTypeInfo_ce_* litaC_m) {
    return (litaC_map__MapIterator_cb_i64_c__ptr_PtrTypeInfo_ce_) {
        .m = litaC_m,
        .it = 0,
        .count = 0
    };
    
    
}

litaC_bool litaC_map__MapIterator_hasNext_cb_i64_c__ptr_PtrTypeInfo_ce_(litaC_map__MapIterator_cb_i64_c__ptr_PtrTypeInfo_ce_* litaC_iter) {
    return litaC_iter->count < litaC_iter->m->length;
    
    
}

litaC_map__MapEntry_cb_i64_c__ptr_PtrTypeInfo_ce_ litaC_map__MapIterator_next_cb_i64_c__ptr_PtrTypeInfo_ce_(litaC_map__MapIterator_cb_i64_c__ptr_PtrTypeInfo_ce_* litaC_iter) {
    litaC_i32 litaC_i = litaC_iter->it;
    assert(litaC_i < litaC_iter->m->capacity);
    
    for(;litaC_i < litaC_iter->m->capacity;litaC_i += 1) {
        {
            litaC_bool litaC_hasValue = !(litaC_iter->m->equalFn(litaC_iter->m->keys[litaC_i], litaC_iter->m->emptyKey));
            if(litaC_hasValue) {
                {
                    litaC_iter->count += 1;
                    {
                        litaC_map__MapEntry_cb_i64_c__ptr_PtrTypeInfo_ce_ ___result = (litaC_map__MapEntry_cb_i64_c__ptr_PtrTypeInfo_ce_) {
                            .key = litaC_iter->m->keys[litaC_i],
                            .value = litaC_iter->m->values[litaC_i],
                            .valuePtr = &(litaC_iter->m->values[litaC_i])
                        };
                        litaC_iter->it = litaC_i + 1;
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    {
        litaC_map__MapEntry_cb_i64_c__ptr_PtrTypeInfo_ce_ ___result = (litaC_map__MapEntry_cb_i64_c__ptr_PtrTypeInfo_ce_) {
            
        };
        litaC_iter->it = litaC_i + 1;
        return ___result;
        
    }
    
    litaC_iter->it = litaC_i + 1;
    
}

litaC_map__MapIterator_cb_i64_c__ptr_ConstTypeInfo_ce_ litaC_map__Map_iter_cb_i64_c__ptr_ConstTypeInfo_ce_(litaC_map__Map_cb_i64_c__ptr_ConstTypeInfo_ce_* litaC_m) {
    return (litaC_map__MapIterator_cb_i64_c__ptr_ConstTypeInfo_ce_) {
        .m = litaC_m,
        .it = 0,
        .count = 0
    };
    
    
}

litaC_bool litaC_map__MapIterator_hasNext_cb_i64_c__ptr_ConstTypeInfo_ce_(litaC_map__MapIterator_cb_i64_c__ptr_ConstTypeInfo_ce_* litaC_iter) {
    return litaC_iter->count < litaC_iter->m->length;
    
    
}

litaC_map__MapEntry_cb_i64_c__ptr_ConstTypeInfo_ce_ litaC_map__MapIterator_next_cb_i64_c__ptr_ConstTypeInfo_ce_(litaC_map__MapIterator_cb_i64_c__ptr_ConstTypeInfo_ce_* litaC_iter) {
    litaC_i32 litaC_i = litaC_iter->it;
    assert(litaC_i < litaC_iter->m->capacity);
    
    for(;litaC_i < litaC_iter->m->capacity;litaC_i += 1) {
        {
            litaC_bool litaC_hasValue = !(litaC_iter->m->equalFn(litaC_iter->m->keys[litaC_i], litaC_iter->m->emptyKey));
            if(litaC_hasValue) {
                {
                    litaC_iter->count += 1;
                    {
                        litaC_map__MapEntry_cb_i64_c__ptr_ConstTypeInfo_ce_ ___result = (litaC_map__MapEntry_cb_i64_c__ptr_ConstTypeInfo_ce_) {
                            .key = litaC_iter->m->keys[litaC_i],
                            .value = litaC_iter->m->values[litaC_i],
                            .valuePtr = &(litaC_iter->m->values[litaC_i])
                        };
                        litaC_iter->it = litaC_i + 1;
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    {
        litaC_map__MapEntry_cb_i64_c__ptr_ConstTypeInfo_ce_ ___result = (litaC_map__MapEntry_cb_i64_c__ptr_ConstTypeInfo_ce_) {
            
        };
        litaC_iter->it = litaC_i + 1;
        return ___result;
        
    }
    
    litaC_iter->it = litaC_i + 1;
    
}

litaC_void litaC_array__Array_add_cb__ptr_FuncTypeInfo_ce_(litaC_array__Array_cb__ptr_FuncTypeInfo_ce_* litaC_a,litaC_types__FuncTypeInfo* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_FuncTypeInfo_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb__ptr_FuncTypeInfo_ce_(litaC_array__Array_cb__ptr_FuncTypeInfo_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_types__FuncTypeInfo*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_types__FuncTypeInfo*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_types__FuncTypeInfo**)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

litaC_types__FuncTypeInfo* litaC_array__Array_pop_cb__ptr_FuncTypeInfo_ce_(litaC_array__Array_cb__ptr_FuncTypeInfo_ce_* litaC_a) {
    assert(litaC_a->length != 0);
    litaC_types__FuncTypeInfo* litaC_r = litaC_a->elements[litaC_a->length - 1];
    litaC_a->length -= 1;
    return litaC_r;
    
    
}

litaC_void litaC_array__Array_insertAt_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__CallArg litaC_element) {
    assert(litaC_index >= 0 && litaC_index <= litaC_a->length);
    if(litaC_index == litaC_a->length) {
        {
            litaC_array__Array_add_cb_CallArg_ce_(litaC_a, litaC_element);
            return;
            
            
            
        }
        
    } 
    
    litaC_a->length += 1;
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb_CallArg_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    memmove((litaC_void*)(&(litaC_a->elements[litaC_index + 1])), (const litaC_void*)(&(litaC_a->elements[litaC_index])), (litaC_a->length - litaC_index) * sizeof(litaC_ast__CallArg));
    litaC_array__Array_set_cb_CallArg_ce_(litaC_a, litaC_index, litaC_element);
    
}

litaC_void litaC_array__Array_set_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__CallArg litaC_element) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    {
        litaC_a->elements[litaC_index] = litaC_element;
        
        
    }
    
}

litaC_ast__CallArg* litaC_array__Array_getPtr_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return &(litaC_a->elements[litaC_index]);
    
    
}

litaC_void litaC_array__Array_addAll_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_a,litaC_array__Array_cb_CallArg_ce_* litaC_other) {
    if(!(litaC_other) || litaC_other->length == 0) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_a->length + litaC_other->length > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb_CallArg_ce_(litaC_a, litaC_other->length);
            
            
        }
        
    } 
    
    memcpy((litaC_void*)(&(litaC_a->elements[litaC_a->length])), (const litaC_void*)(&(litaC_other->elements[0])), litaC_other->length * sizeof(litaC_ast__CallArg));
    litaC_a->length += litaC_other->length;
    
}

litaC_void litaC_array__Array_sort_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 (*litaC_sorter)(litaC_ast__CallArg,litaC_ast__CallArg)) {
    litaC_array__QuickSort_cb_CallArg_ce_(litaC_a, litaC_sorter);
    
}

litaC_void litaC_array__QuickSort_cb_CallArg_ce_(litaC_array__Array_cb_CallArg_ce_* litaC_array,litaC_i32 (*litaC_comp)(litaC_ast__CallArg,litaC_ast__CallArg)) {
    litaC_i32 litaC_beg[300] =  {
        
    };
    litaC_i32 litaC_end[300] =  {
        
    };
    litaC_i32 litaC_i = 0;
    litaC_i32 litaC_L = 0;
    litaC_i32 litaC_R = 0;
    litaC_i32 litaC_swap = 0;
    litaC_ast__CallArg litaC_piv;
    litaC_beg[0] = 0;
    litaC_end[0] = litaC_array->length;
    while(litaC_i >= 0) {
        {
            litaC_L = litaC_beg[litaC_i];
            litaC_R = litaC_end[litaC_i] - 1;
            if(litaC_L < litaC_R) {
                {
                    litaC_piv = litaC_array->elements[litaC_L];
                    while(litaC_L < litaC_R) {
                        {
                            while(litaC_L < litaC_R && litaC_comp(litaC_array->elements[litaC_R], litaC_piv) >= 0) {
                                {
                                    litaC_R -= 1;
                                    
                                    
                                }
                            }
                            if(litaC_L < litaC_R) {
                                {
                                    litaC_array->elements[litaC_L] = litaC_array->elements[litaC_R];
                                    litaC_L += 1;
                                    
                                    
                                }
                                
                            } 
                            
                            while(litaC_L < litaC_R && litaC_comp(litaC_array->elements[litaC_L], litaC_piv) <= 0) {
                                {
                                    litaC_L += 1;
                                    
                                    
                                }
                            }
                            if(litaC_L < litaC_R) {
                                {
                                    litaC_array->elements[litaC_R] = litaC_array->elements[litaC_L];
                                    litaC_R -= 1;
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_array->elements[litaC_L] = litaC_piv;
                            litaC_beg[litaC_i + 1] = litaC_L + 1;
                            litaC_end[litaC_i + 1] = litaC_end[litaC_i];
                            litaC_end[litaC_i + 0] = litaC_L;
                            litaC_i += 1;
                            if(litaC_end[litaC_i] - litaC_beg[litaC_i] > litaC_end[litaC_i - 1] - litaC_beg[litaC_i - 1]) {
                                {
                                    litaC_swap = litaC_beg[litaC_i];
                                    litaC_beg[litaC_i] = litaC_beg[litaC_i - 1];
                                    litaC_beg[litaC_i - 1] = litaC_swap;
                                    litaC_swap = litaC_end[litaC_i];
                                    litaC_end[litaC_i] = litaC_end[litaC_i - 1];
                                    litaC_end[litaC_i - 1] = litaC_swap;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                    }
                    
                    
                }
                
            } else {
                {
                    litaC_i -= 1;
                    
                    
                }
            } 
            
            
            
        }
    }
    
}

litaC_void litaC_array__Array_init_cb_Token_ce_(litaC_array__Array_cb_Token_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_lex__Token) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_lex__Token*)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_array__Array_add_cb_Token_ce_(litaC_array__Array_cb_Token_ce_* litaC_a,litaC_lex__Token litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb_Token_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb_Token_ce_(litaC_array__Array_cb_Token_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_lex__Token) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_lex__Token) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_lex__Token*)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

litaC_void litaC_array__Array_init_cb__ptr_ImportDecl_ce_(litaC_array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__ImportDecl*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__ImportDecl**)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_array__Array_init_cb__ptr_NoteStmt_ce_(litaC_array__Array_cb__ptr_NoteStmt_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__NoteStmt*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__NoteStmt**)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_array__Array_init_cb__ptr_Decl_ce_(litaC_array__Array_cb__ptr_Decl_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__Decl*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__Decl**)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_ast__Decl* litaC_array__Array_last_cb__ptr_Decl_ce_(litaC_array__Array_cb__ptr_Decl_ce_* litaC_a) {
    assert(litaC_a->length != 0);
    return litaC_a->elements[litaC_a->length - 1];
    
    
}

litaC_void litaC_array__Array_insertAt_cb__ptr_ParameterDecl_ce_(litaC_array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__ParameterDecl* litaC_element) {
    assert(litaC_index >= 0 && litaC_index <= litaC_a->length);
    if(litaC_index == litaC_a->length) {
        {
            litaC_array__Array_add_cb__ptr_ParameterDecl_ce_(litaC_a, litaC_element);
            return;
            
            
            
        }
        
    } 
    
    litaC_a->length += 1;
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_ParameterDecl_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    memmove((litaC_void*)(&(litaC_a->elements[litaC_index + 1])), (const litaC_void*)(&(litaC_a->elements[litaC_index])), (litaC_a->length - litaC_index) * sizeof(litaC_ast__ParameterDecl*));
    litaC_array__Array_set_cb__ptr_ParameterDecl_ce_(litaC_a, litaC_index, litaC_element);
    
}

litaC_void litaC_array__Array_set_cb__ptr_ParameterDecl_ce_(litaC_array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__ParameterDecl* litaC_element) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    {
        litaC_a->elements[litaC_index] = litaC_element;
        
        
    }
    
}

litaC_void litaC_array__Array_init_cb__ptr_EnumFieldEntryDecl_ce_(litaC_array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__EnumFieldEntryDecl*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__EnumFieldEntryDecl**)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_array__Array_add_cb__ptr_EnumFieldEntryDecl_ce_(litaC_array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_a,litaC_ast__EnumFieldEntryDecl* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_EnumFieldEntryDecl_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb__ptr_EnumFieldEntryDecl_ce_(litaC_array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__EnumFieldEntryDecl*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__EnumFieldEntryDecl*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__EnumFieldEntryDecl**)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

litaC_void litaC_array__Array_free_cb__ptr_TypeSpec_ce_(litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_a) {
    if(litaC_a && litaC_a->elements) {
        {
            litaC_mem__Allocator_free(litaC_a->alloc, (litaC_void*)litaC_a->elements);
            litaC_a->elements = NULL;
            litaC_a->length = 0;
            litaC_a->capacity = 0;
            
            
        }
        
    } 
    
    
}

LITAC_INLINE 
litaC_void litaC_array__Array_clear_cb__ptr_TypeSpec_ce_(litaC_array__Array_cb__ptr_TypeSpec_ce_* litaC_a) {
    litaC_a->length = 0;
    
}

litaC_lex__Token litaC_array__Array_last_cb_Token_ce_(litaC_array__Array_cb_Token_ce_* litaC_a) {
    assert(litaC_a->length != 0);
    return litaC_a->elements[litaC_a->length - 1];
    
    
}

litaC_array__Array_cb__ptr_Decl_ce_ litaC_array__ArrayInit_cb__ptr_Decl_ce_(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_array__Array_cb__ptr_Decl_ce_ litaC_array =  {
        
    };
    litaC_array__Array_init_cb__ptr_Decl_ce_(&((litaC_array)), litaC_initialSize, litaC_alloc);
    return litaC_array;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_map__Map_size_cb_i64_c_Array_cb_i64_ce__ce_(litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m) {
    return litaC_m->length;
    
    
}

litaC_map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_ litaC_map__Map_iter_cb_i64_c_Array_cb_i64_ce__ce_(litaC_map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m) {
    return (litaC_map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_) {
        .m = litaC_m,
        .it = 0,
        .count = 0
    };
    
    
}

litaC_bool litaC_map__MapIterator_hasNext_cb_i64_c_Array_cb_i64_ce__ce_(litaC_map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_* litaC_iter) {
    return litaC_iter->count < litaC_iter->m->length;
    
    
}

litaC_map__MapEntry_cb_i64_c_Array_cb_i64_ce__ce_ litaC_map__MapIterator_next_cb_i64_c_Array_cb_i64_ce__ce_(litaC_map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_* litaC_iter) {
    litaC_i32 litaC_i = litaC_iter->it;
    assert(litaC_i < litaC_iter->m->capacity);
    
    for(;litaC_i < litaC_iter->m->capacity;litaC_i += 1) {
        {
            litaC_bool litaC_hasValue = !(litaC_iter->m->equalFn(litaC_iter->m->keys[litaC_i], litaC_iter->m->emptyKey));
            if(litaC_hasValue) {
                {
                    litaC_iter->count += 1;
                    {
                        litaC_map__MapEntry_cb_i64_c_Array_cb_i64_ce__ce_ ___result = (litaC_map__MapEntry_cb_i64_c_Array_cb_i64_ce__ce_) {
                            .key = litaC_iter->m->keys[litaC_i],
                            .value = litaC_iter->m->values[litaC_i],
                            .valuePtr = &(litaC_iter->m->values[litaC_i])
                        };
                        litaC_iter->it = litaC_i + 1;
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    {
        litaC_map__MapEntry_cb_i64_c_Array_cb_i64_ce__ce_ ___result = (litaC_map__MapEntry_cb_i64_c_Array_cb_i64_ce__ce_) {
            
        };
        litaC_iter->it = litaC_i + 1;
        return ___result;
        
    }
    
    litaC_iter->it = litaC_i + 1;
    
}

litaC_map__MapIterator_cb__ptr_const_char_c__ptr_Module_ce_ litaC_map__Map_iter_cb__ptr_const_char_c__ptr_Module_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m) {
    return (litaC_map__MapIterator_cb__ptr_const_char_c__ptr_Module_ce_) {
        .m = litaC_m,
        .it = 0,
        .count = 0
    };
    
    
}

litaC_bool litaC_map__MapIterator_hasNext_cb__ptr_const_char_c__ptr_Module_ce_(litaC_map__MapIterator_cb__ptr_const_char_c__ptr_Module_ce_* litaC_iter) {
    return litaC_iter->count < litaC_iter->m->length;
    
    
}

litaC_map__MapEntry_cb__ptr_const_char_c__ptr_Module_ce_ litaC_map__MapIterator_next_cb__ptr_const_char_c__ptr_Module_ce_(litaC_map__MapIterator_cb__ptr_const_char_c__ptr_Module_ce_* litaC_iter) {
    litaC_i32 litaC_i = litaC_iter->it;
    assert(litaC_i < litaC_iter->m->capacity);
    
    for(;litaC_i < litaC_iter->m->capacity;litaC_i += 1) {
        {
            litaC_bool litaC_hasValue = !(litaC_iter->m->equalFn(litaC_iter->m->keys[litaC_i], litaC_iter->m->emptyKey));
            if(litaC_hasValue) {
                {
                    litaC_iter->count += 1;
                    {
                        litaC_map__MapEntry_cb__ptr_const_char_c__ptr_Module_ce_ ___result = (litaC_map__MapEntry_cb__ptr_const_char_c__ptr_Module_ce_) {
                            .key = litaC_iter->m->keys[litaC_i],
                            .value = litaC_iter->m->values[litaC_i],
                            .valuePtr = &(litaC_iter->m->values[litaC_i])
                        };
                        litaC_iter->it = litaC_i + 1;
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    {
        litaC_map__MapEntry_cb__ptr_const_char_c__ptr_Module_ce_ ___result = (litaC_map__MapEntry_cb__ptr_const_char_c__ptr_Module_ce_) {
            
        };
        litaC_iter->it = litaC_i + 1;
        return ___result;
        
    }
    
    litaC_iter->it = litaC_i + 1;
    
}

litaC_u32 litaC_map__PtrHashFn_cb__ptr_Symbol_ce_(litaC_symbols__Symbol* litaC_a) {
    litaC_u32 litaC_hash = (litaC_u32)(((litaC_usize)litaC_a) % 4294967291U);
    return litaC_hash;
    
    
}

litaC_bool litaC_map__PtrEqualFn_cb__ptr_Symbol_ce_(litaC_symbols__Symbol* litaC_a,litaC_symbols__Symbol* litaC_b) {
    return litaC_a == litaC_b;
    
    
}

litaC_void litaC_map__Map_init_cb__ptr_Symbol_c_Dependency_ce_(litaC_map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m,litaC_dependency_graph__Dependency litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_symbols__Symbol*),litaC_bool (*litaC_equalFn)(litaC_symbols__Symbol*,litaC_symbols__Symbol*),const litaC_mem__Allocator* litaC_alloc,litaC_symbols__Symbol* litaC_emptyKey) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_m->length = 0;
    litaC_m->capacity = 0;
    litaC_m->hashFn = litaC_hashFn;
    litaC_m->equalFn = litaC_equalFn;
    litaC_m->alloc = litaC_alloc;
    litaC_m->keys = 0;
    litaC_m->values = 0;
    litaC_m->emptyValue = litaC_emptyValue;
    litaC_m->emptyKey = litaC_emptyKey;
    litaC_initialSize = (litaC_i32)litaC_map__nextPowerOf2(litaC_initialSize);
    litaC_map__MapGrow_cb__ptr_Symbol_c_Dependency_ce_(litaC_m, litaC_initialSize);
    
}

litaC_void litaC_map__MapGrow_cb__ptr_Symbol_c_Dependency_ce_(litaC_map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m,litaC_i32 litaC_newlength) {
    if(litaC_newlength < 16) {
        {
            litaC_newlength = 16;
            
            
        }
        
    } 
    
    litaC_map__Map_cb__ptr_Symbol_c_Dependency_ce_ litaC_newMap =  {
        .length = 0,
        .capacity = litaC_newlength,
        .keys = (litaC_symbols__Symbol**)litaC_mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_symbols__Symbol*)),
        .values = (litaC_dependency_graph__Dependency*)litaC_mem__Allocator_alloc(litaC_m->alloc, litaC_newlength * sizeof(litaC_dependency_graph__Dependency)),
        .hashFn = litaC_m->hashFn,
        .equalFn = litaC_m->equalFn,
        .emptyValue = litaC_m->emptyValue,
        .emptyKey = litaC_m->emptyKey,
        .alloc = litaC_m->alloc
    };
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            if(!(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey))) {
                {
                    litaC_map__Map_put_cb__ptr_Symbol_c_Dependency_ce_(&((litaC_newMap)), litaC_m->keys[litaC_i], litaC_m->values[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_map__Map_free_cb__ptr_Symbol_c_Dependency_ce_(litaC_m);
    *(litaC_m) = litaC_newMap;
    
}

litaC_void litaC_map__Map_put_cb__ptr_Symbol_c_Dependency_ce_(litaC_map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m,litaC_symbols__Symbol* litaC_key,litaC_dependency_graph__Dependency litaC_value) {
    if(2 * litaC_m->length >= litaC_m->capacity) {
        {
            litaC_map__MapGrow_cb__ptr_Symbol_c_Dependency_ce_(litaC_m, 2 * litaC_m->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                {
                    litaC_m->length += 1;
                    litaC_m->keys[litaC_i] = litaC_key;
                    litaC_m->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                    {
                        litaC_m->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_void litaC_map__Map_free_cb__ptr_Symbol_c_Dependency_ce_(litaC_map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m) {
    if(litaC_m) {
        {
            litaC_m->capacity = 0;
            litaC_m->length = 0;
            litaC_mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->keys);
            litaC_mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->values);
            litaC_m->keys = NULL;
            litaC_m->values = NULL;
            
            
        }
        
    } 
    
    
}

litaC_dependency_graph__Dependency* litaC_map__Map_getPtr_cb__ptr_Symbol_c_Dependency_ce_(litaC_map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m,litaC_symbols__Symbol* litaC_key) {
    if(litaC_m->length == 0) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                {
                    return &(litaC_m->values[litaC_i]);
                    
                    
                    
                }
                
            } else {
                if(!(litaC_m->keys[litaC_i])) {
                    {
                        return NULL;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return NULL;
    
    
}

litaC_void litaC_array__Array_add_cb__ptr_Dependency_ce_(litaC_array__Array_cb__ptr_Dependency_ce_* litaC_a,litaC_dependency_graph__Dependency* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_Dependency_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb__ptr_Dependency_ce_(litaC_array__Array_cb__ptr_Dependency_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_dependency_graph__Dependency*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_dependency_graph__Dependency*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_dependency_graph__Dependency**)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

litaC_void litaC_array__Array_init_cb__ptr_Dependency_ce_(litaC_array__Array_cb__ptr_Dependency_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_dependency_graph__Dependency*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_dependency_graph__Dependency**)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_ litaC_map__Map_iter_cb__ptr_Symbol_c_Dependency_ce_(litaC_map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m) {
    return (litaC_map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_) {
        .m = litaC_m,
        .it = 0,
        .count = 0
    };
    
    
}

litaC_bool litaC_map__MapIterator_hasNext_cb__ptr_Symbol_c_Dependency_ce_(litaC_map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_* litaC_iter) {
    return litaC_iter->count < litaC_iter->m->length;
    
    
}

litaC_map__MapEntry_cb__ptr_Symbol_c_Dependency_ce_ litaC_map__MapIterator_next_cb__ptr_Symbol_c_Dependency_ce_(litaC_map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_* litaC_iter) {
    litaC_i32 litaC_i = litaC_iter->it;
    assert(litaC_i < litaC_iter->m->capacity);
    
    for(;litaC_i < litaC_iter->m->capacity;litaC_i += 1) {
        {
            litaC_bool litaC_hasValue = !(litaC_iter->m->equalFn(litaC_iter->m->keys[litaC_i], litaC_iter->m->emptyKey));
            if(litaC_hasValue) {
                {
                    litaC_iter->count += 1;
                    {
                        litaC_map__MapEntry_cb__ptr_Symbol_c_Dependency_ce_ ___result = (litaC_map__MapEntry_cb__ptr_Symbol_c_Dependency_ce_) {
                            .key = litaC_iter->m->keys[litaC_i],
                            .value = litaC_iter->m->values[litaC_i],
                            .valuePtr = &(litaC_iter->m->values[litaC_i])
                        };
                        litaC_iter->it = litaC_i + 1;
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    {
        litaC_map__MapEntry_cb__ptr_Symbol_c_Dependency_ce_ ___result = (litaC_map__MapEntry_cb__ptr_Symbol_c_Dependency_ce_) {
            
        };
        litaC_iter->it = litaC_i + 1;
        return ___result;
        
    }
    
    litaC_iter->it = litaC_i + 1;
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_Dependency_ce_(litaC_array__Array_cb__ptr_Dependency_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_dependency_graph__Dependency* litaC_array__Array_get_cb__ptr_Dependency_ce_(litaC_array__Array_cb__ptr_Dependency_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_i32 litaC_map__Map_size_cb__ptr_Symbol_c_Dependency_ce_(litaC_map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m) {
    return litaC_m->length;
    
    
}

LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb__ptr_Dependency_ce_(litaC_array__Array_cb__ptr_Dependency_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

litaC_void litaC_array__Array_addAll_cb__ptr_Dependency_ce_(litaC_array__Array_cb__ptr_Dependency_ce_* litaC_a,litaC_array__Array_cb__ptr_Dependency_ce_* litaC_other) {
    if(!(litaC_other) || litaC_other->length == 0) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_a->length + litaC_other->length > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_Dependency_ce_(litaC_a, litaC_other->length);
            
            
        }
        
    } 
    
    memcpy((litaC_void*)(&(litaC_a->elements[litaC_a->length])), (const litaC_void*)(&(litaC_other->elements[0])), litaC_other->length * sizeof(litaC_dependency_graph__Dependency*));
    litaC_a->length += litaC_other->length;
    
}

LITAC_INLINE 
litaC_void litaC_array__Array_clear_cb__ptr_Symbol_ce_(litaC_array__Array_cb__ptr_Symbol_ce_* litaC_a) {
    litaC_a->length = 0;
    
}

litaC_void litaC_array__Array_addAll_cb__ptr_Symbol_ce_(litaC_array__Array_cb__ptr_Symbol_ce_* litaC_a,litaC_array__Array_cb__ptr_Symbol_ce_* litaC_other) {
    if(!(litaC_other) || litaC_other->length == 0) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_a->length + litaC_other->length > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_Symbol_ce_(litaC_a, litaC_other->length);
            
            
        }
        
    } 
    
    memcpy((litaC_void*)(&(litaC_a->elements[litaC_a->length])), (const litaC_void*)(&(litaC_other->elements[0])), litaC_other->length * sizeof(litaC_symbols__Symbol*));
    litaC_a->length += litaC_other->length;
    
}

LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb__ptr_const_char_ce_(litaC_array__Array_cb__ptr_const_char_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

litaC_void litaC_array__Array_init_cb_Reference_ce_(litaC_array__Array_cb_Reference_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_references__Reference) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_references__Reference*)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_array__Array_init_cb_FieldReference_ce_(litaC_array__Array_cb_FieldReference_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_references__FieldReference) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_references__FieldReference*)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_u32 litaC_map__PtrHashFn_cb_usize_ce_(litaC_usize litaC_a) {
    litaC_u32 litaC_hash = (litaC_u32)(((litaC_usize)litaC_a) % 4294967291U);
    return litaC_hash;
    
    
}

litaC_bool litaC_map__PtrEqualFn_cb_usize_ce_(litaC_usize litaC_a,litaC_usize litaC_b) {
    return litaC_a == litaC_b;
    
    
}

litaC_void litaC_map__Map_init_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_array__Array_cb_SrcPos_ce_ litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_usize),litaC_bool (*litaC_equalFn)(litaC_usize,litaC_usize),const litaC_mem__Allocator* litaC_alloc,litaC_usize litaC_emptyKey) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_m->length = 0;
    litaC_m->capacity = 0;
    litaC_m->hashFn = litaC_hashFn;
    litaC_m->equalFn = litaC_equalFn;
    litaC_m->alloc = litaC_alloc;
    litaC_m->keys = 0;
    litaC_m->values = 0;
    litaC_m->emptyValue = litaC_emptyValue;
    litaC_m->emptyKey = litaC_emptyKey;
    litaC_initialSize = (litaC_i32)litaC_map__nextPowerOf2(litaC_initialSize);
    litaC_map__MapGrow_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_m, litaC_initialSize);
    
}

litaC_void litaC_map__MapGrow_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_i32 litaC_newlength) {
    if(litaC_newlength < 16) {
        {
            litaC_newlength = 16;
            
            
        }
        
    } 
    
    litaC_map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_ litaC_newMap =  {
        .length = 0,
        .capacity = litaC_newlength,
        .keys = (litaC_usize*)litaC_mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_usize)),
        .values = (litaC_array__Array_cb_SrcPos_ce_*)litaC_mem__Allocator_alloc(litaC_m->alloc, litaC_newlength * sizeof(litaC_array__Array_cb_SrcPos_ce_)),
        .hashFn = litaC_m->hashFn,
        .equalFn = litaC_m->equalFn,
        .emptyValue = litaC_m->emptyValue,
        .emptyKey = litaC_m->emptyKey,
        .alloc = litaC_m->alloc
    };
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            if(!(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey))) {
                {
                    litaC_map__Map_put_cb_usize_c_Array_cb_SrcPos_ce__ce_(&((litaC_newMap)), litaC_m->keys[litaC_i], litaC_m->values[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_map__Map_free_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_m);
    *(litaC_m) = litaC_newMap;
    
}

litaC_void litaC_map__Map_put_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_usize litaC_key,litaC_array__Array_cb_SrcPos_ce_ litaC_value) {
    if(2 * litaC_m->length >= litaC_m->capacity) {
        {
            litaC_map__MapGrow_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_m, 2 * litaC_m->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                {
                    litaC_m->length += 1;
                    litaC_m->keys[litaC_i] = litaC_key;
                    litaC_m->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                    {
                        litaC_m->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_void litaC_map__Map_free_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m) {
    if(litaC_m) {
        {
            litaC_m->capacity = 0;
            litaC_m->length = 0;
            litaC_mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->keys);
            litaC_mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->values);
            litaC_m->keys = NULL;
            litaC_m->values = NULL;
            
            
        }
        
    } 
    
    
}

litaC_bool litaC_map__Map_contains_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_usize litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                {
                    return litaC_true;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_array__Array_cb_SrcPos_ce_ litaC_array__ArrayInit_cb_SrcPos_ce_(litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_array__Array_cb_SrcPos_ce_ litaC_array =  {
        
    };
    litaC_array__Array_init_cb_SrcPos_ce_(&((litaC_array)), litaC_initialSize, litaC_alloc);
    return litaC_array;
    
    
}

litaC_void litaC_array__Array_init_cb_SrcPos_ce_(litaC_array__Array_cb_SrcPos_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_lex__SrcPos) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_lex__SrcPos*)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_array__Array_cb_SrcPos_ce_* litaC_map__Map_getPtr_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_usize litaC_key) {
    if(litaC_m->length == 0) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                {
                    return &(litaC_m->values[litaC_i]);
                    
                    
                    
                }
                
            } else {
                if(!(litaC_m->keys[litaC_i])) {
                    {
                        return NULL;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return NULL;
    
    
}

litaC_void litaC_array__Array_add_cb_SrcPos_ce_(litaC_array__Array_cb_SrcPos_ce_* litaC_a,litaC_lex__SrcPos litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb_SrcPos_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb_SrcPos_ce_(litaC_array__Array_cb_SrcPos_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_lex__SrcPos) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_lex__SrcPos) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_lex__SrcPos*)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

litaC_void litaC_array__Array_add_cb_Reference_ce_(litaC_array__Array_cb_Reference_ce_* litaC_a,litaC_references__Reference litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb_Reference_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb_Reference_ce_(litaC_array__Array_cb_Reference_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_references__Reference) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_references__Reference) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_references__Reference*)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

litaC_void litaC_array__Array_add_cb_FieldReference_ce_(litaC_array__Array_cb_FieldReference_ce_* litaC_a,litaC_references__FieldReference litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb_FieldReference_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb_FieldReference_ce_(litaC_array__Array_cb_FieldReference_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_references__FieldReference) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_references__FieldReference) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_references__FieldReference*)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

litaC_array__Array_cb_SrcPos_ce_ litaC_map__Map_get_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_usize litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_m->emptyValue;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                {
                    return litaC_m->values[litaC_i];
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                    {
                        return litaC_m->emptyValue;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_m->emptyValue;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_Reference_ce_(litaC_array__Array_cb_Reference_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_references__Reference* litaC_array__Array_getPtr_cb_Reference_ce_(litaC_array__Array_cb_Reference_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return &(litaC_a->elements[litaC_index]);
    
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_FieldReference_ce_(litaC_array__Array_cb_FieldReference_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_references__FieldReference* litaC_array__Array_getPtr_cb_FieldReference_ce_(litaC_array__Array_cb_FieldReference_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return &(litaC_a->elements[litaC_index]);
    
    
}

litaC_json__JsonNode* litaC_mem__new_cb_JsonNode_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_json__JsonNode* litaC_result = (litaC_json__JsonNode*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_json__JsonNode));
    return litaC_result;
    
    
}

litaC_array__Array_cb__ptr_JsonNode_ce_* litaC_mem__new_cb_Array_cb__ptr_JsonNode_ce__ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_array__Array_cb__ptr_JsonNode_ce_* litaC_result = (litaC_array__Array_cb__ptr_JsonNode_ce_*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_array__Array_cb__ptr_JsonNode_ce_));
    return litaC_result;
    
    
}

litaC_void litaC_array__Array_init_cb__ptr_JsonNode_ce_(litaC_array__Array_cb__ptr_JsonNode_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_json__JsonNode*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_json__JsonNode**)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_json__JsonObject* litaC_mem__new_cb_JsonObject_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_json__JsonObject* litaC_result = (litaC_json__JsonObject*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_json__JsonObject));
    return litaC_result;
    
    
}

litaC_void litaC_map__Map_init_cb__ptr_const_char_c_i32_ce_(litaC_map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m,litaC_i32 litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(const litaC_char*),litaC_bool (*litaC_equalFn)(const litaC_char*,const litaC_char*),const litaC_mem__Allocator* litaC_alloc,const litaC_char* litaC_emptyKey) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_m->length = 0;
    litaC_m->capacity = 0;
    litaC_m->hashFn = litaC_hashFn;
    litaC_m->equalFn = litaC_equalFn;
    litaC_m->alloc = litaC_alloc;
    litaC_m->keys = 0;
    litaC_m->values = 0;
    litaC_m->emptyValue = litaC_emptyValue;
    litaC_m->emptyKey = litaC_emptyKey;
    litaC_initialSize = (litaC_i32)litaC_map__nextPowerOf2(litaC_initialSize);
    litaC_map__MapGrow_cb__ptr_const_char_c_i32_ce_(litaC_m, litaC_initialSize);
    
}

litaC_void litaC_map__MapGrow_cb__ptr_const_char_c_i32_ce_(litaC_map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m,litaC_i32 litaC_newlength) {
    if(litaC_newlength < 16) {
        {
            litaC_newlength = 16;
            
            
        }
        
    } 
    
    litaC_map__Map_cb__ptr_const_char_c_i32_ce_ litaC_newMap =  {
        .length = 0,
        .capacity = litaC_newlength,
        .keys = (const litaC_char**)litaC_mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(const litaC_char*)),
        .values = (litaC_i32*)litaC_mem__Allocator_alloc(litaC_m->alloc, litaC_newlength * sizeof(litaC_i32)),
        .hashFn = litaC_m->hashFn,
        .equalFn = litaC_m->equalFn,
        .emptyValue = litaC_m->emptyValue,
        .emptyKey = litaC_m->emptyKey,
        .alloc = litaC_m->alloc
    };
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            if(!(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey))) {
                {
                    litaC_map__Map_put_cb__ptr_const_char_c_i32_ce_(&((litaC_newMap)), litaC_m->keys[litaC_i], litaC_m->values[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_map__Map_free_cb__ptr_const_char_c_i32_ce_(litaC_m);
    *(litaC_m) = litaC_newMap;
    
}

litaC_void litaC_map__Map_put_cb__ptr_const_char_c_i32_ce_(litaC_map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m,const litaC_char* litaC_key,litaC_i32 litaC_value) {
    if(2 * litaC_m->length >= litaC_m->capacity) {
        {
            litaC_map__MapGrow_cb__ptr_const_char_c_i32_ce_(litaC_m, 2 * litaC_m->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                {
                    litaC_m->length += 1;
                    litaC_m->keys[litaC_i] = litaC_key;
                    litaC_m->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                    {
                        litaC_m->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_void litaC_map__Map_free_cb__ptr_const_char_c_i32_ce_(litaC_map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m) {
    if(litaC_m) {
        {
            litaC_m->capacity = 0;
            litaC_m->length = 0;
            litaC_mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->keys);
            litaC_mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->values);
            litaC_m->keys = NULL;
            litaC_m->values = NULL;
            
            
        }
        
    } 
    
    
}

litaC_void litaC_array__Array_init_cb_Entry_ce_(litaC_array__Array_cb_Entry_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_json__Entry) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_json__Entry*)litaC_mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_array__Array_add_cb_Entry_ce_(litaC_array__Array_cb_Entry_ce_* litaC_a,litaC_json__Entry litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb_Entry_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb_Entry_ce_(litaC_array__Array_cb_Entry_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_json__Entry) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_json__Entry) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_json__Entry*)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_Entry_ce_(litaC_array__Array_cb_Entry_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_bool litaC_map__Map_contains_cb__ptr_const_char_c_i32_ce_(litaC_map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m,const litaC_char* litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                {
                    return litaC_true;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_i32 litaC_map__Map_get_cb__ptr_const_char_c_i32_ce_(litaC_map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m,const litaC_char* litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_m->emptyValue;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                {
                    return litaC_m->values[litaC_i];
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                    {
                        return litaC_m->emptyValue;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_m->emptyValue;
    
    
}

litaC_json__Entry litaC_array__Array_get_cb_Entry_ce_(litaC_array__Array_cb_Entry_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_void litaC_array__Array_add_cb__ptr_JsonNode_ce_(litaC_array__Array_cb__ptr_JsonNode_ce_* litaC_a,litaC_json__JsonNode* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_array__ArrayGrow_cb__ptr_JsonNode_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_array__ArrayGrow_cb__ptr_JsonNode_ce_(litaC_array__Array_cb__ptr_JsonNode_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_json__JsonNode*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_json__JsonNode*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_json__JsonNode**)litaC_mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    litaC_a->capacity = litaC_n;
    
}

litaC_json__JsonNode* litaC_array__Array_get_cb__ptr_JsonNode_ce_(litaC_array__Array_cb__ptr_JsonNode_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb__ptr_JsonNode_ce_(litaC_array__Array_cb__ptr_JsonNode_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_map__Map_size_cb__ptr_const_char_c_i32_ce_(litaC_map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m) {
    return litaC_m->length;
    
    
}

litaC_void litaC_array__Array_free_cb__ptr_JsonNode_ce_(litaC_array__Array_cb__ptr_JsonNode_ce_* litaC_a) {
    if(litaC_a && litaC_a->elements) {
        {
            litaC_mem__Allocator_free(litaC_a->alloc, (litaC_void*)litaC_a->elements);
            litaC_a->elements = NULL;
            litaC_a->length = 0;
            litaC_a->capacity = 0;
            
            
        }
        
    } 
    
    
}

litaC_void litaC_array__Array_free_cb_Entry_ce_(litaC_array__Array_cb_Entry_ce_* litaC_a) {
    if(litaC_a && litaC_a->elements) {
        {
            litaC_mem__Allocator_free(litaC_a->alloc, (litaC_void*)litaC_a->elements);
            litaC_a->elements = NULL;
            litaC_a->length = 0;
            litaC_a->capacity = 0;
            
            
        }
        
    } 
    
    
}

litaC_map__Map_cb__ptr_const_char_c__ptr_TextDocument_ce_ litaC_map__StrMap_cb__ptr_TextDocument_ce_(litaC_workspace__TextDocument* litaC_emptyValue,litaC_i32 litaC_initialSize,const litaC_mem__Allocator* litaC_alloc) {
    litaC_map__Map_cb__ptr_const_char_c__ptr_TextDocument_ce_ litaC_m =  {
        
    };
    litaC_map__Map_init_cb__ptr_const_char_c__ptr_TextDocument_ce_(&((litaC_m)), litaC_emptyValue, litaC_initialSize, litaC_map__StrHashFn, litaC_map__StrEqualFn, litaC_alloc, 0);
    return litaC_m;
    
    
}

litaC_void litaC_map__Map_init_cb__ptr_const_char_c__ptr_TextDocument_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TextDocument_ce_* litaC_m,litaC_workspace__TextDocument* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(const litaC_char*),litaC_bool (*litaC_equalFn)(const litaC_char*,const litaC_char*),const litaC_mem__Allocator* litaC_alloc,const litaC_char* litaC_emptyKey) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_m->length = 0;
    litaC_m->capacity = 0;
    litaC_m->hashFn = litaC_hashFn;
    litaC_m->equalFn = litaC_equalFn;
    litaC_m->alloc = litaC_alloc;
    litaC_m->keys = 0;
    litaC_m->values = 0;
    litaC_m->emptyValue = litaC_emptyValue;
    litaC_m->emptyKey = litaC_emptyKey;
    litaC_initialSize = (litaC_i32)litaC_map__nextPowerOf2(litaC_initialSize);
    litaC_map__MapGrow_cb__ptr_const_char_c__ptr_TextDocument_ce_(litaC_m, litaC_initialSize);
    
}

litaC_void litaC_map__MapGrow_cb__ptr_const_char_c__ptr_TextDocument_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TextDocument_ce_* litaC_m,litaC_i32 litaC_newlength) {
    if(litaC_newlength < 16) {
        {
            litaC_newlength = 16;
            
            
        }
        
    } 
    
    litaC_map__Map_cb__ptr_const_char_c__ptr_TextDocument_ce_ litaC_newMap =  {
        .length = 0,
        .capacity = litaC_newlength,
        .keys = (const litaC_char**)litaC_mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(const litaC_char*)),
        .values = (litaC_workspace__TextDocument**)litaC_mem__Allocator_alloc(litaC_m->alloc, litaC_newlength * sizeof(litaC_workspace__TextDocument*)),
        .hashFn = litaC_m->hashFn,
        .equalFn = litaC_m->equalFn,
        .emptyValue = litaC_m->emptyValue,
        .emptyKey = litaC_m->emptyKey,
        .alloc = litaC_m->alloc
    };
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            if(!(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey))) {
                {
                    litaC_map__Map_put_cb__ptr_const_char_c__ptr_TextDocument_ce_(&((litaC_newMap)), litaC_m->keys[litaC_i], litaC_m->values[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_map__Map_free_cb__ptr_const_char_c__ptr_TextDocument_ce_(litaC_m);
    *(litaC_m) = litaC_newMap;
    
}

litaC_void litaC_map__Map_put_cb__ptr_const_char_c__ptr_TextDocument_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TextDocument_ce_* litaC_m,const litaC_char* litaC_key,litaC_workspace__TextDocument* litaC_value) {
    if(2 * litaC_m->length >= litaC_m->capacity) {
        {
            litaC_map__MapGrow_cb__ptr_const_char_c__ptr_TextDocument_ce_(litaC_m, 2 * litaC_m->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                {
                    litaC_m->length += 1;
                    litaC_m->keys[litaC_i] = litaC_key;
                    litaC_m->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                    {
                        litaC_m->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_void litaC_map__Map_free_cb__ptr_const_char_c__ptr_TextDocument_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TextDocument_ce_* litaC_m) {
    if(litaC_m) {
        {
            litaC_m->capacity = 0;
            litaC_m->length = 0;
            litaC_mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->keys);
            litaC_mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->values);
            litaC_m->keys = NULL;
            litaC_m->values = NULL;
            
            
        }
        
    } 
    
    
}

litaC_bool litaC_map__Map_contains_cb__ptr_const_char_c__ptr_TextDocument_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TextDocument_ce_* litaC_m,const litaC_char* litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                {
                    return litaC_true;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_workspace__TextDocument* litaC_mem__new_cb_TextDocument_ce_(const litaC_mem__Allocator* litaC_a) {
    litaC_workspace__TextDocument* litaC_result = (litaC_workspace__TextDocument*)litaC_mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_workspace__TextDocument));
    return litaC_result;
    
    
}

litaC_workspace__TextDocument* litaC_map__Map_remove_cb__ptr_const_char_c__ptr_TextDocument_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TextDocument_ce_* litaC_m,const litaC_char* litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_m->emptyValue;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                {
                    litaC_workspace__TextDocument* litaC_v = litaC_m->values[litaC_i];
                    litaC_m->keys[litaC_i] = litaC_m->emptyKey;
                    litaC_m->length -= 1;
                    return litaC_v;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                    {
                        return litaC_m->emptyValue;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_m->emptyValue;
    
    
}

litaC_workspace__TextDocument* litaC_map__Map_get_cb__ptr_const_char_c__ptr_TextDocument_ce_(litaC_map__Map_cb__ptr_const_char_c__ptr_TextDocument_ce_* litaC_m,const litaC_char* litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_m->emptyValue;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_key)) {
                {
                    return litaC_m->values[litaC_i];
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_m->keys[litaC_i], litaC_m->emptyKey)) {
                    {
                        return litaC_m->emptyValue;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_m->emptyValue;
    
    
}

LITAC_INLINE 
litaC_bool litaC_array__Array_empty_cb_SrcPos_ce_(litaC_array__Array_cb_SrcPos_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_array__Array_size_cb_SrcPos_ce_(litaC_array__Array_cb_SrcPos_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_lex__SrcPos* litaC_array__Array_getPtr_cb_SrcPos_ce_(litaC_array__Array_cb_SrcPos_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return &(litaC_a->elements[litaC_index]);
    
    
}

litaC_ast__GenericParam* litaC_array__Array_getPtr_cb_GenericParam_ce_(litaC_array__Array_cb_GenericParam_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return &(litaC_a->elements[litaC_index]);
    
    
}

litaC_ast__FieldStmt* litaC_array__Array_getPtr_cb_FieldStmt_ce_(litaC_array__Array_cb_FieldStmt_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return &(litaC_a->elements[litaC_index]);
    
    
}


litaC_i32 main(litaC_i32 litaC_len,litaC_char** litaC_args) {
    litaC_system__SystemInit();
    litaC_f64 litaC_startTime = litaC_system__SystemTimeMSec();
    litaC_lita__LitaOptions litaC_options =  {
        
    };
    litaC_main__ParseStatus litaC_status = litaC_main__ParseArgs(litaC_len, litaC_args, &(litaC_options));
    if(litaC_status != litaC_main__ParseStatus_OK) {
        {
            return (litaC_main__ParseStatus_TERMINATE == litaC_status) ? 0 : -(1);
            
            
            
        }
        
    } 
    
    litaC_lita__Lita litaC_lita =  {
        
    };
    litaC_lita__Lita_init(&((litaC_lita)), &(litaC_options));
    
    if(litaC_options.languageServer) {
        {
            litaC_lsp__LspServer litaC_server =  {
                
            };
            litaC_lsp__LspServer_init(&((litaC_server)), &(litaC_lita));
            
            litaC_lsp__LspServer_start(&((litaC_server)));
            {
                litaC_i32 ___result = 0;
                litaC_lsp__LspServer_free(&((litaC_server)));
                litaC_lita__Lita_free(&((litaC_lita)));
                return ___result;
                
            }
            
            litaC_lsp__LspServer_free(&((litaC_server)));
            
            
        }
        
    } 
    
    litaC_module__Module* litaC_root = litaC_lita__Lita_parse(&((litaC_lita)));
    if(!(litaC_root)) {
        {
            goto report;
            
            
            
        }
        
    } 
    
    if(!(litaC_lita__Lita_typeCheck(&((litaC_lita)), litaC_root))) {
        {
            goto report;
            
            
            
        }
        
    } 
    
    if(litaC_options.checkerOnly) {
        {
            goto report;
            
            
            
        }
        
    } 
    
    if(!(litaC_lita__Lita_transpile(&((litaC_lita)), litaC_root))) {
        {
            goto report;
            
            
            
        }
        
    } 
    
    litaC_bool litaC_runProgram = litaC_options.run;
    report:;
    
    litaC_f64 litaC_totalTime = litaC_system__SystemTimeMSec() - litaC_startTime;
    litaC_string_buffer__StringBuffer litaC_sb = litaC_string_buffer__StringBufferInit(1024, NULL);
    
    if(!(litaC_array__Array_empty_cb_PhaseError_ce_(&((litaC_lita.result.errors))))) {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_array__Array_size_cb_PhaseError_ce_(&((litaC_lita.result.errors)));litaC_i += 1) {
                {
                    litaC_error_codes__PrintError(&((litaC_sb)), litaC_array__Array_get_cb_PhaseError_ce_(&((litaC_lita.result.errors)), litaC_i));
                    printf("%s\n", litaC_string_buffer__StringBuffer_cStr(&((litaC_sb))));
                    litaC_string_buffer__StringBuffer_clear(&((litaC_sb)));
                    
                    
                }
            }
            printf("Total errors: %d\n", litaC_array__Array_size_cb_PhaseError_ce_(&((litaC_lita.result.errors))));
            
            
        }
        
    } 
    
    if(litaC_options.showProfileInfo) {
        {
            litaC_mem__LinearAllocator* litaC_allocator = (litaC_mem__LinearAllocator*)litaC_lita.allocator;
            printf("\n\n");
            printf("%-30s %-17s %-6s %-14s %-5s\n", "Segment", "Time", "%", "Mem", "#");
            printf("====================================================================================\n");
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_lita__MetricType_MAX_METRIC_TYPES;litaC_i += 1) {
                {
                    litaC_lita__Metric* litaC_metric = &(litaC_lita.metrics[litaC_i]);
                    printf("%-30s %-15.6f   %3.0f%% %-14zu %-5u\n", litaC_lita__MetricTypeAsStr(litaC_i), litaC_metric->executionTime, (litaC_metric->executionTime / litaC_totalTime) * 100.f, litaC_metric->bytesAllocated, litaC_metric->allocationCount);
                    
                    
                }
            }
            printf("\n");
            printf("Total time:         %f\n", litaC_totalTime);
            printf("Total memory:       %zu\n", litaC_allocator->totalBytesAllocated);
            printf("Total allocations:  %u\n", litaC_allocator->totalAllocations);
            printf("Total source lines: %u\n", litaC_lita.totalSourceLines);
            printf("\n");
            
            
        }
        
    } 
    
    if(litaC_runProgram) {
        {
            litaC_lita__Lita_run(&((litaC_lita)));
            
            
        }
        
    } 
    
    {
        litaC_i32 ___result = 0;
        litaC_string_buffer__StringBuffer_free(&((litaC_sb)));
        litaC_lita__Lita_free(&((litaC_lita)));
        return ___result;
        
    }
    
    litaC_string_buffer__StringBuffer_free(&((litaC_sb)));
    litaC_lita__Lita_free(&((litaC_lita)));
    
}